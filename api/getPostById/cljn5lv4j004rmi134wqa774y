{"type":"getPostById","data":{"title":"redis缓存","date":"2023-07-03T09:48:56.000Z","description":"redis缓存相关","categories":[{"name":"redis","_id":"cljn5lv4b002dmi13ascbab3q"}],"tags":[{"name":"redis","_id":"cljn5lv4g0042mi13ddtm7pz8"}],"content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n\n\n<h2 id=\"缓存四问\"><a href=\"#缓存四问\" class=\"headerlink\" title=\"缓存四问\"></a>缓存四问</h2><h3 id=\"1-缓存预热\"><a href=\"#1-缓存预热\" class=\"headerlink\" title=\"1.缓存预热\"></a>1.缓存预热</h3><h4 id=\"是什么\"><a href=\"#是什么\" class=\"headerlink\" title=\"是什么\"></a><font color=\"red\">是什么</font></h4><ul>\n<li>缓存预热就是系统上线后，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据进行写回到缓存的问题！用户直接查询事先被预热的缓存数据！</li>\n</ul>\n<h4 id=\"怎么做\"><a href=\"#怎么做\" class=\"headerlink\" title=\"怎么做\"></a><font color=\"red\">怎么做</font></h4><ul>\n<li>将热点数据提前加载到<code>redis</code>缓存中，可以通过<code>@PostConstruct</code>提前在运行某个程序之前，将其加载到<code>redis</code>中</li>\n<li>或者使用 <code>Spring FrameFramework 提供的接口CommandLineRunner 自定义 预加载类在程序启动的时候</code>存到<code>redis</code>中</li>\n</ul>\n<h3 id=\"雪崩\"><a href=\"#雪崩\" class=\"headerlink\" title=\"雪崩\"></a>雪崩</h3><h4 id=\"是什么-1\"><a href=\"#是什么-1\" class=\"headerlink\" title=\"是什么\"></a><font color=\"red\">是什么</font></h4><ul>\n<li>缓存雪崩就是同一时段大量的缓存<code>key</code>同时失效或者<code>Redis服务宕机</code>，导致大量请求到达数据库，给数据库带来巨大压力。</li>\n</ul>\n<h4 id=\"何时发生\"><a href=\"#何时发生\" class=\"headerlink\" title=\"何时发生\"></a><font color=\"red\">何时发生</font></h4><ul>\n<li>Redis主机挂了，Redis全盘<code>崩溃</code></li>\n<li>Redis中有大量<code>key同时</code>过期<code>大面积失效</code>，</li>\n</ul>\n<h4 id=\"解决-与-预防\"><a href=\"#解决-与-预防\" class=\"headerlink\" title=\"解决 与 预防\"></a><font color=\"red\">解决 与 预防</font></h4><ul>\n<li>Redis中key设置为<code>永不过期</code>或者过期时间为<code>指定时间+随机时间</code>，<code>错开同时过期的概率</code></li>\n<li><p>Redis缓存集群实现高可用 [ <code>主从+哨兵</code>   <code>集群</code>  <code>开启Redis持久化机制AOF/RDB，尽快恢复缓存集群</code>]</p>\n</li>\n<li><p>多级缓存结合预防雪崩   <code>ehcache本地缓存 + Redis缓存</code></p>\n</li>\n<li><p>服务降级               <code>Hystrix</code>或者阿里<code>sentinel</code>限流&amp;降级</p>\n</li>\n</ul>\n<h3 id=\"击穿\"><a href=\"#击穿\" class=\"headerlink\" title=\"击穿\"></a>击穿<redis 先有后失效></redis></h3><h4 id=\"是什么-2\"><a href=\"#是什么-2\" class=\"headerlink\" title=\"是什么\"></a><font color=\"red\">是什么</font></h4><ul>\n<li>大量请求同时查询一个key时，此时这个key正好失效了，就会导致大量的请求都打到数据库，<font color=\"red\">就是热点key突然失效了，MySQL压力增加</font></li>\n</ul>\n<h4 id=\"热点key失效可能\"><a href=\"#热点key失效可能\" class=\"headerlink\" title=\"热点key失效可能\"></a><font color=\"red\">热点key失效可能</font></h4><ul>\n<li>时间到了自然清除但还是被访问到</li>\n<li>delete掉的key，刚好又被访问到</li>\n</ul>\n<h4 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a><font color=\"red\">解决</font></h4><ul>\n<li>方案一：差异失效时间，对于访问频繁的热点key，干脆就<code>不设置过期时间</code>   而是设置<code>逻辑过期时间</code>，但是会有一定的数据不一致性</li>\n<li><font color=\"red\">方案二：互斥锁，互斥更新，采用双检加锁策略</font>        多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个互斥锁来锁住它。其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存</li>\n</ul>\n<h3 id=\"穿透-lt-两库都没-gt\"><a href=\"#穿透-lt-两库都没-gt\" class=\"headerlink\" title=\"穿透&lt;两库都没&gt;\"></a>穿透&lt;两库都没&gt;</h3><h4 id=\"是什么-3\"><a href=\"#是什么-3\" class=\"headerlink\" title=\"是什么\"></a><font color=\"red\">是什么</font></h4><ul>\n<li>请求去查询一条记录，先查redis，后查mysql，都查询不到，说明数据源是不存在的，但是请求每次都会打到数据库上面去，导致后台数据库压力暴增，这种现象我们称为缓存穿透</li>\n</ul>\n<h4 id=\"解决-1\"><a href=\"#解决-1\" class=\"headerlink\" title=\"解决\"></a><font color=\"red\">解决</font></h4><ol>\n<li>使用布隆过滤器(<code>Guava</code>)</li>\n<li>对空对象缓存</li>\n</ol>\n<ul>\n<li><p>回写增强: 如果发生了缓存穿透，我们可以针对要查询的数据，在Redis里存一个规定的缺省值(比如,零、负数、defaultNull等)</p>\n<p>第一次来查询一旦 <code>redis</code>和<code>mysql</code>都没有，返回<code>nul</code>给<code>调用者</code>，同时也让<code>redis</code>存入刚刚查不到的<code>key</code>，并对应的填上<code>规定的缺省值</code>，那么第二次来查，此时redis就有值了。</p>\n</li>\n</ul>\n<blockquote>\n<p>对空值缓存的弊端</p>\n<ul>\n<li><p>一旦多次穿透，redis就会有很多 垃圾 key ，占用内存（可以设置ttl定期删除），</p>\n</li>\n<li><p>但是因为这个<code>ttl</code> 可能会导致数据短期的不一致性 [mysql新增数据的时候同时存到redis,同样会有内存问题]</p>\n<p>所以没有根本不能解决问题</p>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"小结：\"><a href=\"#小结：\" class=\"headerlink\" title=\"小结：\"></a>小结：</h3><p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202307031742656.png\" alt=\"image-20230526130227733\" style=\"zoom:33%;\"></p>\n<h2 id=\"缓存删除过期键的策略\"><a href=\"#缓存删除过期键的策略\" class=\"headerlink\" title=\"缓存删除过期键的策略\"></a>缓存删除过期键的策略</h2><h3 id=\"Redis-过期键的删除策略\"><a href=\"#Redis-过期键的删除策略\" class=\"headerlink\" title=\"Redis 过期键的删除策略\"></a>Redis 过期键的删除策略</h3><ul>\n<li><p>立即删除      对CPU不友好，用处理器性能换取存储空间（拿时间换空间）</p>\n</li>\n<li><p>惰性删除      对 内存 不友好，用存储空间换取处理器性能（拿空间换时间）</p>\n</li>\n<li><p>定期删除    每隔一段时间执行一次删除过期键操作并通过限制删除操作执行时长和频率来减少删除操作对CPU时间的影响。定期抽样key，判断是否过期</p>\n</li>\n</ul>\n<blockquote>\n<p>定期清理的<code>两种模式</code>：</p>\n<ol>\n<li><p><code>SLOW</code>模式执行频率默认为10，每次不超过25ms</p>\n</li>\n<li><p><code>FAST</code>模式执行频率不固定，但两次间隔不低于2ms，每次耗时不超过1ms</p>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"缓存淘汰的策略\"><a href=\"#缓存淘汰的策略\" class=\"headerlink\" title=\"缓存淘汰的策略\"></a>缓存淘汰的策略</h2><h3 id=\"redis-缓存淘汰策略\"><a href=\"#redis-缓存淘汰策略\" class=\"headerlink\" title=\"redis 缓存淘汰策略\"></a>redis 缓存淘汰策略</h3><h4 id=\"主要两类：\"><a href=\"#主要两类：\" class=\"headerlink\" title=\"主要两类：\"></a>主要两类：</h4><ul>\n<li>LRU   <code>最近最少</code>使用的页面置换算法，淘汰最长时间未被使用的页面，看页面<code>最后一次被使用到发生调度的时间长短</code>，首先<code>淘汰最长时间未被使用</code>的页面</li>\n<li>LFU   <code>最近最不常用</code>页面置换算法，淘汰一定时期内被访问次数最少的页面，看<code>一定时间段内被访问次数最少的页</code>，<code>看一定时间段内页面被使用的频率</code>，淘汰一定时期内被访问<code>次数最少的页</code></li>\n</ul>\n<h4 id=\"细分8类：\"><a href=\"#细分8类：\" class=\"headerlink\" title=\"细分8类：\"></a>细分8类：</h4><ul>\n<li>noevication ： <code>不会驱逐任何key</code>，表示<code>即使内存达到上限也不进行置换</code>，所有能引起内存增加的命令都返回 error，<code>默认</code>就是这种策略。</li>\n<li><code>allkeys-lru</code>： 对所有key使用 LRU算法进行删除，<code>优先删除掉最近不经常使用的key</code>，用以保存新数据  <code>工作中常用</code></li>\n<li><code>volatie</code>-lru : 对所有<code>设置了过期时间的key</code>使用<code>LRU 算法</code>删除</li>\n<li>allkeys-random ：对所有key<code>随机删除</code></li>\n<li><code>volatie</code>-random ： 对所有<code>设置了过期时间的key</code> <code>随机删除</code></li>\n<li>volatie-ttl ：对所有设置了过期时间的key<code>随即删除</code></li>\n<li>allkeys-lfu：对所有key使用LFU算法进行删除</li>\n<li>volatile-lfu：对所有设置了过期时间的key使用LFU算法进行删除</li>\n</ul>\n<blockquote>\n<p>上面8种模式:   2 * 4 =8、<code>2</code>个维度(过期键中筛选、所有键中筛选)、<code>4</code>个方面(LRU、LFU、random、ttl)、<code>8</code>个选项</p>\n</blockquote>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202307031742321.png\" alt=\"image-20230527223142532\" style=\"zoom=55%;\"></p>\n<h3 id=\"选择原则\"><a href=\"#选择原则\" class=\"headerlink\" title=\"选择原则\"></a>选择原则</h3><ul>\n<li><p>在所有的key都是最近最经常使用，那么就需要选择<code>allkeys-lru</code>进行置换最近最不经常使用的key,如果你不确定使用哪种策略，那么推荐使用<code>allkeys-lru</code></p>\n</li>\n<li><p>如果所有的key的访问概率都是差不多的，那么可以选用<code>allkeys-random</code>策略去置换数据</p>\n</li>\n<li><p>如果对数据有足够的了解，能够为key指定<code>hint</code>(通过<code>expire/ttl</code>指定)，那么可以选择<code>volatile-ttl</code>进行置换</p>\n</li>\n</ul>\n<h3 id=\"使用建议\"><a href=\"#使用建议\" class=\"headerlink\" title=\"使用建议\"></a>使用建议</h3><ul>\n<li><code>避免</code>存储bigkey</li>\n<li>redis缓存淘汰策略配置性能建议<code>开启橢性淘汰</code>，<code>lazyfree-lazy-eviction=yes</code></li>\n</ul>\n<h2 id=\"缓存一致性\"><a href=\"#缓存一致性\" class=\"headerlink\" title=\"缓存一致性\"></a>缓存一致性</h2><h3 id=\"要求\"><a href=\"#要求\" class=\"headerlink\" title=\"要求\"></a>要求</h3><ul>\n<li>如果redis中<font color=\"red\">有数据</font> ，需要和数据库中的值相同</li>\n<li>如果redis中<font color=\"red\">无数据</font> ，数据库中的值要是最新值，且准备回写redis</li>\n</ul>\n<h3 id=\"缓存一致性的2种发生情况\"><a href=\"#缓存一致性的2种发生情况\" class=\"headerlink\" title=\"缓存一致性的2种发生情况\"></a>缓存一致性的2种发生情况</h3><ul>\n<li><p><code>只读缓存</code></p>\n</li>\n<li><p><code>读写缓存</code></p>\n<ul>\n<li><p>同步直写策略<code>[就是只要查到数据库就立刻回写到缓存，保持同步,及时生效]</code></p>\n<ul>\n<li><p>写数据库之后也同步写redis缓存，缓存和数据库中的数据一致；</p>\n</li>\n<li><p>对于读写缓存来说，要想保证缓存和数据库中的数据一致，就要采用<code>同步直写策略</code></p>\n</li>\n</ul>\n</li>\n<li><p>异步缓写策略<code>[业务上有一定的延时允许]</code></p>\n<ul>\n<li><p>正常业务中，MySQL数据变了，但是可以在业务上容许出现一定时间后才作用于redis，比如仓库、物流系统</p>\n</li>\n<li><p>异常情况出现了， 不得不将失败的动作重新修补，有可能需要借助kafka或者RabbitMQ等消息中间件，实现重试重写</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"优化使用\"><a href=\"#优化使用\" class=\"headerlink\" title=\"优化使用\"></a>优化使用</h3><blockquote>\n<p> 采用  <code>双检加锁</code>的思想</p>\n</blockquote>\n<h4 id=\"没有加锁的隐患：\"><a href=\"#没有加锁的隐患：\" class=\"headerlink\" title=\"没有加锁的隐患：\"></a>没有加锁的隐患：</h4><ol>\n<li><p>对于mysql的请求会大量增加<code>（mysql会被打爆）</code>0</p>\n</li>\n<li><p>对于redis 的回写操作可能会 数据覆盖（不是原子操作，多线程就会并发，引发问题）</p>\n</li>\n</ol>\n<h4 id=\"实现思路：\"><a href=\"#实现思路：\" class=\"headerlink\" title=\"实现思路：\"></a>实现思路：</h4><p>当有多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个<code>互斥锁</code>来锁住它。</p>\n<p>其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存；后面的线程进来发现已经有缓存了，就直接走缓存。</p>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202307031742344.png\" alt=\"image-20230525225420679\" style=\"zoom: 25%;\"></p>\n<h3 id=\"一致性的更新策略\"><a href=\"#一致性的更新策略\" class=\"headerlink\" title=\"一致性的更新策略\"></a>一致性的更新策略</h3><h4 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h4><p>达到数据的 <code>最终一致性</code></p>\n<h4 id=\"一致性要求\"><a href=\"#一致性要求\" class=\"headerlink\" title=\"一致性要求\"></a>一致性要求</h4><h5 id=\"弱一致性：\"><a href=\"#弱一致性：\" class=\"headerlink\" title=\"弱一致性：\"></a>弱一致性：</h5><ul>\n<li>过期剔除：   使用<code>redis</code>的内存淘汰机制 ； <font color=\"blue\">给缓存设置过期时间，定期清理缓存并回写，是保证最终一致性的解决方案。</font></li>\n</ul>\n<p>我们可以对存入缓存的数据设置过期时间，所有的<font color=\"red\">写操作以数据库为准</font>，对缓存操作只是尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存，达到一致性，<font color=\"red\">切记，要以mysql的数据库写入库为准</font>。</p>\n<h5 id=\"强一致性：\"><a href=\"#强一致性：\" class=\"headerlink\" title=\"强一致性：\"></a>强一致性：</h5><ol>\n<li>可以停机：停机升级，服务降级</li>\n<li><p>不可以停机：四种策略</p>\n<ul>\n<li><p>先更新数据库，在更新缓存</p>\n</li>\n<li><p>先更新缓存，再更新数据库</p>\n</li>\n<li><p>先删除缓存，在更新数据库</p>\n</li>\n<li><p>先更新数据库，在删除缓存</p>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"细说四种方式\"><a href=\"#细说四种方式\" class=\"headerlink\" title=\"细说四种方式\"></a>细说四种方式</h4><h5 id=\"先更新数据库，再更新缓存\"><a href=\"#先更新数据库，再更新缓存\" class=\"headerlink\" title=\"先更新数据库，再更新缓存\"></a><span style=\"color:red\">先更新数据库，再更新缓存</span></h5><h6 id=\"异常情况：\"><a href=\"#异常情况：\" class=\"headerlink\" title=\"异常情况：\"></a><strong>异常情况：</strong></h6><p>多线程环境下，A、B两个线程有快有慢，有前有后有并行</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 A update mysql 100</span><br><span class=\"line\">3 B update mysql 80</span><br><span class=\"line\">4 B update redis 80</span><br><span class=\"line\">2 A update redis 100</span><br></pre></td></tr></table></figure>\n<p>最终结果，mysql和lredis数据不一致，  <code>mysql  80,redis   100</code></p>\n<h5 id=\"先更新缓存，再更新数据库\"><a href=\"#先更新缓存，再更新数据库\" class=\"headerlink\" title=\"先更新缓存，再更新数据库\"></a><span style=\"color:red\">先更新缓存，再更新数据库</span></h5><h6 id=\"异常情况：-1\"><a href=\"#异常情况：-1\" class=\"headerlink\" title=\"异常情况：\"></a><strong>异常情况</strong>：</h6><p>多线程环境下，A、B两个线程有快有慢，有前有后有并行</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A update redis 100</span><br><span class=\"line\">B update redis 80</span><br><span class=\"line\">B update mysql 80</span><br><span class=\"line\">A update mysql 100</span><br><span class=\"line\">mysql 100,redis 80</span><br></pre></td></tr></table></figure>\n<p>最终结果，mysql和lredis数据不一致，  <code>mysql  100,redis  80</code></p>\n<h5 id=\"先删除缓存，再更新数据库\"><a href=\"#先删除缓存，再更新数据库\" class=\"headerlink\" title=\" 先删除缓存，再更新数据库 \"></a><span style=\"color:red\"> 先删除缓存，再更新数据库 </span></h5><h6 id=\"异常情况\"><a href=\"#异常情况\" class=\"headerlink\" title=\"异常情况\"></a><strong>异常情况</strong></h6><ol>\n<li><p>A线程先成功删除了redis里面的数据，然后去更新mysql,  此时mysql正在更新中，还没有结束。(比如网络延时)</p>\n</li>\n<li><p>B突然出现要来读取缓存数据。此时redis里面的数据是空的，B线程来读取，先去读redis里数据(已经被A线程delete掉了)，</p>\n</li>\n</ol>\n<p>此处出来2个问题:<br>2.1 B从mysql获得了旧值   B线程发现redis里没有(缓存缺失)马上去mysql里面读取，从数据库里面读取来的是旧值。<br>2.2 B会把获得的旧值写回redis  获得旧值数据后返回前台并回写进redis(刚被A线程删除的旧数据有极大可能早被写回了)。</p>\n<ol>\n<li><p>就是说   A线程更新完mysql,发现redis里面的缓存是脏数据，两个并发操作，一个是更新操作，另一个是查询操作，A删除缓存后，B查询操作没有命中缓存，B先把老数据读出来后放到缓存中，然后A更新操作更新了数据库。于是，在缓存中的数据还是老的数据，导致缓存中的数据是脏的，而且还一直这样脏下去了。</p>\n</li>\n<li><p>总结流程:<br>(1)请求A进行写操作，删除redis缓存后，工作正在进行中，更新mysql….. A还没有彻底更新完mysql,还没commit<br>(2)请求B开工查询，查询redis发现缓存不存在(被A从redis中删除了)<br>(3)请求B继续，去数据库查询得到了mysql中的旧值(A还没有更新完)<br>(4)请求B将旧值写回redis缓存<br>(5)请求A将新值写入mysql数据库</p>\n</li>\n</ol>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202307031742941.png\" alt=\"image-20230525231633568\" style=\"zoom:43%;\"></p>\n<p>问题：如果数据库更新失败或超时或返回不及时，导致B线程请求访问缓存时发现redis里面没数据，缓存缺失，B再去读取mysql时，从数据库中读取到旧值，还写回redis， 导致A白干了</p>\n<h6 id=\"解决方案：\"><a href=\"#解决方案：\" class=\"headerlink\" title=\"解决方案：\"></a><strong>解决方案：</strong></h6><blockquote>\n<p>$\\textcolor{blue}{\\large延时双删}$：<font color=\"red\">采用<code>延时双删</code>[ 在第一次删除缓存值后，延迟一段时间再次进行删除]  策略 </font></p>\n</blockquote>\n<p>主要思想就是： 让一个线程删除前先进行休眠，并且其sleep的时间  需要大于另一个正在进行  <code>读取数据+ 写入缓存</code>的线程 的耗时之和</p>\n<h6 id=\"追问\"><a href=\"#追问\" class=\"headerlink\" title=\"追问\"></a><font color=\"red\"><strong>追问</strong></font></h6><ul>\n<li><p><strong>这个删除该休眠多久呢</strong>？</p>\n<ul>\n<li>线程A <code>sleep的时间</code>，就需要<code>大于</code>线程B<code>读取数据再写入缓存的时间之和</code>。</li>\n</ul>\n</li>\n<li><p><strong>这个时间怎么确定呢</strong>?</p>\n<font color=\"blue\">第一种方法：</font>在业务程序运行的时候，统计下线程读数据和写缓存的操作时间，`自行评估`自己的项目的读数据业务逻辑的耗时，以此为基础来进行估算。然后写数据的`休眠时间`则在`读数据业务逻辑的耗时基础上`加`百毫秒`即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。\n<font color=\"blue\">第二种方法：</font><font color=\"blue\">新启动一个后台监控程序，比如 `WatchDog`监控程序，会自动续费加时</font>\n</li>\n<li><p><strong>这种同步淘汰策略，吞吐量降低怎么办？</strong></p>\n<ul>\n<li>将第二次删除作为异步的，再启动一个线程进行异步删除，就可以不让写请求进行sleep 之后再返回，即可加大吞吐量</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202307031742326.png\" alt=\"image-20230525233149371\" style=\"zoom:50%;\"></p>\n<p>​</p>\n<h5 id=\"先更新数据库，再删除缓存\"><a href=\"#先更新数据库，再删除缓存\" class=\"headerlink\" title=\" 先更新数据库，再删除缓存 \"></a><span style=\"color:red\"> 先更新数据库，再删除缓存 </span></h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>时间</th>\n<th>线程A</th>\n<th>线程B</th>\n<th>出现的问题</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>t1</td>\n<td>更新数据库中的值……</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>t2</td>\n<td></td>\n<td>缓存立刻命中，此时B读取的是缓存旧值</td>\n<td>A还没来得及删除缓存的值，导致B缓存命中读到旧值</td>\n</tr>\n<tr>\n<td>t3</td>\n<td>更新缓存的数据，over</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h6 id=\"问题：\"><a href=\"#问题：\" class=\"headerlink\" title=\"问题：\"></a>问题：</h6><p>先更新数据库，在删除缓存，假如缓存删除失败或者来不及删除，导致请求再次访问redis时缓存命中，<font color=\"red\">读取到的是缓存的旧值。</font></p>\n<h6 id=\"解决：\"><a href=\"#解决：\" class=\"headerlink\" title=\"解决：\"></a>解决：</h6><ul>\n<li>使用MQ</li>\n<li>使用 基于 订阅MySQL的 binlog程序的中间件<code>canal</code>   [代码0侵入，所以会更优]</li>\n</ul>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202307031742833.png\" alt=\"image-20230525233703703\" style=\"zoom:35%;\"></p>\n<p>使用<code>消息队列</code>的基本思想</p>\n<ul>\n<li>可以把要删除的缓存值或者是要更新的数据库值<code>暂存</code>到<code>消息队列</code>中（例如使用Kafka/RabbitMQ等)。</li>\n<li>当程序<code>没有能够成功地删除</code>缓存值或者是更新数据库值时，可以从消息队列中<code>重新读取</code>这些值，然后再次进行删除或更新。</li>\n<li>如果<code>能够成功地删除或更新</code>，我们就要把这些值<code>从消息队列中去除</code>，以免重复操作，此时，我们也可以保证数据库和缓存的数据一致了，否则还需要再次进行重试</li>\n<li>如果<code>重试超过的一定次数后还是没有成功</code>，我们就需要向业务层发送报错信息了，通知运维人员。</li>\n</ul>\n<p>此种模式下严格意义上的 <code>强一致性</code>：</p>\n<ul>\n<li>如果业务层要求必须读取一致性的数据，那么我们就需要在更新数据库时，先在Redis缓存客户端暂停并发读请求，等数据库更新完、缓存值删除后，再读取数据，从而保证数据一致性</li>\n</ul>\n<font color=\"blue\" size=\"4\">只能达到最终一致性!!!!</font>\n\n\n\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305262244890.png\" alt=\"image-20230526224429842\" style=\"zoom:35%;\"></p>\n<h4 id=\"textcolor-red-总结\"><a href=\"#textcolor-red-总结\" class=\"headerlink\" title=\"$\\textcolor{red}{总结}$\"></a>$\\textcolor{red}{总结}$</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>策略</th>\n<th>是否是高并发多线程条件下</th>\n<th>问题</th>\n<th>现象</th>\n<th>解决方案</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>先删再更</td>\n<td>否</td>\n<td>缓存删除成功但数据库更新失败</td>\n<td>Java程序从数据库中读到旧值</td>\n<td>再次更新数据库，重试</td>\n</tr>\n<tr>\n<td>先删再更</td>\n<td>是</td>\n<td>缓存删除成功但数据库更新中…有并发请求</td>\n<td>并发请求从数据库读到旧值并回写到redis，导致后续都是从redis读取到旧值</td>\n<td>延迟双删</td>\n</tr>\n<tr>\n<td>先更再删</td>\n<td>否</td>\n<td>数据库更新成功，但缓存删除失败</td>\n<td>Java程序从redis中读到旧值</td>\n<td>再次删除缓存，重试</td>\n</tr>\n<tr>\n<td>先更再删</td>\n<td>是</td>\n<td>数据库更新成功但缓存删除中……有并发读请求</td>\n<td>并发请求从缓存读到旧值</td>\n<td>等待redis删除完成，这段时间数据不一致，短暂存在。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"三种缓存的设计模式：\"><a href=\"#三种缓存的设计模式：\" class=\"headerlink\" title=\"三种缓存的设计模式：\"></a>三种缓存的设计模式：</h2><ul>\n<li><p><code>Cache Aside Pattern</code> 旁路缓存模式：缓存调用者在<code>更新完数据库后再去更新缓存</code>，也称之为双写方案</p>\n</li>\n<li><p><code>Read/Write Through Pattern</code> 读写穿透模式: 由系统本身完成，<code>数据库与缓存的问题交由系统本身去处理</code></p>\n</li>\n<li><p><code>Write Behind Caching Pattern</code> 异步缓存写入模式：调用者只操作缓存，其他线程去<code>异步处理数据库</code>，实现最终一致</p>\n</li>\n</ul>\n<h4 id=\"如何保证缓存与数据库的操作的同时成功或失败\"><a href=\"#如何保证缓存与数据库的操作的同时成功或失败\" class=\"headerlink\" title=\"如何保证缓存与数据库的操作的同时成功或失败\"></a>如何保证缓存与数据库的操作的同时成功或失败</h4><ul>\n<li>单体系统，将缓存与数据库操作放在一个<code>事务</code></li>\n<li>分布式系统，利用<code>TCC等分布式事务</code>方案</li>\n</ul>\n","_path":"post/d27b7f98.html","_link":"http://rycan.top/post/d27b7f98.html","_id":"cljn5lv4j004rmi134wqa774y"}}