{"type":"getPostById","data":{"title":"MySQL索引","date":"2023-07-02T12:17:34.000Z","description":"MySQL索引的简单介绍","categories":[{"name":"MySQL","_id":"cljmtkunl0004hi0p8yn88urj"}],"tags":[{"name":"MySQL","_id":"cljmtkunl0005hi0p6d8g6ui9"}],"content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<h2 id=\"为什么使用索引\"><a href=\"#为什么使用索引\" class=\"headerlink\" title=\"为什么使用索引\"></a>为什么使用索引</h2><p>目的： 减少磁盘的<code>IO</code>次数，快速找到数据的记录，没有建立索引的时候，进行数据读取的时候是非常耗时的</p>\n<h2 id=\"索引是什么\"><a href=\"#索引是什么\" class=\"headerlink\" title=\"索引是什么\"></a>索引是什么</h2><h3 id=\"本质\"><a href=\"#本质\" class=\"headerlink\" title=\"本质\"></a>本质</h3><p>就是一种数据结构，由于其 <code>在存储引擎中实现</code>，所以每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型</p>\n<h3 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><ul>\n<li>唯一索引可以 保证表中每一行数据的唯一性</li>\n<li>可以加速 <code>表之间的连接</code></li>\n<li>降低了CPU的消耗，减少查询中<code>分组 和 排序</code>的时间</li>\n</ul>\n<h3 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h3><ul>\n<li>创建和维护索引 需要<code>耗费一定的时间</code>，并且会随着数据库中数据量的增加所耗费的时间也会增加</li>\n<li>索引会<code>占用一定的磁盘空间</code>，每个索引还需要一定的物理空间存储在磁盘中</li>\n<li><code>会降低更新表的速度</code>，因为在更新表数据的时候，索引也是需要进行动态维护的，从而间接影响了数据的维护速度</li>\n</ul>\n<h3 id=\"Innodb存储引擎的数据结构\"><a href=\"#Innodb存储引擎的数据结构\" class=\"headerlink\" title=\"Innodb存储引擎的数据结构\"></a><code>Innodb</code>存储引擎的数据结构</h3><ul>\n<li><p>B+树</p>\n<p>索引快的原因：</p>\n<p>​    <strong>其一：</strong> 因为<strong>B+树一般不会超过 4 层，所以在进行键值对查找的时候最多只需要4次磁盘IO操作，指挥进行3次目录项页和1次记录页</strong></p>\n<p>​    <strong>其二：</strong> 在每个页面之间是进行<code>二分法</code>进行 快速定位 记录的</p>\n</li>\n<li><p>特点：</p>\n<ul>\n<li>一个B+树索引的根节点不会移动</li>\n<li>B+树的同一层页节点的目录项记录<code>除页号</code>这个字段<code>以外</code>是<code>唯一的</code></li>\n<li>一个页面最少存储 2 条记录</li>\n<li>一个B+树只需要很少的层级就可以存储数亿条记录</li>\n</ul>\n</li>\n</ul>\n<p>​</p>\n<h2 id=\"索引的分类\"><a href=\"#索引的分类\" class=\"headerlink\" title=\"索引的分类\"></a>索引的分类</h2><ul>\n<li>功能逻辑上分为：普通索引，唯一索引，逐渐索引，全文索引</li>\n<li>物理实现方式： 聚簇索引和非聚簇索引</li>\n<li>作用字段个数：单列索引和联合索引</li>\n</ul>\n<h3 id=\"聚簇索引\"><a href=\"#聚簇索引\" class=\"headerlink\" title=\"聚簇索引\"></a>聚簇索引</h3><h4 id=\"介绍：\"><a href=\"#介绍：\" class=\"headerlink\" title=\"介绍：\"></a>介绍：</h4><ul>\n<li>所有的记录都是存储在叶子结点的</li>\n</ul>\n<h4 id=\"特点：\"><a href=\"#特点：\" class=\"headerlink\" title=\"特点：\"></a>特点：</h4><ul>\n<li><p>B+树的 叶子节点 存储的是<code>数据记录</code></p>\n</li>\n<li><p>一个表<code>只能有一个聚簇索引</code>，因为只能有一种排序存储的方式</p>\n</li>\n<li><p>使用记录主键值的<code>大小</code>进行记录并对其进行页的排序</p>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202307021912998.png\" alt=\"image-20230702191254974\" style=\"zoom:50%;\"></p>\n<ul>\n<li><p><code>页内记录</code>是按照<code>主键大小</code>顺序排成一个 <code>单向链表</code></p>\n</li>\n<li><p>不同的层次存放的 <code>目录项记录的页</code> 在同一层次中的页也是根据页中目录项记录的<code>主键大小</code>顺序排成一个 <code>双向链表</code></p>\n</li>\n<li><p>存放 <code>用户记录的页</code> 也是根据页中用户记录的<code>主键大小</code>顺序排成一个 <code>双向链表</code></p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ul>\n<li><code>数据访问更快</code> ，因为聚簇索引将<code>索引和数据保存在同一个B+树中</code>，因此从聚簇索引中获取数据更快</li>\n<li>聚簇索引支持主键的 <code>排序查找</code> 和 <code>范围查找</code> ，所以速度非常快</li>\n<li>按照聚簇索引排列顺序，<code>查询</code>显示<code>一定范围数据</code>的时候，由于数据都是紧密相连，数据库不用从多 个数据块中提取数据，所以 <code>节省了大量的IO操作</code></li>\n</ul>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ul>\n<li><code>插入速度严重依赖于插入顺序</code> ，按照主键的顺序插入是最快的方式，否则将会出现<code>页分裂</code>，严重影响性能。<ul>\n<li>因此，对于InnoDB表，我们一般都会定义一个<code>自增的ID列为主键</code></li>\n</ul>\n</li>\n<li><code>更新主键的代价很高</code> ，因为将会导致被更新的行移动。<ul>\n<li>因此，对于InnoDB表，我们一般定义<strong>主键为不可更新</strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"非聚簇索引（二级索引-辅助索引）\"><a href=\"#非聚簇索引（二级索引-辅助索引）\" class=\"headerlink\" title=\"非聚簇索引（二级索引 / 辅助索引）\"></a>非聚簇索引（二级索引 / 辅助索引）</h3><h4 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h4><ul>\n<li>非聚簇索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个非聚簇索引</li>\n<li>非聚簇索引的叶子节点存储的是<code>数据位置</code></li>\n<li>对数据进行插入，删除，更新等操作，效率会比聚簇索引高</li>\n</ul>\n<h4 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ul>\n<li><code>更新主键的代价不是很高</code></li>\n</ul>\n<h4 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ul>\n<li><code>插入速度严重依赖于插入顺序</code></li>\n<li><code>会进行回表查询</code></li>\n</ul>\n<h3 id=\"联合索引\"><a href=\"#联合索引\" class=\"headerlink\" title=\"联合索引\"></a>联合索引</h3><ul>\n<li><p>每条目录项都有<code>c2、c3、页号</code>这三个部分组成，各条记录先按照<code>c2</code>列的值进行排序，如果记录的<code>c2</code>列相同，则按照<code>c3</code>列的值进行排序</p>\n</li>\n<li><p>B+树叶子节点处的用户记录由<code>c2、c3和主键c1</code>列组成</p>\n</li>\n<li><p>以c2和c3列的大小为排序规则建立的B+树称为 <code>联合索引</code> ，本质上也是一个<code>二级索引</code>。</p>\n<p>注意一点，它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：</p>\n<ul>\n<li>建立 联合索引 只会建立1棵B+树。</li>\n<li>为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"普通索引\"><a href=\"#普通索引\" class=\"headerlink\" title=\"普通索引\"></a>普通索引</h3><ul>\n<li>在创建普通索引时，不附加任何限制条件，只是用于提高查询效率。</li>\n</ul>\n<h3 id=\"唯一性索引\"><a href=\"#唯一性索引\" class=\"headerlink\" title=\"唯一性索引\"></a>唯一性索引</h3><ul>\n<li>使用UNIQUE:参数可以设置索引为唯一性索引 ，限制该索引的值必须是唯一的，但允许有空值。在一张数据表里可以有多个唯一索引。<br>可以更快速地确定某条记录。</li>\n</ul>\n<h3 id=\"主键索引\"><a href=\"#主键索引\" class=\"headerlink\" title=\"主键索引\"></a>主键索引</h3><ul>\n<li>在唯一索引的基础上增加了不为空的约束，也就是<code>NOT NULL+UNIQUE</code>,一张表里最多只有一个主键索引。这是由主键索引的物理实现方式决定的，因为数据存储在文件中只能按照一种顺序进行存储。</li>\n</ul>\n<h3 id=\"单列索引\"><a href=\"#单列索引\" class=\"headerlink\" title=\"单列索引\"></a>单列索引</h3><ul>\n<li>在表中的单个字段上创建索引。单列索引只根据该字段进行索引。单列索引可以是普通索引，也可以是唯一性索引，还可以是全文索引。只要保证该索引只对应一个字段即可。一个表可以有多个单列索引。</li>\n</ul>\n<h3 id=\"多列（组合、联合）索引\"><a href=\"#多列（组合、联合）索引\" class=\"headerlink\" title=\"多列（组合、联合）索引\"></a>多列（组合、联合）索引</h3><ul>\n<li>多列索引是在表的多个字段组合上创建一个索引。该索引指向创建时对应的多个字段，可以通过这几个字段进行查询，但是只有查询条件中使用了这些字段中的第一个字段时才会被使用。使用组合索引时遵循最左前缀集合。</li>\n</ul>\n<h3 id=\"全文检索\"><a href=\"#全文检索\" class=\"headerlink\" title=\"全文检索\"></a>全文检索</h3><ul>\n<li>利用【分词技术】等多种算法智能分析出文本文字中关键词的频率和重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。全文索引非常适合大型数据集，对于小的数据集，它的用处比较小。</li>\n</ul>\n<blockquote>\n<p><code>Innodb</code>和<code>MyISAM</code>默认的索 引是<code>Btree索引</code>；而<code>Memory</code>默认的索引是<code>Hash索引</code>。</p>\n</blockquote>\n<h2 id=\"Innodb和MyISAM区别\"><a href=\"#Innodb和MyISAM区别\" class=\"headerlink\" title=\"Innodb和MyISAM区别\"></a><code>Innodb</code>和<code>MyISAM</code>区别</h2><p>①在InnoDB存储引擎中，我们<code>只</code>需要根据<code>主键值</code>对 <code>聚簇索引</code> 进行<code>一次查找就能找到对应的记录</code>；而在 MyISAM 中<code>却需要进行一次 回表</code> 操作，意味着MyISAM中建立的<code>索引</code>相当于全部都是 <code>二级索引</code>。</p>\n<p>② InnoDB的数据文件本身就是<code>索引文件</code>;  而MyISAM<code>索引文件和数据文件</code>是分离的 ，<code>MyISAM</code>de索引文件仅保存数据记录的地址。</p>\n<p>③ InnoDB的非聚簇索引data域存储相应记录 <code>主键的值</code> ，而MyISAM索引记录的是 <code>地址</code>。换句话说，InnoDB的所有非聚簇索引都引用主键作为data域。</p>\n<blockquote>\n<p>为什么不建议使用过长的字段作为主键？  因为所有二级索引都引用主键索引，过长的主键索引会令二级索引变得过大。</p>\n</blockquote>\n<h2 id=\"多种索引数据结构的选择\"><a href=\"#多种索引数据结构的选择\" class=\"headerlink\" title=\"多种索引数据结构的选择\"></a>多种索引数据结构的选择</h2><h3 id=\"Hash\"><a href=\"#Hash\" class=\"headerlink\" title=\"Hash\"></a>Hash</h3><blockquote>\n<p>Hash结构<code>效率高</code>，那为什么索引结构要设计成树型呢？</p>\n<ul>\n<li>Hash索引<code>仅能</code>满足(=)(&lt;  &gt; )和IN查询。如果进行范围查询，哈希型的索引，时间复杂度会退化为O(n)；而树型的“有序”特性，依然能够保持<code>O(logN)</code>的高效率。</li>\n<li>另一个缺陷，数据的存储是<code>没有顺序</code>的，在ORDER BY的情况下，使用Hash索引还需要对数据重新排序。</li>\n<li>对于<code>联合索引</code>的情况，Hash值是将联合索引键<code>合并后一起来计算</code>的，无法对单独的一个键或者几个索键进行查询。</li>\n<li>对于<code>等值查询</code>来说，通常<code>Hash索引的效率更高</code>，不过也存在一种情况，就是索引列的<code>重复值如果很多</code>，效率就会降低。这是因为遇到Hash冲突时，需要遍历桶中的行指针来进行比较，找到查询的关键字，非常耗时。</li>\n<li>所以，Hash索引通常不会用到重复值多的列上，比如列为性别、年龄的情况等。</li>\n</ul>\n</blockquote>\n<h3 id=\"二叉搜索树\"><a href=\"#二叉搜索树\" class=\"headerlink\" title=\"二叉搜索树\"></a>二叉搜索树</h3><blockquote>\n<p>磁盘的IO次数和索引树的高度是相关的,<code>特殊情况下会达到O(n)的复杂度，此时就会退化为链表</code></p>\n</blockquote>\n<h3 id=\"AVL树\"><a href=\"#AVL树\" class=\"headerlink\" title=\"AVL树\"></a>AVL树</h3><blockquote>\n<p>可以解决<code>退化为链表</code> 的问题，但是当节点很多的时候，树的深度还是会很大。</p>\n</blockquote>\n<h3 id=\"B-Tree\"><a href=\"#B-Tree\" class=\"headerlink\" title=\"B-Tree\"></a>B-Tree</h3><blockquote>\n<ul>\n<li>B树在插入和删除节点的时候如果导致树不平衡，就通过自动调整节点的位置来保持树的自平衡。</li>\n<li>关键字集合分布在整棵树中，即叶子节点和非叶子节点都存放数据。搜索有可能在非叶子节点结束</li>\n<li>其搜索性能等价于在关键字全集内做一次二分查找。</li>\n<li><p>一个 M 阶的 B 树（M&gt;2）有以下的特性：</p>\n<ol>\n<li>根节点的<code>孩子数</code>的范围是 [2,M]</li>\n<li>每个中间节点包含<code>k-1</code> 个关键字和<code>k</code> 个孩子，孩子的数量 = 关键字的数量 +1，k 的取值范围为<code>[ceil(M/2), M]</code></li>\n<li>叶子节点包括 <code>k-1</code>个关键字（叶子节点没有孩子），<code>k</code> 的取值范围为<code>[ceil(M/2), M]</code></li>\n<li>假设中间节点节点的关键字为：<code>Key[1], Key[2], …, Key[k-1]</code>，且关键字按照升序排序，即 <code>Key[i]&lt;Key[i+1]</code>。此时 <code>k-1</code> 个关键字相当于划分了<code>k</code> 个范围，也就是对应着 <code>k</code>个指针，即为：<code>P[1], P[2], …, P[k]</code>，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k] 指向关键字大于 Key[k-1] 的子树</li>\n<li>所有叶子节点位于同一层</li>\n</ol>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"B-Tree-1\"><a href=\"#B-Tree-1\" class=\"headerlink\" title=\"B+Tree\"></a>B+Tree</h3><blockquote>\n<p>B+树的中间节点并不直接存储数据。这样的好处都有什么呢？</p>\n<ul>\n<li>首先，<code>B+树查询效率更稳定</code>。因为B+树每次只有访问到叶子节点才能找到对应的数据；而在<code>B树</code>中，非叶子节点也会存储数据，这样就会造成查询效率不稳定的情况，有时候访问到了非叶子节点就可以找到关键字，而有时需要访问到叶子节点才能找到关键字。</li>\n<li>其次，<code>在单个关键字上，B+树的查询效率更高</code>。这是因为通常B+树比B树更矮胖（阶数更大，深度更低），查询所需要的磁盘IO也会更少。同样的磁盘页大小，B+树可以存储更多的节点关键字。</li>\n<li><code>在查询范围上，B+树的效率也比B树高</code>。这是因为所有关键字都出现在B+树的叶子节点中，叶子节点之间会有指针，数据又是递增的，这使得我们范围查找可以通过指针连接查找。而在B树中则需要通过中序遍历才能完成查询范围的查找，效率要低很多。</li>\n</ul>\n</blockquote>\n<h3 id=\"R树\"><a href=\"#R树\" class=\"headerlink\" title=\"R树\"></a>R树</h3><blockquote>\n<ul>\n<li>仅支持 <code>geometry</code>数据类型</li>\n<li>R树就很好的 解决了这种<code>高维空间搜索问题</code></li>\n<li>它把B 树的思想很好的扩展到了多维空间，采用了B树分割空间的思想，并在添加、删除操作时采用合并、分解 结点的方法，保证树的平衡性。</li>\n<li>因此，R树就是一棵用来 存储高维数据的平衡树 。相对于<code>B-Tree，R-Tree</code> 的优势在于范围查找。</li>\n</ul>\n</blockquote>\n<h2 id=\"B树-VS-B-树\"><a href=\"#B树-VS-B-树\" class=\"headerlink\" title=\"B树 VS. B+树\"></a><code>B树</code> VS. <code>B+树</code></h2><blockquote>\n<ol>\n<li>B+树  有 k 个孩子的节点就有 k 个关键字。也就是<code>孩子数量 = 关键字数</code>，而 B 树中，<code>孩子数量 = 关键字数 +1</code>。</li>\n<li>B+树  <code>非叶子节点</code>的关键字也会同时存在<code>子节点</code>中，并且是在子节点中所有关键字的<code>最大（或最小）</code>。</li>\n<li>B+树  <code>非叶子节点</code>仅用于索引，不保存数据记录，跟<code>记录有关的信息都放在叶子节点</code>中。而 <code>B 树</code>中， <code>非叶子节点既保存索引，也保存数据记录</code> 。</li>\n<li>B+树  所有<code>关键字</code>都在<code>叶子节点</code>出现，叶子节点构成一个<code>有序链表</code>，而且叶子节点本身按照关键字的大小<code>从小到大顺序链接</code></li>\n</ol>\n</blockquote>\n<h2 id=\"Hash-索引-VS-B-树索引\"><a href=\"#Hash-索引-VS-B-树索引\" class=\"headerlink\" title=\"Hash 索引 VS. B+树索引\"></a><code>Hash 索引</code> VS. <code>B+</code>树索引</h2><ul>\n<li>Hash索引<code>不能进行范围查询</code>，而B+树<code>可以</code>。这是因为<code>Hash索引指向的数据是无序</code>的，而B+树的叶子节点是个有序的链表。</li>\n<li>Hash索引<code>不支持</code>联合索引的<code>最左匹配原则</code>（即联合索引的部分索无法使用），而<code>B+树可以</code>。对于联合索引来说，Hash索引在计算Hash值的时候是将<code>索引键合并</code>后再一起计算Hash值，所以不会针对每个索引单独计算Hash值。因此如果用到联合索引的一个或者几个索时，联合索引无法被利用。</li>\n<li>Hash索引不支持<code>ORDER BY</code>排序，因为<code>Hash</code>索引指向的数据是<code>无序</code>的，因此无法起到排序优化的作用，而<code>B+树</code>索引数据是有序的，可以起到对该字段<code>ORDER BY</code>排序优化的作用</li>\n<li>无法用<code>Hash索引</code>进行模糊查询，而B+树使用<code>LIKE</code>进行模糊查询的时候，<code>LIKE</code>后面模糊查询（比如%结尾）的话就可以起到优化作用。</li>\n<li><code>InnoDB</code>不支持哈希索引</li>\n</ul>\n<h2 id=\"索引的设计原则\"><a href=\"#索引的设计原则\" class=\"headerlink\" title=\"索引的设计原则\"></a>索引的设计原则</h2><h3 id=\"哪些情况适合创建索引\"><a href=\"#哪些情况适合创建索引\" class=\"headerlink\" title=\"哪些情况适合创建索引\"></a>哪些情况适合创建索引</h3><ul>\n<li>如果某个字段是<code>唯一性</code>的，就可以直接创建<code>唯一性索引</code>，或者<code>主键索引</code>（具有唯一特性的字段，即使是组合字段，也必须建成唯一索引）</li>\n<li>频繁作为 <code>WHERE</code>查询条件的字段</li>\n<li>经常 <code>GROUP BY 和 ORDER BY</code>的列</li>\n<li><code>UPDATE、DELETE 的 WHERE</code>条件列</li>\n<li><code>DISTINCT</code> 字段需要创建索引</li>\n<li><p>使用列的<code>类型小（数据范围小）的创建索引</code></p>\n<ul>\n<li>数据类型越小，在查询时进行的比较操作越快</li>\n<li>数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘I0带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</li>\n</ul>\n</li>\n<li>使用<code>字符串前缀创建索引</code>:  可以通过截取字段的前面一部分内容建立索引，这个就叫前缀索引</li>\n<li><code>区分度高(散列性高)的列</code>适合作为索引</li>\n<li>使用<code>最频繁的列</code>放到<code>联合索引</code>的左侧</li>\n</ul>\n<blockquote>\n<p>但是使用索引列前缀的方式 <code>无法支持使用索引排序</code> ，只能使用文件排序。</p>\n<p>==ps==  在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据<code>实际文本</code> 区分度决定<code>索引长度</code>。</p>\n</blockquote>\n<h3 id=\"多表-JOIN-连接操作时，创建索引注意事项\"><a href=\"#多表-JOIN-连接操作时，创建索引注意事项\" class=\"headerlink\" title=\"多表 JOIN 连接操作时，创建索引注意事项\"></a>多表 JOIN 连接操作时，创建索引注意事项</h3><ul>\n<li>首先， <code>连接表的数量尽量不要超过 3 张</code></li>\n<li>其次， <code>对 WHERE 条件创建索引</code> ，因为 WHERE 才是对数据条件的过滤。</li>\n<li><p>最后， <code>对用于连接的字段创建索引</code> ，并且该字段在多张表中的 类型必须一致</p>\n</li>\n<li><p>在多个字段都要创建索引的情况下，<code>联合索引优于单值索引</code></p>\n<ul>\n<li>在where中使用不到的字段，不要设置索引</li>\n<li><code>数据量小</code>的表最好不要使用索引</li>\n<li>避免对经常<code>更新的表</code>创建过多的索引</li>\n<li>有<code>大量重复数据的列</code>上不要建立索引</li>\n<li>不建议用<code>无序的值</code>作为索引    eg：身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字 符串等。</li>\n<li><code>删除不再使用或者很少使用的索引</code></li>\n<li><code>不要定义冗余或重复</code>的索引</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>为了减少IO，索引树会一次性加载吗？</p>\n</blockquote>\n<ul>\n<li>数据量非常大的时候不太可能，只能逐一加载</li>\n</ul>\n<blockquote>\n<p> B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO</p>\n</blockquote>\n<p>InnoDB存储引擎中<code>页的大小为16KB</code>,一个页(B+Tre中的一个节点)中大概存储<code>1K个键值</code>（因为是估值，为方便计算，这里的K取值为10^3^。也就是说一个<code>深度为3</code>的<code>B+Tree索引可以维护</code>10^3^*10^3^*10^3^=<code>10亿条记录</code>。（这里假定一个数据页也存储10^3^条行记录数据了）<br>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2~4层。MySQL的InnoDB存储引擎在设计时是将<code>根节点常驻内存</code>的，也就是说查找某一键值的行记录时<code>最多只需要1~3次磁盘</code>I0操作。</p>\n","_path":"post/43a71ae4.html","_link":"http://rycan.top/post/43a71ae4.html","_id":"cljmtkunj0001hi0phm5h5unx"}}