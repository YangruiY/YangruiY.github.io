{"type":"getPostByPath","data":{"title":"JUC 学习合集","date":"2023-07-03T12:23:00.000Z","description":"JUC合集","categories":[{"name":"Java","_id":"cloioo9e3003jni0pa4q13wrr"}],"tags":[{"name":"Java","_id":"cloioo9e3003nni0p1taq6ln4"}],"content":"<meta name=\"referrer\" content=\"no-referrer\">\n<p>承[满一航  JUC+周阳 JUC][]</p>\n<h1>JUC</h1>\n<h2 id=\"面试合集\">面试合集</h2>\n<h5 id=\"Synchronized相关问题\">Synchronized相关问题</h5>\n<p>1.Synchronized用过吗， 其原理是什么?</p>\n<p>2.你刚才提到获取对象的锁，这个锁到底是什么?如何确定对象的锁?</p>\n<p>3.什么是可重入性，为什么说Synchronized是可重入锁?</p>\n<p>4.JVM对Java的原生锁做了哪些优化?</p>\n<p>5.为什么说Synchronized是非公平锁?</p>\n<p>6.什么是锁消除和锁粗化?</p>\n<p>7.为什么说Synchronized是个悲观锁?乐观锁的实现原理又是什么?什么是CAS</p>\n<p>8.乐观锁一定就是好的吗?</p>\n<h5 id=\"可重入锁Reentrant-Lock及其他显式锁相关问题\">可重入锁Reentrant Lock及其他显式锁相关问题</h5>\n<p>1.跟Synchronized相比，可重入锁Reentrant Lock其实现原理有什么不同?</p>\n<p>2.那么请谈谈AQS框架是怎么回事儿?</p>\n<p>3.请尽可能详尽地对比下Synchronized和Reentrant Lock的异同</p>\n<p>4.Reentrant Lock是如何实现可重入性的?</p>\n<h5 id=\"java线程池\">java线程池</h5>\n<p>3.你怎么理解java多线程的?怎么处理并发?线程池有那几个核心参数?</p>\n<p>4.Java加锁有哪几种锁?我先说了synchronized， 刚讲到偏向锁， 他就不让我讲了，</p>\n<p>5.简单说说lock?</p>\n<p>6.hashmap的实现原理?hash冲突怎么解决?为什么使用红黑树?</p>\n<p>7.spring里面都使用了那些设计模式?循环依赖怎么解决?</p>\n<p>8.项目中那个地方用了countdownlanch， 怎么使用的?</p>\n<h5 id=\"interrupt-interrupted-isInterrupted\">interrupt()    interrupted()    isInterrupted()</h5>\n<ul>\n<li>三个方法了解过吗？用在哪？</li>\n<li>如何停止一个运行中的线程？</li>\n<li>如何中断一个运行中的线程？？</li>\n</ul>\n<h5 id=\"JMM\">JMM</h5>\n<ul>\n<li>你知道什么是Java内存模型<code>JMM</code>吗？</li>\n<li><code>JMM</code>与<code>volatile</code>它们两个之间的关系？（下一章详细讲解）</li>\n<li><code>JMM</code>有哪些特性or它的三大特性是什么？</li>\n<li>为什么要有<code>JMM</code>，它为什么出现？作用和功能是什么？</li>\n<li><code>happens-before</code>先行发生原则你有了解过吗？</li>\n</ul>\n<h5 id=\"ThreadLocal\">ThreadLocal</h5>\n<ul>\n<li>ThreadLocal中ThreadLocalMap的数据结构和关系？</li>\n<li>ThreadLocal的key是弱引用，这是为什么？</li>\n<li>ThreadLocal<a href=\"https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F&amp;spm=1001.2101.3001.7020\">内存泄漏</a>问题你知道吗？</li>\n<li>ThreadLocal中最后为什么要加remove方法？</li>\n</ul>\n<h5 id=\"Java对象内存布局和对象头\">Java对象内存布局和对象头</h5>\n<ul>\n<li>你觉得目前面试，你还有那些方面理解的比较好，我没问到的</li>\n<li>那先说juc吧，说下aqs的大致流程</li>\n<li>cas自旋锁，是获取不到锁就一直自旋吗？cas和synchronizedl区别在哪里，为什么cas好，具体优势在哪里，我说cas避免cpu切换线程的开销，又问我在自旋的这个线程能保证一直占用cpu吗？假如cpu放弃了这个线程，不是还要带来线程再次抢占cpu的开销？</li>\n<li>synchronized)底层如何实现的，实现同步的时候用到cas了吗？具体哪里用到了</li>\n<li>我说上个问题的时候说到了对象头，问我对象头存储哪些信息，长度是多少位存储</li>\n</ul>\n<h2 id=\"涉及的概念\">涉及的概念</h2>\n<p><font color=\"red\" size=\"4\">进程</font></p>\n<ul>\n<li>进程就是用来加载指令管理 、 内存管理IO的，当一个指令被运行，从<code>磁盘</code>加载这个程序的代码到<code>内存</code>，这时候就开启了一个进程,进程就可以视为程序的一个实例,进程作为<code>资源分配</code>的<code>最小单位</code></li>\n</ul>\n<p><font color=\"red\" size=\"4\">线程</font></p>\n<ul>\n<li>一个进程之内可以分为多个线程,一个线程就是一个<code>指令流</code>，将指令流中的一条条指令<code>以一定的顺序交给 CPU 执行</code>,线程作为<code>最小调度单位</code>，</li>\n</ul>\n<p><font color=\"red\" size=\"4\">对比</font></p>\n<ul>\n<li>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集</li>\n<li>进程拥有共享的资源，供其内部的线程共享</li>\n<li>进程间通信较为复杂，线程通信相对简单</li>\n<li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换<code>低</code></li>\n</ul>\n<p><font color=\"red\" size=\"4\">管程</font></p>\n<ul>\n<li>Monitor（锁），也就是我们平时所说的锁。</li>\n<li>保证了同一时刻只有一个进程在管程内活动,即管程内定义的操作在同一时刻只被一个进程调用(由编译器实现）</li>\n<li>Monitor其实是一种<strong>同步机制</strong>，可以<code>保证</code>（同一时间）只有一个线程可以访问被保护的<code>数据和代码</code></li>\n<li>JVM中同步是基于进入和退出监视器（管程对象）来实现的，每个<code>对象实例</code>都会有一个<code>Monitor对象</code>，<code>Monitor对象</code>和<code>Java对象</code>一同创建并销毁，底层由C++语言实现。就是说：JVM 中同步是基于进入和退出管程(monitor)对象实现的，每个对象都会有一个管程(monitor)对象，管程(monitor)会随着 java 对象一同创建和销毁</li>\n<li>执行线程首先要持有<code>管程对象</code>，然后<code>才能执行方法</code>，当方法完成之后会<code>释放管程</code>，<code>方法在执行时候会持有管程</code>，其他线程无法再获取同一个管程</li>\n</ul>\n<p><font color=\"red\" size=\"4\">并行</font></p>\n<ul>\n<li>\n<p>多核 cpu下，每个核（core） 都可以调度运行线程，不同的线程同时<code>使用</code>不同的<code>cpu在执行</code></p>\n</li>\n<li>\n<p>并行（parallel）是同一时间<code>动手做</code>（doing）多件事情的能力 ,多项工作一起执行，之后再汇总</p>\n</li>\n<li>\n<p>==&lt;一个人做&gt;==</p>\n</li>\n</ul>\n<p><font color=\"red\" size=\"4\">并发</font></p>\n<ul>\n<li>\n<p>在单核 cpu 下，线程实际还是串行执行的,只是由于 cpu 在线程间（时间片很短）的切换非常快，感觉是同时运行的,线程轮流使用 CPU 的做法称为并发</p>\n</li>\n<li>\n<p>并发（concurrent）是同一时间<code>应对</code>（dealing with）多件事情的能力</p>\n</li>\n<li>\n<p>==&lt;多个人做&gt;==</p>\n</li>\n</ul>\n<p><font color=\"red\" size=\"4\">同步异步</font></p>\n<p>如果<code>需要等待结果返回</code>才能继续运行的话就是同步，如果<code>不需要等待</code>就是异步</p>\n<p>思路：<strong>要解决大并发问题，通常是将大任务分解成多个小任务</strong>, 由于操作系统对进程的调度是随机的，所以切分成多个小任务后，可能会从任一小任务处执行。这可能会出现一些现象：</p>\n<ul>\n<li>\n<p>可能出现一个小任务执行了多次，还没开始下个任务的情况。这时一般会采用<code>队列或类似的数据结构</code>来存放各个小任务的成果</p>\n</li>\n<li>\n<p>可能出现还没准备好第一步就执行第二步的可能。这时，一般采用<code>多路复用或异步</code>的方式，比如只有准备好产生了事件通知才执行某个任务。</p>\n</li>\n<li>\n<p>可以多进程/多线程的方式并行执行这些小任务。也可以单进程/单线程执行这些小任务，这时很可能要配合多路复用才能达到较高的效率</p>\n</li>\n</ul>\n<h3 id=\"Java线程基础知识\">Java线程基础知识</h3>\n<h4 id=\"创建线程\">创建线程</h4>\n<ul>\n<li>\n<p>方法一：继承 <code>Thread</code>类</p>\n</li>\n<li>\n<p>方法二：使用 <code>Runnable  </code>接口</p>\n</li>\n<li>\n<p>方法三：实现<code>Callable</code>接口</p>\n</li>\n</ul>\n<blockquote>\n<p>和下面一一对应</p>\n</blockquote>\n<h4 id=\"创建-运行线程\">创建+运行线程</h4>\n<ul>\n<li>方法一  直接使用 Thread</li>\n<li>方法二  使用 Runnable 配合 Thread</li>\n<li>方法三  FutureTask 配合 Thread   必要的时候可以通过<code>get()</code>方法获取执行结果，但是这个方法会阻塞直到 任务返回结果</li>\n</ul>\n<h4 id=\"线程运行原理涉及的概念\">线程运行原理涉及的概念</h4>\n<blockquote>\n<p>需要 JVM的知识</p>\n</blockquote>\n<p><font color=\"red\">虚拟机栈</font>：每个方法被执行的时候都会同时创建一个栈帧(stack frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息，是属于线程的私有的。</p>\n<p><font color=\"red\">栈帧</font>： 当java中使用多线程时，每个线程都会维护它自己的<code>栈帧</code>！每个线程只能有一个<code>活动栈帧</code>，对应着当前正在执行的那个方法</p>\n<p><font color=\"red\">线程上下文切换的时机：</font></p>\n<ul>\n<li>线程的 cpu 时间片用完(每个线程轮流执行，看前面并行的概念)</li>\n<li>垃圾回收</li>\n<li>有更高优先级的线程需要运行</li>\n<li>线程自己调用了 <code>sleep</code>、<code>yield</code>、<code>wait</code>、<code>join</code>、<code>park</code>、<code>synchronized</code>、<code>lock</code> 等方法</li>\n</ul>\n<p>操作系统保存当前线程的状态，并恢复另一个线程的状态，随后使用<font color=\"red\">程序计数器</font>记住下一条 jvm 指令的执行地址进行地址的转变</p>\n<h4 id=\"Thread的方法\">Thread的方法</h4>\n<ul>\n<li><code>thread.start()</code>       对 重写的 <code>run()</code>方法里面内容的调用是<code>异步</code>的</li>\n<li><code>thread.run()</code>           对 重写的 <code>run()</code>方法里面内容的调用是<code>同步</code>的</li>\n</ul>\n<blockquote>\n<p>直接调用 <code>run()</code> 是在主线程中执行了 <code>run()</code>，没有启动新的线程<br>\n使用 <code>start()</code> 是启动新的线程，通过新的线程间接执行 <code>run()</code>方法 中的代码</p>\n</blockquote>\n<ul>\n<li><code>sleep()</code>\n<ul>\n<li>调用 sleep 会让当前线程从 <code>Running</code> 进入 <code>Timed Waiting</code> 状态（阻塞）</li>\n<li>其它线程可以使用 <code>interrupt</code> 方法打断正在睡眠的线程，那么被打断的线程这时就会抛出 <code>InterruptedException</code>异常【注意：这里打断的是<code>正在休眠</code>的线程，而不是其它状态的线程】</li>\n<li>睡眠结束后的线程未必会立刻得到执行(需要分配到cpu时间片)</li>\n</ul>\n</li>\n<li><code>yield()</code>\n<ul>\n<li>调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程</li>\n<li>yield使cpu调用其它线程，但是cpu可能会再分配时间片给该线程</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><code>yield</code>使cpu调用其它线程，但是cpu可能会再分配时间片给该线程；而<code>sleep</code>需要等过了休眠时间之后才有<code>可能</code>被分配cpu时间片</p>\n</blockquote>\n<ul>\n<li>\n<p><code>join()</code></p>\n<ul>\n<li>在主线程中调用t1.join，则主线程会等待t1线程执行完之后再继续</li>\n</ul>\n</li>\n<li>\n<p><code>join(n)</code>  在指定时间<code>n</code>内要是线程仍在睡眠，那就提前终止t1 线程，不会获得t1线程的内容，要是<code>n&gt;睡眠时间</code>，那就提前结束<code>join(n)</code></p>\n</li>\n<li>\n<p><code>interrupt ()</code>  [深入了解][(<a href=\"https://www.cnblogs.com/noteless/p/10372826.html#0\">https://www.cnblogs.com/noteless/p/10372826.html#0</a>)]</p>\n<ul>\n<li>打断的是 <code>sleep，wait，join</code> 的线程(<code>含有方法 sleep，wait，join的线程 都是阻塞状态的线程</code>)：<code>isInterrupted()</code> 会清空/复位中断状态\n<ul>\n<li>中断状态默认是false ,在打断的时候会是true,因为会清空/复位中断状态，所以状态将会被清除，\n<ul>\n<li>会再次置为<code>false</code>，并且会有异常信息：<code>InterruptedException</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>打断的是正常运行的线程\n<ul>\n<li>可以调用方法<code>Thread.currentThread().isInterrupted();</code>[得到返回值为true]  手动停止线程</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><code>park()</code>: 打断 park 线程，不会清空打断状态（true）,如果<code>打断标记</code>已经是 true, 则 park 会失效,线程不会阻塞</p>\n</li>\n<li>\n<p><code>unpark()</code>: 只要有 这个方法，不管是先<code>park() </code> 还是 后<code>park() </code>，线程都不会进行阻塞</p>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li><code>sleep</code> 不释放锁、释放cpu</li>\n<li><code>join</code> 释放锁、抢占cpu</li>\n<li><code>yiled</code> 不释放锁、释放cpu</li>\n<li><code>wait</code> 释放锁、释放cpu</li>\n</ul>\n</blockquote>\n<h4 id=\"守护线程\">守护线程</h4>\n<ul>\n<li>\n<p>默认情况下，java进程需要等待所有的线程结束后才会停止</p>\n</li>\n<li>\n<p>但是有一种特殊的线程，叫做守护线程</p>\n</li>\n<li>\n<p>在其他线程<code>全部结束</code>的时候即使<code>守护线程</code> 还未结束,代码未执行完  ;java进程也会停止。</p>\n</li>\n<li>\n<p>普通线程t1可以调用<code>t1.setDeamon(true);</code> 方法变成守护线程</p>\n</li>\n</ul>\n<blockquote>\n<p>当前 运行的线程 都是 守护线程,没有用户进程时，Java 虚拟机将退出，因为普通线程执行完后，JVM 是守护线程，不会继续运行下去</p>\n</blockquote>\n<blockquote>\n<p>Java线程分为<code>用户线程和守护线程</code>，线程的<code>daemon</code>属性为**<code>true</code>表示是<code>守护线程</code>，<code>false</code>表示是<code>用户线程</code>**</p>\n</blockquote>\n<ul>\n<li>守护线程\n<ul>\n<li>是一种特殊的线程，在<strong>后台默默地完成一些系统性的服务</strong>，比如垃圾回收线程</li>\n</ul>\n</li>\n<li>用户线程\n<ul>\n<li>是系统的工作线程，它会完成这个程序需要完成的业务操作</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>==注意事项:==</p>\n<ul>\n<li>\n<p>设置守护线程，需要在<code>start()</code>方法之前进行</p>\n</li>\n<li>\n<p>当程序中所有用户线程执行完毕之后，不管守护线程是否结束，系统都会自动退出;就是说：如果用户线程全部结束了，意味着程序需要完成的业务操作已经结束了，系统可以退出<br>\n了。所以当系统只剩下守护进程的时候，java虚拟机会自动退出</p>\n</li>\n</ul>\n</blockquote>\n<h4 id=\"线程的状态\">线程的状态</h4>\n<blockquote>\n<p>五状态</p>\n</blockquote>\n<ul>\n<li>初始状态，仅仅是在语言层面上创建了线程对象，即<code>Thead thread = new Thead();</code>，还未与操作系统线程关联</li>\n<li>可运行状态，也称就绪状态，指该线程已经被创建，与操作系统相关联，等待cpu给它分配时间片就可运行</li>\n<li>运行状态，指线程获取了CPU时间片，正在运行\n<ul>\n<li>当CPU时间片用完，线程会转换至【可运行状态】，等待 CPU再次分配时间片，会导致我们前面讲到的上下文切换</li>\n</ul>\n</li>\n<li>阻塞状态\n<ul>\n<li>如果调用了阻塞API，如BIO读写文件，那么线程实际上不会用到CPU，不会分配CPU时间片，会导致上下文切换，进入【阻塞状态】</li>\n<li>等待BIO操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li>\n<li>与【可运行状态】的区别是，只要操作系统一直不唤醒线程，调度器就一直不会考虑调度它们，CPU就一直不会分配时间片</li>\n</ul>\n</li>\n<li>终止状态，表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li>\n</ul>\n<blockquote>\n<p>六状态</p>\n</blockquote>\n<ul>\n<li><code>NEW</code> 跟五种状态里的初始状态是一个意思</li>\n<li><code>RUNNABLE</code> 是当调用了 <code>start()</code> 方法之后的状态，注意，Java API 层面的 <code>RUNNABLE</code> 状态涵盖了操作系统层面的【可运行状态】、【运行状态】和【io阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是可运行）</li>\n<li><code>BLOCKED</code> ， <code>WAITING</code> ， <code>TIMED_WAITING</code> 都是 Java API 层面对【阻塞状态】的细分</li>\n<li><code>TERMINATED</code></li>\n</ul>\n<h4 id=\"Synchronized-关键字\"><strong>Synchronized 关键字</strong></h4>\n<p><code>synchronized</code> 是 Java 中的关键字，是一种同步锁。</p>\n<p>它修饰的对象有以下几种：</p>\n<ul>\n<li>\n<p>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；</p>\n</li>\n<li>\n<p>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；</p>\n<ul>\n<li>\n<p>注意：</p>\n<ul>\n<li>\n<p>虽然可以使用 <code>synchronized</code> 来定义方法，但 <code>synchronized</code> 并不属于方法定义的一部分，因此，synchronized 关键字<code>不能被继承</code>。</p>\n</li>\n<li>\n<p>如果在父类中的某个方法使用了 <code>synchronized</code> 关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上synchronized 关键字才可以。当然，还可以在子类方法中调用父类中相应的方法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此，子类的方法也就相当于同步了。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>修改一个静态的方法，其作用的<code>范围</code>是<code>整个静态方法</code>，作用的<code>对象</code>是这个<code>类的所有对象</code>；</p>\n</li>\n<li>\n<p>修改一个<code>类</code>，其作用的范围是 <code>synchronized</code> 后面括号括起来的部分，作用的对象是这个<code>类的所有对象</code>。</p>\n</li>\n</ul>\n<p>如果一个<code>代码块</code>被 synchronized 修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里</p>\n<p>获取锁的线程<code>释放锁</code>只会有两种情况：</p>\n<ul>\n<li>获取锁的线程执行完了该代码块，然后线程释放对锁的占有；</li>\n<li>线程执行发生异常，此时 JVM 会让线程自动释放锁。</li>\n</ul>\n<p>如果这个获取锁的线程由于要等待 IO 或者其他原因（比如调用 sleep方法）<code>被阻塞</code>了，但是又没有释放锁，其他线程便只能等待，非常影响程序执行效率。</p>\n<p>因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过 Lock 就可以办到。</p>\n<h4 id=\"Lock接口\">Lock接口</h4>\n<h5 id=\"Lock-与的-Synchronized-区别\">Lock 与的 Synchronized 区别</h5>\n<ul>\n<li>\n<p>Lock<code> 不是 Java 语言内置</code>的，synchronized 是 Java 语言的关键字，因此是<code>内置特性</code>。Lock 是一个类，通过这个类可以实现同步访问；</p>\n</li>\n<li>\n<p>Lock 和 synchronized <code>有一点非常大的不同</code>，采用 synchronized 不需要用户去手动释放锁，当 synchronized 方法或者 synchronized 代码块执行完之后，系统会自动让线程释放对锁的占用；而 Lock 则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。</p>\n</li>\n</ul>\n<h5 id=\"Lock-接口中每个方法的使用\">Lock 接口中每个方法的使用</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Lock</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">lock</span><span class=\"params\">()</span>; </span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">lockInterruptibly</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException; </span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">tryLock</span><span class=\"params\">()</span>; </span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">tryLock</span><span class=\"params\">(<span class=\"type\">long</span> time, TimeUnit unit)</span> <span class=\"keyword\">throws</span> InterruptedException; </span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">unlock</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    Condition <span class=\"title function_\">newCondition</span><span class=\"params\">()</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p><code>lock()</code>        用来获取锁。如果锁已被其他线程获取，则进行等待。</p>\n<ul>\n<li>\n<p>一般来说，使用 Lock 必须在 <code>try&#123;&#125;catch&#123;&#125;</code>块中进行，并且将释放锁的操作放在<code>finally </code>块中进行，以保证锁一定被被释放，防止死锁的发生。</p>\n</li>\n<li>\n<p>通常使用 Lock来进行同步的话，是以下面这种形式去使用的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Lock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> ...;</span><br><span class=\"line\">lock.lock();</span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//处理任务</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(Exception ex)&#123;</span><br><span class=\"line\">&#125;<span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">  lock.unlock(); <span class=\"comment\">//释放锁</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p><code>newCondition()</code></p>\n<ul>\n<li>\n<p>Lock 锁的 newContition()方法返回 Condition 对象，Condition 类也可以实现等待/通知模式。此时是和：关键字 synchronized 与 wait()/notify()这两个方法一起使用可以实现等待/通知模式 是一样的</p>\n</li>\n<li>\n<p>用 <code>notify()</code>通知时，<code>JVM</code> 会随机唤醒某个等待的线程， 使用 <code>Condition</code> 类可以进行选择性通知， Condition 比较常用的<code>两个方法</code>：</p>\n<ul>\n<li>\n<p><code>await()</code>会使当前线程等待,同时会释放锁,当其他线程调用<code> signal()</code>时,线程会重新获得锁并继续执行。</p>\n</li>\n<li>\n<p><code>signal()</code>用于唤醒一个等待的线程。</p>\n</li>\n</ul>\n<p>==注意：在调用 Condition 的 <code>await()/signal()</code>方法前，也需要线程持有相关的 <code>Lock</code> 锁，调用<code> await()</code>后线程会释放这个锁，在 <code>singal()</code>调用后会从当前<code>Condition</code> 对象的等待队列中，唤醒 一个线程，唤醒的线程尝试获得锁， 一旦获得锁成功就继续执行。==</p>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>ReentrantLock 是<code>唯一</code>实现了 <code>Lock 接口</code>的类</p>\n</blockquote>\n<h4 id=\"ReadWriteLock接口\">ReadWriteLock接口</h4>\n<p>其中只定义了两个方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ReadWriteLock</span> &#123;</span><br><span class=\"line\">    Lock <span class=\"title function_\">readLock</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    Lock <span class=\"title function_\">writeLock</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一个用来<code>获取读锁</code>，一个用来<code>获取写锁</code>。也就是说将文件的<code>读写操作分开</code>，分成 2 个锁来分配给线程，从而使得<code>多个线程可以同时进行读操作</code>。下面的</p>\n<p><strong>ReentrantReadWriteLock</strong> 实现了 <code>ReadWriteLock</code> 接口。</p>\n<p>ReentrantReadWriteLock 里面提供了很多丰富的方法，不过最主要的有两个方法：<code>readLock()</code>和 <code>writeLock()</code>用来获取<code>读锁和写锁</code>。</p>\n<p>下面通过几个例子来看一下 ReentrantReadWriteLock 具体用法。</p>\n<p>假如有多个线程要同时进行读操作的话，先看一下 synchronized 达到的效果：</p>\n<p>==注意:==</p>\n<ul>\n<li>\n<p>如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。</p>\n</li>\n<li>\n<p>如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁</p>\n</li>\n</ul>\n<p><strong>Lock 和 synchronized 区别</strong></p>\n<ul>\n<li>\n<p>Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言实现；</p>\n</li>\n<li>\n<p>synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁；</p>\n</li>\n<li>\n<p>Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用synchronized 时，等待的线程会一直等待下去，不能够响应中断；通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</p>\n</li>\n<li>\n<p>Lock 可以提高多个线程进行读操作的效率。在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时 Lock 的性能要远远优于synchronized。</p>\n</li>\n</ul>\n<h4 id=\"线程间通信\">线程间通信</h4>\n<ul>\n<li>模型有两种：<code>共享内存</code>和<code>消息传递</code></li>\n</ul>\n<h4 id=\"Callable-接口\">Callable 接口</h4>\n<p>至此已经有两种创建线程的方法</p>\n<ul>\n<li>\n<p>一种是通过创建 Thread 类</p>\n</li>\n<li>\n<p>另一种是通过使用 Runnable 创建线程</p>\n<ul>\n<li>但是，Runnable 缺少的一项功能，就是当线程<code>终止</code>时（即 run（）完成时），我们无法使线程返回结果。为了支持此功能，Java 中提供了 Callable 接口。</li>\n</ul>\n</li>\n<li>\n<p>Callable 接口</p>\n</li>\n</ul>\n<p>==特点如下==</p>\n<ul>\n<li>\n<p>为了实现 <code>Runnable</code>，需要实现<code>不返回任何内容</code>的 <code>run()</code>方法，而对于<code>Callable</code>，需要<code>实现在完成时返回结果</code>的 <code>call()</code>方法。</p>\n</li>\n<li>\n<p><code>call()</code>方法可以引发异常，而 <code>run()</code>则不能。</p>\n</li>\n<li>\n<p>为实现 <code>Callable</code> 而必须重写 <code>call()</code> 方法</p>\n</li>\n<li>\n<p>不能直接替换 <code>runnable</code>,因为 Thread 类的构造方法根本没有 <code>Callable</code></p>\n</li>\n</ul>\n<h4 id=\"Future-接口\">Future 接口</h4>\n<p>当 <code>call()</code>方法完成时，结果必须<code>存储</code>在<code>主线程已知的对象</code>中，以便主线程可以知道该线程返回的结果。为此，可以使用 <code>Future</code> 对象。</p>\n<p>将 <code>Future</code> 视为<code>保存结果的对象</code>，它可能暂时不保存结果，但将来会保存（一旦<code>Callable</code> 返回）。</p>\n<p><code>Future</code> 基本上是主线程可以跟踪进度以及其他线程的结果的一种方式。</p>\n<p>要实现此接口，必须<code>重写 5 种方法</code>，这里列出了重要的方法,如下:</p>\n<ul>\n<li>\n<p>**public boolean cancel（boolean mayInterrupt）：**用于停止任务。</p>\n<ul>\n<li>如果尚未启动，它将停止任务</li>\n<li>如果已启动，则仅在 <code>mayInterrupt</code> 为 <code>true</code>时才会中断任务。</li>\n</ul>\n</li>\n<li>\n<p><strong>public Object get（）抛出 InterruptedException，ExecutionException：</strong></p>\n<ul>\n<li>用于获取任务的结果。\n<ul>\n<li>如果任务完成，它将立即返回结果，</li>\n<li>否则将等待任务完成，然后返回结果。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>public boolean isDone（）：</strong></p>\n<ul>\n<li>如果任务完成，则返回 true，否则返回 false</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>可以看到 Callable 和 Future 做两件事 Callable 与 Runnable 类似，因为它封装了要在另一个线程上运行的任务，而 Future 用于存储从另一个线程获得的结果。实际上，future 也可以与 Runnable 一起使用。要创建线程，需要 Runnable。为了获得结果，需要 future。</p>\n</blockquote>\n<h4 id=\"FutureTask\">FutureTask</h4>\n<p>Java 库具有具体的 FutureTask 类型，该类型实现 Runnable 和 Future，并方便地将两种功能组合在一起。</p>\n<ul>\n<li>可以通过为其构造函数提供 <code>Callable</code> 来创建FutureTask。</li>\n<li>将 FutureTask 对象提供给 Thread 的构造函数以创建Thread 对象</li>\n<li>因此，间接地使用 Callable 创建线程。</li>\n</ul>\n<p><strong>核心原理:(重点)</strong></p>\n<p>在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给 <code>Future</code> 对象在后台完成</p>\n<ul>\n<li>\n<p>当主线程将来需要时，就可以通过 <code>Future</code> 对象获得后台作业的计算结果或者执行状态 ,一般 FutureTask 多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。</p>\n</li>\n<li>\n<p>仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞<code> get 方法</code></p>\n</li>\n<li>\n<p>一旦计算完成，就不能再重新开始或取消计算get 方法, 而获取结果只有在<code>计算完成时</code>获取，否则会<code>一直阻塞</code>直到任务转入完成状态，然后会返回结果或者抛出异常</p>\n</li>\n<li>\n<p>get 只计算一次,因此 get 方法要放到程序最后</p>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>\n<p>在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给 <code>Future</code> 对象在后台完成, 当主线程将来需要时，就可以通过 <code>Future</code>对象获得后台作业的计算结果或者执行状态</p>\n</li>\n<li>\n<p>一般 FutureTask 多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果;仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法。一旦计算完成，就不能再重新开始或取消计算。get 方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完成状态，然后会返回结果或者抛出异常。</p>\n</li>\n<li>\n<p>只会计算一次</p>\n</li>\n</ul>\n</blockquote>\n<h4 id=\"CompletableFuture\">CompletableFuture</h4>\n<ul>\n<li>\n<p><strong>简介</strong></p>\n<ul>\n<li><code>CompletableFuture</code> 在 Java 里面被用于<code>异步编程</code>，异步通常意味着非阻塞，可以使得我们的任务<code>单独运行</code>在与主线程分离的<code>其他线程</code>中，并且通过回调可以在主线程中得到<code>异步任务的执行状态</code>，是否完成，和是否异常等信息。</li>\n<li><code>CompletableFuture</code> 实现了 <code>Future</code>, <code>CompletionStage</code> 接口，实现了 <code>Future</code>接口就可以兼容现在有线程池框架，而 <code>CompletionStage</code> 接口才是异步编程的接口抽象，里面定义多种异步方法，通过这两者集合，从而打造出了强大的<code>CompletableFuture</code> 类。</li>\n</ul>\n</li>\n<li>\n<p><strong>Future 与 CompletableFuture</strong></p>\n<ul>\n<li>\n<p>Futrue 在 Java 里面，通常用来表示一个<code>异步任务的引用</code></p>\n<ul>\n<li>比如我们将任务提交到线程池里面，然后我们会得到一个 <code>Futrue</code>，在 <code>Future</code> 里面有 <code>isDone</code> 方法来 判断任务是否<code>处理结束</code>，还有 <code>get</code> 方法可以一直<code>阻塞</code>直到任务结束然后获取结果，但整体来说这种方式，还是同步的，因为需要客户端不断<code>阻塞等待</code>或者<code>不断轮询</code>才能知道任务是否完成。</li>\n</ul>\n</li>\n<li>\n<p><strong>Future 的主要缺点如下：</strong></p>\n<ul>\n<li>\n<p>不支持手动完成</p>\n<ul>\n<li>我提交了一个任务，但是执行太慢了，我通过其他路径已经获取到了任务结果，现在没法把这个任务<code>结果通知</code>到正在执行的线程，所以必须主动取消或者一直等待它执行完成</li>\n</ul>\n</li>\n<li>\n<p>不支持进一步的非阻塞调用</p>\n<ul>\n<li>通过 Future 的 <code>get</code> 方法会一直阻塞到任务完成，现在想在获取任务之后执行额外的任务，但是由于 Future 不支持回调函数，所以无法实现这个功能</li>\n</ul>\n</li>\n<li>\n<p>不支持链式调用</p>\n<ul>\n<li>对于 Future 的执行结果，我们想继续传到下一个 Future 处理使用，从而形成一个<code>链式</code>的 pipline 调用，这在 Future 中是没法实现的。</li>\n</ul>\n</li>\n<li>\n<p>不支持多个 Future 合并</p>\n<ul>\n<li>比如我们有 10 个 Future 并行执行，我们想在所有的 Future 运行完毕之后，执行某些函数，是没法通过 Future 实现的。</li>\n</ul>\n</li>\n<li>\n<p>不支持异常处理</p>\n<ul>\n<li>Future 的 API 没有任何的异常处理的 api，所以在异步运行时，如果出了问题是不好定位的。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>介于此种情况我们引出了 <code>CompletableFuture</code></p>\n</blockquote>\n<p><strong>CompletableFuture</strong></p>\n<p><strong>场景:</strong></p>\n<ul>\n<li><strong>主线程里面创建一个 CompletableFuture，然后主线程调用 get 方法会阻塞，随后我们在一个子线程中使其终止。</strong></li>\n</ul>\n<p><strong>没有返回值的异步任务：</strong></p>\n<ul>\n<li><code>runAsync()</code></li>\n</ul>\n<p><strong>有返回值的异步任务：</strong></p>\n<ul>\n<li><code>supplyAsync()</code></li>\n</ul>\n<p><strong>线程依赖</strong></p>\n<ul>\n<li>当一个线程依赖另一个线程时，可以使用 <code>thenApply()</code> 方法来把这两个线程串行化。</li>\n</ul>\n<p><strong>消费处理结果</strong></p>\n<ul>\n<li><code>thenAccept()</code> 消费处理结果, 接收任务的处理结果，并消费处理，无返回结果。</li>\n</ul>\n<p><strong>异常处理</strong></p>\n<ul>\n<li>\n<p><code>exceptionally</code> 异常处理,出现异常时触发</p>\n</li>\n<li>\n<p><code>handle</code> 类似于 <code>thenAccept</code>/<code>thenRun</code> 方法,是最后一步的处理调用,但是同时可以处理异常</p>\n</li>\n</ul>\n<p><strong>结果合并</strong></p>\n<ul>\n<li>\n<p><code>thenCompose</code> 合并两个<code>有依赖关系</code>的 <code>CompletableFutures</code> 的执行结果</p>\n</li>\n<li>\n<p><code>thenCombine</code> 合并两个<code>没有依赖</code>关系的 <code>CompletableFutures</code> 任务</p>\n</li>\n<li>\n<p>合并多个任务的结果 <code>allOf</code> 与 <code>anyOf</code></p>\n<ul>\n<li>\n<p><strong>allOf:</strong> 一系列独立的 <code>future</code> 任务，等其<code>所有的</code>任务执行完后做一些事情</p>\n</li>\n<li>\n<p><strong>anyOf</strong>: 只要在多个 <code>future</code> 里面<code>有一个</code>返回，整个任务就可以结束，而不需要等到每一个<code>future</code> 结束</p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"JUC-常用的辅助类\"><code>JUC 常用的辅助类</code></h4>\n<p>JUC 中提供了三种常用的辅助类，通过这些辅助类可以很好的解决线程<code>数量过多时 Lock 锁的频繁</code>操作。这三种辅助类为：</p>\n<ul>\n<li>\n<p>CountDownLatch: 减少计数</p>\n<ul>\n<li>\n<p>主要思想就是：</p>\n<p><code>CountDownLatch</code> 类可以设置一个计数器，然后通过 <code>countDown</code> 方法来进行减 1 的操作，使用 <code>await</code> 方法等待,只要计数器<code>不大于 0</code>，然后继续执行 <code>await</code> 方法之后的语句。</p>\n<p>具体流程：</p>\n<ul>\n<li><code>CountDownLatch</code> 主要有两个方法，当一个或多个线程调用 <code>await</code> 方法时，这些线程会阻塞</li>\n<li>其它线程调用 <code>countDown</code> 方法会将计数器<code>减 1</code>(调用 <code>countDown</code> 方法的线程不会阻塞)</li>\n<li>当计数器的值变为 0 时，因 <code>await</code> 方法阻塞的线程会被唤醒，继续执行</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>CyclicBarrier: 循环栅栏</p>\n<ul>\n<li>循环阻塞的意思，在使用中CyclicBarrier 的构造方法<code>第一个参数</code>是目标障碍数，每次执行 CyclicBarrier 一次障碍数会加1，如果达到了目标障碍数，才会执行 cyclicBarrier.await()之后的语句。可以将 CyclicBarrier 理解为加 1 操作</li>\n</ul>\n</li>\n<li>\n<p>Semaphore: 信号灯</p>\n<ul>\n<li>Semaphore 的构造方法中传入的<code>第一个参数</code>是最大信号量（可以看成最大线程池），每个信号量初始化为一个最多只能分发一个许可证。使用 <code>acquire</code> 方法获得许可证，<code>release</code> 方法释放许可</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"读写锁\">读写锁</h4>\n<ul>\n<li><strong>JAVA 的并发包提供了读写锁 ReentrantReadWriteLock，它表示两个锁，一个是读操作相关的锁，称为共享锁；一个是写相关的锁，称为排他锁</strong></li>\n</ul>\n<p>线程<code>进入读锁</code>前提条件：</p>\n<ul>\n<li>\n<p>没有其他线程的写锁</p>\n<ul>\n<li>没有写请求, 或者==有写请求，但调用线程和持有锁的线程是同一个(可重入锁)。==</li>\n</ul>\n</li>\n<li>\n<p>线程<code>进入写锁</code>的前提条件：</p>\n<ul>\n<li>没有其他线程的读锁</li>\n<li>没有其他线程的写锁</li>\n</ul>\n</li>\n</ul>\n<p>而读写锁有以下三个重要的特性：</p>\n<p>（1）公平选择性：支持非公平（默认）和公平的锁获取方式，吞吐量还是非公平优于公平。</p>\n<p>（2）重进入：读锁和写锁都支持线程重进入。</p>\n<p>（3）锁降级：遵循<code>获取写锁</code>、<code>获取读锁再释放写锁</code>的次序，写锁能够降级成为读锁</p>\n<p>小结：</p>\n<ul>\n<li>\n<p>在线程<code>持有读锁</code>的情况下，该线程<code>不能取得写锁</code>(因为<code>获取写锁</code>的时候，如果发现当前的<code>读锁</code>被占用，就马上<code>获取失败</code>，不管读锁是不是被当前线程持有)。</p>\n</li>\n<li>\n<p>在线程<code>持有写锁</code>的情况下，该线程可以继续获取读锁（获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）</p>\n<ul>\n<li>原因: 当线程获取读锁的时候，可能有其他线程同时也在持有读锁，因此不能把获取读锁的线程“升级”为写锁；而对于获得写锁的线程，它一定独占了读写锁</li>\n<li>因此可以继续让它获取读锁，当它同时获取了写锁和读锁后，还可以<code>先释放写锁继续持有读锁</code>，这样一个写锁就<code>降级</code>为了<code>读锁</code></li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>源码：</p>\n<p>可以看到，<code>ReentrantReadWriteLock</code> 实现了 <code>ReadWriteLock</code> 接口，<code>ReadWriteLock</code> 接口定义了获取<code>读锁和写锁</code>的规范，具体需要实现类去实现；</p>\n<p>同时其还实现了 <code>Serializable</code> 接口，表示可以进行<code>序列化</code>，在源代码中可以看到 <code>ReentrantReadWriteLock</code> 实现了自己的序列化逻辑。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ReentrantReadWriteLock</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ReadWriteLock</span>, java.io.Serializable &#123;</span><br><span class=\"line\"> <span class=\"comment\">/** 读锁 */</span></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class=\"line\"> <span class=\"comment\">/** 写锁 */</span></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">final</span> Sync sync;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">/** 使用默认（非公平）的排序属性创建一个新的  ReentrantReadWriteLock */</span></span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"title function_\">ReentrantReadWriteLock</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">     <span class=\"built_in\">this</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"comment\">/** 使用给定的公平策略创建一个新的 ReentrantReadWriteLock */</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"title function_\">ReentrantReadWriteLock</span><span class=\"params\">(<span class=\"type\">boolean</span> fair)</span> &#123;</span><br><span class=\"line\">         sync = fair ? <span class=\"keyword\">new</span> <span class=\"title class_\">FairSync</span>() : <span class=\"keyword\">new</span> <span class=\"title class_\">NonfairSync</span>();</span><br><span class=\"line\">         readerLock = <span class=\"keyword\">new</span> <span class=\"title class_\">ReadLock</span>(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">         writerLock = <span class=\"keyword\">new</span> <span class=\"title class_\">WriteLock</span>(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"comment\">/** 返回用于写入操作的锁 */</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> ReentrantReadWriteLock.WriteLock <span class=\"title function_\">writeLock</span><span class=\"params\">()</span> &#123; <span class=\"keyword\">return</span> writerLock; &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">/** 返回用于读取操作的锁 */</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> ReentrantReadWriteLock.ReadLock <span class=\"title function_\">readLock</span><span class=\"params\">()</span> &#123; <span class=\"keyword\">return</span> readerLock; &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"keyword\">abstract</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractQueuedSynchronizer</span> &#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">NonfairSync</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Sync</span> &#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FairSync</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Sync</span> &#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ReadLock</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Lock</span>, java.io.Serializable &#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WriteLock</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Lock</span>, java.io.Serializable &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"BlockingQueue阻塞队列\"><code>BlockingQueue</code><strong>阻塞队列</strong></h4>\n<p>Concurrent 包中，BlockingQueue 很好的解决了多线程中，如何高效安全<code>传输</code>数据的问题。通过这些高效并且线程安全的队列类，为我们快速搭建</p>\n<p>高质量的多线程 程序带来极大的便利。</p>\n<p>BlockingQueue 家庭中的所有成员，包括他们各自的功能以及常见使用场景。</p>\n<ul>\n<li>\n<p>阻塞队列，顾名思义，首先它是一个队列, 通过一个共享的队列，可以使得数据由队列的一端输入，从另外一端输出；</p>\n<ul>\n<li>当队列是空的，从队列中<code>获取</code>元素的操作将会被<code>阻塞</code></li>\n<li>当队列是满的，从队列中<code>添加</code>元素的操作将会被<code>阻塞</code></li>\n<li>试图从<code>空的</code>队列中<code>获取</code>元素的线程将会被<code>阻塞</code>，直到其他线程往<code>空的队列</code>插入新的元素</li>\n<li>试图向<code>已满</code>的队列中<code>添加</code>新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多个元素或者完全清空，使队列变得空闲起来并后续新增</li>\n</ul>\n</li>\n<li>\n<p>常用的队列主要有以下两种：</p>\n<ul>\n<li>\n<p>先进先出（FIFO）：<code>先插入</code>的队列的元素也最先出去的队列，类似于排队的功能。从某种程度上来说这种队列也体现了一种公平性</p>\n</li>\n<li>\n<p>后进先出（LIFO）：后插入队列的元素最先出队列，这种队列优先处理最近发生的事件(栈)</p>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤起</p>\n</blockquote>\n<ul>\n<li>为什么需要 BlockingQueue\n<ul>\n<li>好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切<code>BlockingQueue</code> 都给已经解决好了</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>多线程环境中，通过队列可以很容易实现数据共享，比如经典的“生产者”和 “消费者”模型中，通过队列可以很便利地实现两者之间的数据共享。</p>\n<p>假设我们有若干生产者线程，另外又有若干个消费者线程。如果生产者线程需要把准备好的数据共享给消费者线程，利用队列的方式来传递数据，就可以很方便地解决他们之间的数据共享问题。但如果生产者和消费者在某个时间段内，万一发生数据处理速度不匹配的情况呢？理想情况下，如果生产者产出数据的速度大于消费者消费的速度，并且当生产出来的数据累积到一定程度的时候，那么生产者必须暂停等待一下（阻塞生产者线程），以便等待消费者线程把累积的数据处理完毕，反之亦然。</p>\n<p>当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放入队列</p>\n<p>当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程被自动唤醒</p>\n</blockquote>\n<p><strong>BlockingQueue 核心方法</strong></p>\n<ul>\n<li>\n<p><strong>放入数据</strong></p>\n<ul>\n<li>\n<p><code>offer(anObject)</code>:表示如果可能的话,将 <code>anObject</code> 加到 <code>BlockingQueue</code> 里,即如果 <code>BlockingQueue</code> 可以容纳,则返回 <code>true</code>,否则返回 <code>false</code>.<strong>（本方法不阻塞当前执行方法的线程）</strong></p>\n</li>\n<li>\n<p><code>offer(E o, long timeout, TimeUnit unit)</code>：可以设定等待的时间，如果在指定的时间内，还不能往队列中加入 <code>BlockingQueue</code>，则返回失败</p>\n</li>\n<li>\n<p><code>put(anObject)</code>:把 <code>anObject</code> 加到 <code>BlockingQueue</code> 里,如果 <code>BlockQueue</code> 没有空间,则调用此方法的线程被阻断直到 <code>BlockingQueue</code> 里面有空间再继续.</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>获取数据</strong></p>\n<ul>\n<li>\n<p><code>poll(time)</code>: 取走 BlockingQueue 里排在首位的对象,若不能立即取出,<strong>则可以等time 参数规定的时间,取不到时返回 null</strong></p>\n</li>\n<li>\n<p><code>poll(long timeout, TimeUnit unit)</code>：从 BlockingQueue 取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则知道时间超时还没有数据可取，返回失败。</p>\n</li>\n<li>\n<p><code>take()</code>: 取走 <code>BlockingQueue</code> 里排在首位的对象,若 <code>BlockingQueue</code> 为空,<strong>阻断进入等待状态直到 BlockingQueue 有新的数据被加入</strong>;</p>\n</li>\n<li>\n<p><code>drainTo()</code>: 一次性从 <code>BlockingQueue</code> 获取所有可用的数据对象（还可以指定获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"常见的-BlockingQueue\">常见的 BlockingQueue</h5>\n<p><strong>ArrayBlockingQueue(常用)</strong></p>\n<p>基于数组的<code>阻塞队列</code>实现，在 <code>ArrayBlockingQueue</code> 内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数组外，<code>ArrayBlockingQueue</code> 内部还保存着两个整形变量，<code>分别标识</code>着队列的<code>头部</code>和<code>尾部</code>在数组中的位置。</p>\n<p><code>ArrayBlockingQueue</code> 在<code>生产者放入数据</code>和<code>消费者获取数据</code>，都是<code>共用同一个锁对象</code>，由此也意味着<code>两者无法真正并行运行</code>，这点尤其不同于<code>LinkedBlockingQueue</code>；按照实现原理来分析，<code>ArrayBlockingQueue</code> 完全可以采用<code>分离锁</code>，从而实现生产者和消费者操作的完全并行运行。Doug Lea 之所以没这样去做，也许是因为 <code>ArrayBlockingQueue</code> 的数据<code>写入和获取</code>操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。</p>\n<p><code>ArrayBlockingQueue</code> 和<code>LinkedBlockingQueue</code> 间还有一个明显的不同之处在于，前者在<code>插入或删除</code>元素时<code>不会产生或销毁任何额外的对象实例</code>，而后者则会生成一个额外的<code>Node</code> 对象。这在长时间内需要<code>高效并发</code>地处理大批量数据的系统中，其对于<code>GC</code> 的影响还是存在一定的区别。而在创建 <code>ArrayBlockingQueue</code> 时，我们还可以控制对象的<code>内部锁</code>是否采用公平锁，默认采用<code>非公平锁</code>。</p>\n<p>==<strong>一句话总结: 由数组结构组成的有界阻塞队列。</strong>==</p>\n<p><strong>LinkedBlockingQueue(常用)</strong></p>\n<p>基于<code>链表</code>的阻塞队列，同 <code>ArrayListBlockingQueue</code> 类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；</p>\n<p>只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue 可以通过构造函数指定该值），才会阻塞生产者队列，<code>直到消费者从队列中消费掉</code>一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。</p>\n<p>而 <code>LinkedBlockingQueue</code> 之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别<code>采用了独立的锁</code>来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</p>\n<blockquote>\n<p>ArrayBlockingQueue 和 LinkedBlockingQueue 是两个最普通也是最常用的阻塞队列</p>\n</blockquote>\n<p>==<strong>总结: 由链表结构组成的<code>有界</code>（但大小默认值为integer.MAX_VALUE）阻塞队列。</strong>==</p>\n<p><strong>DelayQueue</strong></p>\n<p>DelayQueue 中的元素只有当其指定的<code>延迟时间</code>到了，才能够从队列中获取到该元素。DelayQueue 是一个没有大小限制的队列，因此往队列中插入数据的</p>\n<p>操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。</p>\n<p>==<strong>总结: 使用优先级队列实现的延迟无界阻塞队列。</strong>==</p>\n<p><strong>PriorityBlockingQueue</strong></p>\n<p>基于<code>优先级的阻塞队列</code>（优先级的判断通过构造函数传入的 <code>Compator</code> 对象来决定），但需要注意的是 <code>PriorityBlockingQueue</code>不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者。</p>\n<p>因此使用的时候要特别注意，<strong>生产者生产数据的速度绝对不能快于消费者消费数据的速度</strong>，否则时间一长，会最终耗尽所有的可用堆内存空间。</p>\n<p>在实现 PriorityBlockingQueue 时，内部控制线程同步的锁采用的是<strong>公平锁</strong>。</p>\n<p>==<strong>总结: 支持优先级排序的无界阻塞队列。</strong>==</p>\n<p><strong>SynchronousQueue</strong></p>\n<p>一种<code>无缓冲</code>的等待队列，类似于无中介的直接交易，有点像原始社会中的生产者和消费者，生产者拿着产品去集市销售给产品的最终消费者，而消费者必须亲自去集市找到所要商品的直接生产者，如果一方没有找到合适的目标，那么大家都在集市等待。相对于有缓冲的 BlockingQueue 来说，少了一个中间经销商的环节（缓冲区），如果有经销商，生产者直接把产品批发给经销商，而无需在意经销商最终会将这些产品卖给那些消费者，由于经销商可以库存一部分商品，因此相对于直接交易模式，总体来说采用中间经销商的模式会吞吐量高一些（可以批量买卖）；但另一方面，又因为经销商的引入，使得产品从生产者到消费者中间增加了额外的交易环节，单个产品的及时响应性能可能会降低。</p>\n<p>声明一个 SynchronousQueue 有两种不同的方式，它们之间有着不太一样的行为。</p>\n<p><strong>公平模式和非公平模式的区别:</strong></p>\n<ul>\n<li>\n<p>公平模式：<code>SynchronousQueue</code> 会采用<code>公平锁</code>，并配合一个<code> FIFO 队列来阻塞</code>多余的生产者和消费者，从而体现整体的公平策略；</p>\n</li>\n<li>\n<p>非公平模式（SynchronousQueue 默认）：<code>SynchronousQueue</code> 采用非公平锁，同时配合一个 LIFO 队列来管理多余的生产者和消费者，而后一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理。</p>\n</li>\n</ul>\n<p>==<strong>总结: 不存储元素的阻塞队列，也即单个元素的队列。</strong>==</p>\n<p><strong>LinkedTransferQueue</strong></p>\n<p><code>LinkedTransferQueue</code> 是一个由链表结构组成的无界阻塞 <code>TransferQueue</code> 队列。相对于其他阻塞队列，<code>LinkedTransferQueue</code> 多了 <code>tryTransfer</code> 和</p>\n<p><code>transfer</code> 方法。<code>LinkedTransferQueue</code> 采用一种<code>预占模式</code>。意思就是消费者线程取元素时，如果队列不为空，则直接取走数据，若队列为空，那就生成一个节点（节点元素为 <code>null</code>）入队，然后消费者线程被等待在这个节点上，后面生产者线程入队时发现有一个元素为 null 的节点，生产者线程就不入队了，直接就将元素填充到该节点，并唤醒该节点等待的线程，被唤醒的消费者线程取走元素，从调用的方法返回。</p>\n<p>==<strong>总结: 由链表组成的无界阻塞队列。</strong>==</p>\n<p><strong>LinkedBlockingDeque</strong></p>\n<p><code>LinkedBlockingDeque</code> 是一个由链表结构组成的<code>双向阻塞队列</code>，可以从队列的<code>两端插入和移除元素</code>。对于一些指定的操作，在插入或者获取队列元素时如果队列状态不允许该操作可能会阻塞住该线程直到队列状态变更为允许操作，这里的阻塞一般有两种情况</p>\n<ul>\n<li>\n<p>插入元素时: 如果当前队列已满将会进入阻塞状态，一直等到队列有空的位置时再将该元素插入，该操作可以通过设置超时参数，超时后返回 false 表示操作失败，也可以不设置超时参数一直阻塞，中断后抛出 InterruptedException 异 常</p>\n</li>\n<li>\n<p>读取元素时: 如果当前队列为空会阻塞住直到队列不为空然后返回元素，同样可以通过设置超时参数</p>\n</li>\n</ul>\n<p>==<strong>总结: 由链表组成的双向阻塞队列</strong>==</p>\n<p><strong>小结</strong></p>\n<p><strong>1. 在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤起</strong></p>\n<p><strong>2. 为什么需要 BlockingQueue?</strong></p>\n<ul>\n<li>我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切 BlockingQueue 都给予解决</li>\n</ul>\n<h4 id=\"线程池\">线程池</h4>\n<ul>\n<li>\n<p>一种线程使用模式。</p>\n</li>\n<li>\n<p>线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。</p>\n</li>\n</ul>\n<p><strong>线程池的优势：</strong> 线程池做的工作主要是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量<code>超过</code>了最大数量，超出数量的线程排队等候，等其他线程执行完毕，<code>再从队列中取出任务来执行</code>。</p>\n<p><strong>特点：</strong></p>\n<ul>\n<li>降低资源消耗: 通过重复利用已创建的线程降低线程创建和销毁造成的销耗。</li>\n<li>提高响应速度: 当任务到达时，任务可以不需要等待线程创建就能立即执行。</li>\n<li>提高线程的可管理性: 线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>\n</ul>\n<blockquote>\n<p><strong>Java中的线程池是通过<code>Executor</code>框架实现的，该框架中用到了<code>Executor,Executors,ExecutorService,hreadPoolExecutor</code>这几个类</strong></p>\n</blockquote>\n<p><strong>线程池的参数</strong></p>\n<ul>\n<li><code>corePoolSize</code> 线程池的核心线程数</li>\n<li><code>maximumPoolSize</code> 能容纳的最大线程数</li>\n<li><code>keepAliveTime</code> 空闲线程存活时间</li>\n<li><code>unit</code> 存活的时间单位</li>\n<li><code>workQueue</code> 存放提交但未执行任务的队列</li>\n<li><code>threadFactory</code> 创建线程的工厂类</li>\n<li><code>handler</code> 等待队列满后的拒绝策略</li>\n</ul>\n<p>线程池中，有三个重要的参数，决定影响了拒绝策略：</p>\n<ul>\n<li><code>corePoolSize</code>  \t   核心线程数，也即最小的线程数</li>\n<li><code>workQueue</code> -              阻塞队列</li>\n<li><code>maximumPoolSize</code>   最大线程数</li>\n</ul>\n<p>当提交任务数<code>大于</code> corePoolSize 的时候，会优先将任务放到 workQueue 阻塞队列中。当阻塞队列<code>饱和</code>后，会<code>扩充线程池中线程数</code>，直到达到<code>maximumPoolSize</code>   最大线程数配置。此时，再有多余的任务，则会触发线程池的<code>拒绝策略</code>了。</p>\n<p>也就是说：<strong>当提交的任务数<code>大于</code>（workQueue.size() +maximumPoolSize ），就会触发线程池的拒绝策略</strong>。</p>\n<p><strong>拒绝策略(重点)</strong></p>\n<ul>\n<li>\n<p><strong>CallerRunsPolicy</strong>: 当触发拒绝策略，只要线程池没有关闭的话，则使用调用线程直接运行任务。一般并发比较小，性能要求不高，不允许失败。但是，由于调用者自己运行任务，如果任务提交速度过快，可能<code>导致程序阻塞</code>，性能效率上必然的损失较大。<code>调用者运行</code>是一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。</p>\n</li>\n<li>\n<p><strong>AbortPolicy</strong>: 丢弃任务，并抛出拒绝执行 RejectedExecutionException 异常信息。线程池默认的拒绝策略。必须处理好抛出的异常，否则会打断当前的执行流程，影响后续的任务执行。[<code>默认</code>]</p>\n</li>\n<li>\n<p><strong>DiscardPolicy</strong>: 直接丢弃无法处理的任务，不予任何处理也不抛出异常。如果允许任务丢失，这是最好的一种策略。</p>\n</li>\n<li>\n<p><strong>DiscardOldestPolicy</strong>: 当触发拒绝策略，只要线程池没有关闭的话，丢弃阻塞队列 <code>workQueue</code> 中最老的一个任务，并将新任务加入；就是抛弃队列中等待最久的任务，然后把当前任务加人队列中尝试再次提交当前任务。</p>\n</li>\n</ul>\n<p><strong>线程池的种类与创建</strong></p>\n<p><strong>newCachedThreadPool(常用)</strong></p>\n<p><strong>作用</strong>：创建一个<code>可缓存</code>线程池，如果线程池长度超过处理需要，可<code>灵活回收空闲线程</code>，如果没有超过线程池的长度就可以进行回收，此时就会新建线程.</p>\n<p><strong>特点</strong>:</p>\n<ul>\n<li>线程池中数量没有固定，可达到最大值（Interger. MAX_VALUE）</li>\n<li>线程池中的线程可进行缓存重复利用和回收（回收默认时间为 1 分钟）</li>\n<li>当线程池中，没有可用线程，会重新创建一个线程</li>\n</ul>\n<p><strong>场景:</strong></p>\n<ul>\n<li>适用于创建一个可无限扩大的线程池，服务器负载压力较轻，执行时间较短，任务多的场景</li>\n</ul>\n<p><strong>newFixedThreadPool(常用)</strong></p>\n<p><strong>作用</strong>：</p>\n<ul>\n<li>创建一个可重用固定线程数的线程池，以共享的<code>无界队列方式</code>来运行这些线程。在任意点，大多数线程会处于<code>处理任务</code>的活动状态。</li>\n<li>如果在所有线程处于活动状态时提交附加任务，则在<code>有可用线程</code>之前，附加任务将在队列中等待。</li>\n<li>如果在关闭前在执行期间 由于失败而导致任何线程终止，那么创建的新线程将代替它<code>继续</code>执行后续的任务（如果需要）。</li>\n<li>在某个线程被显式地关闭之前，线程池中的线程将一直存在。</li>\n</ul>\n<p><strong>特征：</strong></p>\n<ul>\n<li>\n<p>线程池中的线程处于一定的量，可以很好的控制线程的并发量</p>\n</li>\n<li>\n<p>线程可以重复被使用，在显示关闭之前，都将一直存在</p>\n</li>\n<li>\n<p>超出一定量的线程被提交时候需在队列中等待</p>\n</li>\n</ul>\n<p><strong>场景:</strong></p>\n<p>适用于可以预测线程数量的业务中，或者服务器负载较重，对线程数有严格限制的场景</p>\n<p><strong>newSingleThreadExecutor(常用)</strong></p>\n<p><strong>作用</strong>：</p>\n<ul>\n<li>创建一个使用单个 <code>worker</code> 线程的 <code>Executor</code>，以<code>无界队列</code>方式来运行该线程。\n<ul>\n<li>（注意:如果因为在关闭前的执行期间出现失败而终止了此单个线程，那么如果需要，新创建的新线程也将代替它执行后续的任务）。</li>\n</ul>\n</li>\n<li>可保证<code>顺序</code>地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。与其等效的<code>newFixedThreadPool</code> 不同，可保证无需重新配置此方法所返回的执行程序即可使用其他的线程。</li>\n</ul>\n<p><strong>特征：</strong></p>\n<ul>\n<li>线程池中最多执行 1 个线程，之后提交的线程活动将会排在队列中以此执行</li>\n</ul>\n<p><strong>场景:</strong></p>\n<ul>\n<li>适用于需要保证顺序执行各个任务，并且在任意时间点，不会同时有多个线程的场景</li>\n</ul>\n<p><strong>newScheduleThreadPool(了解)</strong></p>\n<p><strong>作用:</strong></p>\n<ul>\n<li>线程池支持<code>定时以及周期性执行</code>任务，创建一个 <code>corePoolSize</code> 为传入参数，最大线程数为整形的最大数的线程池</li>\n</ul>\n<p><strong>特征:</strong></p>\n<ul>\n<li>\n<p>线程池中具有<code>指定数量</code>的线程，即便是<code>空线程也将保留</code></p>\n</li>\n<li>\n<p>可<code>定时或者延迟执行</code>线程活动</p>\n</li>\n</ul>\n<p><strong>场景:</strong></p>\n<ul>\n<li>适用于需要<code>多个后台线程</code>执行<code>周期任务</code>的场景</li>\n</ul>\n<p><strong>newWorkStealingPool</strong></p>\n<ul>\n<li>jdk1.8 提供的线程池，底层使用的是 <code>ForkJoinPool</code> 实现，创建一个<code>拥有多个任务队列</code>的线程池，可以减少连接数，创建当前可用 <code>cpu</code> 核数的线程来并行执行任务</li>\n</ul>\n<p><strong>场景:</strong></p>\n<ul>\n<li>适用于大耗时，可并行执行的场景</li>\n</ul>\n<h5 id=\"底层原理\">底层原理</h5>\n<ul>\n<li>\n<p>在创建了线程池后，线程池中的线程数为零</p>\n</li>\n<li>\n<p>当调用<code> execute()</code>方法添加一个请求任务时，线程池会做出如下判断：</p>\n<ul>\n<li>\n<p>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</p>\n</li>\n<li>\n<p>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；</p>\n</li>\n<li>\n<p>如果这个时候队列满了且正在运行的线程数量还小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</p>\n</li>\n<li>\n<p>如果队列满了且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>当一个线程完成任务时，它会从队列中取下一个任务来执行</p>\n</li>\n<li>\n<p>当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断：</p>\n<ul>\n<li>如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。</li>\n<li>所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</li>\n</ul>\n</li>\n</ul>\n<p>注意事项：</p>\n<ul>\n<li>\n<p>创建多线程时，使用常见的<code>三种</code>线程池创建方式，<code>单一、可变、定长</code>都有一定问题，原因是 FixedThreadPool 和 SingleThreadExecutor 底层都是用<code>LinkedBlockingQueue</code> 实现的，这个队列最大长度为<code> Integer.MAX_VALUE</code>，容易导致 OOM。所以实际生产一般自己通过 ThreadPoolExecutor 的 7 个参数，自定义线程池</p>\n</li>\n<li>\n<p>创建线程池推荐适用 ThreadPoolExecutor 及其 7 个参数手动创建</p>\n</li>\n<li>\n<p>为什么线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式</p>\n<ul>\n<li>这样的处理方式可以更加明确线程池的运行规则，规避资源耗尽的风险。</li>\n<li>说明：Executors返回的线程池对象的弊端如下：\n<ul>\n<li><code>FixedThreadPool</code> <code>SingleThreadPool</code>:允许的<code>请求队列</code>长度为<code>Integer.MAX_VALUE</code>,可能会<code>堆积大量</code>的请求，从而导致O0M。</li>\n<li><code>CachedThreadPool</code> <code>ScheduledThreadPool</code>:允许的<code>创建线程</code>数量为<code>Integer.MAX_VALUE</code>,可能会<code>创建大量</code>的线程，从而导致OOM</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Fork-Join\"><strong>Fork/Join</strong></h4>\n<p><strong>Fork/Join 框架简介</strong></p>\n<p>Fork/Join 它可以将一个大的任务拆分成多个子任务进行并行处理，最后将子任务结果合并成 最后的计算结果，并进行输出。</p>\n<p><code>Fork/Join </code>框架要完成两件事情：</p>\n<ul>\n<li>\n<p><strong>Fork：把一个复杂任务进行拆分，大事化小</strong></p>\n</li>\n<li>\n<p><strong>Join：把分拆任务的结果进行合并</strong></p>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>\n<p><strong>任务分割</strong>：首先 Fork/Join 框架需要把大的任务分割成足够小的子任务，如果子任务比较大的话还要对子任务进行继续分割</p>\n</li>\n<li>\n<p><strong>执行任务并合并结果</strong>：分割的子任务分别放到双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都放在另外一个队列里，启动一个线程从队列里取数据，然后合并这些数据。</p>\n</li>\n<li>\n<p>在 Java 的<code> Fork/Join</code> 框架中，使用两个类完成上述操作</p>\n</li>\n</ul>\n</blockquote>\n<p><strong>Fork/Join 框架的实现原理</strong></p>\n<p><code>ForkJoinPool</code> 由 <code>ForkJoinTask</code> 数组和 <code>ForkJoinWorkerThread</code> 数组组成，<code>ForkJoinTask</code> 数组负责将存放以及将程序提交给 <code>ForkJoinPool</code>，而<code>ForkJoinWorkerThread</code> 负责执行这些任务。</p>\n<p><strong>Fork 方法的实现原理：</strong> 当我们调用 <code>ForkJoinTask</code> 的 <code>fork</code> 方法时，程序会把任务放在 <code>ForkJoinWorkerThread</code> 的 <code>pushTask</code> 的 <strong><code>workQueue</code></strong> 中，异步地执行这个任务，然后立即返回结果</p>\n<p><code>pushTask</code> 方法把当前任务存放在 <code>ForkJoinTask</code> 数组队列里。然后再调用<code>ForkJoinPool</code> 的 <code>signalWork()</code>方法唤醒或创建一个工作线程来执行任务</p>\n<p><strong>Join 方法的实现原理：</strong> <code>Join</code> 方法的主要作用是阻塞当前线程并等待获取结果。</p>\n<ul>\n<li>\n<p>代码实现方面：</p>\n<ul>\n<li>\n<p>首先调用 doJoin 方法，通过 doJoin()方法得到当前任务的状态来判断返回什么结果，任务状态有 4 种：<strong>==已完成（NORMAL）、被取消（CANCELLED）、信号（SIGNAL）和出现异常（EXCEPTIONAL）==</strong></p>\n<ul>\n<li>如果任务状态是已完成，则直接返回任务结果。</li>\n<li>如果任务状态是被取消，则直接抛出 CancellationException</li>\n<li>如果任务状态是抛出异常，则直接抛出对应的异常</li>\n</ul>\n</li>\n<li>\n<p><code>doJoin </code>方法的实现</p>\n<ul>\n<li>首先通过查看任务的状态，看任务是否已经执行完成，如果执行完成，则直接返回任务状态；</li>\n<li>如果没有执行完，则从任务数组里取出任务并执行。</li>\n<li>如果任务顺利执行完成，则设置任务状态为 <code>NORMAL</code>，如果出现异常，则记录异常，并将任务状态设置为 <code>EXCEPTIONAL</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>Fork/Join 框架的异常处理</strong></p>\n<p><code>ForkJoinTask</code> 在执行的时候可能会抛出异常，但是我们没办法在主线程里直接捕获异常，所以 <code>ForkJoinTask</code> 提供了 <code>isCompletedAbnormally()</code>方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过 <code>ForkJoinTask</code> 的<code>getException</code> 方法获取异常。<code>getException</code> 方法返回 <code>Throwable</code> 对象，如果任务被取消了则返回<code>CancellationException</code>。如果任务没有完成或者没有抛出异常则返回 null。</p>\n<h2 id=\"共享模型之管程\">共享模型之管程</h2>\n<p>线程出现原因的根本原因：</p>\n<ul>\n<li><code>线程上下文切换</code>，导致线程里的<code>指令没有执行完</code>就切换执行其它线程了</li>\n<li><code>对多线程执行读写操作</code></li>\n</ul>\n<p>具体表现为：</p>\n<ul>\n<li>首先需要知道的是：一个程序运行多线程本身是没有问题的，并且多个线程同时对共享资源进行<code>读操作</code>本身也没有问题</li>\n<li>正真出问题的地方：对共享资源同时进行<code>读写</code>操作时就有问题了</li>\n</ul>\n<p>此时：一段代码内如果存在<code>多对共享资源的多线程读写操作</code>，那么称这段代码为<code>临界区</code></p>\n<p>多个线程在临界区执行，那么由于代码指令的<code>执行顺序的不确定而导致的结果无法预测</code>，称为<code>竞态条件</code></p>\n<blockquote>\n<p>解决方法：  为了避免临界区中的竞态条件发生，由多种手段可以达到</p>\n<ul>\n<li>阻塞式解决方案：synchronized ，Lock</li>\n<li>非阻塞式解决方案：原子变量</li>\n</ul>\n</blockquote>\n<h3 id=\"synchronized\">synchronized</h3>\n<p>​\t\t\t\t\t\t\t\t\t——对象锁</p>\n<p>==思想：==</p>\n<ul>\n<li>\n<p>它采用<code>互斥</code>的方式让<code>同一时刻</code>至多<code>只有一个线程持有对象锁</code>，其他线程如果想获取这个锁就会<code>阻塞住</code>，这样就能保证拥有锁的线程可以<code>安全的</code>执行临界区内的代码，<code>不用担心线程上下文切换</code></p>\n</li>\n<li>\n<p>synchronized实际是 <code>用对象锁保证了临界区中代码的原子性</code> 所谓的原子性就是说 : 临界区内的代对码对外是不可分割的，不会被线程切换所打断。</p>\n</li>\n</ul>\n<p>==注意：==<br>\n虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的：</p>\n<ul>\n<li>互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区的代码</li>\n<li>同步是由于线程执行的先后，顺序不同但是需要一个线程等待其它线程运行到某个点。</li>\n</ul>\n<blockquote>\n<ul>\n<li>\n<p>如果把 synchronized（obj）放在for循环外面如何理解？&lt;原子性&gt;</p>\n<p><span style=\"color:red\">放在外面相当于给<code>整个循环</code>加上了锁那么就是保护了循环次数* ++/–的指令   这期间不会被其他线程干扰</span></p>\n</li>\n<li>\n<p>如果t1 synchronized(obj1）但 t2 synchronized(obj2)会怎么样？</p>\n<p><span style=\"color:red\">不可以，t1，t2如果锁的不是一个对象，那么当发生上下文切换的时候，别的线程不会被阻塞</span></p>\n</li>\n<li>\n<p>如果t1 synchronized（obj）t2没有会怎么样？如何理解下 &lt;锁对象的时候要将所有线程的 <code>临界资源都进行上锁</code>&gt;</p>\n<p><span style=\"color:red\">t2不加锁的话他可以直接拿到共享变量，不会被阻塞住</span></p>\n</li>\n</ul>\n</blockquote>\n<h4 id=\"synchronized-加在方法上\">synchronized 加在方法上</h4>\n<ul>\n<li>\n<p>同步方法</p>\n<ul>\n<li>把出现线程安全问题的核心方法锁起来，每次只能一个线程进入访问</li>\n</ul>\n</li>\n<li>\n<p><code>synchronized</code> 修饰的方法的不具备继承性，所以子类是线程不安全的，</p>\n<ul>\n<li>如果子类的方法也被 <code>synchronized</code> 修饰，两个锁对象其实是一把锁，而且是<strong>子类对象作为锁</strong></li>\n</ul>\n</li>\n<li>\n<p>同步方法底层也是<code>有锁对象</code>的：</p>\n<ul>\n<li>如果方法是<code>实例方法</code>：同步方法默认用<code> this 作为的锁对象</code></li>\n<li>如果方法是<code>静态方法</code>：同步方法默认用<code>类名 .class 作为的锁对象</code></li>\n<li>如果方法是<code>同步方法块</code>，锁的是 <code>synchronized 括号内的对象</code></li>\n</ul>\n</li>\n</ul>\n<p>主要关注锁住的对象是不是同一个,只要锁对象<code>不相同</code>就<code>不会出现加锁阻塞</code>的情况</p>\n<ul>\n<li>锁住类对象，<code>所有类的实例</code>的方法都是安全的，类的所有实例都相当于<code>同一把锁</code></li>\n<li>锁住 this 对象，只有在<code>当前实例</code>对象的线程内是安全的，如果有多个实例就不安全</li>\n</ul>\n<blockquote>\n<p>小结：</p>\n<ul>\n<li>synchronized 有三种加锁方式\n<ul>\n<li>同步方法:锁的是当前实例对象，通常指this\n<ul>\n<li>如果两个调用对象是相同的那么就是同一把锁,会出现锁的情况</li>\n<li>如果如果两个调用对象不是相同的那么则无影响,就算是相同类的两个对象也是一样.</li>\n</ul>\n</li>\n<li>静态同步方法:静态同步方法，锁的是当前类的Class对象\n<ul>\n<li>众所周知一个类在jvm中只有一个对应的Class对象,所以调用同一个类的两个静态同步方法一定是会被锁住的.</li>\n</ul>\n</li>\n<li>同步代码块:我们手动指定加锁对象比较容易判断,即判断两个线程的锁对象是否一致</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"变量的线程安全分析\">变量的线程安全分析</h3>\n<blockquote>\n<p>类里面定义的是<code>成员</code>变量</p>\n<p>static 修饰的是 <code>静态</code>变量</p>\n<p>方法内部或代码块内部的是<code>局部</code>变量</p>\n</blockquote>\n<ul>\n<li>\n<p>成员变量和静态变量的线程安全分析</p>\n<ul>\n<li>\n<p>如果没有变量在线程间共享，那么变量是安全的</p>\n</li>\n<li>\n<p>如果变量在线程间共享</p>\n<ul>\n<li>如果<code>只有读</code>操作，则<code>线程安全</code></li>\n<li>如果<code>有读写</code>操作，则这段代码是<code>临界区</code>，需要<code>考虑线程安全</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>局部变量线程安全分析</p>\n<ul>\n<li>局部变量【局部变量被初始化为基本数据类型】是安全的</li>\n<li>局部变量<code>引用的对象</code>未必是安全的\n<ul>\n<li>如果局部变量引用的对象<code>没有引用线程</code>共享的对象，那么是线程<code>安全的</code></li>\n<li>如果局部变量引用的对象<code>引用了线程共享的对象</code>，那么线程安全要看情况而定</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"常见线程安全类\">常见线程安全类</h4>\n<blockquote>\n<p>这里说它们是线程安全的是指，<span style=\"color:red\">多个线程调用它们同一个实例的某个方法时，是线程安全的</span>。</p>\n<p>==注意==</p>\n<ul>\n<li>可以理解为它们的每个方法<code>单独</code>使用都是原子的</li>\n<li>但<strong>注意</strong>它们多个方法的<code>组合</code>不是原子的</li>\n</ul>\n</blockquote>\n<ol>\n<li><code>String</code>   不可变的类,因为其类内部状态（属性）是<code>不可改变</code>的，因此它们的方法都是线程安全的</li>\n<li><code>Integer等包装类</code>   不可变的类，因为其类内部状态（属性）是<code>不可改变</code>的，因此它们的方法都是线程安全的</li>\n<li><code>StringBuffer</code></li>\n<li><code>Random</code></li>\n<li><code>Vector</code></li>\n<li><code>Hashtable</code></li>\n<li><code>java.util.concurrent ( JUC)包下的类</code></li>\n</ol>\n<p>分析线程安全的思路：</p>\n<ul>\n<li>先对类的成员变量，类变量，局部变量进行考虑，\n<ul>\n<li>如果变量会在各个线程之间共享，那么<code>就得考虑线程安全问题</code>了，</li>\n<li>如果变量A引用的是线程安全类的实例，并且只调用该线程安全类的一个方法，那么该变量A<code>是线程安全的</code>。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"Vector\">Vector</h5>\n<p>Vector 是<strong>矢量队列</strong>。</p>\n<ul>\n<li>\n<p>继承于 <code>AbstractList</code>，实现了 <code>List</code>, <code>RandomAccess</code>, <code>Cloneable</code> 这些接口。</p>\n</li>\n<li>\n<p><code>Vector</code> 继承了 <code>AbstractList</code>，实现了 <code>List</code>；所以，<strong>它是一个队列，支持相关的添加、删除、修改、遍历等功能</strong>。</p>\n</li>\n<li>\n<p><code>Vector</code> 实现了 <code>RandmoAccess</code> 接口，即<strong>提供了随机访问功能</strong>。<code>RandmoAccess</code> 是 java 中用来被 <code>List</code> 实现，为 <code>List</code> 提供<code>快速访问</code>功能的。在<code>Vector</code> 中，我们可以通过元素的序号<code>快速获取</code>元素对象；这就是快速随机访问。</p>\n</li>\n<li>\n<p>Vector 实现了 <code>Cloneable</code> 接口，即实现<code> clone()</code>函数。它能<code>被克隆</code>。</p>\n</li>\n</ul>\n<p><strong>==和 ArrayList 不同的是 ，Vector 中的操作是线程安全的。==</strong></p>\n<h4 id=\"线程八锁的总结\">线程八锁的总结</h4>\n<blockquote>\n<ul>\n<li>\n<p>一个对象里面如果有<code>多个 synchronized </code>方法，某一个时刻内，只要一个线程去调用其中的一个 synchronized 方法了，其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些<code>synchronized </code>方法;</p>\n</li>\n<li>\n<p>锁的是当前对象 this，被锁定后，其它的线程都不能进入到当前对象的其它的<code>synchronized</code> 方法，加个普通方法后发现和同步锁无关,换成两个对象后，不是同一把锁了，情况变化。</p>\n</li>\n</ul>\n<p><code>synchronized</code> 实现同步的基础：<code>Java 中的每一个对象都可以作为锁</code>。</p>\n<p><strong>具体表现为以下</strong> <strong>3</strong> <strong>种形式。</strong></p>\n<p><strong>对于普通同步方法，锁是当前实例对象。</strong></p>\n<p><strong>对于静态同步方法，锁是当前类的</strong> <strong>Class</strong> <strong>对象。</strong></p>\n<p><strong>对于同步方法块，锁是</strong> <strong>Synchonized</strong> <strong>括号里配置的对象</strong></p>\n<ul>\n<li>\n<p>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，</p>\n</li>\n<li>\n<p>可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。</p>\n</li>\n<li>\n<p>所有的静态同步方法用的也是同一把锁:  <code>类对象本身</code>，这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，而不管是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象！</p>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"Monitor\">Monitor</h3>\n<blockquote>\n<p>Monitor被翻译为<strong>监视器</strong>或者说<strong>管程</strong>       Monitor （就是锁） 是重量级的锁</p>\n<p>一个对象一个<code>锁</code>，就是说一个对象一个<code>monitor</code></p>\n</blockquote>\n<h4 id=\"组成：\">组成：</h4>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305292303029.png\" style=\"zoom:33%;\">\n<h4 id=\"原理：\">原理：</h4>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305292305430.png\" alt=\"image-20230529230557390\" style=\"zoom:33%;\">\n<p>每个java对象都可以关联一个<code>Monitor</code>，如果使用<code>synchronized</code>给对象上锁（重量级），该对象头的<code>Mark Word</code>中就被设置为指向<code>Monitor</code>对象的指针</p>\n<p><code>EntryList</code>  称为等待队列,其中的元素是<code>非公平</code>的，不是FIFO的顺序执行，<code>其依赖于JDK的底层实现</code></p>\n<ul>\n<li>刚开始时<code>Monitor</code>中的<code>Owner</code>为<code>null</code></li>\n<li>当Thread-2 执行<code>synchronized(obj)&#123;&#125;</code>代码时就会将Monitor的所有者Owner 设置为 <code>Thread-2</code>，上锁成功，Monitor中同一时刻只能有一个<code>Owner</code></li>\n<li>当Thread-2 占据锁时，如果线程Thread-3，Thread-4也来执行<code>synchronized(obj)&#123;&#125;</code>代码，就会进入<code>EntryList</code>中变成<code>BLOCKED</code>状态</li>\n<li>Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来<code>竞争锁</code>，<code>竞争时是非公平的</code></li>\n<li>图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，<code>后面讲wait-notify 时会分析</code></li>\n</ul>\n<h4 id=\"原理-字节码层面\">原理&lt;字节码层面&gt;</h4>\n<ul>\n<li>1、首先会获取到 <code>lock</code>  的引用地址  并存储到 <code>slot 1 </code>中</li>\n<li>2、执行 <code>synchronized </code>  对应的就是 <code>monitorenter</code>字段</li>\n<li>3、进行 <code>i++</code>操作 的==四步==</li>\n<li>4、得到<code>lock</code> 对象的引用</li>\n<li>5、得到<code>lock</code> 之后  重置 <code>MarkWord</code>  并唤醒 ，随后进入等待队列</li>\n<li>6、出现异常就类似重复 <code>1~5 </code> 并最后抛出异常</li>\n</ul>\n<h3 id=\"synchronized锁优化\">synchronized锁优化</h3>\n<h4 id=\"轻量级锁\">轻量级锁</h4>\n<blockquote>\n<p>轻量级锁对使用者是透明的，即语法仍然是<code>synchronized</code></p>\n</blockquote>\n<p>使用场景：</p>\n<ul>\n<li>如果一个对象虽然有多个线程要对它进行加锁，但是加锁的时间是错开的（也就是没有人可以竞争的），那么可以使用轻量级锁来进行优化。</li>\n</ul>\n<p>原理：</p>\n<blockquote>\n<p>加锁：</p>\n</blockquote>\n<p>​\t<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305292321401.png\" alt=\"image-20230529232118374\" style=\"zoom:35%;\"></p>\n<ul>\n<li>\n<p>每次指向到synchronized代码块时，都会创建<code>锁记录</code>（Lock Record）对象，每个线程都会包括一个锁记录的结构，锁记录内部 有锁记录的地址和对象引用reference，对象头 中有Mark word 和klass word</p>\n</li>\n<li>\n<p>让锁记录中的Object reference指向对象，并且尝试用cas(compare and sweep)替换Object对象的Mark Word ，将Mark Word 的值存入锁记录中</p>\n</li>\n<li>\n<p>如果cas替换<code>成功</code>，那么对象的对象头储存的就是<code>锁记录的地址和状态00 </code>  , 表示由该线程给对象加锁，</p>\n</li>\n<li>\n<p>如果cas失败，有两种情况</p>\n<ol>\n<li>如果是其它线程已经持有了该Object的轻量级锁（状态已经是 00 ），那么表示有竞争，将进入<code>锁膨胀阶段</code></li>\n<li>如果是自己的线程执行了synchronized锁重入，那么再添加一条 Lock Record [锁记录]作为<code>重入的计数</code></li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>解锁</p>\n</blockquote>\n<ul>\n<li>\n<p>当线程退出synchronized代码块的时候，**如果获取的是取值为 null 的锁记录 **，表示有重入，这时重置锁记录，表示重入计数<code>减一</code></p>\n</li>\n<li>\n<p>当线程退出synchronized代码块的时候，如果获取的锁记录取值不为 null，那么使用cas将Mark Word的值恢复给对象</p>\n<ol>\n<li>成功则解锁成功</li>\n<li>失败，则说明轻量级锁进行了<code>锁膨胀</code>或已经<code>升级为重量级锁</code>，执行<code>重量级锁解锁</code>流程</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"锁膨胀\">锁膨胀</h4>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305292333669.png\" alt=\"image-20230529233342649\" style=\"zoom:33%;\">\n<p>如果在尝试加轻量级锁的过程中，cas操作无法成功，有一种情况就是<code>其它线程已经为这个对象加上了轻量级锁，</code>这是就要进行<code>锁膨胀</code>，将<code>轻量级锁升级为重量级锁。</code></p>\n<ul>\n<li>\n<p>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁（状态已经00 所以会T1加锁失败）</p>\n</li>\n<li>\n<p>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程 ,T1 即为对象申请Monitor锁，让Object指向重量级锁地址，然后自己进入Monitor 的EntryList 变成BLOCKED状态</p>\n</li>\n<li>\n<p>当Thread-0 <code> 退出synchronized</code>同步块时，如果使用<code>cas</code>将Mark Word的值<code>恢复</code>给对象头，<code>T0恢复信息时就会失败</code>，T0 就会进入<code>重量级锁的解锁过程，即按照Monitor的地址找到Monitor对象，将Owner设置为null，唤醒EntryList 中的Thread-1线程</code></p>\n</li>\n</ul>\n<h4 id=\"自旋优化\">自旋优化</h4>\n<p>重量级锁<code>竞争</code>时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即在自旋的时候<code>持锁的线程释放了锁</code>），那么当前线程就可以<code>不用</code>进行上下文切换<code>就获得了锁</code></p>\n<ul>\n<li>自旋重试失败是指，自旋了<code>一定次数</code>还是没有等到持锁的线程释放锁</li>\n<li>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。\n<ul>\n<li>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能</li>\n<li>Java 7 之后<code>不能控制是否开启自旋功能</code></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"偏向锁\">偏向锁</h4>\n<p>​\t在轻量级的锁中，我们可以发现，如果同一个线程对同一个对象进行重入锁时，也需要执行<code>CAS</code>操作，会耗时，那么java6开始引入了偏向锁，</p>\n<blockquote>\n<p>只有第一次使用CAS时将对象的Mark Word头设置为<code>入锁线程ID</code>，<strong>之后这个入锁线程再进行重入锁时，发现线程ID是自己的，那么就不用再进行CAS了</strong></p>\n<p>以后只要不发生竞争，这个对象就归该线程所有</p>\n</blockquote>\n<p><code>偏向锁默认是延迟的</code>，不会在程序启动的时候立刻生效，如果想避免延迟，可以添加虚拟机参数来禁用延迟：-<code>XX:BiasedLockingStartupDelay=0</code>来禁用延迟</p>\n<p><strong>加锁顺序</strong>:</p>\n<p>1、<code>未禁用</code>偏向锁 创建的就是<code>偏向锁</code></p>\n<p>2、<code>禁用</code>偏向锁 之后 创建的就是 <code>轻量级锁</code></p>\n<p>3、但是 <code>·之后，就创建 ``重量级锁</code></p>\n<h5 id=\"font-size-3-撤销偏向锁的方法-font\"><font size=\"3\">撤销偏向锁的方法</font></h5>\n<p><strong>撤销偏向锁-hashcode方法</strong></p>\n<ul>\n<li>当调用对象的hashcode方法的时候就会撤销这个对象的偏向锁，因为使用偏向锁时没有位置存<code>hashcode</code>的值了，锁就变为了<code>轻量级锁</code></li>\n</ul>\n<p><strong>撤销偏向锁-让其它线程使用对象</strong></p>\n<ul>\n<li>让偏向锁撤销变成轻量级锁的过程，那么就得满足轻量级锁的使用条件，就是没有线程对同一个对象进行锁竞争，注意使用<code>wait</code> 和 <code>notify</code> 来辅助实现，就是让两个线程一个等待，一个执行，执行完的线程通过<code>notify()</code>通知另一个线程就消去了<code>竞争</code>的关系 ;    此时就会导致只能偏向于一个线程的锁现在又要偏向 另一个线程；锁就变为了<code>轻量级锁</code></li>\n</ul>\n<p><strong>撤销偏向锁 - 调用 wait/notify</strong></p>\n<ul>\n<li>会使对象的锁变成重量级锁，因为<code>wait/notify</code>方法<code>重量级锁</code>才支持，锁就变为了<code>重量级锁</code></li>\n</ul>\n<h5 id=\"font-size-3-批量重偏向-font\"><font size=\"3\">批量重偏向</font></h5>\n<ul>\n<li>如果对象被多个线程访问，但是没有竞争，这时候偏向了线程T1的对象又有机会重新偏向线程T2[就是上面的 <code>撤销偏向锁-让其它线程使用对象</code>的情况]；</li>\n<li>此时为了可以不升级为轻量级锁，又要实现重新偏向是要有<code>条件</code>的：<code>就是超过一定的阈值（20）</code>;</li>\n<li>之后对象会在<code>第20次及以后</code>撤销对<code>先前线程</code>的偏向，转为偏向线程T2</li>\n</ul>\n<h5 id=\"font-size-3-批量撤销-font\"><font size=\"3\">批量撤销</font></h5>\n<ul>\n<li>当撤销偏向锁阈值超过 <code>40 </code>次后，</li>\n<li>jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的</li>\n</ul>\n<h4 id=\"锁粗化\"><em>锁粗化</em></h4>\n<h4 id=\"锁消除\"><em>锁消除</em></h4>\n<h3 id=\"wait-notify\">wait-notify</h3>\n<blockquote>\n<p>是<code>Object 类的 API</code></p>\n</blockquote>\n<h4 id=\"原理\">原理</h4>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305300007647.png\" alt=\"image-20230530000744618\" style=\"zoom:33%;\">\n<blockquote>\n<p><code>BLOCKED</code> 未获得锁的等待 过程   <code>WAITING</code>获得锁之后又放弃锁，之后进入<code>WaitSet</code>的 等待过程</p>\n</blockquote>\n<ul>\n<li>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态</li>\n<li>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片</li>\n<li>BLOCKED 线程会在 Owner 线程释放锁时唤醒</li>\n<li>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，唤醒后并不意味者立刻获得锁，<strong>需要进入 EntryList 重新竞争</strong></li>\n</ul>\n<h4 id=\"API\">API:</h4>\n<blockquote>\n<ul>\n<li><code>notify()</code>:唤醒正在等待对象监视器的单个线程,随机唤醒</li>\n<li><code>notifyAll():</code>唤醒正在等待对象监视器的所有线程,全部唤醒</li>\n<li><code>wait():</code>导致当前线程等待，直到另一个线程调用该对象的 notify() 方法或 notifyAll()方法</li>\n<li><code>wait(long timeout)</code>:有时限的等待, 到n毫秒后结束等待，或是被唤醒</li>\n</ul>\n<p><strong>wait 是挂起线程，需要唤醒的都是挂起操作</strong>，阻塞线程可以自己去争抢锁，挂起的线程需要唤醒后去争抢锁(<code>等待 != 阻塞</code>)</p>\n<p>必须都要<code>获得对象锁</code>,成为<code> owner</code>才能调用<code>notify() notifyAll()</code> 和<code>wait()    wait(long timeout) </code>方法</p>\n<p>就是说： 它们都是线程之间进行协作的手段，都属于 <code>Object 对象的方法</code>。必须获得此<code>对象的锁</code>，才能调用这几个方法</p>\n<p><code>wait(n)</code>可以被<code>sleep(t)</code>（t  &lt; n）的提前<code>唤醒 notify()</code>  和<code>join()</code>是一样的</p>\n</blockquote>\n<p>**sleep  VS   wait **</p>\n<p><code>sleep(long n)</code> <strong>和</strong> <code>wait(long n) </code>的区别</p>\n<ul>\n<li>\n<p><code>sleep</code> 是 Thread 方法，而 <code>wait</code> 是 Object 的方法</p>\n</li>\n<li>\n<p>sleep 不需要强制和 <code>synchronized</code> 配合使用，但 wait 需要和 <code>synchronized</code> 一起用</p>\n</li>\n<li>\n<p>sleep 在睡眠的同时，不会释放对象锁的，但 <code>wait 在等待的时候会释放对象锁 </code></p>\n</li>\n<li>\n<p>不管进入哪一个方法，线程的状态都是<code> TIMED_WAITING</code></p>\n</li>\n<li>\n<p>如果需要是线程进行等待，应该使用<code>wait </code>而不是<code>sleep</code></p>\n</li>\n<li>\n<p>它们都可以被 interrupted 方法中断</p>\n</li>\n</ul>\n<h4 id=\"正确的使用\">正确的使用</h4>\n<blockquote>\n<ul>\n<li><code>wait()  </code>  —   使用    <code>notifyall()</code>  进行全部唤醒</li>\n<li>用  <code>while </code>  代替 <code>if</code>  防止虚假唤醒</li>\n</ul>\n<p>模版</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span>(lock) &#123;</span><br><span class=\"line\"> <span class=\"keyword\">while</span>(条件不成立) &#123;</span><br><span class=\"line\"> lock.wait();</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"comment\">// 干活</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//另一个线程</span></span><br><span class=\"line\"><span class=\"keyword\">synchronized</span>(lock) &#123;</span><br><span class=\"line\"> lock.notifyAll();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h3 id=\"park-unpack\">park -&amp; unpack</h3>\n<blockquote>\n<p>是 LockSupport 类中的方法</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 暂停当前线程</span></span><br><span class=\"line\">LockSupport.park();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 恢复某个线程的运行</span></span><br><span class=\"line\">LockSupport.unpark();</span><br></pre></td></tr></table></figure>\n<h4 id=\"对比\">对比</h4>\n<p>Thread 的<code>park unpark </code>与 Object 的<code>wait &amp; notify</code>相比</p>\n<ul>\n<li><code>wait</code>，<code>notify</code> 和 <code>notifyAll</code> 必须配合 Object Monitor 一起使用，而 <code>park</code>，<code>unpark</code> 不用</li>\n<li><code>park</code> &amp; <code>unpark</code> 是以<code>线程</code>为单位来【阻塞】和【唤醒】线程，而 <code>notify</code> 只能随机唤醒一个等待线程，<code>notifyAll</code> 是唤醒所有等待线程，就不那么【精确】</li>\n<li><code>park</code> &amp; <code>unpark</code> 可以先 <code>unpark</code>，而 <code>wait</code> &amp; <code>notify</code> 不能先 <code>notify</code></li>\n</ul>\n<h4 id=\"原理-2\">原理</h4>\n<p>每个线程都有自己的一个 Parker 对象，由三部分组成 <code>_counter</code>，<code> _cond</code>和<code> _mutex</code></p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305300040521.png\" alt=\"image-20230530004007480\" style=\"zoom: 43%;\">\n<h5 id=\"先调用park再调用upark的过程\">先调用park再调用upark的过程</h5>\n<ul>\n<li>\n<p>先调用<code>park</code></p>\n<ol>\n<li>当前线程调用 Unsafe.park() 方法</li>\n<li>检查 _counter ，此时为 0，这时，获得 _mutex 互斥锁(mutex对象有个等待队列 _cond)</li>\n<li>线程进入 _cond 条件变量阻塞</li>\n<li>设置 _counter = 0</li>\n</ol>\n</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305300041615.png\" alt=\"image-20230530004044023\" style=\"zoom:43%;\">\n<ul>\n<li>\n<p>再调用<code>unpark</code></p>\n<ol>\n<li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</li>\n<li>唤醒 _cond 条件变量中的 Thread_0</li>\n<li>Thread_0 恢复运行</li>\n<li>设置 _counter 为 0</li>\n</ol>\n</li>\n</ul>\n<h5 id=\"先调用upark再调用park的过程\">先调用upark再调用park的过程</h5>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305300042776.png\" alt=\"image-20230530004228751\" style=\"zoom:45%;\">\n<ol>\n<li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</li>\n<li>当前线程调用 Unsafe.park() 方法</li>\n<li>检查 _counter ，此时为 1，这时线程无需阻塞，继续运行</li>\n<li>设置 _counter 为 0</li>\n</ol>\n<h3 id=\"线程状态的转换条件\">线程状态的转换条件</h3>\n<ul>\n<li>NEW --&gt; RUNNABLE</li>\n</ul>\n<p>​\t\t当调用 t.start() 方法时，由 NEW --&gt; RUNNABLE</p>\n<blockquote>\n<p><code>RUNNABLE &lt;--&gt; WAITING</code></p>\n</blockquote>\n<ul>\n<li>\n<p>RUNNABLE &lt;–&gt; WAITING</p>\n<ul>\n<li>线程用synchronized(obj)<code>获取了对象锁后</code>\n<ul>\n<li>调用<code>obj.wait()</code>方法时，t 线程从<code>RUNNABLE</code> --&gt; <code>WAITING</code></li>\n<li>调用<code>obj.notify()，obj.notifyAll()，t.interrupt()</code>时\n<ul>\n<li>竞争锁成功，t 线程从<code>WAITING</code> --&gt; <code>RUNNABLE\t</code></li>\n<li>竞争锁失败，t 线程从<code>WAITING</code> --&gt; <code>BLOCKED</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>RUNNABLE &lt;–&gt; WAITING</p>\n<ul>\n<li>\n<p>当前线程调用 <code>LockSupport.park()</code> 方法会让当前线程从<code> RUNNABLE --&gt; WAITING</code></p>\n</li>\n<li>\n<p>调用<code>LockSupport.unpark(目标线程)</code>或调用了线程 的 <code>interrupt()</code> ，会让目标线程从 <code>WAITING --&gt; RUNNABLE</code></p>\n</li>\n</ul>\n</li>\n<li>\n<p>RUNNABLE &lt;–&gt; WAITING</p>\n<ul>\n<li>\n<p>当前线程调用<code> t.join()</code> 方法时，当前线程从 <code>RUNNABLE --&gt; WAITING</code><br>\n注意是当前线程在t 线程对象的监视器上等待</p>\n</li>\n<li>\n<p><code>t 线程运行结束</code>，或调用了当前线程的<code> interrupt()</code> 时，当前线程从<code> WAITING --&gt; RUNNABLE</code></p>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><code>RUNNABLE &lt;--&gt; TIMED_WAITING</code></p>\n</blockquote>\n<ul>\n<li>\n<p>RUNNABLE &lt;–&gt; TIMED_WAITING(有时限的waiting)</p>\n<p>线程用 synchronized(obj) 获取了对象锁后</p>\n<ul>\n<li>\n<p>调用 <code>obj.wait(long n) </code>方法时，t 线程从<code> RUNNABLE --&gt; TIMED_WAITING</code></p>\n</li>\n<li>\n<p>t 线程等待时间超过了 n 毫秒，或调用 <code>obj.notify() ， obj.notifyAll() ， t.interrupt()</code> 时</p>\n<ul>\n<li>竞争锁成功，t 线程从 <code>TIMED_WAITING --&gt; RUNNABLE</code></li>\n<li>竞争锁失败，t 线程从 <code>TIMED_WAITING --&gt; BLOCKED</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>RUNNABLE &lt;–&gt; TIMED_WAITING</p>\n<ul>\n<li>当前线程调用 <code>t.join(long n) </code>方法时，当前线程从 <code>RUNNABLE --&gt; TIMED_WAITING</code><br>\n注意是当前线程在t 线程对象的监视器上等待</li>\n<li>当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从<br>\nTIMED_WAITING --&gt; RUNNABLE</li>\n</ul>\n</li>\n<li>\n<p>RUNNABLE &lt;–&gt; TIMED_WAITING</p>\n<ul>\n<li>当前线程调用 <code>Thread.sleep(long n) </code>，当前线程从 RUNNABLE --&gt; TIMED_WAITING</li>\n<li>当前线程<code>等待时间超过了 n 毫秒</code>或调用了线程 的<code> interrupt()</code> ，当前线程从 TIMED_WAITING --&gt; RUNNABLE</li>\n</ul>\n</li>\n<li>\n<p>RUNNABLE &lt;–&gt; TIMED_WAITING当前线程</p>\n<ul>\n<li>调用 <code>LockSupport.parkNanos(long nanos)</code> 或 <code>LockSupport.parkUntil(long millis) </code>时，当前线<br>\n程从 RUNNABLE --&gt; TIMED_WAITING</li>\n<li>调用 <code>LockSupport.unpark(目标线程) </code>或调用了线程 的<code>interrupt()</code>，或是<code>等待超时</code>，会让目标线程从<br>\nTIMED_WAITING–&gt; RUNNABLE</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><code>RUNNABLE &lt;--&gt; BLOCKED       </code></p>\n</blockquote>\n<ul>\n<li>RUNNABLE &lt;–&gt; BLOCKED\n<ul>\n<li>t 线程用 synchronized(obj) <code>获取了对象锁</code>时，如果<code>竞争失败</code>，从 RUNNABLE --&gt; BLOCKED</li>\n<li>持 obj 锁线程的<code>同步代码块执行完毕</code>，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程<code>竞争成功</code>，从 BLOCKED --&gt; RUNNABLE ，其它失败的线程仍然 BLOCKED</li>\n</ul>\n</li>\n<li>RUNNABLE &lt;–&gt; TERMINATED<br>\n当前线程<code>所有代码</code>运行完毕，进入 TERMINATED</li>\n</ul>\n<h3 id=\"活跃性\">活跃性</h3>\n<blockquote>\n<p>相关问题</p>\n</blockquote>\n<ul>\n<li>死锁\n<ul>\n<li>一个线程需要同时获取多把锁，这时就容易发生死锁；</li>\n<li>t1 线程<code>获得A</code>对象锁，接下来<code>想获取B</code>对象的锁；</li>\n<li>此时 t2 线程<code>获得B</code>对象锁，接下来<code>想获取A</code>对象的锁例</li>\n</ul>\n</li>\n<li>活锁\n<ul>\n<li>现象： 一直执行，无法停止</li>\n<li><span style=\"color:purple\">解决：执行时间有一定的<code>交错</code> 或者设置随机的<code>睡眠时间</code></span></li>\n</ul>\n</li>\n<li>饥饿\n<ul>\n<li>一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束，讲读写锁时会涉及饥饿问题</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>活跃性相关问题 都可以用ReentrantLock进行解决</p>\n</blockquote>\n<h3 id=\"ReentrantLock\">ReentrantLock</h3>\n<blockquote>\n<p>相对于 synchronized 它具备如下特点</p>\n</blockquote>\n<ol>\n<li><code>可中断</code>（比如：a有锁    b可以将这个锁取消掉）</li>\n<li>可以设置<code>超时时间</code>，超过时间就放弃<code>争抢锁</code>，执行其他逻辑</li>\n<li>可以设置为<code>公平锁</code>，防止饥饿（先到先得，不争抢）</li>\n<li>支持<code>多个条件变量</code>（类似<code>waitset</code>，但是ReentrantLock有多个，可以将 等烟、等外卖等分开等，有多个休息室），即对与不满足条件的线程可以放到不同的集合中等待</li>\n<li>与 synchronized 一样（只有一个<code>waitset</code>可以将 等烟、等外卖等分开等，只有个休息室，<code>notify()</code>通知所有对象），都支持可重入（同一个线程可以对同一个对象反复加锁）</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--   使用</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 获取锁  或者放在 临界区也是可以的</span></span><br><span class=\"line\">reentrantLock.lock();</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\"> <span class=\"comment\">// 临界区</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\"> <span class=\"comment\">// 释放锁，要在finally中释放锁，确保一定能释放</span></span><br><span class=\"line\"> reentrantLock.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"可重入\">可重入</h4>\n<ul>\n<li>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁</li>\n<li>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</li>\n</ul>\n<h4 id=\"可打断\">可打断</h4>\n<ul>\n<li>当设置为 <code>可打断模式</code>,即调用 : 打断锁方法：<code>  lock.lockInterruptibly()</code></li>\n<li>如果没有竞争   那么此方法就会获取Lock对象锁</li>\n<li>如果有竞争    就进入阻塞队列，可以被其它线程用  <code>interruput</code> 方法打断</li>\n</ul>\n<blockquote>\n<p>注意如果是不可中断模式，那么即使使用了 interrupt 也不会让等待中断</p>\n</blockquote>\n<h4 id=\"锁超时\">锁超时</h4>\n<p>等待一段时间，要是还是没有获得锁，就放弃等待，表示<code>获取失败</code>，因此不会死锁</p>\n<ul>\n<li>\n<p><code>tryLock()</code>无参的形式</p>\n</li>\n<li>\n<p><code>tryLock(n)</code>带参数的形式 : <code>n</code> 表示时间,指定时间内其他线程释放锁，仍会得到锁</p>\n</li>\n</ul>\n<h4 id=\"公平锁\">公平锁</h4>\n<ul>\n<li>\n<p>synchronized锁中，在<code>entrylist</code>等待的锁在竞争时不<code>是按照先到先得</code>来获取锁的，所以说synchronized锁时<code>不公平</code>的；</p>\n</li>\n<li>\n<p>ReentranLock锁默认是不公平的，但是可以通过<code>设置实现公平锁</code>。<code>本意是为了解决之前提到的饥饿问题</code>，但是公平锁一般没有必要，会降低并发度，使用<code>trylock</code>也可以实现。</p>\n</li>\n</ul>\n<h4 id=\"条件变量\">条件变量</h4>\n<ul>\n<li>\n<p>synchronized 中也有条件变量，就是我们讲原理时那个 <code>waitSet</code> 休息室，当条件不满足时进入<code> waitSet</code> 等待<br>\nReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持<code>多个条件变量</code>的，这就好比</p>\n<ul>\n<li>synchronized 是那些不满足条件的线程都在一间休息室等消息</li>\n</ul>\n</li>\n<li>\n<p>而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒</p>\n</li>\n</ul>\n<p>使用要点：</p>\n<p><code>await() singal() siangalall()</code></p>\n<ol>\n<li><code>await</code> 前需要获得锁</li>\n<li><code>await</code> 执行后，会释放锁，进入<code> conditionObject&lt;休息室&gt;</code> 等待</li>\n<li><code>await</code> 的线程被唤醒（或打断<code>interrupt</code>、或超时<code>await</code>）去重新竞争 <code>lock</code> 锁，执行唤醒的线程也必须先获得锁</li>\n<li>竞争 <code>lock</code> 锁成功后，从 <code>await</code> 后继续执行</li>\n</ol>\n<blockquote>\n<p>注意： <code>ReentrantLock</code>必须<code>lock() unlock()</code>同时使用，不像<code>synchronized</code> 在<code>字节码层面</code>的退出时会<code>自动释放锁</code></p>\n<p><code>ReentrantLock</code> 的使用细节：<code>可打断</code>&lt;不会死锁&gt;、<code>锁超时</code>&lt;规定时间内得不到锁返回false不会死锁&gt;、<code>公平锁</code>（<code>ReentrantLock</code>  <code>synchronized</code> 默认都是非公平锁）、<code>条件变量</code></p>\n</blockquote>\n<h3 id=\"多把锁的改进\">多把锁的改进</h3>\n<blockquote>\n<p>就是将多把锁合并为一把锁，增加<code>并发度</code></p>\n</blockquote>\n<p>将锁的粒度<code>细分</code></p>\n<ul>\n<li>\n<p>好处，是可以<code>增强并发度</code></p>\n</li>\n<li>\n<p>坏处，如果一个线程需要同时获得多把锁，就容易发生死锁</p>\n</li>\n</ul>\n<h2 id=\"共享模型之内存\">共享模型之内存</h2>\n<blockquote>\n<p>承上启下：</p>\n<ul>\n<li>上一章讲解的 Monitor 主要关注的是访问共享变量时，保证临界区代码的原子性。</li>\n<li>这一章学习共享变量在多线程间的【可见性】问题与多条指令执行时的【有序性】问题</li>\n</ul>\n</blockquote>\n<h3 id=\"Java-内存模型\">Java 内存模型</h3>\n<p><code>JMM 即 Java Memory Model</code>，它从java层面定义了主存、工作内存抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、CPU 指令优化等。</p>\n<p>JMM 体现：</p>\n<ol>\n<li><code>原子性</code> - 保证指令执行时是原子的，不会受到线程上下文切换的影响</li>\n<li><code>可见性</code> - 保证指令不会受 <code>cpu 缓存</code>的影响</li>\n<li><code>有序性</code> - 保证指令不会受 <code>cpu 指令并行优化</code>的影响</li>\n</ol>\n<h3 id=\"可见性\">可见性</h3>\n<p><strong>退不出的循环</strong> :</p>\n<p>原因就是在于：</p>\n<ul>\n<li>执行循环的线程，会共享变量(用于子线程循环执行退出的条件)缓存到自己的工作内存中的高速缓冲区中，可以减少对主存的访问，提升效率</li>\n<li>主线程即使实时修改并同步到内存了，但是分支线程仍然是从自己的内存中的高速缓冲区中读到此变量，从而使得在子线程中该值未发生任何修改。</li>\n</ul>\n<p><strong>解决</strong></p>\n<p><code>volatile</code></p>\n<ul>\n<li>\n<p>可以用来修饰成员变量和静态成员变量</p>\n</li>\n<li>\n<p>作用：</p>\n<ul>\n<li>可以<code>避免</code>线程从<code>自己的工作缓存</code>中查找变量的值，必须到<code>主存中获取它的值</code>，线程操作<code> volatile</code> 变量都是直接操作<code>主存</code></li>\n</ul>\n<blockquote>\n<p>使用<code>synchronized</code>关键字也有相同的效果！</p>\n<ul>\n<li>因为：线程在加锁时</li>\n</ul>\n<p>先<code>清空</code>工作内存→在主内存中<code>拷贝</code>最新变量的副本到<code>工作内存</code> →执行完代码→将更改后的<code>共享变量</code>的值刷新到<code>主内存</code>中→释放<code>互斥锁</code></p>\n<p><code>volatile</code> 更加轻量   可见性角度 推荐使用 <code>volatile</code> 而不是  <code>synchronized</code></p>\n</blockquote>\n</li>\n</ul>\n<p>==说明==</p>\n<ul>\n<li><code>synchronized</code> 内部的代码块可以由 <code>synchronized</code>保证 变量的可见性</li>\n<li>非<code>synchronized</code> 内部的代码块需要由 <code>volatile</code>保证 变量的可见性</li>\n<li><code>t1=new Thread(()-&gt;&#123;…&#125;)  …</code>中的代码出现变量只会 被 t1自己调用/修改，不会有多线程调用的情况，所以只要保证可见性就可以了，不用保证原子性</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- 说明演示</span><br><span class=\"line\"></span><br><span class=\"line\">-- `<span class=\"keyword\">synchronized</span>` 内部的代码块可以由 `<span class=\"keyword\">synchronized</span>`保证 变量的可见性</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"variable\">starting</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"> \t<span class=\"keyword\">synchronized</span> (<span class=\"built_in\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (starting) &#123; <span class=\"comment\">// false</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">-- 非`<span class=\"keyword\">synchronized</span>` 内部的代码块需要由 `<span class=\"keyword\">volatile</span>`保证 变量的可见性</span><br><span class=\"line\">            starting = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"type\">boolean</span> starting;</span><br><span class=\"line\">-- `t1=<span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt;&#123;…&#125;)  …`中的代码出现变量只会 被 t1自己调用/修改，不会有多线程调用的情况，所以只要保证可见性就可以了，不用保证原子性</span><br><span class=\"line\"><span class=\"comment\">// 由于之前的 balking 模式，以下代码只可能被一个线程执行，因此无需互斥</span></span><br><span class=\"line\">        monitorThread = <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!stop) &#123;</span><br><span class=\"line\">                report();</span><br><span class=\"line\">                sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 这里的监控线程只可能启动一个，因此只需要用 volatile 保证 starting 的可见性</span></span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;监控线程已停止...&quot;</span>);</span><br><span class=\"line\">            </span><br><span class=\"line\">  <span class=\"comment\">//starting 变量只会 有 monitorThread自己调用/修改，不会有多线程调用的情况，所以只要保证可见性就可以了，不用保证原子性</span></span><br><span class=\"line\">            starting = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"有序性\">有序性</h3>\n<blockquote>\n<p>使用synchronized并不一定能解决有序性问题，但是如果是该变量整个都在synchronized代码块的保护范围内，那么变量就不会被多个线程同时操作，也不用考虑有序性问题！</p>\n</blockquote>\n<h4 id=\"指令重排序优化\">指令重排序优化</h4>\n<blockquote>\n<p>对指令做更小力度的划分：<code>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</code> 这 5 个阶段称为 <code>五级指令流水线</code></p>\n<p>流水线指令的虽然<code>不能缩短指令的</code>执行时间<code>，但是变相的</code>提高了<code>指令的</code>吞吐量`</p>\n</blockquote>\n<p>指令重排的前提是，重排指令<code>不能影响结果</code></p>\n<p>重排序遵守的规则：</p>\n<ul>\n<li>\n<p>重排序操作不会对<code>存在数据依赖关系</code>的操作进行重排序。</p>\n<ul>\n<li>比如：<code>a=1;b=a; </code>这个指令序列，由于第二个操作依赖于第一个操作，所以在编译时和处理器运行时这两个操作不会被重排序。</li>\n</ul>\n</li>\n<li>\n<p>重排序是为了优化性能，但是不管怎么重排序，单线程下程序的执行结果不能被改变。</p>\n<ul>\n<li>比如：<code>a=1;b=2;c=a+b</code>这三个操作，第一步（a=1)和第二步(b=2)由于不存在数据依赖关系，所以可能会发生重排序，但是<code>c=a+b</code>这个操作是不会被重排序的，因为需要保证最终的结果一定是c=a+b=3。</li>\n</ul>\n</li>\n</ul>\n<p>使用使用 <code>volatile</code> 修饰 就可以 <code>禁止指令重排</code></p>\n<p>就是：重排序在<code>单线程</code>模式下是一定会保证最终结果的正确性，但是在<code>多线程</code>环境下，问题就出来了。解决方法：volatile 修饰的变量，可以禁用指令重排</p>\n<h3 id=\"原理-3\">原理</h3>\n<blockquote>\n<p>volatile 的底层实现原理是内存屏障</p>\n</blockquote>\n<ol>\n<li>对 volatile 变量的<code>写指令后</code>会加入<code>写屏障</code></li>\n<li>对 volatile 变量的<code>读指令前</code>会加入<code>读屏障</code></li>\n</ol>\n<blockquote>\n<p>如何保证可见性</p>\n</blockquote>\n<ol>\n<li>写屏障（sfence）保证在该屏障之<code>前</code>的，对共享变量的改动，<code>都同步到主存当中</code></li>\n<li>读屏障（lfence）保证在该屏障之<code>后</code>，对共享变量的读取，<code>加载的是主存中最新数据</code></li>\n</ol>\n<blockquote>\n<p>如何保证有序性</p>\n</blockquote>\n<ol>\n<li>写屏障会确保指令重排序时，不会将<code>写屏障之前</code>的代码排在<code>写屏障之后</code></li>\n<li>读屏障会确保指令重排序时，不会将<code>读屏障之后</code>的代码排在<code>读屏障之前</code></li>\n</ol>\n<blockquote>\n<p><code>volatile</code> 只能保证<code>有序性和可见性</code>不能解决指令交错：</p>\n</blockquote>\n<ol>\n<li><code>写屏障</code>仅仅是保证之后的读能够读到<code>最新</code>的结果，但不能保证其它线程的读跑到它前面去</li>\n<li><code>有序性</code>的保证也只是保证了<code>本线程内</code>相关代码<code>不被</code>重排序  ,线程间的需要由 <code>cpu分配的时间片决定</code></li>\n</ol>\n<h4 id=\"双检加锁问题与解决\">双检加锁问题与解决</h4>\n<p>&lt;单例模式懒汉式的一种&gt;</p>\n<blockquote>\n<p><code>double-checked locking </code>问题产生原因：</p>\n<ul>\n<li>因为<code>synchronized</code>不能完全阻止重排序 ，【synchronized 并不能保证同步块外部的指令按照预期顺序执行，因此有可能会导致一些意外情况的发生，特别是在多线程的情况下】</li>\n<li>但是<code>volatile</code> 是可以阻止重排序的</li>\n<li>就是说如果 <code>共享变量</code>完全被<code>synchronized</code>保护，那么<code>共享变量</code>是没有<code>原子  可见   有序 的问题的</code></li>\n<li>所以出现问题就是因为<code>if(INSTANCE == null)</code>判断代码<code>没有</code>在同步代码块<code>synchronized</code>中,没有被完全保护的，发生了指令重排的现象，\n<ul>\n<li>假设此时有两个线程在执行，<code>t1</code>还未完全将构造方法执行完毕，如果在构造方法中要执行很多<code>初始化</code>操作，那么 t2 拿到的是将是一个<code>未初始化完毕</code>的单例</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p><strong>解决</strong></p>\n<p><code>INSTANCE  加  volatile 修饰 就行了</code>,这个时候就会再读写的时候对指令加 <code>内存屏障</code>,不会有上述现象的产生</p>\n<p>具体而言就是：</p>\n<blockquote>\n<p>读写 <code>volatile</code> 变量操作（即<code>getstatic</code>操作和<code>putstatic</code>操作）时会加入内存屏障），禁止了指令重排序&lt;<code>主要是写屏障</code>&gt;，解决了上述问题。</p>\n</blockquote>\n<p>有序性</p>\n<ol>\n<li>写屏障会确保指令重排序时，不会将<code>写屏障之前</code>的代码排在<code>写屏障之后</code></li>\n<li>读屏障会确保指令重排序时，不会将<code>读屏障之后</code>的代码排在<code>读屏障之前</code></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123; &#125;</span><br><span class=\"line\">       <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> <span class=\"type\">Singleton</span> <span class=\"variable\">INSTANCE</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">       <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 实例没创建，才会进入内部的 synchronized代码块</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (INSTANCE == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">synchronized</span> (Singleton.class) &#123; <span class=\"comment\">// t2</span></span><br><span class=\"line\">                   <span class=\"comment\">// 也许有其它线程已经创建实例，所以再判断一次</span></span><br><span class=\"line\">                   <span class=\"keyword\">if</span> (INSTANCE == <span class=\"literal\">null</span>) &#123; <span class=\"comment\">// t1</span></span><br><span class=\"line\">                       INSTANCE = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Happens-before规则\">Happens-before规则</h3>\n<p>就是规定了<code>对共享变量的写操作</code>对其它线程的<code>读操作可见</code>，它是可见性与有序性的一套<code>规则的总结</code>，抛开 happens-before 规则，<code>JMM 并不能保证一个线程对共享变量的写</code>，对于其它线程对<code>共享变量</code>的<code>读可见</code></p>\n<p>规则：</p>\n<ul>\n<li>\n<p>线程解锁 <code>m 之前</code>对变量<code>的写</code>，对于接下来对 <code>m 加锁</code>的其它线程对该变量的<code>读可见</code></p>\n</li>\n<li>\n<p>线程对 <code>volatile</code> 变量的写，对接下来其它线程对该变量的<code>读可见</code></p>\n</li>\n<li>\n<p>线程 <code>start</code> 前对变量的写，对该线程开始后对该变量的读可见</p>\n</li>\n<li>\n<p>线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）</p>\n</li>\n<li>\n<p>线程 t1 打断<code> t2（interrupt）</code>前对变量的写，对于其他线程得知 <code>t2 被打断后</code>对变量的读可见（通过<code>t2.interrupted </code>或<code> t2.isInterrupted</code>）</p>\n</li>\n<li>\n<p>对变量默认值（0，false，null）的写，对其它线程对该变量的读可见</p>\n</li>\n<li>\n<p>具有传递性，如果 x -&gt; y 并且 y -&gt; z 那么有 x -&gt; z ，可以配合 volatile 的防指令重排</p>\n</li>\n</ul>\n<p><strong>volatile主要使用场景</strong></p>\n<ul>\n<li>用在一个线程写 其他多个线程读时的来保证可见性</li>\n<li>和double-checked locking模式中保证<code>synchronized</code>代码块外的共享变量的<code>指令重排序</code>问题</li>\n</ul>\n<blockquote>\n<p>其他情况还是要使用<code>synchronized</code></p>\n</blockquote>\n<h5 id=\"总结\">总结</h5>\n<ul>\n<li>获取共享变量时，<code>为了保证该变量的可见性</code>，需要使用 volatile 修饰。</li>\n<li>它可以用来修饰<strong>成员变量和静态成员变量</strong>，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存。即一个线程对 volatile 变量的修改，对另一个线程可见。</li>\n<li>==反复记忆==        volatile <code>仅仅</code>保证了共享变量的可见性，让其它线程能够看到最新值，但<code>不能解决指令交错</code>问题（不能保证原子性）</li>\n</ul>\n<h2 id=\"共享模型之无锁\">共享模型之无锁</h2>\n<blockquote>\n<p>承上启下：</p>\n<ul>\n<li>管程即<code>monitor</code>是阻塞式的<code>悲观锁</code>实现并发控制</li>\n<li>这章我们将通过<code>非阻塞式的乐观锁</code>的来<code>实现并发控制</code></li>\n</ul>\n</blockquote>\n<blockquote>\n<p>一般的使用<code>synchronized</code>加锁操作来实现线程安全，但是<code>synchronized</code>加锁操作<code>太耗费资源</code>，这里我们<code>使用无锁</code>来解决此问题：</p>\n</blockquote>\n<p>无锁：</p>\n<ul>\n<li>原子类</li>\n<li>CAS</li>\n</ul>\n<h3 id=\"CAS\">CAS</h3>\n<blockquote>\n<p>原子性的保证：</p>\n</blockquote>\n<ul>\n<li>\n<p>CAS 的底层是<code> lock cmpxchg</code> 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够<code>保证</code>【比较-交换】的<code>原子性</code>。</p>\n</li>\n<li>\n<p>在多核状态下，<code>某个核</code>执行到带 <code>lock 的指令</code>时，<code>CPU 会让总线锁住</code>，当<code>这个核</code>把此指令执行完毕，再开启总线。这个过程中<code>不会被线程的调度机制所打断</code>，保证了多个线程对内存操作的准确性，<code>是原子的</code>。</p>\n</li>\n</ul>\n<blockquote>\n<p>CAS 必须借助 <code>volatile</code> 才能读取到<code>共享变量的最新值</code>来<code>实现</code>【<code>比较并交换</code>】的效果</p>\n</blockquote>\n<blockquote>\n<p>为什么无锁效率高</p>\n</blockquote>\n<ul>\n<li>\n<p>无锁情况下，<code>即使重试失败</code>，线程<code>始终在高速运行</code>，没有停歇</p>\n</li>\n<li>\n<p>而 synchronized 会让线程在没有获得锁的时候，<code>发生上下文切换，进入阻塞</code></p>\n</li>\n</ul>\n<p>值得注意的是：</p>\n<ul>\n<li>但无锁情况下，因为线程要保持运行，需要额外 <code>CPU 的支持</code>，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还是会导致上下文切换。</li>\n</ul>\n<p>特点：</p>\n<ul>\n<li>\n<p>结合 <code>CAS</code> 和 <code>volatile</code> 可以实现无锁并发，适用于<code>线程数少(不超多核心cpu数)、多核 CPU </code>的场景下</p>\n</li>\n<li>\n<p><code>CAS</code> 是基于乐观“锁”的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系,重试就好。</p>\n<p><code>synchronized</code> 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，<code>synchronized</code>上了锁其他线程就别想改了，只有当前线程改完了之后解开锁，其他线程才会进行竞争。</p>\n</li>\n<li>\n<p>CAS 体现的是<code>无锁并发、无阻塞并发</code></p>\n<ol>\n<li>因为没有使用<code> synchronized</code>，所以线程<code>不会陷入阻塞</code>，这是效率提升的因素之一</li>\n<li>但如果<code>竞争激烈(写操作多)</code>，可以想到<code>重试必然频繁发生</code>，反而效率会受影响</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"JUC下的API\"><code>JUC</code>下的API</h3>\n<h4 id=\"基本类型的原子类\">基本类型的原子类</h4>\n<p><strong>分类</strong>：</p>\n<ul>\n<li>\n<p>使用原子的方式更新基本类型</p>\n<ul>\n<li><code>AtomicInteger</code>：整型原子类（4字节）</li>\n<li><code>AtomicLong</code>：长整型原子类 （8字节）</li>\n<li><code>AtomicBoolean</code> ：布尔型原子类</li>\n</ul>\n<p>上面三个类提供的方法几乎相同，所以我们将以 <code>AtomicInteger</code> 为例子来介绍。</p>\n</li>\n<li>\n<p>原子引用</p>\n</li>\n<li>\n<p>原子数组</p>\n</li>\n<li>\n<p>字段更新器</p>\n</li>\n<li>\n<p>原子累加器</p>\n</li>\n</ul>\n<blockquote>\n<p>原子类的底层实现还是通过<code>cas</code>原理来进行实现的</p>\n</blockquote>\n<h4 id=\"原子引用（引用类型原子类）\">原子引用（引用类型原子类）</h4>\n<blockquote>\n<p>为什么需要原子引用类型？</p>\n</blockquote>\n<ul>\n<li>\n<p>保证<code>引用类型</code>的<code>共享变量是线程安全</code>的（确保这个原子引用没有引用过别人）。</p>\n</li>\n<li>\n<p><code>基本类型原子类</code>只能更新一个变量，如果需要原子更新<code>多个变量</code>，需要使用<code>引用类型原子类</code>。</p>\n</li>\n</ul>\n<blockquote>\n<p>分类：</p>\n</blockquote>\n<ul>\n<li>\n<p><code>AtomicReference</code>：引用类型原子类</p>\n</li>\n<li>\n<p><code>AtomicStampedReference</code>：原子<code>更新带有版本号</code>的引用类型。该类将<code>整数值与引用关联</code>起来，可用于解决原子的更新数据和数据的版本号，可以【加一个版本号】解决使用<code> CAS 进行原子更新</code>时<code>可能出现的 ABA 问题</code>。</p>\n</li>\n<li>\n<p><code>AtomicMarkableReference </code>：原子更新<code>带有标记</code>的引用类型。该类将<code> boolean 标记与引用关联</code>起来，也可以【引入一个额外的标志位】<code>一定程度上</code>解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</p>\n</li>\n</ul>\n<blockquote>\n<p>ABA问题</p>\n</blockquote>\n<ul>\n<li>ABA 问题指的是在某个线程执行过程中，某个变量的值从 A 变成 B，又从 B 变成 A，而其他线程在此期间对这个变量进行了修改，导致这些修改没有被检测到。</li>\n<li>这种情况下，使用 CAS 操作时可能会出现误判，因为 CAS 操作只能比较对象引用是否相等，而无法判断其中的值是否发生过变化。</li>\n</ul>\n<p>解决：</p>\n<ul>\n<li>\n<p>使用<code>AtomicStampedReference</code>来解决： 只需要再<code>加一个版本号</code>。</p>\n</li>\n<li>\n<p>但是有时候，并不关心引用变量改变了几次，只是单纯的关心是否更改过，所以就有了<code>AtomicMarkableReference   </code></p>\n</li>\n</ul>\n<h4 id=\"原子数组\">原子数组</h4>\n<blockquote>\n<p>修改引用本身  使用 <code>AtomicReference</code></p>\n<p>修改引用对象里面的内容： 比如数组: 想要 修改<code>数组对象</code>里面的值</p>\n</blockquote>\n<p>分类：</p>\n<ul>\n<li><code>AtomicIntegerArray</code>：整形数组原子类</li>\n<li><code>AtomicLongArray</code>：长整形数组原子类</li>\n<li><code>AtomicReferenceArray</code>  ：引用类型数组原子类</li>\n</ul>\n<h4 id=\"字段更新器\">字段更新器</h4>\n<blockquote>\n<p>保护的是类里面的属性，成员变量，保证<code>多线程访问成员变量</code>时的线程安全性</p>\n<p>注意：利用字段更新器，可以针对<code>对象的某个域（Field）</code>进行原子操作，只能配合<code> volatile</code> 修饰的字段使用，否则会出现异常</p>\n</blockquote>\n<ul>\n<li>\n<p><code>AtomicReferenceFieldUpdater</code>      域 字段    引用类型 [String  或者 Date() 等]</p>\n</li>\n<li>\n<p><code>AtomicIntegerFieldUpdater</code>          整型</p>\n</li>\n<li>\n<p><code>AtomicLongFieldUpdater</code>                 long型</p>\n</li>\n</ul>\n<h4 id=\"原子累加器\">原子累加器</h4>\n<ul>\n<li>累加器性能比较\n<ul>\n<li><code>LongAdder</code>累加器的使用</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><code>longadder</code>的性能比较高的原因：</p>\n<ul>\n<li>\n<p><code>CAS</code>在有竞争时，会使用 <code>while(true)&#123; &#125;</code>循环不断尝试更新，竞争激烈的时候<code>往一个共享变量</code>上进行累加时就会使得<code>重试次数增多</code>，就增长了时间</p>\n</li>\n<li>\n<p>就是<code>LongAdder</code>在有竞争时，设置多个累加单元(但不会超过cpu的核心数)，Therad-0 累加 Cell[0]，而 Thread-1 累加Cell[1]… 最后将结果汇总。这样它们在累加时操作的<code>不同的 Cell 共享变量</code>，因此减少了 CAS 重试失败，从而提高性能。</p>\n</li>\n</ul>\n</blockquote>\n<h5 id=\"原理-4\">原理</h5>\n<p><code>@sun.misc.Contended</code>    <code>缓存行的伪共享</code>用来解决缓存行的失效</p>\n<ul>\n<li>它的原理是在<code>使用此注解</code>的对象或字段的前后各增加 128 字节大小的padding(间隙)，（24+128&gt;64）会使得一个缓存行至多只能存储一个<code>Cell</code>, 从而会让 CPU 将对象<code>预读至缓存时占用不同的缓存行</code>，这样，不会造成对方缓存行的失效</li>\n</ul>\n<h3 id=\"Unsafe\">==Unsafe==</h3>\n<ul>\n<li>\n<p><code>Unsafe</code> 对象提供了非常底层的 <code>操作内存</code>、<code>线程</code>的方法，<code>Unsafe</code> 对象<code>不能直接调用</code>，只能通过<code>反射</code>获得</p>\n</li>\n<li>\n<p><code>LockSupport</code>的<code>park</code>方法，<code>cas</code>相关的方法底层都是通过<code>Unsafe</code>类来实现的</p>\n</li>\n</ul>\n<h4 id=\"cas操作\">cas操作</h4>\n<p>方法：</p>\n<ul>\n<li><code>compareAndSwapInt  </code>    比较并交换 整型</li>\n<li><code>compareAndSwapLong</code>  比较并交换 长整型</li>\n<li><code>compareAndSwapObject</code>   比较并交换 Object</li>\n</ul>\n<h2 id=\"共享模型之不可变\">共享模型之不可变</h2>\n<h4 id=\"日期转换\">日期转换</h4>\n<p>问题与解决</p>\n<ul>\n<li>由于 <code>SimpleDateFormat</code> 不是线程安全的，在使用的时候需要加上锁<code>synchronized</code></li>\n</ul>\n<p><code>DateTimeFormatter</code> 就是线程安全的，因为这个对象<code>不能够</code>修改其<code>内部状态</code>（属性），不存在并发修改的问题，所以它就是线程安全的，</p>\n<h4 id=\"不可变的设计\">不可变的设计</h4>\n<h5 id=\"String不可变的原因\">String不可变的原因</h5>\n<ul>\n<li>\n<p><code>final</code> 保证其只能在构造的时候赋值  <code>保证数组的引用</code>无法被更改</p>\n</li>\n<li>\n<p><code>构造器中</code>保证数组的内容无法改变</p>\n<ul>\n<li>\n<p>构造器中：<code>拷贝</code>  将数组的<code>内容 </code>拷贝为一份<code>新数组</code> 并将新数组作为<code>String</code> 的<code>value</code></p>\n<ul>\n<li><code>String</code>构造器中  传过来的如果是<code>String</code> 的变量，那么会给<code>String</code>对象的<code>value</code>赋值，会新创建了一个数组来保存原来<code>String</code>对象的值，</li>\n<li><code>String</code>构造器中  传过来的如果是<code>char</code> 的数组,   那么就会对 <code>char</code> 类型的数组 进行的复制 ，产生了新的 char型的数组  并将新数组作为新的<code>字符串对象的value属性</code></li>\n</ul>\n<p>如果此时的 this.value 引用了一个char数组，没有进行复制的话，一旦  外部也引用了一个 char数组，并且两者引用的是一个char数组的对象 ，只要外部元素发生变化，会导致<code>this.value</code>也会跟着变化，由此破坏了  String的不可变性</p>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"final-的使用\">final 的使用</h5>\n<p>发现该类、类中所有属性都是 final 的，</p>\n<ul>\n<li>\n<p>属性用 final 修饰保证了该<code>属性（成员变量）是只读的</code>，不能修改</p>\n</li>\n<li>\n<p>类用 final 修饰保证了该类中的<code>方法不能被覆盖</code>，防止<code>子类</code>无意间破坏不可变性</p>\n</li>\n</ul>\n<h5 id=\"保护性拷贝\">保护性拷贝</h5>\n<p>通过创建副本对象来避免共享的手段称之为【<code>保护性拷贝（defensive copy）</code>】</p>\n<blockquote>\n<p>使用字符串时，也有一些跟<code>修改相关</code>的方法啊，比如 substring 等，那么下面就看一看这些方法是如何实现的，</p>\n</blockquote>\n<ul>\n<li>首先发现<code>substring</code>函数的内部是调用 <code>String</code> 的构造方法创建了一个<code>新字符串</code>，再进入<code>String</code>构造方法发现并没有对 <code>final char[] value </code>做出了修改，构造新<code>字符串对象</code>时，会生成新的<code> char[] value</code>，对内容进行复制。也就是对 <code>char</code> 类型的数组 进行的<code>复制 </code>产生了<code>新的 char型的数组</code>  再<code>复制给新的字符串对象的value属性</code></li>\n<li>所以 substring <code>没有改动原来的字符串</code> 而是<code>创建了一个新的字符串对象</code>  对象里面的value也得到了复制</li>\n</ul>\n<h5 id=\"final-的原理\">final 的原理</h5>\n<p><strong>设置的原理</strong></p>\n<ul>\n<li>\n<p>final变量的赋值操作都必须在定义时或者构造器中进行初始化赋值，并且 final 变量的<code>赋值</code>也会通过 <code>putfield</code> 指令来完成，同样在这条指令之后也会加入<code>写屏障</code>，保证在其它线程读到它的值时不会出现为 0 的情况。</p>\n</li>\n<li>\n<p><code>final </code> 是自带 写屏障的</p>\n</li>\n</ul>\n<p><strong>获取的原理</strong></p>\n<blockquote>\n<p>字节码层面上的理解</p>\n<ul>\n<li>会将<code>变量的值</code>复制到<code>栈中</code> 读的是<code>栈内存</code>（效率比读共享内存更高）  <code>比XXX.MAX_VALUE小的值放到栈中</code></li>\n<li>读的是<code>常量池</code>中的内容（效率比读共享内存更高）  <code>比XXX.MAX_VALUE大的值放到常量池中</code></li>\n</ul>\n</blockquote>\n<h4 id=\"安全的类\">安全的类</h4>\n<ul>\n<li>\n<p>（包装类、 String 、 BigDecimal 、BigInteger）都是不可变的，都是安全的</p>\n</li>\n<li>\n<p><code>String 串池机制</code></p>\n</li>\n<li>\n<p><code>BigDecimal      BigInteger</code></p>\n</li>\n<li>\n<p><code>没有任何成员变量的</code>类是线程安全的,又称为  <code>无状态的类是安全的</code></p>\n<ul>\n<li>因为成员变量保存的数据也可以称为状态信息，因此<code>没有成员变量</code>就称之为【<code>无状态</code>】</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>包装类的缓存：</p>\n<ul>\n<li><code>Byte, Short, Long</code> 缓存的范围都是 <code>-128~127</code></li>\n<li><code>Character </code>缓存的范围是 <code>0~127</code></li>\n<li><code>Integer</code>的默认范围是 <code>-128~127</code>，<code>最小值不能变</code>，但<code>最大值</code>可以通过调整虚拟机参数 <code> &quot;-Djava.lang.Integer.IntegerCache.high &quot;</code>来改变</li>\n<li><code>Boolean</code> 缓存了<code> TRUE</code> 和 <code>FALSE</code></li>\n</ul>\n</blockquote>\n<p>什么时候将导致用户态到内核态的转变</p>\n<ul>\n<li>上下文切换的时候，也就是在<code>synchroniezed</code>进行加锁的时候。</li>\n</ul>\n<h2 id=\"共享模型之使用工具\">共享模型之使用工具</h2>\n<h3 id=\"线程池-2\">线程池</h3>\n<p><code>池化技术</code>的思想主要是为了<code>减少</code>每次获取资源的消耗，<code>提高对资源的利用率</code>。</p>\n<p>线程池的好处：</p>\n<ul>\n<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>\n<li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>\n<li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>\n</ul>\n<h4 id=\"ThreadPoolExecutor\">ThreadPoolExecutor</h4>\n<h5 id=\"Executor-框架结构-主要由三大部分组成\"><strong>Executor 框架结构(主要由三大部分组成)</strong></h5>\n<ul>\n<li>\n<p>任务(<code>Runnable</code> /<code>Callable</code>)</p>\n<ul>\n<li>执行任务需要实现的 <code>Runnable</code> 接口 或 <code>Callable</code>接口。Runnable 接口或 Callable 接口<code>实现类</code>都可以被 <code>ThreadPoolExecutor</code> 或 <code>ScheduledThreadPoolExecutor</code> 执行。</li>\n</ul>\n</li>\n<li>\n<p>任务的执行(<code>Executor</code>)</p>\n<ul>\n<li>\n<p>任务执行机制的核心   接口 <code>Executor</code> ，以及继承自 <code>Executor</code> 接口的 <code>ExecutorService</code> 接口。</p>\n</li>\n<li>\n<p><code>ThreadPoolExecutor</code> 和 <code>ScheduledThreadPoolExecutor</code> 这两个关键类实现了 ExecutorService 接口。</p>\n<blockquote>\n<p>实际上我们需要更多关注的是 <code>ThreadPoolExecutor</code> 这个类，这个类在我们实际使用线程池的过程中，使用频率还是非常高的。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>\n<p>异步计算的结果(<code>Future</code>)</p>\n<ul>\n<li>Future 接口以及 <code>Future</code> 接口的实现类 <code>FutureTask</code> 类都可以代表异步计算的结果。</li>\n<li>随后会把 Runnable接口 或 Callable 接口 的实现类提交给 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行(调用 <code>submit()</code> 方法时会返回一个 <code>FutureTask </code>对象）</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305302032937.png\" alt=\"image-20230530203252862\" style=\"zoom:33%;\">\n<ul>\n<li>流程\n<ul>\n<li>主线程首先要创建实现 Runnable 或者 Callable 接口的任务对象。</li>\n<li>把创建完成的 ，实现了 Runnable/Callable接口的 对象直接交给 ExecutorService 执行: <code>ExecutorService.execute（Runnable command）</code>）或者也可以把 <code>Runnable</code> 对象或<code>Callable</code> 对象提交给 <code>ExecutorService</code> 执行（<code>ExecutorService.submit（Runnable task）</code>或 <code>ExecutorService.submit（Callable &lt;T&gt; task）</code>）。</li>\n<li>如果执行<code> ExecutorService.submit（…）</code>，ExecutorService 将返回一个实现Future接口的对象（注意：执行 <code>execute()</code>方法和 <code>submit()</code>方法的区别，<code>submit()</code>会返回一个 <code>FutureTask</code> 对象）。</li>\n<li>最后，主线程可以执行<code> FutureTask.get()</code>方法来等待任务执行完成。主线程也可以执行<code> FutureTask.cancel（boolean mayInterruptIfRunning）</code>来取消此任务的执行</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"线程池状态\">线程池状态</h5>\n<p><code>ThreadPoolExecutor </code>使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量</p>\n<table>\n<thead>\n<tr>\n<th><strong>状态名</strong></th>\n<th><strong>高3位</strong></th>\n<th><strong>接收新任务</strong></th>\n<th><strong>处理阻塞队列任务</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>RUNNING</td>\n<td>111</td>\n<td>Y</td>\n<td>Y</td>\n<td>-</td>\n</tr>\n<tr>\n<td>SHUTDOWN</td>\n<td>000</td>\n<td>N</td>\n<td>Y</td>\n<td>不会接收<code>新</code>任务，但会<code>处理</code>阻塞队列剩余任务</td>\n</tr>\n<tr>\n<td>STOP</td>\n<td>001</td>\n<td>N</td>\n<td>N</td>\n<td>会<code>中断</code>正在执行的任务，并<code>抛弃</code>阻塞队列任务</td>\n</tr>\n<tr>\n<td>TIDYING</td>\n<td>010</td>\n<td>-</td>\n<td>-</td>\n<td>任务全执行完毕，活动线程为<code> 0</code> 即将进入<code>终结</code></td>\n</tr>\n<tr>\n<td>TERMINATED</td>\n<td>011</td>\n<td>-</td>\n<td>-</td>\n<td>终结状态</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"构造方法\">构造方法</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ThreadPoolExecutor</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">    </span></span><br><span class=\"line\"><span class=\"params\">     <span class=\"type\">int</span> corePoolSize, //corePoolSize 核心线程数目 (最多保留的线程数)</span></span><br><span class=\"line\">\t <span class=\"type\">int</span> maximumPoolSize, <span class=\"comment\">//maximumPoolSize 最大线程数目(核心线程数加上救急线程数)</span></span><br><span class=\"line\"> \t <span class=\"type\">long</span> keepAliveTime,  <span class=\"comment\">//keepAliveTime 救急线程的生存时间(核心线程没有生存时间这个东西，核心线程会一直运行) </span></span><br><span class=\"line\"> \t TimeUnit unit,<span class=\"comment\">//unit 时间单位 - 针对救急线程</span></span><br><span class=\"line\"> \t BlockingQueue&lt;Runnable&gt; workQueue, <span class=\"comment\">//workQueue 阻塞队列</span></span><br><span class=\"line\"> \t ThreadFactory threadFactory,<span class=\"comment\">//threadFactory 线程工厂 - 可以为线程创建时起个好名字</span></span><br><span class=\"line\">\t RejectedExecutionHandler handler)&#123;<span class=\"comment\">//handler 拒绝策略</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>创建流程</p>\n<ul>\n<li>线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务。</li>\n</ul>\n</li>\n<li>\n<p>当线程数达到 corePoolSize 并没有线程空闲，这时再加入任务，新加的任务会被加入workQueue 队列排队，直到有空闲的线程。</p>\n</li>\n<li>\n<p>如果队列选择了有界队列，那么任务超过了队列大小时，会创建<code>maximumPoolSize - corePoolSize</code>数目的救急线程来<code>救急</code>。</p>\n</li>\n<li>\n<p>如果线程到达 maximumPoolSize 仍然有新任务这时会执行拒绝策略。拒绝策略<code>jdk</code>提供了下面的前4 种实现</p>\n<ul>\n<li>ThreadPoolExecutor.<code>AbortPolicy</code>让调用者<code>抛出 RejectedExecutionException 异常</code>，这是<code>默认策略</code></li>\n<li>ThreadPoolExecutor.<code>CallerRunsPolicy </code>让调用者<code>运行任务</code></li>\n<li>ThreadPoolExecutor.<code>DiscardPolicy </code>放弃本次任务</li>\n<li>ThreadPoolExecutor.<code>DiscardOldestPolicy 放弃队列中最早的任务</code>，本任务取而代之</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>注意：</p>\n<p>当高峰过去后，超过corePoolSize 的救急线程如果一段时间没有任务做，需要结束,节省资源，这个时间由<code>keepAliveTime</code> 和 <code>unit</code> 来控制。</p>\n</blockquote>\n<blockquote>\n<p><code>JDK Executors 类</code>中提供了众多<code>工厂方法</code>来创建各种用途的线程池</p>\n<p><code>Executors</code> 是<code>Executor</code> 框架的工具类</p>\n</blockquote>\n<h5 id=\"newFixedThreadPool\">newFixedThreadPool</h5>\n<ul>\n<li>\n<p>固定大小的线程池:使用了<code>默认的线程工厂和拒绝策略!</code></p>\n</li>\n<li>\n<p><span style=\"color:red\">特点</span></p>\n<ul>\n<li>核心线程数 == 最大线程数（<code>没有救急线程</code>被创建），因此也无需设置超时时间</li>\n<li>阻塞队列是<code>无界</code>的，可以放任意数量的任务</li>\n<li>适用于<code>任务量已知</code>，相对耗时的任务</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"newCachedThreadPool\">newCachedThreadPool</h5>\n<ul>\n<li>带有缓冲功能的线程池</li>\n<li><span style=\"color:red\">特点</span>\n<ul>\n<li>\n<p>核心线程数是<code> 0</code>， 最大线程数是 <code>Integer.MAX_VALUE</code>，救急线程的空闲生存时间是 <code>60s</code>，意味着</p>\n<ol>\n<li>全部都是<code>救急线程</code>（60s 后可以回收）</li>\n<li>救急线程可以无限创建</li>\n</ol>\n</li>\n<li>\n<p>队列采用了 <code>SynchronousQueue</code> 实现特点是，它没有容量，没有线程来取，是放不进去的</p>\n</li>\n<li>\n<p>整个线程池中 线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟（60s）后释放线程。</p>\n</li>\n<li>\n<p>适合任务数比较密集，但每个任务执行时间较短的情况</p>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"newSingleThreadExecutor\">newSingleThreadExecutor</h5>\n<ul>\n<li>\n<p>是单线程的</p>\n</li>\n<li>\n<p>使用场景：</p>\n<p><code>希望多个任务排队执行</code>。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程也不会被释放。</p>\n</li>\n<li>\n<p>特点</p>\n<p><code>Executors.newSingleThreadExecutor() </code>线程个数始终为1，不能修改，<code>FinalizableDelegatedExecutorService</code> 应用的是<code>装饰器模式</code>，只对外暴露了<code>ExecutorService</code>接口，因此不能调用<code>ThreadPoolExecutor</code>中<code>特有的方法</code>,返回的是一个经过包装之后的对象，不能再改</p>\n</li>\n<li>\n<p>区别：</p>\n<ol>\n<li>\n<p>和<code>自己创建单线程执行任务</code>的区别：</p>\n<p>​\t自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施</p>\n<p>​\t而线程池还会新建一个线程，保证池的正常工作</p>\n</li>\n</ol>\n</li>\n</ul>\n<ol start=\"2\">\n<li>\n<p>和<code>Executors.newFixedThreadPool(1) </code>初始时为<code>1</code>时的区别：</p>\n<p>​\t<code>Executors.newFixedThreadPool(1) </code>初始时为1，以后还可以修改，对外暴露的是 <code>ThreadPoolExecutor</code> 对象，可以<code>强转</code>后调用 <code>setCorePoolSize </code>等方法进行修改</p>\n</li>\n</ol>\n<h5 id=\"ScheduledThreadPoolExecutor\"><code>ScheduledThreadPoolExecutor</code></h5>\n<ul>\n<li>创建具有任务调度功能的线程池</li>\n<li>线程数固定，任务数多于线程数时，会放入无界队列排队。</li>\n<li>任务执行完毕，这些线程也不会被释放。</li>\n<li>用来执行<code>延迟</code>或<code>反复执行</code>的任务。</li>\n</ul>\n<h5 id=\"弊端\">弊端</h5>\n<p>Executors 返回线程池对象的<code>弊端</code>如下：</p>\n<ul>\n<li>FixedThreadPool 和 SingleThreadExecutor ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM。</li>\n<li>CachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</li>\n</ul>\n<p>应该怎么做：</p>\n<ul>\n<li>使用有界队列，控制线程创建数量。</li>\n</ul>\n<p>除了避免 OOM 的原因之外，不推荐使用 <code>Executors</code>提供的<code>两种快捷的线程池</code>的原因还有：</p>\n<ol>\n<li>实际使用中需要根据自己机器的性能、业务场景来手动配置线程池的参数比如核心线程数、使用的任务队列、饱和策略等等。</li>\n<li>我们应该<code>显示地给我们的线程池命名</code>，这样<code>有助于我们定位问题</code>。</li>\n</ol>\n<h5 id=\"执行任务\">执行任务</h5>\n<p><code>void execute(Runnable command);</code></p>\n<h5 id=\"提交任务\">提交任务</h5>\n<p><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</code></p>\n<ul>\n<li>提交任务 task，用返回值 Future 获得任务执行结果</li>\n<li>Future的原理\n<ul>\n<li>利用保护性暂停模式 来接受返回结果的 <code>Future</code> 的实现类  <code>FutureTask</code></li>\n<li>主线程可以执行 <code>FutureTask.get()</code> 方法来等待任务执行完成</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"关闭线程池\">关闭线程池</h5>\n<h6 id=\"shutdown\"><code>shutdown()</code></h6>\n<ul>\n<li>线程池状态变为<code> SHUTDOWN</code></li>\n<li>特点：\n<ul>\n<li>不会接收新任务</li>\n<li>但已提交任务会<code>执行完</code>，包括等待队列里面的</li>\n<li>此方法不会阻塞<code>调用线程的执行</code></li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><code>shutdown()</code>并不会<code>取消</code>正在执行的任务  和 已经在<code>任务队列</code>中等待的任务，但是此时再提交一个任务的时候就会<code>报错，执行拒绝策略</code></p>\n<p>也不会阻塞（等待）主线程之外的其他任务执行，要等待的话要执行<code>awaitTermination(含参数)</code>方法</p>\n</blockquote>\n<h6 id=\"shutdownNow\"><code>shutdownNow()</code></h6>\n<ul>\n<li>\n<p>线程池状态变为 STOP</p>\n</li>\n<li>\n<p>不会接收新任务</p>\n</li>\n<li>\n<p>会将队列中的任务返回</p>\n</li>\n<li>\n<p>并用 <code>interrupt</code> 的方式中断正在执行的任务</p>\n</li>\n</ul>\n<h6 id=\"其他方法\">其他方法</h6>\n<p><code>isShutdown()</code>            不在 <code>RUNNING</code> 状态的线程池，此方法就返回 <code>true</code></p>\n<p><code>isTerminated()</code>         线程池状态是否是 TERMINATED</p>\n<p><code>awaitTermination(long timeout, TimeUnit unit) </code>      调用 shutdown 后，由于调用使线程结束，线程的方法是异步的并不会等待所有任务运行结束就返回，因此如果它想在线程池 <code>TERMINATED</code> 后做些其它事情，可以利用此方法等待</p>\n<h5 id=\"创建多大的线程池合适\">创建多大的线程池合适?</h5>\n<ul>\n<li>\n<p><code>过小</code>会导致程序不能充分地利用系统资源、容易导致饥饿，</p>\n</li>\n<li>\n<p><code>过大</code>会导致更多的线程上下文切换，占用更多内存</p>\n</li>\n</ul>\n<h6 id=\"CPU-密集型运算\">CPU 密集型运算</h6>\n<p>通常采用<code> cpu 核数 + 1</code> 能够实现<code>最优的</code> CPU 利用率，+1 是保证当线程由于<code>页缺失故障（操作系统）或其它原因导致暂停</code>时，额外的这个线程就能顶上去，保证 <code>CPU 时钟周期</code>不被浪费</p>\n<h6 id=\"I-O-密集型运算\">I/O 密集型运算</h6>\n<p>CPU 不总是处于繁忙状态，【例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I/O 操作时、远程RPC 调用时，包括进行数据库操作时，】这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。</p>\n<p>经验公式如下：线程数 = <code>核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间</code></p>\n<ul>\n<li>例如 4 核 CPU 计算时间是 50% ，其它等待时间是 50%，期望 cpu 被 100% 利用，套用公式 <code>4 * 100% * 100% / 50% = 8</code></li>\n<li>例如 4 核 CPU 计算时间是 10% ，其它等待时间是 90%，期望 cpu 被 100% 利用，套用公式 <code>4 * 100% * 100% / 10% = 40</code></li>\n</ul>\n<h5 id=\"任务调度线程池\">任务调度线程池</h5>\n<p>在『<code>任务调度线程池</code>』功能加入之前，可以使用<code>java.util.Timer</code>来实现<code>定时功能</code></p>\n<blockquote>\n<p><code>定时功能</code>的两种实现方式</p>\n</blockquote>\n<h6 id=\"Timer\"><code>Timer </code></h6>\n<ul>\n<li>优点：在于简单易用</li>\n<li>缺点：但由于所有任务都是由同一个线程来调度，因此所有任务都是<code>串行</code>执行的，同一时间只能有一个任务在执行，前一个<br>\n任务的<code>延迟或异常</code>都将会影响到之后的任务。</li>\n</ul>\n<h6 id=\"任务调度线程池-2\"><code>任务调度线程池</code></h6>\n<p><code>newScheduledThreadPool()方法</code> 创建具有任务调度功能的线程池</p>\n<ul>\n<li>\n<p>可以改变<code>newScheduledThreadPool(&gt;1的数)</code>大小进行控制<code>并行</code>    如果是<code>(1)</code>的话，仍然是<code>串行</code></p>\n</li>\n<li>\n<p>可以执行定时任务</p>\n<ul>\n<li>使用  <code>scheduleAtFixedRate</code>方法</li>\n<li>使用  <code>scheduleWithFixedDelay</code>方法</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"正确处理执行任务异常\">正确处理执行任务异常</h5>\n<p>可以发现，如果线程池中的线程执行任务时，如果任务抛出了异常，默认是<code>中断</code>执行该任务<code>而不是抛出</code>异常或者<code>打印</code>异常信息。</p>\n<ul>\n<li>方法1：主动捉异常（<code>try-catch 主动捕获异常</code>）</li>\n<li>方法2：使用 <code>Future</code>，错误信息都被封装进<code>submit</code>方法的返回方法中！&lt;普通线程池 + Runnable接收结果 +Future获取结果 &gt;</li>\n</ul>\n<h5 id=\"Tomcat线程池\">Tomcat线程池</h5>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305280049172.png\" alt=\"image-20230522122314203\" style=\"zoom:50%;\">\n<ol>\n<li>LimitLatch 用来限流，可以控制最大连接个数，类似<code>J.U.C</code>中的 <code>Semaphore</code> 后面再讲</li>\n<li><code>Acceptor</code> 只负责【接收新的 socket 连接】</li>\n<li>Poller 只负责监听 socket channel 是否有【可读的<code>I/O</code>事件】</li>\n<li>一旦可读，封装一个任务对象（<code>socketProcessor</code>），提交给 <code>Executor</code> 线程池处理</li>\n<li><code>Executor</code> 线程池中的工作线程最终负责【处理请求】</li>\n</ol>\n<p>Tomcat 线程池扩展了 <code>ThreadPoolExecutor</code>，行为稍有不同；如果总线程数达到 <code>maximumPoolSize</code>，这时不会立刻抛 <code>RejectedExecutionException</code> 异常，而是再次尝试将任务放入队列，如果还失败，才抛出 <code>RejectedExecutionException</code> 异常</p>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305302216791.png\" alt></p>\n<h4 id=\"Fork-Join【合并-拆分】\">Fork/Join【合并  拆分】</h4>\n<ul>\n<li>\n<p>是一种<code> 新的线程池</code>实现，它体现的是一种<code>分治思想</code>，适用于能够进行<code>任务拆分</code>的 <code>cpu 密集型运算</code></p>\n</li>\n<li>\n<p>任务拆分:</p>\n<ul>\n<li>是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。其实就是分治的思想</li>\n</ul>\n</li>\n<li>\n<p><code>Fork/Join </code>在分治的基础上加入了多线程，可以把每个任务的<code>分解和合并</code>交给<code>不同的线程</code>来完成，进一步<code>提升了运算效率</code></p>\n</li>\n<li>\n<p><code>Fork/Join </code> <code>默认</code>会创建与 cpu 核心数<code>大小相同</code>的线程池</p>\n</li>\n</ul>\n<blockquote>\n<p>使用上：</p>\n<p>​\t提交给 Fork/Join 线程池的任务需要继承 RecursiveTask（有返回值）或 RecursiveAction（没有返回值）</p>\n<p>​\t<code>new ForkJoinPool(n)</code></p>\n</blockquote>\n<h3 id=\"JUC\"><code>JUC</code></h3>\n<h4 id=\"AQS\"><code>AQS</code></h4>\n<ul>\n<li>\n<p>全称是<code> AbstractQueuedSynchronizer</code>，是<code>阻塞式锁和相关的同步器工具的框架</code>  是一个父类</p>\n</li>\n<li>\n<p>特点：</p>\n<ol>\n<li>用 <code>state </code>属性来表示资源的状态（分<code>独占模式和共享模式</code>），子类需要定义如何维护这个状态，控制如何<code>获取锁和释放锁</code>\n<ol>\n<li><code>getState</code> - <code>获取 state 状态</code></li>\n<li><code>setState</code> - <code>设置 </code>state 状态</li>\n<li><code>compareAndSetState</code> - <code>cas </code>机制设置 state 状态</li>\n<li><code>独占</code>模式是<code>只有一个线程</code>能够访问资源，而<code>共享</code>模式可以允许<code>多个线程访问资源</code></li>\n</ol>\n</li>\n<li>提供了基于 <code>FIFO</code> 的等待队列，类似于 <code>Monitor</code> 的 <code>EntryList</code></li>\n<li><code>条件变量</code>来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet</li>\n</ol>\n</li>\n<li>\n<p>子类主要实现这样一些方法</p>\n<ul>\n<li>\n<p><code>tryAcquire</code>                          如果获取锁失败,入队, 可以<code>选择阻塞</code>当前线程     使用 <code>park unpark</code></p>\n</li>\n<li>\n<p>``tryRelease`                        如果释放锁成功,让阻塞线程恢复运行</p>\n</li>\n<li>\n<p><code>tryAcquireShared</code></p>\n</li>\n<li>\n<p><code>tryReleaseShared</code></p>\n</li>\n<li>\n<p><code>isHeldExclusively</code></p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"ReentrantLock-原理\"><code>ReentrantLock 原理</code></h4>\n<blockquote>\n<p>ReentrantLock提供了两个同步器，实现公平锁和非公平锁，<code>默认是</code>非公平锁</p>\n</blockquote>\n<h5 id=\"非公平锁实现原理\">==非公平锁实现原理==</h5>\n<h5 id=\"可重入的原理\">==可重入的原理==</h5>\n<h5 id=\"可打断原理\">==可打断原理==</h5>\n<blockquote>\n<p>不可打断模式：在此模式下，即使它被打断，仍会驻留在 AQS 队列中，一直要等到获得锁后方能得知自己被打断了</p>\n</blockquote>\n<h5 id=\"公平锁实现原理\">==公平锁实现原理==</h5>\n<h5 id=\"条件变量实现原理\">==条件变量实现原理==</h5>\n<h4 id=\"读写锁ReentrantReadWriteLock\">读写锁<code>ReentrantReadWriteLock()</code></h4>\n<blockquote>\n<p>注意</p>\n</blockquote>\n<ol>\n<li>\n<p>读锁不支持条件变量</p>\n</li>\n<li>\n<p>重入时不支持升级：即持<code>读锁</code>有的情况下去获取<code>写锁</code>，会导致获取<code>写锁永久等待</code></p>\n</li>\n<li>\n<p>重入时降级支持：即持有<code>写锁</code>的情况下去获取<code>读锁</code></p>\n</li>\n</ol>\n<p>当读操作远远高于写操作时，这时候使用读写锁让读-读可以并发，提高性能。读-写，写-写都是相互互斥的！</p>\n<p>自定义一个数据容器类，内部分别使用<code>读锁保护数据的read()方法</code>，<code>写锁保护数据的write()方法</code></p>\n<h5 id=\"使用\">使用:</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">DataContainer</span> <span class=\"variable\">dataContainer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DataContainer</span>();</span><br><span class=\"line\">dataContainer.read();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">DataContainer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">ReentrantReadWriteLock</span> <span class=\"variable\">rw</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantReadWriteLock</span>();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ReentrantReadWriteLock.<span class=\"type\">ReadLock</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> rw.readLock();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ReentrantReadWriteLock.<span class=\"type\">WriteLock</span> <span class=\"variable\">w</span> <span class=\"operator\">=</span> rw.writeLock();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">read</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">write</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">         ...</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"读写锁原理\">==读写锁原理==</h5>\n<h5 id=\"戳StampedLock\">戳<code>StampedLock</code></h5>\n<ul>\n<li>为了进一步优化读性能，它的特点是在使用读锁、写锁时都必须配合【戳】使用</li>\n</ul>\n<p>加解锁（读、写）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">stamp</span> <span class=\"operator\">=</span> lock.readLock();</span><br><span class=\"line\">lock.unlockRead(stamp);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">stamp</span> <span class=\"operator\">=</span> lock.writeLock();</span><br><span class=\"line\">lock.unlockWrite(stamp);</span><br></pre></td></tr></table></figure>\n<p>乐观读，StampedLock 支持 tryOptimisticRead() 方法（乐观读），</p>\n<ul>\n<li><code>读取</code>完毕后需要做一次 <code>戳校验</code> 如果校验<code>通过</code>，表示这期间确实没有<code>写操作</code>，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据安全。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">stamp</span> <span class=\"operator\">=</span> lock.tryOptimisticRead();</span><br><span class=\"line\"><span class=\"comment\">// 验戳</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(!lock.validate(stamp))&#123;</span><br><span class=\"line\"> <span class=\"comment\">// 锁升级</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>和读写锁一样</p>\n</blockquote>\n<p>利用提供一个 数据容器类 内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法</p>\n<blockquote>\n<p>注意：</p>\n</blockquote>\n<ul>\n<li>StampedLock 不支持条件变量</li>\n<li>StampedLock 不支持可重入</li>\n</ul>\n<h4 id=\"Semaphore信号量\"><code>Semaphore</code>信号量</h4>\n<ul>\n<li>\n<p>用来限制能<code>同时</code>访问<code>共享资源</code>的<code>线程上限</code>。</p>\n<ul>\n<li><code>Semaphore semaphore = new Semaphore(3);</code>    创建<code>semaphore</code>对象   访问共享资源的数量<code>3</code></li>\n</ul>\n</li>\n<li>\n<p>获取许可  <code>semaphore.acquire();</code></p>\n</li>\n<li>\n<p>释放许可   <code>semaphore.release();</code></p>\n</li>\n</ul>\n<h5 id=\"应用\">应用</h5>\n<ul>\n<li>\n<p>使用 Semaphore 限流，</p>\n<ul>\n<li>在访问高峰期时，让请求线程阻塞，高峰期过去再释放许可，当然它<code>只适合限制单机线程</code>数量，并且<code>仅是限制线程数</code>，而<code>不是</code>限制<code>资源</code>数（例如连接数，请对比 <code>Tomcat LimitLatch</code> 的实现）</li>\n</ul>\n</li>\n<li>\n<p>用 Semaphore 实现简单连接池，对比『享元模式』下的实现（用wait notify），性能和可读性显然更好，</p>\n</li>\n</ul>\n<p>==原理==</p>\n<h4 id=\"CountdownLatch-倒计时锁\"><code>CountdownLatch</code> 倒计时锁</h4>\n<ul>\n<li>用来进行线程同步协作，等待所有线程<code>完成倒计时</code></li>\n<li><code>CountDownLatch</code>允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</li>\n</ul>\n<h5 id=\"原理描述\">原理描述</h5>\n<ul>\n<li>\n<p><code>CountDownLatch</code>是共享锁的一种实现,它默认构造 AQS 的 state 值为 count。</p>\n</li>\n<li>\n<p>当线程使用<code>countDown</code>方法时,其实使用了<code>tryReleaseShared</code>方法以<code>CAS</code>的操作来<code>减少state</code>,直至<code>state为0</code>就代表所有的线程都调用了<code>countDown</code>方法。</p>\n</li>\n<li>\n<p>当调用<code>await</code>方法的时候，如果<code>state</code>不为0，就代表仍然有线程没有调用<code>countDown</code>方法，那么就把已经调用过<code>countDown</code>的线程都放入<code>阻塞队列Park</code>,并自旋CAS判断<code>state  == 0</code>，直至最后一个线程调用了<code>countDown</code>，使得<code>state == 0</code>，于是阻塞的线程便判断成功，全部往下执行。</p>\n</li>\n</ul>\n<h4 id=\"CyclicBarrier循环栅栏\"><code>CyclicBarrier</code>循环栅栏</h4>\n<ul>\n<li>用来进行线程协作，等待线程满足某个计数。</li>\n<li>构造时设置『计数个数』，每个线程执行到某个需要“同步”的时刻调用 await() 方法进行等待，当等待的线程数满足『计数个数』时，继续执行。</li>\n<li>跟CountdownLatch一样，但这个可以<code>重用</code></li>\n</ul>\n<p>解决了： <code>new CountDownLatch(2);</code>  无法重用，每次循环都会创建 ，浪费资源 的问题</p>\n<hr>\n<h4 id=\"线程安全集合类概述\"><code>线程安全集合类</code>概述</h4>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305302332409.png\" alt></p>\n<p>线程安全集合类可以分为三大类：</p>\n<ul>\n<li>\n<p>遗留的<code>线程安全</code>集合如<code> Hashtable ， Vector</code></p>\n</li>\n<li>\n<p>使用 <code>Collections 装饰</code>的线程安全集合，如：</p>\n<ul>\n<li>Collections.synchronizedCollection</li>\n<li><code>Collections.synchronizedList</code>  :    保证 <code>list</code> 是同步线程安全的</li>\n<li>Collections.synchronizedMap</li>\n<li>Collections.synchronizedSet</li>\n<li>Collections.synchronizedNavigableMap</li>\n<li>Collections.synchronizedNavigableSet</li>\n<li>Collections.synchronizedSortedMap</li>\n<li>Collections.synchronizedSortedSet</li>\n</ul>\n</li>\n</ul>\n<p><code>java.util.concurrent.* </code> 下的线程安全集合类，可以发现它们有规律，里面包含三类关键词：<code>Blocking、CopyOnWrite、Concurrent</code></p>\n<ul>\n<li><code>Blocking</code> 大部分实现<code>基于锁</code>，并提供用来<code>阻塞的方法</code></li>\n<li><code>CopyOnWrite</code> 之类容器修改开销相对较重,用于<code>读多写少</code>的时候</li>\n<li><code>Concurrent </code>类型的容器\n<ul>\n<li>内部很多操作使用 <code>cas </code>优化，一般可以提供较高吞吐量</li>\n<li>弱一致性\n<ul>\n<li>遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的</li>\n<li>求大小弱一致性，size 操作未必是 100% 准确</li>\n<li>读取弱一致性</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>遍历时如果发生了修改，对于非安全容器来讲，使用 <strong>fail-fast</strong> 机制也就是让遍历立刻失败，抛出<code>ConcurrentModifificationException</code>，不再继续遍历</p>\n</blockquote>\n<blockquote>\n<p>注意： JDK7 的<code>HashMap</code>插入新节点 是<code>头插法</code> 但是扩容的时候出现<code>并发死链</code>的问题</p>\n<ul>\n<li>\n<p>查看源码，是因为在多线程环境下使用了<code>非线程安全的 map 集合</code></p>\n</li>\n<li>\n<p>JDK 8 虽然将<code>扩容算法</code>做了调整，<code>不再将元素加入链表头</code>(<code>尾插法</code>)（而是保持与扩容前一样的顺序），但仍<code>不意味着能够在多线程环境下能够安全扩容</code>，还会出现其它问题（如扩容丢数据）</p>\n</li>\n</ul>\n</blockquote>\n<h5 id=\"ConcurrentHashMap\"><code>ConcurrentHashMap</code></h5>\n<h6 id=\"JDK7-ConcurrentHashMap\"><code>JDK7  ConcurrentHashMap</code></h6>\n<p>它维护了一个 segment 数组，每个 segment 对应一把锁</p>\n<ul>\n<li>\n<p>优点：如果多个线程访问不同的 segment，实际是没有冲突的，这与 jdk8 中是类似的</p>\n</li>\n<li>\n<p>缺点：Segments 数组默认大小为16，这个容量初始化指定后就不能改变了，并且不是懒惰初始化</p>\n</li>\n</ul>\n<h6 id=\"JDK-8-ConcurrentHashMap\"><code>JDK 8 ConcurrentHashMap</code></h6>\n<p><strong>Java 8</strong> 数组（Node） +（ 链表 Node | 红黑树 TreeNode ）</p>\n<p>以下数组简称（table），链表简称（bin）</p>\n<ul>\n<li>初始化，使用 cas 来保证并发安全，懒惰初始化 table</li>\n<li>树化，当 table.length &lt; 64 时，先尝试扩容，超过 64 时，并且 bin.length &gt; 8 时，会将链表树化，树化过程会用 synchronized 锁住链表头</li>\n<li>put，如果该 bin 尚未创建，只需要使用 cas 创建 bin；如果已经有了，锁住链表头进行后续 put 操作，元素添加至 bin 的尾部</li>\n<li>get，无锁操作仅需要保证可见性，扩容过程中 get 操作拿到的是 ForwardingNode 它会让 get 操作在新table 进行搜索</li>\n<li>扩容，扩容时以 bin 为单位进行，需要对 bin 进行 synchronized，但这时妙的是其它竞争线程也不是无事可做，它们会帮助把其它 bin 进行扩容，扩容时平均只有 1/6 的节点会把复制到新 table 中</li>\n<li>size，元素个数保存在 baseCount 中，并发时的个数变动保存在 CounterCell[] 当中。最后统计数量时累加即可</li>\n</ul>\n<h5 id=\"LinkedBlockingQueue阻塞队列\"><code>LinkedBlockingQueue</code>阻塞队列</h5>\n<p>简单的<code>性能对比</code></p>\n<p><code> LinkedBlockingQueue</code>   VS <code>ArrayBlockingQueue</code></p>\n<ul>\n<li>Linked 支持有界，Array 强制有界</li>\n<li>Linked 实现是链表，Array 实现是数组</li>\n<li>Linked 是懒惰的，而 Array 需要提前初始化 Node 数组</li>\n<li>Linked 每次入队会生成新 Node，而 Array 的 Node 是提前创建好的</li>\n<li>Linked 两把锁，Array 一把锁</li>\n</ul>\n<h5 id=\"ConcurrentLinkedQueue并发队列\"><code>ConcurrentLinkedQueue</code>并发队列</h5>\n<p><code>ConcurrentLinkedQueue</code> 的设计与 <code>LinkedBlockingQueue</code> 非常像</p>\n<ul>\n<li>\n<p>也是两把【锁】，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行</p>\n</li>\n<li>\n<p><code>dummy</code> 节点的引入让两把【锁】将来锁住的是不同对象，避免竞争</p>\n</li>\n<li>\n<p>只是这【锁】使用了<code>cas</code>来实现</p>\n</li>\n</ul>\n<p>事实上，<code>ConcurrentLinkedQueue</code> 应用还是非常广泛的</p>\n<h5 id=\"CopyOnWriteArrayList\"><code>CopyOnWriteArrayList</code></h5>\n<p><font color=\"red\">特点</font></p>\n<p>它相当于线程安全版的 <code>ArrayList</code>。和 <code>ArrayList</code> 一样，它是个<code>可变数组</code>；但是和<code>ArrayList</code> 不同的时，它具有以下特性：</p>\n<ul>\n<li>\n<p>它最适合于具有以下特征的<code>应用程序</code>：List 大小通常保持很小，<code>只读</code>操作多于<code>可变</code>操作，需要在<code>遍历期间防止线程间的冲突</code>。</p>\n</li>\n<li>\n<p>它是线程安全的。</p>\n</li>\n<li>\n<p>因为通常需要复制整个基础数组，所以可变操作（add()、set() 和 remove() 等等）的开销很大。</p>\n</li>\n<li>\n<p>迭代器支持 <code>hasNext(), next()</code>等<code>不可变</code>操作，但<code>不支持可变 remove()</code>等操作。</p>\n</li>\n<li>\n<p>使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器<code>依赖于不变的数组快照</code>。</p>\n</li>\n</ul>\n<p>==解决思路：==</p>\n<ol>\n<li>\n<p>独占锁效率低：采用读写分离思想解决</p>\n</li>\n<li>\n<p>写线程获取到锁，其他写线程阻塞</p>\n</li>\n<li>\n<p>采用<code>复制的思想</code>：当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行 <code>Copy</code>，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，<code>再将原容器的引用指向新的容器</code>。</p>\n</li>\n</ol>\n<p><strong>这时候会抛出来一个新的问题，也就是数据不一致的问题。如果写线程还没来得及写回内存，其他的线程就会读到了脏数据。</strong></p>\n<p>==<strong>这就是 CopyOnWriteArrayList 的思想和原理。就是拷贝一份。</strong>==</p>\n<p>底层实现采用了<code>写入时拷贝</code>的思想，<code>(写入)增删改操作</code>会将底层数组拷贝一份，更改操作在<code>新数组</code>上执行，这时不影响其它线程的<code>并发读，读写分离</code>。</p>\n<p>适合『读多写少』的应用场景,所有的<code>读操作</code>并未加锁</p>\n<p><font color=\"red\">特点</font></p>\n<ul>\n<li>\n<p>get弱一致性</p>\n<ul>\n<li>所有以  <code>current</code>   和 <code>CopyOnWrite</code>开头的集合类都是弱一致性的</li>\n</ul>\n</li>\n<li>\n<p>迭代器弱一致性</p>\n</li>\n</ul>\n<h5 id=\"原理-5\">原理</h5>\n<p><strong>基于动态数组的机制而言</strong></p>\n<p>o 它内部有个“<code>volatile</code> 数组”来保持数据。在“添加/修改/删除”数据时，都会新建一个数组，并将更新后的数据<code>拷贝到新建的数组中</code>，最后再将该</p>\n<p>新数组<code>赋值</code>给“<code>volatile</code> 数组”</p>\n<p>o <strong>由于它在“添加/修改/删除”数据时，都会新建数组，所以涉及到修改数据的操作，CopyOnWriteArrayList 效率很低；但是单单只是进行遍历查找的话，效率比较高。</strong></p>\n<p><strong>基于线程安全机制而言</strong></p>\n<p>o 通过 <code>volatile</code> 和<code>互斥锁</code>来实现的。</p>\n<p>o 通过<code>volatile</code> 数组来保存数据的。一个线程读取 volatile 数组时，总能看到其它线程对该 <code>volatile</code> 变量最后的写入；这样，通过 <code>volatile</code> 提供了<code>读取到的数据</code>总是<code>最新的</code>这个机制的保证。</p>\n<p>o 通过<code>互斥锁</code>来保护数据。在<code>添加/修改/删除</code>数据时，会先<code>获取互斥锁</code>, 修改完毕之后，先将数据更新到<code>volatile 数组</code>中，然后再<code>释放互斥锁</code>，就达到了保护数据的目的。</p>\n<p><font color=\"red\">注意</font></p>\n<p>不要觉得是弱一致性就一定不好</p>\n<ul>\n<li>\n<p>数据库的 MVCC 都是弱一致性的表现</p>\n</li>\n<li>\n<p>并发高和一致性是矛盾的，需要权衡</p>\n</li>\n</ul>\n<h2 id=\"Future\">Future</h2>\n<h3 id=\"Future接口\">Future接口</h3>\n<p>功能：</p>\n<ul>\n<li>判断任务是否完成；</li>\n<li>能够中断任务；</li>\n<li>能够获取任务执行结果。</li>\n</ul>\n<p>作用：</p>\n<ul>\n<li>定义了可以操作<code>异步任务</code>执行的方法，为主线程开一个分支任务，处理耗时的复杂业务</li>\n<li>可以继续执行自己的任务，并且能够异步的获取耗时的子线程的任务处理的结果或者任务的状态；就是说：如果<code>主线程</code>需要执行一个很耗时的计算任务，我们就可以通过<code>Future</code>把这个<code>任务放进异步线程</code>中执行，<code>主线程继续处理其他任务</code>或者<code>先行结束</code>，再通过<code>Future</code>获取计算结果。</li>\n<li><code>可以和线程池异步多线程任务配合</code>，能提高程序的运行效率。</li>\n</ul>\n<h3 id=\"实现类FutureTask异步任务\">实现类FutureTask异步任务</h3>\n<p>有三个特点：<code>多线程</code>,<code>异步任务</code>,<code>返回值</code></p>\n<ul>\n<li>实现 <code>Runnable接口(多线程)</code></li>\n<li>实现<code>Future接口(异步任务)</code></li>\n<li>构造时参数注入<code>Callable接口(有返回值)</code></li>\n</ul>\n<blockquote>\n<p><code>callable接口</code></p>\n<ul>\n<li><code>Callable</code>接口中定义了需要   有返回的任务   需要实现的方法</li>\n<li></li>\n</ul>\n</blockquote>\n<p><font color=\"red\">缺点：所以引出了CompleteableFuture</font></p>\n<ul>\n<li><code>get()阻塞</code>—一旦调用get()方法求结果，一旦调用，非要等到结果才会离开，不管你是否计算完成，都可能会<code>导致程序堵塞</code>。</li>\n<li><code>isDone()轮询</code>—轮询的方式会<code>耗费cpu资源</code>，如果想要异步获取结果，通常会以轮询的方式去获取结果，<code>尽量不发生阻塞</code>。</li>\n</ul>\n<blockquote>\n<p>小结：</p>\n<ul>\n<li><code>FutureTask</code>对于结果的获取不是很友好，只能通过阻塞或轮询的方式得到任务的结果。</li>\n<li>对于简单的业务场景使用Future完全可以.但最好使用<code>轮询</code>方式</li>\n</ul>\n</blockquote>\n<h3 id=\"CompletableFuture类\">CompletableFuture类</h3>\n<blockquote>\n<p><code>CompletableFuture</code>提供了一种观察者模式类似的机制，可以让任务执行完成后通知监听的一方。</p>\n<ul>\n<li>\n<p>可能<strong>代表一个明确完成的<code>Future</code></strong></p>\n</li>\n<li>\n<p>也可能<strong>代表一个完成阶段(<code>CompletionStage</code>)</strong> ， 它支持在计算完成以后触发一些函数或执行某些动作。</p>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li>\n<p>实现了<code>CompletionStage</code> 接口</p>\n<ul>\n<li>\n<p><code>CompletionStage</code>代表异步计算过程中的某一个阶段，一个阶段完成以后可能会触发另外一个阶段。</p>\n</li>\n<li>\n<p>一个阶段的执行可能是 由单个阶段的完成触发，也可能是由多个阶段一起触发</p>\n</li>\n</ul>\n</li>\n<li>\n<p><code>CompletableFuture</code>可能代表一个明确完成的<code>Future</code>，也可能代表一个<code>完成阶段</code>,支持在计算完成之后触发某些动作</p>\n</li>\n<li>\n<p>CompletableFuture<code>减少阻塞和轮询</code>，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。</p>\n</li>\n</ul>\n<p>优点</p>\n<ul>\n<li>异步任务<strong>结束</strong>时，会<code>自动回调</code>某个对象的方法</li>\n<li>主线程设置好回调后，不用关心异步任务的执行，<code>异步任务之间可以顺序执行</code></li>\n<li>异步任务<strong>出错</strong>时，会<code>自动回调</code>某个对象的方法</li>\n</ul>\n<p>创建异步任务的四个静态方法</p>\n<ul>\n<li><code>runAsync(Runnable runnble)</code></li>\n<li><code>runAsync(Runnable runnble,Excutor excutor)</code></li>\n<li><code>supplyAsync(Supplier&lt;U&gt; supplier)</code></li>\n<li><code>supplyAsync(Supplier&lt;U&gt; supplier,Excutor excutor)</code></li>\n</ul>\n<p><code>runAsync</code> 没有返回值</p>\n<p><code>supplyAsync</code> 有返回值</p>\n<p>对于上述<code>Executor</code>参数说明：</p>\n<ul>\n<li>\n<p>若没有指定线程池（不带Executor的方法），则使用默认的<code>ForkJoinPoolcommonPool()</code>作为它的线程池</p>\n<p>==注意:默认线程池ForkJoin会在主线程执行完成时关闭,如果有任务正在使用该线程池那么可能不会出结果,就是说，一旦主线程关闭，那么completeFuture默认使用的线程池也会立即关闭==</p>\n</li>\n<li>\n<p>如果指定线程池(带Executor的方法），则使用我们自定义的 或者 特别指定的线程池执行异步代码</p>\n</li>\n</ul>\n<p><strong>join和get对比</strong></p>\n<p>功能几乎一样,区别在于编码时是否需要抛出异常</p>\n<ul>\n<li>\n<p><code>get()</code>方法会在编译期间<code>会</code>做异常的检查,因此需要抛出异常或者做异常处理</p>\n</li>\n<li>\n<p><code>join()</code>方法<code>不会</code>在编译期间会做异常的检查</p>\n</li>\n</ul>\n<blockquote>\n<p><strong>常见的函数式接口</strong></p>\n<table>\n<thead>\n<tr>\n<th>函数式接口名称</th>\n<th>方法名称</th>\n<th>参数</th>\n<th>返回值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Runnable</td>\n<td>run</td>\n<td>无参数</td>\n<td>无返回值</td>\n</tr>\n<tr>\n<td>Function</td>\n<td>apply</td>\n<td>1个参数</td>\n<td>有返回值</td>\n</tr>\n<tr>\n<td>Consume</td>\n<td>accept</td>\n<td>1个参数</td>\n<td>无返回值</td>\n</tr>\n<tr>\n<td>Supplier</td>\n<td>get</td>\n<td>没有参数</td>\n<td>有返回值</td>\n</tr>\n<tr>\n<td>Biconsumer</td>\n<td>accept</td>\n<td>2个参数</td>\n<td>无返回值</td>\n</tr>\n</tbody>\n</table>\n<p><strong>链式编程</strong></p>\n<p><code>@Accessors(chain = true)</code>开启链式编程,<strong>需要lombok</strong></p>\n<p><strong>常用方法</strong></p>\n <img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306051801838.png\" alt=\"image-20230605180142701\" style=\"zoom:50%;\">\n<ul>\n<li><code>getNow</code>相当于备用方案如果此时异步任务还没执行完成就使用<code>getNow</code>设置的默认值,如果完成了就是用任务返回值</li>\n<li>当调用<code>CompletableFuture.get()</code>被阻塞的时候,<code>complete</code>方法就是结束阻塞并<code>get()</code>获取设置的<code>complete</code>里面的值</li>\n<li><code>thenApply</code> 和<code>handle</code>都是对线程进行处理；</li>\n<li>但是<code>thenApply</code> 报异常后,之后的线程无法继续执行，<code>thenApply</code> 带一个参数即返回值</li>\n<li><code>handle</code> 报异常后,之后的线程可以继续执行，<code>handle</code>带两个参数多带一个异常</li>\n</ul>\n</blockquote>\n<h2 id=\"模式\">模式</h2>\n<h3 id=\"终止模式之两阶段终止模式\">终止模式之两阶段终止模式</h3>\n<p>T1线程“优雅”的终止T2,不是让t2 立即终止，”优雅”说的就是可以给T2线程有料理后事的时间处理一下后续的事件</p>\n<h5 id=\"方式一：就是使用-interrupt-进行终止\">方式一：就是使用  <code>interrupt()</code>进行终止</h5>\n<blockquote>\n<p>摒弃的方法：</p>\n<ul>\n<li><code>stop</code>方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会<code>释放锁</code>，<code>其它</code>线程将<code>永远无法获取锁</code></li>\n<li>使用System.exit(int)方法停l止线程     目的仅是停止一个线程，但这种做法会让<code>整个程序都停止</code></li>\n</ul>\n</blockquote>\n<p>思路：</p>\n<ul>\n<li>\n<p>线程的<code>isInterrupted()</code>方法可以取得线程的打断标记，</p>\n<ul>\n<li>\n<p>如果线程在睡眠<code>sleep</code>期间被打断，打断标记是不会变的，为false，但是<code>sleep</code>期间被打断会抛出异常，我们据此手动设置打断标记为<code>true</code>；</p>\n</li>\n<li>\n<p>如果是在程序正常运行期间被打断的，那么打断标记就被自动设置为<code>true</code>。随后进行手动停止处理后事</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305310003472.png\" alt=\"image-20230529202840882\" style=\"zoom: 50%;\">\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"方式二：使用volatile关键字\">方式二：使用<code>volatile关键字</code></h5>\n<blockquote>\n<p>此时只要将用于打断线程执行的变量用<code>volatile</code> 修饰即可,使得在打断的时候判断<code>变量的值</code>决定是否打断，而不是再去进行判断打断标记决定是否打断。</p>\n<p><code>而不再是</code>打断标记来实现两阶段终止模式</p>\n</blockquote>\n<h3 id=\"同步模式之保护性暂停\">同步模式之保护性暂停</h3>\n<blockquote>\n<p>单任务版本</p>\n</blockquote>\n<p>用在一个线程等待另一个线程的执行结果时，要点：</p>\n<ol>\n<li>\n<p>有一个结果需要从一个线程传递到另一个线程，让他们<code>关联</code>同一个<code> GuardedObject</code></p>\n</li>\n<li>\n<p>JDK 中，<code>join 的实现、Future 的实现</code>，采用的就是此模式</p>\n</li>\n<li>\n<p>因为要等待另一方的结果，因此归类到同步模式</p>\n<blockquote>\n<p>但是 如果有结果<code>不断</code>从一个线程到另一个线程那么可以使用消息队列（见生产者/消费者）</p>\n</blockquote>\n</li>\n</ol>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305310003150.png\" alt=\"image-20230521000134940\" style=\"zoom:33%;\">\n<p>相较于 <code>join</code>交互结果的好处：</p>\n<ul>\n<li><code>join</code>只能<code>等待另一个线程执行结束才</code>可以进行交互 ，而现在 执行传递结果的线程在完成之后还可以做些别的事</li>\n<li><code>join </code>等待结果的<code>变量</code>只能是全局的，现在可以是局部的<code> List&lt;String&gt;list = Downloader.download();</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">GuardedObject</span> <span class=\"variable\">object</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">GuardedObjectV2</span>();</span><br><span class=\"line\">    <span class=\"comment\">//t1等待结果</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt;&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//等待结果</span></span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;begin&quot;</span>)；</span><br><span class=\"line\">                <span class=\"comment\">// get得到结果</span></span><br><span class=\"line\">           <span class=\"type\">Object</span> <span class=\"variable\">response</span>  <span class=\"operator\">=</span>guardedObject.get(<span class=\"number\">2000</span>);</span><br><span class=\"line\">            Log.debug(<span class=\"string\">&quot;结果大小：&#123;&#125;&quot;</span>,response);</span><br><span class=\"line\">         &#125;,<span class=\"string\">&quot;t1&quot;</span>).start();</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//t2产生结果</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt;&#123;</span><br><span class=\"line\">        \tlog.debug(<span class=\"string\">&quot;begin&quot;</span>)；</span><br><span class=\"line\">            <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">             \tThread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                <span class=\"comment\">//传递结果</span></span><br><span class=\"line\">                guardedObject.complete(<span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>());</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">//虚假唤醒  guardedObject.complete(null);</span></span><br><span class=\"line\">            &#125;<span class=\"keyword\">catch</span> (IOException e)&#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;,<span class=\"string\">&quot;t2&quot;</span>).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">                   </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">GuardedObject</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object response;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//获取结果</span></span><br><span class=\"line\">    <span class=\"comment\">//timeout :最大等待时间</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">get</span><span class=\"params\">(<span class=\"type\">long</span> millis)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 1) 记录最初时间</span></span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">begin</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">            <span class=\"comment\">// 2) 已经经历的时间</span></span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">timePassed</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (response == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 4) 假设 millis 是 1000，结果在 400 时唤醒了，那么还有 600 要等</span></span><br><span class=\"line\">                <span class=\"type\">long</span> <span class=\"variable\">waitTime</span> <span class=\"operator\">=</span> millis - timePassed;</span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot;waitTime: &#123;&#125;&quot;</span>, waitTime);</span><br><span class=\"line\">                <span class=\"comment\">//经历时间超过最大等待时间退出循环</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (waitTime &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    log.debug(<span class=\"string\">&quot;break...&quot;</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    lock.wait(waitTime);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 3) 如果提前被唤醒，这时已经经历的时间假设为 400</span></span><br><span class=\"line\">                timePassed = System.currentTimeMillis() - begin;</span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot;timePassed: &#123;&#125;, object is null &#123;&#125;&quot;</span>,</span><br><span class=\"line\">                        timePassed, response == <span class=\"literal\">null</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//产生结果</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">complete</span><span class=\"params\">(Object response)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 条件满足，通知等待线程</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.response = response;</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;notify...&quot;</span>);</span><br><span class=\"line\">            lock.notifyAll();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">                   </span><br><span class=\"line\"><span class=\"comment\">//  下载网页:</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Downloader</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;String&gt; <span class=\"title function_\">download</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">HttpURLConnection</span> <span class=\"variable\">conn</span> <span class=\"operator\">=</span> (HttpURLConnection) <span class=\"keyword\">new</span> <span class=\"title class_\">URL</span>(<span class=\"string\">&quot;https://www.baidu.com/&quot;</span>).openConnection();</span><br><span class=\"line\">        List&lt;String&gt; lines = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (<span class=\"type\">BufferedReader</span> <span class=\"variable\">reader</span> <span class=\"operator\">=</span></span><br><span class=\"line\">                     <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedReader</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">InputStreamReader</span>(conn.getInputStream(), StandardCharsets.UTF_8))) &#123;</span><br><span class=\"line\">            String line;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((line = reader.readLine()) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                lines.add(line);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lines;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>多任务版 GuardedObject</p>\n</blockquote>\n<p>图中 Futures 就好比居民楼一层的信箱（每个信箱有房间编号）</p>\n<p>左侧的 t0，t2，t4 就好比等待邮件的居民；右侧的 t1，t3，t5 就好比邮递员如果需要在多个类之间使用 GuardedObject 对象，作为参数传递不是很方便</p>\n<p>因此设计一个用来解耦的中间类，这样不仅能够解耦【结果等待者】和【结果生产者】，还能够同时支持多个任务的管理。</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305310003632.png\" alt=\"image-20230521005409614\" style=\"zoom: 33%;\">\n<p>和生产者消费者模式的区别就是：这个生产者和消费者之间是一一对应的关系，但是生产者消费者模式并不是。</p>\n<p><code>rpc框架</code>的调用中就使用到了这种模式。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j(topic = &quot;c.Test20&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test20</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">People</span>().start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Integer id : Mailboxes.getIds()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Postman</span>(id, <span class=\"string\">&quot;内容&quot;</span> + id).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//居民进行收信</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j(topic = &quot;c.People&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">People</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 收信</span></span><br><span class=\"line\">        <span class=\"type\">GuardedObject</span> <span class=\"variable\">guardedObject</span> <span class=\"operator\">=</span> Mailboxes.createGuardedObject();</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;开始收信 id:&#123;&#125;&quot;</span>, guardedObject.getId());</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">mail</span> <span class=\"operator\">=</span> guardedObject.get(<span class=\"number\">5000</span>);</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;收到信 id:&#123;&#125;, 内容:&#123;&#125;&quot;</span>, guardedObject.getId(), mail);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//邮递员</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j(topic = &quot;c.Postman&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Postman</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> <span class=\"keyword\">throw</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String mail;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Postman</span><span class=\"params\">(<span class=\"type\">int</span> id, String mail)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.id = id;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.mail = mail;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        <span class=\"type\">GuardedObject</span> <span class=\"variable\">guardedObject</span> <span class=\"operator\">=</span> Mailboxes.getGuardedObject(id);</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;送信 id:&#123;&#125;, 内容:&#123;&#125;&quot;</span>, id, mail);</span><br><span class=\"line\">        <span class=\"comment\">//送信</span></span><br><span class=\"line\">        guardedObject.complete(mail);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// Mailboxes  和 GuardedObject 有一定的复用性</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Mailboxes</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Map&lt;Integer, GuardedObject&gt; boxes = <span class=\"keyword\">new</span> <span class=\"title class_\">Hashtable</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 产生唯一 id  </span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"type\">int</span> <span class=\"title function_\">generateId</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> id++; <span class=\"comment\">//synchronized 保证线程安全，对 Mailboxes.Class上锁</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> GuardedObject <span class=\"title function_\">getGuardedObjCct</span><span class=\"params\">(<span class=\"type\">int</span> id)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//remove有get的功能，并且还具有删除的功能</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> boxes.remove(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> GuardedObject <span class=\"title function_\">createGuardedObject</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">GuardedObject</span> <span class=\"variable\">go</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">GuardedObject</span>(generateId());</span><br><span class=\"line\">        boxes.put(go.getId(), go);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> go;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//获取所有集合</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Set&lt;Integer&gt; <span class=\"title function_\">getIds</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> boxes.keySet();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">GuardedObject</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 标识 Guarded Object</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> id;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">GuardedObject</span><span class=\"params\">(<span class=\"type\">int</span> id)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.id = id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 结果</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object response;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取结果</span></span><br><span class=\"line\">    <span class=\"comment\">// timeout 表示要等待多久 2000</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">get</span><span class=\"params\">(<span class=\"type\">long</span> timeout)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"built_in\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 开始时间 15:00:00</span></span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">begin</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">            <span class=\"comment\">// 经历的时间</span></span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">passedTime</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (response == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 这一轮循环应该等待的时间</span></span><br><span class=\"line\">                <span class=\"type\">long</span> <span class=\"variable\">waitTime</span> <span class=\"operator\">=</span> timeout - passedTime;</span><br><span class=\"line\">                <span class=\"comment\">// 经历的时间超过了最大等待时间时，退出循环</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (timeout - passedTime &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"built_in\">this</span>.wait(waitTime); <span class=\"comment\">// 虚假唤醒 15:00:01</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 求得经历时间</span></span><br><span class=\"line\">                passedTime = System.currentTimeMillis() - begin; <span class=\"comment\">// 15:00:02  1s</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 产生结果</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">complete</span><span class=\"params\">(Object response)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"built_in\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 给结果成员变量赋值</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.response = response;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.notifyAll();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"异步模式之生产者-消费者\">异步模式之生产者/消费者</h3>\n<ol>\n<li>与前面的保护性暂停中的 GuardObject 不同，不需要产生结果的线程 和 消费结果的线程<code>一一对应</code></li>\n<li>消费队列可以用来平衡生产和消费的线程资源</li>\n<li>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</li>\n<li>消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据</li>\n<li>JDK 中各种<a href=\"https://blog.csdn.net/yanpenglei/article/details/79556591\">阻塞队列</a>，采用的就是这种模式</li>\n</ol>\n<p><code>异步</code>的意思就是生产者产生消息之后消息<code>没有被立刻消费</code>，而<code>同步模式</code>中，消息在产生之后<code>被立刻消费</code>了。</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305300029719.png\" alt=\"image-20230521011029781\" style=\"zoom:33%;\">\n<p>我们写一个<code>线程</code>间通信的消息队列，要注意区别，像rabbit mq等消息框架是<code>进程间</code>通信的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j(topic = &quot;c.Test21&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test21</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">MessageQueue</span> <span class=\"variable\">queue</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MessageQueue</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        <span class=\"comment\">// 3个生产者线程</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> i;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">                queue.put(<span class=\"keyword\">new</span> <span class=\"title class_\">Message</span>(id , <span class=\"string\">&quot;值&quot;</span>+id));</span><br><span class=\"line\">            &#125;, <span class=\"string\">&quot;生产者&quot;</span> + i).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 1个消费者线程</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"type\">Message</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> queue.take();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;消费者&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 消息队列类 ， java 线程之间通信</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j(topic = &quot;c.MessageQueue&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MessageQueue</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 消息的队列集合   共享的变量就是  list 所有list有锁</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> LinkedList&lt;Message&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">// 消息队列的容量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> capcity;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MessageQueue</span><span class=\"params\">(<span class=\"type\">int</span> capcity)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.capcity = capcity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取消息</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Message <span class=\"title function_\">take</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 检查队列是否为空</span></span><br><span class=\"line\">        </span><br><span class=\"line\">       <span class=\"comment\">// 对共享变量进行上锁</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (list) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(list.isEmpty()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    log.debug(<span class=\"string\">&quot;队列为空, 消费者线程等待&quot;</span>);</span><br><span class=\"line\">                    <span class=\"comment\">//队列为空, 消费者线程等待</span></span><br><span class=\"line\">                    <span class=\"comment\">// list有锁  所以可以进行调用 wait（） 方法</span></span><br><span class=\"line\">                    list.wait();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 从队列头部获取消息并返回</span></span><br><span class=\"line\">            <span class=\"type\">Message</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> list.removeFirst();</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;已消费消息 &#123;&#125;&quot;</span>, message);</span><br><span class=\"line\">           </span><br><span class=\"line\">            <span class=\"comment\">// 唤醒所有生产者的线程</span></span><br><span class=\"line\">            list.notifyAll();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 存入消息</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">put</span><span class=\"params\">(Message message)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (list) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 检查对象是否已满</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(list.size() == capcity) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    log.debug(<span class=\"string\">&quot;队列已满, 生产者线程等待&quot;</span>);</span><br><span class=\"line\">                    list.wait();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 将消息加入队列尾部</span></span><br><span class=\"line\">            list.addLast(message);</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;已生产消息 &#123;&#125;&quot;</span>, message);</span><br><span class=\"line\">            <span class=\"comment\">// 唤醒所有消费者的线程</span></span><br><span class=\"line\">            list.notifyAll();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Message</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Message</span><span class=\"params\">(<span class=\"type\">int</span> id, Object value)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.id = id;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">getValue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Message&#123;&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;id=&quot;</span> + id +</span><br><span class=\"line\">                <span class=\"string\">&quot;, value=&quot;</span> + value +</span><br><span class=\"line\">                <span class=\"string\">&#x27;&#125;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"同步模式之顺序控制\">同步模式之顺序控制</h3>\n<h4 id=\"固定运行顺序-之打印-一次\">固定运行顺序 之打印 一次</h4>\n<blockquote>\n<p>必须先 2 后 1 打印</p>\n</blockquote>\n<h5 id=\"synchronized-的wait-notify-版\"><code>synchronized </code> 的<code>wait notify</code> 版</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j(topic = &quot;c.Test25&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test25</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 表示 t2 是否运行过</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"variable\">t2runalready</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//t2没有等待，就让t1执行</span></span><br><span class=\"line\">                <span class=\"comment\">//使用 while 是为了 防止虚假唤醒</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (!t2runalready) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        lock.wait();</span><br><span class=\"line\">                        <span class=\"comment\">// 进入wait 会释放锁</span></span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;t1&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\">                t2runalready = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                lock.notify();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;t2&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        t1.start();</span><br><span class=\"line\">        t2.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// t1先执行，到 wait 会先暂停，释放锁，随后 t2 执行到 notify 会唤醒t1 ,t1继续执行</span></span><br><span class=\"line\"><span class=\"comment\">// t2先执行，t2runalready =true, 随后t1执行到wait 就不会暂停，而是继续执行</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"Park-Unpark-版\"><code>Park Unpark </code>版</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j(topic = &quot;c.Test26&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test26</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            LockSupport.park();</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;t1&quot;</span>);</span><br><span class=\"line\">        t1.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\">            LockSupport.unpark(t1); </span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;t2&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// t1先执行，到park 会先暂停，随后 t2 执行到unpark 会唤醒t1 ,t1继续执行</span></span><br><span class=\"line\"><span class=\"comment\">// t2先执行，到unpark会继续执行t1，随后t1执行到while (!t2runalready) 就不会执行到循环中，而是继续向下执行</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"ReentrantLock-的await-singal-版\"><code>ReentrantLock </code>的<code>await singal </code>版</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j(topic = &quot;c.text111&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">test111</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 表示 t2 是否运行过</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"variable\">t2runalready</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ReentrantLock</span> <span class=\"variable\">reentrantLock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\">        <span class=\"type\">Condition</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> reentrantLock.newCondition();</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            reentrantLock.lock();</span><br><span class=\"line\">                <span class=\"comment\">//t2没有等待，就让t1执行</span></span><br><span class=\"line\">                <span class=\"comment\">//使用 while 是为了 防止虚假唤醒</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (!t2runalready) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        lock.await();</span><br><span class=\"line\">                        <span class=\"comment\">// 进入wait 会释放锁</span></span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">            reentrantLock.unlock();</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;t1&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            reentrantLock.lock();</span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\">                t2runalready = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                lock.signal();</span><br><span class=\"line\">            reentrantLock.unlock();</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;t2&quot;</span>);</span><br><span class=\"line\">        t1.start();</span><br><span class=\"line\">        t2.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"同步顺序之交替输出\">同步顺序之交替输出</h4>\n<blockquote>\n<p>线程 1 输出 a 5 次，线程 2 输出 b 5 次，线程 3 输出 c 5 次。现在要求输出 abcabcabcabcabc 怎么实现</p>\n</blockquote>\n<h5 id=\"synchronized-wait-notify-版\"><code>synchronized</code> <code>wait notify </code>版</h5>\n<blockquote>\n<p>将 <code>输出的内容 、等待标记（谁唤醒我）、 下一个标记（我唤醒谁） </code> 设置为函数对应的参数 进行传递寻找，线程之间依次调用</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">输出内容       等待标记     下一个标记</span></span><br><span class=\"line\"><span class=\"comment\">   a           1             2</span></span><br><span class=\"line\"><span class=\"comment\">   b           2             3</span></span><br><span class=\"line\"><span class=\"comment\">   c           3             1</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WaitNotify</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 等待标记   公共标记</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> flag; </span><br><span class=\"line\">    <span class=\"comment\">// 循环次数</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> loopNumber;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">WaitNotify</span><span class=\"params\">(<span class=\"type\">int</span> flag, <span class=\"type\">int</span> loopNumber)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.flag = flag;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.loopNumber = loopNumber;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 打印               a           1             2</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">print</span><span class=\"params\">(String str, <span class=\"type\">int</span> waitFlag, <span class=\"type\">int</span> nextFlag)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (<span class=\"built_in\">this</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span>(flag != waitFlag) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">this</span>.wait();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.print(str);</span><br><span class=\"line\">                <span class=\"comment\">//等待标记需要等待下一个标记的整数</span></span><br><span class=\"line\">                flag = nextFlag;</span><br><span class=\"line\">                <span class=\"built_in\">this</span>.notifyAll();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">WaitNotify</span> <span class=\"variable\">wn</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">WaitNotify</span>(<span class=\"number\">1</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            wn.print(<span class=\"string\">&quot;a&quot;</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            wn.print(<span class=\"string\">&quot;b&quot;</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            wn.print(<span class=\"string\">&quot;c&quot;</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"ReentrantLock-的条件变量版\"><code>ReentrantLock</code>   的条件变量版</h5>\n<blockquote>\n<p>参数为：<code> 打印的内容     进入的是哪一间休息室     下一间休息室</code></p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">AwaitSignal</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ReentrantLock</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">start</span><span class=\"params\">(Condition first)</span> &#123;</span><br><span class=\"line\">         <span class=\"built_in\">this</span>.lock();</span><br><span class=\"line\">         <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;start&quot;</span>);</span><br><span class=\"line\">            first.signal();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> \t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//str  表示打印的内容    current 表示 进入的是哪一间休息室   next 表示下一间休息室</span></span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">print</span><span class=\"params\">(String str, Condition current, Condition next)</span> &#123;</span><br><span class=\"line\">         <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class=\"line\">             <span class=\"comment\">//加锁</span></span><br><span class=\"line\">             <span class=\"built_in\">this</span>.lock();            </span><br><span class=\"line\">             <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                 <span class=\"comment\">//首次  不管是谁，都进入自己的休息室等待</span></span><br><span class=\"line\">                 <span class=\"comment\">//随后获取锁时候 都将进入自己的休息室，唤醒其他线程</span></span><br><span class=\"line\">                 current.await();</span><br><span class=\"line\">                 <span class=\"comment\">//打印</span></span><br><span class=\"line\">                 log.debug(str);</span><br><span class=\"line\">                 <span class=\"comment\">//唤醒下一间休息室</span></span><br><span class=\"line\">                 next.signal();</span><br><span class=\"line\">             &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            \t e.printStackTrace();</span><br><span class=\"line\">             &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                 <span class=\"comment\">// 解锁</span></span><br><span class=\"line\">             \t <span class=\"built_in\">this</span>.unlock();</span><br><span class=\"line\">         \t &#125;</span><br><span class=\"line\">     \t&#125;</span><br><span class=\"line\"> \t&#125;</span><br><span class=\"line\"> \t<span class=\"comment\">// 循环次数</span></span><br><span class=\"line\">     <span class=\"keyword\">private</span> <span class=\"type\">int</span> loopNumber;</span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"title function_\">AwaitSignal</span><span class=\"params\">(<span class=\"type\">int</span> loopNumber)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.loopNumber = loopNumber;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"type\">AwaitSignal</span> <span class=\"variable\">as</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AwaitSignal</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"type\">Condition</span> <span class=\"variable\">aWaitSet</span> <span class=\"operator\">=</span> as.newCondition();</span><br><span class=\"line\"><span class=\"type\">Condition</span> <span class=\"variable\">bWaitSet</span> <span class=\"operator\">=</span> as.newCondition();</span><br><span class=\"line\"><span class=\"type\">Condition</span> <span class=\"variable\">cWaitSet</span> <span class=\"operator\">=</span> as.newCondition();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 线程    去哪里休息    去谁的休息室唤醒他继续工作</span></span><br><span class=\"line\">     as.print(<span class=\"string\">&quot;a&quot;</span>, aWaitSet, bWaitSet);</span><br><span class=\"line\">    &#125;).start();</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">     as.print(<span class=\"string\">&quot;b&quot;</span>, bWaitSet, cWaitSet);</span><br><span class=\"line\">    &#125;).start();</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">     as.print(<span class=\"string\">&quot;c&quot;</span>, cWaitSet, aWaitSet);</span><br><span class=\"line\">    &#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\">\tsleep(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 主线程上锁</span></span><br><span class=\"line\">\tas.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">\t   System.out.println(<span class=\"string\">&quot;开始...&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 唤醒 a 休息室的线程</span></span><br><span class=\"line\">       aWaitSet.singal();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">        as.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//该实现没有考虑 a，b，c 线程都就绪再开始</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"Park-Unpark-版-2\"><code>Park Unpark </code>版</h5>\n<blockquote>\n<p>使用<code>unpark</code> 指定 下一次要唤醒的线程</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ParkUnpark</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> loopNumber;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ParkUnpark</span><span class=\"params\">(<span class=\"type\">int</span> loopNumber)</span> &#123;</span><br><span class=\"line\">     \t<span class=\"built_in\">this</span>.loopNumber = loopNumber;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">print</span><span class=\"params\">(String str,Thread next)</span> &#123;</span><br><span class=\"line\">         <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class=\"line\">             LockSupport.park();</span><br><span class=\"line\">             System.out.print(str);</span><br><span class=\"line\">             LockSupport.unpark(next);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">ParkUnpark</span> <span class=\"variable\">Park</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ParkUnpark</span>(<span class=\"number\">5</span>); </span><br><span class=\"line\">\t<span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">         Park.print(<span class=\"string\">&quot;a&quot;</span>,t2);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">     \t Park.print(<span class=\"string\">&quot;b&quot;</span>,t3);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">t3</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">      \t Park.print(<span class=\"string\">&quot;c&quot;</span>,t1);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">\t</span><br><span class=\"line\">t1.start();</span><br><span class=\"line\">t2.start();</span><br><span class=\"line\">t3.start();</span><br></pre></td></tr></table></figure>\n<h3 id=\"同步模式之-Balking\">同步模式之 Balking</h3>\n<p><code>Balking （犹豫）</code>模式：</p>\n<ul>\n<li>用在一个线程发现另一个线程 或 <code>本线程</code>已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回</li>\n</ul>\n<h3 id=\"异步模式之工作线程\">异步模式之<code>工作线程</code></h3>\n<h5 id=\"定义\">定义</h5>\n<ul>\n<li>让有限的工作线程（Worker Thread）来<code>轮流</code>异步处理无限多的任务。也可以将其归类为<code>分工模式</code>，它的典型实现就是线程池，也体现了经典设计模式中的<code>享元模式</code></li>\n</ul>\n<blockquote>\n<p>注意，<code>不同任务类型</code>应该<code>使用不同的线程池</code>，这样能够<code>避免饥饿</code>，并能<code>提升效率</code></p>\n</blockquote>\n<h5 id=\"饥饿现象\">饥饿现象</h5>\n<ul>\n<li>\n<p>产生时机：固定大小线程池<code> 会</code>有 饥饿现象  ，带缓冲的<code>不会</code>有  饥饿现象 ，单线程的也<code>会</code>有 饥饿现象</p>\n</li>\n<li>\n<p>解决方法</p>\n<ul>\n<li>可以<code>增加线程池的大小</code>，不过不是根本解决方案</li>\n<li>根本解决方案还是前面提到的，<code>不同的任务类型，采用不同的线程池</code>   就是创建<code>不同种类的线程池</code></li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//根本解决</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j(topic = &quot;c.TestDeadLock&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestStarvation</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> List&lt;String&gt; MENU = Arrays.asList(<span class=\"string\">&quot;地三鲜&quot;</span>, <span class=\"string\">&quot;宫保鸡丁&quot;</span>, <span class=\"string\">&quot;辣子鸡丁&quot;</span>, <span class=\"string\">&quot;烤鸡翅&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">Random</span> <span class=\"variable\">RANDOM</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Random</span>();</span><br><span class=\"line\">    <span class=\"keyword\">static</span> String <span class=\"title function_\">cooking</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> MENU.get(RANDOM.nextInt(MENU.size()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//根本解决</span></span><br><span class=\"line\">        <span class=\"type\">ExecutorService</span> <span class=\"variable\">waiterPool</span> <span class=\"operator\">=</span> Executors.newFixedThreadPool(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"type\">ExecutorService</span> <span class=\"variable\">cookPool</span> <span class=\"operator\">=</span> Executors.newFixedThreadPool(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        waiterPool.execute(() -&gt; &#123;</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;处理点餐...&quot;</span>);</span><br><span class=\"line\">            Future&lt;String&gt; f = cookPool.submit(() -&gt; &#123;</span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot;做菜&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> cooking();</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot;上菜: &#123;&#125;&quot;</span>, f.get());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"comment\">//处理点餐waiterPool</span></span><br><span class=\"line\">        waiterPool.execute(() -&gt; &#123;</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;处理点餐...&quot;</span>);</span><br><span class=\"line\">            <span class=\"comment\">//做菜 cookPool</span></span><br><span class=\"line\">            Future&lt;String&gt; f = cookPool.submit(() -&gt; &#123;</span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot;做菜&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> cooking();</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot;上菜: &#123;&#125;&quot;</span>, f.get());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"享元模式-1-23\">享元模式(1/23)</h3>\n<ol>\n<li>\n<p>需要<code>重用</code>数量有限的同一类对象时</p>\n<blockquote>\n<p>主要目标是为了尽可能小的使用内存，<code>不是每一次都创建</code>新的对象，尽可能的对相同取值的对象进行共享</p>\n</blockquote>\n</li>\n<li>\n<p>体现</p>\n<blockquote>\n<p>(包装类、 String 、 BigDecimal 、BigInteger) 都是不可变的，都是安全的</p>\n</blockquote>\n<ol>\n<li>在JDK中 <code>Boolean，Byte，Short，Integer，Long，Character</code> 等<code>包装类</code>提供了 <code>valueOf</code> 方法，例如 <code>Long</code> 的<code>valueOf</code> 会缓存<code>-128~127</code>之间的 <code>Long</code> 对象，在这个范围之间会重用对象，大于这个范围，才会新建 <code>Long</code> 对象</li>\n<li><code>String 串池机制</code></li>\n<li><code>BigDecimal      BigInteger</code></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"源码\">源码</h2>\n<h3 id=\"longadder\"><code>longadder</code></h3>\n<p><code>add()</code></p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305310003550.png\" alt=\"image-20230521194500666\" style=\"zoom: 53%;\">\n<p><code>longAccumulate</code></p>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305310003983.png\" alt></p>\n<p><code>Cell[]  </code>数组存在但是  线程对应的<code>cell还没创建好</code></p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305310003839.png\" alt=\"image-20230521200412034\" style=\"zoom: 33%;\">\n<p><code>Cell[]  </code>数组存在   而且 线程对应的<code>cell</code>已经创建好，逻辑如下</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305310003934.png\" alt=\"image-20230521200649904\" style=\"zoom:33%;\">\n<h3 id=\"Reentrantlock\"><code>Reentrantlock</code></h3>\n<h3 id=\"读写锁ReentrantReadWriteLock-2\">读写锁<code>ReentrantReadWriteLock()</code></h3>\n<h3 id=\"Semaphore\"><code>Semaphore</code></h3>\n<h3 id=\"CountdownLatch\"><code>CountdownLatch</code></h3>\n<h3 id=\"CyclicBarri\"><code> CyclicBarri</code></h3>\n<h3 id=\"ConcurrentHashMap-2\"><code>ConcurrentHashMap</code></h3>\n<h3 id=\"LinkedBlockingQueue阻塞队列-2\"><code>LinkedBlockingQueue</code>阻塞队列</h3>\n<h3 id=\"CopyOnWriteArrayList-2\"><code>CopyOnWriteArrayList</code></h3>\n<h3 id=\"ConcurrentLinkedQueue并发队列-2\"><code>ConcurrentLinkedQueue</code>并发队列</h3>\n<h2 id=\"相关博文：\">相关博文：</h2>\n<p><a href=\"https://www.cnblogs.com/snowater/p/8024776.html\">单线程情况下问题分析及解决方案</a></p>\n<p>[阻塞队列][<a href=\"https://blog.csdn.net/yanpenglei/article/details/79556591\">https://blog.csdn.net/yanpenglei/article/details/79556591</a>]</p>\n<p>[不可变类][<a href=\"https://www.cnblogs.com/dolphin0520/p/10693891.html\">https://www.cnblogs.com/dolphin0520/p/10693891.html</a>]</p>\n<p>[final类][<a href=\"https://www.cnblogs.com/xiaoxi/p/6392154.html\">https://www.cnblogs.com/xiaoxi/p/6392154.html</a>]</p>\n<p><a href=\"https://mp.weixin.qq.com/s/RX5rVuGr6Ab0SmKigmZEag\">FutureTask是Future和Runable的实现</a></p>\n<h2 id=\"start一个线程原理\">start一个线程原理</h2>\n<ol>\n<li>我们调用一个线程的<code>start()</code> <code>实质上</code>是调用<code>start0()</code>,但是<code>start0</code>是<code>native</code>方法,<code>java</code>语言本身的底层就是c++语言，</li>\n<li><code>java</code>线程是通过<code>start</code>的方法启动执行的，主要内容在<code>native</code>修饰的方法<code>start0</code>中</li>\n<li><code>start0</code>其实就是<code>JVM_StartThread</code>,<code>JVM_StartThread</code>方法<code>本质上</code>就是<code>调用了JVM</code>中的<code>start</code>方法,<code>JVM</code>中的<code>start</code>方法<code>本质上</code>就是<code>C++</code>调用操作系统的<code>创建一个线程</code></li>\n<li>所以说：  <code>java</code> 中调用<code>start</code>本质上就是调用的<code>start0</code>本地方法,而本地方法是<code>C++</code>通过调用操作系统创建线程</li>\n</ol>\n<h2 id=\"Java锁\">Java锁</h2>\n<blockquote>\n<ul>\n<li>阿里巴巴代码规范\n<ul>\n<li>【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。</li>\n<li>说明：尽可能使加锁的代码块<code>工作量</code>尽可能的<code>小</code>，避免在锁代码块中调用 <code>RPC</code> 方法。</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"乐观锁和悲观锁\">乐观锁和悲观锁</h3>\n<blockquote>\n<p>synchronized关键字和Lock的实现类都是悲观锁</p>\n</blockquote>\n<ul>\n<li>\n<p><code>悲观锁</code>: 认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。</p>\n<ul>\n<li>适合<code>写操作多</code>的场景,先加锁可以保证写操作时数据正确</li>\n<li>显式的锁定之后在操作同步资源</li>\n</ul>\n</li>\n<li>\n<p><code>乐观锁</code>:乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作</p>\n<ul>\n<li>乐观锁在Java中是通过使用无锁编程来实现，最常采用的是<code>CAS算法</code>，Java原子类中的<code>递增操作</code>就通过<code>CAS自旋</code>实现的</li>\n<li>适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</li>\n<li>乐观锁一般有两种实现方式：\n<ul>\n<li>采用<code>版本号机制</code></li>\n<li><code>CAS</code>（Compare-and-Swap，即比较并替换）算法实现</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>对于八锁(说的就是<code>synchronized</code>)问题：</p>\n<p>主要的<code>思路</code>就是判断锁对象是否一致,判断我们的锁是<code>对象锁</code>还是<code>类锁</code>,只要锁对象<code>不相同</code>就<code>不会出现加锁阻塞</code>的情况</p>\n<ul>\n<li>同步方法:锁的是当前实例对象，通常指<code>this</code>\n<ul>\n<li>如果两个调用对象是相同的那么就是同一把锁,会出现锁的情况</li>\n<li>如果如果两个调用对象不是相同的那么则无影响,就算是相同类的两个对象也是一样.</li>\n</ul>\n</li>\n<li>静态同步方法:静态同步方法，锁的是当前类的<code>Class</code>对象\n<ul>\n<li>众所周知一个类在<code>jvm</code>中只有一个对应的<code>Class</code>对象,所以调用同一个类的两个静态同步方法一定是会被锁住的.</li>\n</ul>\n</li>\n<li>同步代码块: 会手动指定加锁对象比较容易判断,即判断两个线程的锁对象是否一致</li>\n</ul>\n</blockquote>\n<h4 id=\"从字节码角度进行理解：synchronized\">从字节码角度进行理解：synchronized</h4>\n<blockquote>\n<p>示例</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * synchronized同步代码块字节码实现</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LockByteCodeDemo</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">object</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">    <span class=\"comment\">//m1</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">m1</span><span class=\"params\">()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (object)&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;----------hello sync code&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>反编译</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javap -c    ***.class文件反编译  [-c 对代码进行反汇编]</span><br><span class=\"line\"></span><br><span class=\"line\">javap -v \t***.class文件反编译\t[-v -verbose 输出附加信息（包括行号、本地变量表，反汇编等详细信息）]</span><br></pre></td></tr></table></figure>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306051905610.png\" alt=\"image-20230605190546487\" style=\"zoom:33%;\">\n<blockquote>\n<ol>\n<li><code>synchronized</code>同步<code>代码块</code>实现   是通过使用<code>monitorenter</code>和<code>monitorexit</code>指令</li>\n</ol>\n<ul>\n<li>一定是一个<code>enter</code>两个<code>exit</code>吗？\n<ul>\n<li>不是;当在程序出现了异常的时候，就会只有一个<code>enter</code>  和 一个<code>exit</code></li>\n</ul>\n</li>\n</ul>\n<ol start=\"2\">\n<li>同步<code>方法</code>字节码的实现    是通过加标志位<code>ACC_SYNCHRONIZED</code>实现的</li>\n</ol>\n<ul>\n<li>调用指令将会<code>检查</code>方法的<code>ACC_SYNCHRONIZED</code>访问标志是否被设置。\n<ul>\n<li>如果设置了，执行线程会将先持有<code>monitor</code>然后再执行方法，最后在方法完成(无论是正常完成还是非正常完成)时释放 <code>monitor</code></li>\n</ul>\n</li>\n</ul>\n<ol start=\"3\">\n<li><code>静态同步方法</code>字节码的实现是通过加标志位<code>ACC_STATIC</code>和<code>ACC_SYNCHRONIZED</code>实现的</li>\n</ol>\n</blockquote>\n<p>反编译<code>synchronized</code>锁的<code>是什么</code>(为什么任何一个对象都可以成为一个锁?)</p>\n<ul>\n<li><strong>因为在HotSpot虚拟机中，monitor采用ObjectMonitor实现</strong></li>\n<li>而我们每个java类的父类都是Object类</li>\n<li>所以<code>每个对象天生</code>都带着一个<code>对象监视器</code>,所以任何一个对象都可以成为一个锁</li>\n</ul>\n<h3 id=\"公平锁和非公平锁\">公平锁和非公平锁</h3>\n<ul>\n<li>公平锁：指多个线程<strong>按照申请锁的顺序来获取锁</strong>，这里类似排队买票，先来的人先买后来的人在队尾排着，这是公平的</li>\n<li>非公平锁： 指多个<strong>线程获取锁的顺序并不是按照申请锁的顺序</strong>，有可能后中请的线程比先中请的线程优先获取锁，在高并发环境下，有可能造成优先级翻转或者饥饿的状态（某个线程一直得不到锁)</li>\n</ul>\n<p>代码演示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ReentrantLock</span> <span class=\"variable\">reentrantLock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>(<span class=\"literal\">true</span>);  <span class=\"comment\">// 指定为公平锁</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">ReentrantLock</span> <span class=\"variable\">reentrantLock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>(<span class=\"literal\">false</span>);<span class=\"comment\">//默认false</span></span><br><span class=\"line\"><span class=\"type\">ReentrantLock</span> <span class=\"variable\">reentrantLock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();<span class=\"comment\">//等价于   默认非公平锁</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>问：为什么会有公平锁/非公平锁的设计；为什么默认非公平？</p>\n</li>\n<li>\n<p>答：</p>\n<ul>\n<li>从恢复挂起的线程到真正锁的获取还是有时间差的，从开发人员来看这个时间微乎其微，但是从CPU的角度来看，这个时间差存在的还是很明显的。所以非公平锁能更充分的利用CPU 的时间片，尽量减少 CPU 空闲状态时间。</li>\n<li>使用多线程很重要的考量点是线程切换的开销，当采用非公平锁时，当某个线程请求锁获取同步状态，然后释放同步状态，因为不需要考虑是否还有前驱节点，所以刚释放锁的线程在此刻再次获取同步状态的概率就变得非常大，所以就减少了线程的开销。</li>\n</ul>\n</li>\n<li>\n<p>问：使⽤公平锁会有什么问题</p>\n</li>\n<li>\n<p>答：</p>\n<ul>\n<li>公平锁保证了排队的公平性，不会造成锁饥饿,但是<code>会增加线程的开销</code></li>\n<li>非公平锁忽视这个规则，但是就会导致排队的长时间在排队，也没有机会获取到锁，这就是传说中的 “锁饥饿”</li>\n</ul>\n</li>\n<li>\n<p>问: 什么时候用公平？什么时候用非公平？</p>\n</li>\n<li>\n<p>答：</p>\n<ul>\n<li>如果为了更高的吞吐量，很显然非公平锁是比较合适的，因为节省很多线程切换时间，吞吐量自然就上去了；</li>\n<li>否则那就用公平锁，大家公平使用。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"可重入锁\">可重入锁</h3>\n<blockquote>\n<p>又名 ： 递归锁</p>\n<p>是指<strong>在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁(前提，锁对象得是同一个对象)，不会因为之前已经获取过还没释放而阻塞。</strong></p>\n<p>作用： <strong>一定程度可以避免死锁</strong></p>\n</blockquote>\n<p>分类：</p>\n<ul>\n<li>隐式锁：（即synchronized关键字使用的锁）默认是<code>可重入锁</code></li>\n<li>显式锁:  （即Lock）  比如： <code>ReentrantLock</code></li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306051954114.png\" alt=\"image-20230605195403072\" style=\"zoom:50%;\">\n<h5 id=\"Synchronized的重入的实现机理\">Synchronized的重入的实现机理</h5>\n<ul>\n<li>每个锁对象拥有一个<code>锁计数器</code>和一个<code>指向持有该锁的线程的指针</code>     <code>_count</code>  <code>_owner</code>\n<ul>\n<li><strong>首次加锁</strong>：当执行<code>monitorenter</code>时，如果目标锁对象的计数器<code>_count</code>为零，那么说明它没有被其他线程所持有，Java虚拟机会将该锁对象的持有线程<code>_owner</code>设置为当前线程，并且将其计数器<code>_count</code>加1。</li>\n<li><strong>重入</strong>：在目标锁对象的计数器不为零的情况下，如果锁对象的持有线程是当前线程，那么 Java 虚拟机可以将其计数器<code>_count</code>加1,并且锁的重入次数<code>_recursions</code>加一，否则需要等待，直至持有线程释放该锁。</li>\n<li><strong>释放锁</strong>：当执行<code>monitorexit</code>时，Java虚拟机则需将锁对象的计数器减1。如果<code>_recursions</code>不为0,<code>_recursions</code>同时减一,计数器为零代表锁已被释放。</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306051957893.png\" alt=\"image-20230605195708766\" style=\"zoom:33%;\">\n<h2 id=\"LockSupport与线程中断\">LockSupport与线程中断</h2>\n<h3 id=\"中断\">中断</h3>\n<ul>\n<li>\n<p>什么是中断?</p>\n<ul>\n<li>一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止。(<code>Thread.stop, Thread.suspend, Thread.resume</code> 都已经被废弃了。)</li>\n<li><strong>在Java中没有办法立即停止一条线程，然而停止线程却显得尤为重要</strong>，如取消一个耗时操作。因此，Java提供了一种用于停止线程的机制——<code>中断</code>。</li>\n<li>中断只是一种<code>协商机制</code>，Java没有给中断增加任何语法，中断的过程完全需要程序员自己实现。</li>\n</ul>\n</li>\n<li>\n<p>如何中断一个线程</p>\n<ul>\n<li>若要中断一个线程，可以 手动调用该线程的<code>interrupt</code>方法，该方法也仅仅是将线程对象的中断标识设成<code>true</code>；</li>\n<li>接着自己写的代码将会不断地检测当前线程的标识位，如果为<code>true</code>，表示别的线程要求这条线程中断，此时究竟该做什么需要自己实现。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>每个线程对象中都有一个标识，用于表示线程<code>是否被中断</code>；该标识位为<code>true</code>表示中断，为<code>false</code>表示未中断；<br>\n通过调用线程对象的<code>interrupt</code>方法将该线程的标识位设为<code>true</code>；可以在别的线程中调用，也可以在自己的线程中调用。</p>\n</blockquote>\n<ul>\n<li>中断相关<code>API</code></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>public void interrupt()</code></td>\n<td>实例方法，<br>实例方法<code>interrupt</code>仅仅是设置线程的中断状态为true,<code>不会停止线程</code></td>\n</tr>\n<tr>\n<td><code>public static boolean interrupted()</code></td>\n<td>静态方法，判断线程是否被中断，并清除当前中断状态<br>这个方法做了两件事：<br>1. 返回<code>当前</code>线程的中断<code>状态</code><br>2. 将<code>当前</code>线程的<code>中断</code>状态<code>设</code>为<code>false</code><br>这个方法有点不好理解，因为连续调用两次的结果可能不一样。</td>\n</tr>\n<tr>\n<td><code>public boolean isInterrupted()</code></td>\n<td>实例方法，<br>判断当前线程<code>是否被中断</code>（通过检查中断标志位）</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>\n<p>使用中断标识停止线程</p>\n<ul>\n<li>\n<p>方式一: 通过一个volatile变量实现</p>\n<blockquote>\n<p>如果一个变量被<code>volatile</code>那么这个变量就具备可见性,在高并发情况下通过修改变量状态来决定程序和系统的运行</p>\n</blockquote>\n</li>\n<li>\n<p>方式二:通过AtomicBoolean实现</p>\n<blockquote>\n<p><code>AtomicBoolean</code>就是原子性的<code>Boolean</code>,因为带有原子性天生就不需要加锁</p>\n</blockquote>\n</li>\n<li>\n<p>方式三:通过Thread类<code>自带的中断api</code>方法(见上)实现</p>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"interrupt-方法源码分析\">interrupt()方法源码分析</h5>\n<blockquote>\n<p>如果此线程在调用Object:类的Wait()、Wait(Long)或Wait(Long,int)方法或join()、join(Long)、join(Long,int)时被阻塞，sleep(Long)或sleep(Long,int),这个类的方法，它的中断状态将被清除并且它会收到一个InterruptedException。<br>\n如果线程1在执行其中方法时，那么线程2调用线程1的中断方法此时会抛出异常，并且会清除中断状态，设为默认值false</p>\n</blockquote>\n<h5 id=\"isInterrupted-方法与interrupted-源码分析\">isInterrupted()方法与interrupted() 源码分析</h5>\n<p>当对一个线程，调用 interrupt() 时：</p>\n<ul>\n<li>如果线程处于正常活动状态，那么会将该线程的中断标志设置为<code> true</code>，仅此而已。被设置中断标志的线程将继续正常运行，不受影响。所以， <code>interrupt() </code>并不能真正的中断线程，需要被调用的线程自己进行配合才行。</li>\n<li>如果线程处于被阻塞状态（例如处于<code>sleep, wait, join </code>等状态），在别的线程中调用当前线程对象的<code>interrupt</code>方法，那么线程将立即退出被阻塞状态，并抛出一个<code>InterruptedException</code>异常。</li>\n</ul>\n<blockquote>\n<p>遇到<code>InterruptedException</code>怎么办</p>\n<ul>\n<li>代码</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">InterruptDemo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;-----isInterrupted() = true，程序结束。&quot;</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\"><span class=\"comment\">// Thread.currentThread().interrupt();//???????  //线程的中断标志位为false,无法停下，需要再次掉interrupt()设置true</span></span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;------hello Interrupt&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;t1&quot;</span>);</span><br><span class=\"line\">        t1.start();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123; TimeUnit.SECONDS.sleep(<span class=\"number\">3</span>); &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            t1.interrupt();<span class=\"comment\">//修改t1线程的中断标志位为true</span></span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;t2&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>现象：</li>\n</ul>\n<p>程序出现<code>InterruptedException</code>后会一直执行不会停止,因为我们调用interrupt方法时t1线程正<strong>处于sleep状态,根据之前api的说明会爆出<code>InterruptedException</code>并且会将我们中断状态清除</strong></p>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306052211108.png\" alt></p>\n<ul>\n<li>解决方法</li>\n</ul>\n<p>在catch代码块中让中断标志为true,防止出现<code>InterruptedException</code>异常程序无法停止</p>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306052211122.png\" alt></p>\n</blockquote>\n<p><code>interrupted()</code>对比<code>isInterrupted()</code></p>\n<ul>\n<li>他们在底层都调用了<code>native</code>方法<code>isInterrupted</code>。</li>\n<li>只不过传入参数<code>ClearInterrupted</code>一个传参传了<code>true</code>，一个传了<code>false</code>。</li>\n<li>静态方法<code>interrupted() </code>中<code>true</code>表示清空当前中断状态。</li>\n<li>实例方法<code>isInterrupted</code> 则不会。</li>\n</ul>\n<p>当前线程的中断标识为true，是不是就立刻停止</p>\n<ul>\n<li>不是，在执行interrupt方法后线程仍然在执行；只是将中断标志位设为了true，随后在线程结束之后中断标志才会被清除</li>\n</ul>\n<h3 id=\"LockSupport\">LockSupport</h3>\n<ul>\n<li>\n<p>是什么</p>\n<ul>\n<li>创建锁和其他同步类的基本线程<code>阻塞原语</code></li>\n</ul>\n</li>\n<li>\n<p>主要的方法</p>\n<ul>\n<li><code>park() </code>         <strong>阻塞线程</strong></li>\n<li><code>unpark()</code>     <strong>解除阻塞线程</strong></li>\n</ul>\n</li>\n<li>\n<p>3种让线程等待和唤醒的方法</p>\n<ul>\n<li>方式1：使用<code>Object</code>中的<code>wait()</code>方法让线程等待，使用<code>Object</code>中的<code>notify()</code>方法唤醒线程   ——结合  <code>synchronized</code>使用</li>\n<li>方式2：使用<code>JUC</code>包中<code>Condition</code>的<code>await()</code>方法让线程等待，使用<code>signal()</code>方法唤醒线程       ——结合  <code>reentrantlock</code>使用</li>\n<li>方式3：<code>LockSupport</code>类中的<code>park</code>等待和<code>unpark</code>唤醒</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><code>Object</code>和<code>Condition</code>使用的限制条件:</p>\n<ul>\n<li>线程先要获得并持有锁，必须在锁块(synchronized或lock)中必须要先等待后唤醒，线程才能够被唤醒</li>\n</ul>\n<p><code>LockSupport</code>类使用了一种名为<code>Permit(许可)</code>的概念来做到阻塞和唤醒线程的功能，每个线程都有一个<code>许可(permit),permit</code>只有两个值1和零，默认是零。</p>\n<p>可以把<code>Permit 许可</code>看成是一种(0,1)<code>信号量(Semaphore)</code>,但与<code>Semaphore</code>不同的是，许可的累加<code>上限</code>是1。</p>\n<p>==注意==</p>\n<p>方式1 不能丢失同步代码块<code>synchronized</code>  并且  <code>wait</code> <code>notify</code> 的顺序不能颠倒</p>\n<p>方式2 不能丢失<code>lock</code> 和 <code>unlock</code>   并且  <code>await</code> <code>signal</code> 的顺序不能颠倒</p>\n</blockquote>\n<blockquote>\n<ul>\n<li>调用<code>LockSupport.park()</code>时</li>\n</ul>\n<p><strong>permit默认是零</strong>，<strong>所以一开始调用park()方法，当前线程就会阻塞，直到别的线程将当前线程的permit设置为1时，park方法会被唤醒，然后会将permit再次设置为零并返回。</strong></p>\n<ul>\n<li>调用<code>LockSupport.unpark()</code>时</li>\n</ul>\n<p>调用<code>unpark(thread)</code>方法后，就会将thread线程的许可<code>permit</code>设置成<code>1</code>(注意多次调用<code>unpark</code>方法，不会累加，<code>permit</code>值还是1)会自动唤醒<code>thread</code>线程，即之前阻塞中的<code>LockSupport.park()</code>方法会立即返回。</p>\n<p>==注意==</p>\n<ul>\n<li>多次park多次unpark会产生异常；线程一直无法被唤醒,因为park颁发的许可证只能有一个,就算颁发多个也只能有一个,但是我们unpark两次就需要两个许可证所以无法唤醒线程t1</li>\n<li>Lock Support是一个线程阻塞工具类， 所有的方法都是静态方法， 可以让线程在任意位置阻塞， 阻塞之后也有对应的唤醒方法。<code>归根结 底</code>， Lock Support调用的<code>Unsafe</code>中的<code>native</code>代码。调用<code>LockSupport.park()</code>时，发现它调用了<code>unsafe类</code>，并且默认传了一个<code>0</code>; 调用<code>LockSupport.unpark();</code>时，也调用了<code>unsafe类</code></li>\n</ul>\n</blockquote>\n<h2 id=\"Java内存模型之JMM\">Java内存模型之JMM</h2>\n<p>引入：</p>\n<ul>\n<li>因为计算机存储结构中有多级的缓存(cpu和物理主内存的速度不一致的)，CPU的<strong>运行并不是直接操作内存而是先把内存里边的数据读到缓存</strong>，而内存的读和写操作的时候就会造成不一致的问题</li>\n</ul>\n<p>是什么</p>\n<ul>\n<li>\n<p>Java虚拟机规范中试图定义一种Java内存模型（<code>java Memory Model，简称JMM</code>) 来屏蔽掉各种<code>硬件和操作系统的内存</code>访问差异，以实现让<code>Java</code>程序在各种平台下都能达到<code>一致的内存访问效果</code></p>\n</li>\n<li>\n<p>是一种<strong>抽象的</strong>概念,<strong>并不真实存在</strong>它仅仅描述的是一组约定或规范</p>\n</li>\n<li>\n<p>通过这组规范定义了程序中各个变量的读写访问方式,并决定一个线程对共享变量的写入<code>何时以及如何</code>让对另一个线程可见（关键技术点都是围绕多线程的<code>原子性</code>、<code>可见性</code>和<code>有序性</code>展开的）</p>\n</li>\n</ul>\n<p>能干什么</p>\n<ul>\n<li>通过JMM来实现<strong>线程和主内存之间的抽象关系。</strong></li>\n<li><strong>屏蔽各个硬件平台和操作系统的内存访问差异</strong>，以实现让Java程序在各种平台下都能达到一致的内存访问效果。</li>\n</ul>\n<h4 id=\"JMM规范下三大特性\">JMM规范下三大特性</h4>\n<h5 id=\"可见性-2\">可见性</h5>\n<ul>\n<li>\n<p>是指当一个线程<code>修改</code>了某一个共享变量的值，其他线程是否能够<code>立即</code>知道该变更 ，JMM规定了<code>所有的变量</code>都存储在<code>主内存</code>中。</p>\n</li>\n<li>\n<p>没有可见性，那么会产生的问题是</p>\n<ul>\n<li>\n<p><code>线程脏读</code>问题</p>\n<ul>\n<li>Java中<code>普通的共享变量</code>不保证可见性，因为数据修改<code>被写入内存的时机</code>是不确定的，<code>多线程并发</code>下很可能出现&quot;脏读&quot;，所以每个线程都有自己的工作内存</li>\n<li>线程自己的<code>工作内存</code>中保存了该线程使用到的变量的<code>主内存副本拷贝</code>，线程对变量的所有操作（读取，赋值等 ）都必须在线程自己的工作内存中进行，而不能够直接读写主内存中的变量。</li>\n<li>不同线程之间也<code>无法直接访问</code>对方工作内存中的变量，线程间变量值的<code>传递</code>均需要通过<code>主内存</code>来完成</li>\n<li>复现</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306052333367.png\" alt=\"image-20230605233301227\" style=\"zoom:33%;\">\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"原子性\">原子性</h5>\n<ul>\n<li>一个操作是不可中断的，即多线程环境下，操作不能被其他线程干扰</li>\n</ul>\n<h5 id=\"有序性-2\">有序性</h5>\n<ul>\n<li>\n<p>指令重排</p>\n<blockquote>\n<p>三个层面：</p>\n<ul>\n<li>编译器优化的重排</li>\n<li>指令并行的重排</li>\n<li>内存系统的重排</li>\n</ul>\n</blockquote>\n<ul>\n<li>为了提升性能，编译器和处理器通常会对指令序列进行<code>重新排序</code>。</li>\n<li>Java规范规定JVM线程内部维持<code>顺序化语义</code>，即<code>只要程序</code>的最终结果与它顺序化执行的结果相等，那么指令的执行顺序可以与代码顺序不一致,此过程叫指令的重排序。</li>\n<li>指令重排可以保证<code>串行语义一致</code>，但不能保证在<code>多线程</code>情况下的语义也是一致的，可能产生&quot;脏读&quot;简单说:两行以上不相干的代码在执行的时候有可能先执行的不是第一条，也就是不一定是从上到下顺序执行，执行顺序会被优化。</li>\n</ul>\n</li>\n</ul>\n<p>从源码到最终执行示例图:</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306060002052.png\" alt=\"image-20230606000213005\" style=\"zoom:50%;\">\n<blockquote>\n<p>单线程环境里面确保<code>程序 </code>  <code> 最终执行结果</code> 和 <code>代码</code> <code>顺序执行的结果</code>一致。</p>\n<p>处理器在进行<code>重排序</code>时必须要考虑指令之间的<code>数据依赖性</code></p>\n<p>多线程环境中线程<code>交替执行</code>,由于编译器<code>优化重排的存在</code>，两个线程中使用的变量能否保证一致性是无法确定的,结果无法预测</p>\n<p>所以有时候我们会根据特殊场景业务<code>禁止指令重排</code>从而保证程序执行的有序性</p>\n</blockquote>\n<h4 id=\"多线程对变量的读取过程：\">多线程对变量的读取过程：</h4>\n<blockquote>\n<p>读取过程</p>\n</blockquote>\n<p>由于JVM运行程序的实体是<code>线程</code></p>\n<p>而每个线程<code>创建时JVM</code>都会为其<code>创建一个工作内存</code>(有些地方称为<code>栈空间</code>)，<code>工作内存</code>是每个线程的<code>私有数据区域</code>,而Java内存模型中规定所有变量都<code>存储在主内存</code></p>\n<p>主内存是<code>共享内存区域</code>，所有线程都可以访问，但线程对变量的<code>操作</code>必须在<code>工作内存</code>中进行，</p>\n<p>首先要将变量从主内存拷贝到的线程自己的工作内存空间，然后对变量进行操作，操作完成后再将变量<code>写回</code>主内存，<code>不能直接操作</code>主内存中的变量</p>\n<p>各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过<code>主内存</code>来完成</p>\n<p>JMM定义了线程和主内存之间的抽象关系</p>\n<ul>\n<li>线程之间的共享变量存储在主内存中(从硬件角度来说就是内存条)</li>\n<li>每个线程都有一个私有的本地工作内存，本地<strong>工作内存</strong>中存储了该线程用来<code>读/写共享变量的副本</code>(从硬件角度来说就是CPU的缓存，比如寄存器、L1、L2、L3缓存等)</li>\n</ul>\n<blockquote>\n<p>总结:</p>\n<ul>\n<li>我们定义的所有共享变量都储存在<code>物理主内存</code></li>\n<li>每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本(主内存中该变量的一份拷贝)</li>\n<li>线程对共享变量所有的操作都必须先在线程自己的工作内存中进行后写回主内存，不能直接从主内存中读写(不能越级)</li>\n<li>不同线程之间也无法直接访问其他线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行(同级不能相互访问)</li>\n</ul>\n</blockquote>\n<h4 id=\"先行发生原则-happens-before\"><code>先行发生原则</code> <code>happens-before</code></h4>\n<ul>\n<li>如果一个操作执行的结果需要对另一个操作<code>可见性或者代码重排序</code>那么这两个操作<code>之间</code>必须存在<code>happens-before</code>关系</li>\n</ul>\n<h5 id=\"作用\">作用</h5>\n<ul>\n<li>可以进行判断数据<code>是否存在竞争</code>，<code>线程是否安全</code>的非常有用的手段。</li>\n<li>依赖这个原则，我们可以通过几条简单规则简单直接的<code>判断</code>并发环境下两个操作之间<code>是否可能存在冲突的所有问题</code></li>\n</ul>\n<h5 id=\"总原则\">总原则</h5>\n<ul>\n<li>如果一个操作<code>happens-before</code>另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</li>\n<li>两个操作之间存在<code>happens-before</code>关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照<code>happens-before</code>关系来执行的结果一致，那么这种重排序并不非法。</li>\n</ul>\n<h5 id=\"细分的8条原则\">细分的8条原则</h5>\n<ul>\n<li>\n<p>次序规则<br>\n一个线程内，按照代码顺序，写在前面的操作先行发生于写在后面的操作；(前一个操作的<code>结果</code>可以被后续的操作<code>获取</code>)</p>\n</li>\n<li>\n<p>锁定规则: 锁的获取的先后顺序<br>\n一个<code>unLock</code>操作先行发生于后面对同一个锁的<code>lock</code>操作；(对于同一把锁<code>objectLock</code>，<code>threadA</code>一定先<code>unlock</code>同一把锁后,<code>threadB</code>才能获得该锁， A 先行发生于B)              (这里的“后面”是指时间上的先后)</p>\n</li>\n<li>\n<p><code>volatile</code>变量规则<br>\n对一个<code>volatile</code>变量的写操作先行发生于后面对这个变量的读操作，前面的写对后面的读是可见的，这里的“后面”同样是指时间上的先后。</p>\n</li>\n<li>\n<p>传递规则<br>\n如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</p>\n</li>\n<li>\n<p>线程启动规则(Thread Start Rule)<br>\nThread对象的<code>start()</code>方法先行发生于此线程的每一个动作</p>\n</li>\n<li>\n<p>线程中断规则(Thread Interruption Rule)</p>\n<p>对线程<code>interrupt()</code>方法的调用先行发生于被中断线程的代码<code>检测到中断事件的发生</code>；</p>\n<p>可以通过<code>Thread.interrupted()</code>检测到是否发生中断</p>\n</li>\n<li>\n<p>线程终止规则(Thread Termination Rule)<br>\n线程中的<code>所有操作</code>都<code>先行</code>发生于对此线程的<code>终止检测</code>，</p>\n<p>我们可以通过<code>Thread::join()</code>方法是否结束、<code>Thread::isAlive()</code>的<code>返回值</code>等手段检测线程是否已经终止执行。</p>\n</li>\n<li>\n<p>对象终结规则(Finalizer Rule)<br>\n一个对象的<code>初始化完成</code>（构造函数执行结束）先行发生于它的<code>finalize()</code>方法的开始(对象没有完成初始化之前，是不能调用<code>finalized()</code>方法的)</p>\n</li>\n</ul>\n<blockquote>\n<p><strong>happens-before总结</strong></p>\n<ul>\n<li>在Java 语言里面，<code>Happens-Before</code> 的语义<code>本质上</code>是一种<code>可见性</code></li>\n<li>A Happens-Before B意味着A发生过的事情对B来说是可见的，无论A事件和B事件是否发生在同一个线程里.</li>\n<li>JMM的设计分为两部分:\n<ul>\n<li>一部分是面向我们程序员提供的，也就是<code>happens-before</code>规则，它通俗易懂的向我们程序员阐述了一个<code>强内存模型</code>，我们只要理解<code>happens-before</code>规则，就可以编写并发安全的程序了。</li>\n<li>另一部分是针对JVM实现的，为了尽可能少的对编译器和处理器做约束从而提高性能，JMM在不影响程序执行结果的前提下对其不做要求，即<code>允许优化重排序</code>。</li>\n<li>我们只需要关注前者就好了,也就是理解happens-before规则即可，其它繁杂的内容有JMM规范结合操作系统给我们搞定，我们只写好代码即可。</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"volatile与Java内存模型\">volatile与Java内存模型</h2>\n<h4 id=\"volatile的内存语义\">volatile的内存语义</h4>\n<ul>\n<li>当写一个<code>volatile</code>变量时，JMM会把该线程对应的本地内存中的<code>共享变量值</code> <code>立即刷新回主内存中</code></li>\n<li>当读一个<code>volatile</code>变量时，JMM会把该线程对应的<code>本地内存设置为无效</code>，直接从<code>主内存中读取</code>共享变量</li>\n<li>所以volatile的<code>写内存语义</code>是<code>直接刷新到主内存中</code>，<code>读的内存语义</code>是直接从<code>主内存中读取</code>。</li>\n</ul>\n<blockquote>\n<p>volatile凭什么可以保证可见性和有序性-内存屏障(Memory Barriers / Fences)</p>\n<ul>\n<li>内存屏障: 先行发生原则</li>\n</ul>\n</blockquote>\n<h4 id=\"内存屏障\">内存屏障</h4>\n<blockquote>\n<p>也称内存栅栏，内存栅障，屏障指令等</p>\n</blockquote>\n<ul>\n<li>\n<p>是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作，避免代码重排序。</p>\n</li>\n<li>\n<p>内存屏障其实就是一种JVM指令，Java内存模型的重排规则会要求Java编译器在生成JVM指令时插入特定的内存屏障指令，通过这些内存屏障指令，volatile实现了Java内存模型中的<strong>可见性</strong>和<strong>有序性(禁重排)</strong>，但<code>volatile</code> <code>无法保证原子性</code>。</p>\n</li>\n<li>\n<p><code>内存屏障之前</code>的所有<code>写操作</code>都要回写到主内存</p>\n</li>\n<li>\n<p><code>内存屏障之后</code>的所有<code>读操作</code>都能获得内存屏障之前的所有写操作的<code>最新结果</code>(实现了<code>可见性</code>)。</p>\n</li>\n<li>\n<p>因此<code>重排序时</code>，不允许把内存屏障之后的指令重排序到内存屏障之前。</p>\n</li>\n</ul>\n<blockquote>\n<p>什么是读写屏障</p>\n<ul>\n<li>写屏障(Store Memory Barrier) ：告诉处理器在写屏障之前将所有存储在缓存(store buffer es) 中的数据同步到主内存。也就是说当看到<code>Store</code>屏障指令， 就必须把该指令之前所有写入指令执行完毕才能继续往下执行。</li>\n<li>读屏障(Load Memory Barrier) ：处理器在读屏障之后的读操作， 都在读屏障之后执行。也就是说在<code>Load</code>屏障指令之后就能够保证后面的读取数据指令一定能够读取到最新的数据。</li>\n</ul>\n</blockquote>\n<pre><code>&gt;  对一个 `volatile` 变量的写, 先行发生于任意后续对这个 `volatile` 变量的读，也叫写后读。\n</code></pre>\n<h4 id=\"JVM中提供了四类内存屏障指令\">JVM中提供了四类内存屏障指令</h4>\n<table>\n<thead>\n<tr>\n<th>屏障类型</th>\n<th>指令示例</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>LoadLoad</td>\n<td>Load1;LoadLoad;Load2</td>\n<td>保证<code>load1</code>的读取操作在<code>load2</code>及后续读取操作之前执行==(先读1后读2)==</td>\n</tr>\n<tr>\n<td>StoreStore</td>\n<td>Store1;StoreStore;Store2</td>\n<td>在<code>store2</code>及其后的写操作执行前，保证<code>store1</code>的写操作已刷新到主内存==(先写1后写2)==</td>\n</tr>\n<tr>\n<td>LoadStore</td>\n<td>Load1;LoadStore;Store2</td>\n<td>在<code>stroe2</code>及其后的写操作执行前，保证<code>load1</code>的读操作已读取结束==(先读后写)==</td>\n</tr>\n<tr>\n<td>StoreLoad</td>\n<td>Store1;StoreLoad;Load2</td>\n<td>保证<code>store1</code>的写操作已刷新到主内存之后，<code>load2</code>及其后的读操作才能执行==(先写后读)==</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"JMM-就将内存屏障插⼊策略分为-4-种\">JMM 就将内存屏障插⼊策略分为 4 种</h5>\n<ul>\n<li>写屏障\n<ul>\n<li><code>StoreStore</code> 屏障(写写屏障)     在每个 volatile <code>写操作的前</code>⾯插⼊⼀个 <code>StoreStore</code> 屏障</li>\n<li><code>StoreLoad</code> 屏障(写读屏障)              在每个 <code>volatile 写操作的后</code>⾯插⼊⼀个 <code>StoreLoad</code> 屏障</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306061208438.png\" alt=\"image-20230606120827364\" style=\"zoom:33%;\">\n<ul>\n<li>读屏障\n<ul>\n<li><code>LoadLoad</code> 屏障(读读屏障)              在每个 <code>volatile</code> 读操作的<code>后</code>⾯插⼊⼀个 <code>LoadLoad</code> 屏障</li>\n<li><code>LoadStore</code>屏障(读写屏障)              在每个 <code>volatile</code> 读操作的<code>后</code>⾯插⼊⼀个 <code>LoadStore</code> 屏障</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306061210802.png\" alt=\"image-20230606121028556\" style=\"zoom:33%;\">\n<h4 id=\"volatile特性\">volatile特性</h4>\n<h5 id=\"保证可见性\">保证可见性</h5>\n<p>保证不同线程对这个变量进行操作时的可见性，即变量一旦改变所有线程立即可见</p>\n<blockquote>\n<p><code>volatile</code>的实现功能</p>\n<ul>\n<li>线程中修改了工作内存中的副本之后，<code>立即将其刷新到主内存</code></li>\n<li>工作内存中每次读取共享变量时，都去主内存中重新读取，<code>然后拷贝到工作内存</code></li>\n</ul>\n<p>没有<code>volatile</code>之前,<code>t1</code>线程会看不到主线程 修改的 <code>flag</code> 值</p>\n<ul>\n<li>主线程修改了<code>flag</code>之后没有将其刷新到主内存，所以<code>t1</code>线程看不到。</li>\n<li>主线程将<code>flag</code>刷新到了主内存，但是<code>t1</code>一直读取的是自己工作内存中<code>flag</code>的值，没有去主内存中更新获取<code>flag</code>最新的值</li>\n</ul>\n</blockquote>\n<h5 id=\"volatile变量的读写过程\">volatile变量的读写过程</h5>\n<p>Java内存模型中定义的8种工作内存与主内存之间的原子操作:</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306070042144.png\" alt=\"image-20230607004240806\" style=\"zoom:23%;\">\n<p><strong>read(读取)→load(加载)→use(使用)→assign(赋值)→store(存储)→write(写入)→lock(锁定)→unlock(解锁)</strong></p>\n<ul>\n<li>\n<p>read: 作用于<code>主</code>内存，将变量的值从主内存传输到工作内存，主内存到工作内存</p>\n</li>\n<li>\n<p>load: 作用于<code>工作</code>内存，将read从主内存传输的变量值放入工作内存变量副本中，即数据加载</p>\n</li>\n<li>\n<p>use: 作用于<code>工作</code>内存，将工作内存变量副本的值传递给执行引擎，每当JVM遇到需要该变量的字节码指令时会执行该操作</p>\n</li>\n<li>\n<p>assign: 作用于<code>工作</code>内存，将从执行引擎接收到的值赋值给工作内存变量，每当JVM遇到一个给变量赋值字节码指令时会执行该操作</p>\n</li>\n<li>\n<p>store: 作用于<code>工作</code>内存，将赋值完毕的工作变量的值写回给主内存</p>\n</li>\n<li>\n<p>write: 作用于<code>主</code>内存，将store传输过来的变量值赋值给主内存中的变量<br>\n由于上述6条只能保证<code>单条指令的原子性</code>，但是无法保证多条指令的<code>组合型原子保证</code>，没有大面积加锁，所以，JVM提供了另外两个原子指令:</p>\n</li>\n<li>\n<p>lock: 作用于<code>主</code>内存，将一个变量标记为一个线程独占的状态，只是写时候加锁，就只是锁了写变量的过程。</p>\n</li>\n<li>\n<p>unlock: 作用于<code>主</code>内存，把一个处于锁定状态的变量释放，然后才能被其他线程占用</p>\n</li>\n</ul>\n<h5 id=\"没有原子性\">没有原子性</h5>\n<ul>\n<li>volatile变量的复合操作(如i++)<code>不具有原子性</code></li>\n</ul>\n<blockquote>\n<p>从<code>i++</code>的<code>字节码</code>角度说明</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306061225297.png\" alt=\"image-20230606122500046\" style=\"zoom:50%;\">\n<ul>\n<li>原子性指的是一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响</li>\n<li>i++不具备原子性，该操作是先读取值，然后写回一个新值，相当于原来的值加上1，分3步完成</li>\n<li>如果第二个线程在第一个线程读取旧值和写回新值期间读取i的域值，那么第二个线程就会与第一个线程一起看到同一个值，并执行相同值的加1操作，这也就造成了线程安全失败</li>\n<li>因此对于add方法必须使用synchronized修饰，以便保证线程安全.</li>\n<li>由此可见volatile解决的是变量读时的可见性问题，但无法保证原子性，对于多线程修改共享变量的场景必须使用加锁同步</li>\n</ul>\n<p>从底层来说，<code>i++</code>其实是分了三步的：<em>数据加载</em> 、<em>数据计算</em> 、<em>数据赋值</em> 。而这三步组合起来并非原子操作</p>\n<p>对于volatile变量具备可见性 ，JVM只是保证从主内存加载到线程工作内存的值是<code>最新</code>的，也仅是数据加载时是<code>最新</code>的。</p>\n<p>但是多线程环境下，“数据计算”和“数据赋值”操作可能多次出现，若数据在加载之后，若主内存<code>volatile</code>修饰变量发生修改之后，线程工作内存中的操作将会作废,去读主内存最新值，操作出现写丢失问题。即各线程私有内存和主内存公共内存中变量不同步 ，进而导致数据不一致。</p>\n<p>由此可见volatile解决的是变量读取时的可见性问题，但无法保证原子性，对于多线程修改主内存共享变量的场景必须使用加锁同步。</p>\n</blockquote>\n<p>总结：</p>\n<ul>\n<li>\n<p>对于volatile变量，JVM只是保证从主内存加载到线程工作内存的值是最新的，也只是数据加载时是最新的。</p>\n</li>\n<li>\n<p>但是此时  如果第二个线程在第一个线程<strong>读取旧值</strong>和<strong>写回新值期</strong>间读取i的阈值，也就造成了线程安全问题。</p>\n</li>\n<li>\n<p>既然一修改就是可见，为什么还不能保证原子性？</p>\n</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306061231743.png\" alt=\"image-20230606123126475\" style=\"zoom:33%;\">\n<ul>\n<li>\n<p>要<code>use(使用)</code>一个变量的时候必需<code>load(载入）</code>，要载入的时候必需从主内存<code>read(读取）</code>这样就解决了读的可见性。<code> (load和user关联)</code></p>\n</li>\n<li>\n<p>写操作是把<code>assign</code>和<code>store</code>做了关联(在<code>assign</code>(赋值)后必需<code>store</code>(存储))。<code>store</code>(存储)后<code>write</code>(写入)。也就是做到了给一个变量赋值的时候一串关联指令直接把变量值写到主内存。<code>(assign和store关联)</code></p>\n</li>\n<li>\n<p>就这样<code>用的</code>时候直接从主内存取，在<code>赋值</code>到直接写回主内存就可以保证做到内存可见。注意蓝色框框的间隙(但是<code>use</code>和<code>assign</code>直接仍然有有间隙)</p>\n</li>\n</ul>\n<h5 id=\"结论\">结论:</h5>\n<ul>\n<li>\n<p><code>read-load-use</code> 和 <code>assign-store-write</code> 成为了两个不可分割的原子操作，但是在<code>use</code>和<code>assign</code>之间依然有极小的一段<code>真空期</code>，有可能变量会被其他线程读取，导致写丢失一次</p>\n</li>\n<li>\n<p>但是无论在哪一个时间点主内存的变量和任一工作内存的变量的值都是相等的。这个特性就导致了<code>volatile</code>变量不适合参与到依赖当前值的运算，如i = i + 1; i++;之类的</p>\n</li>\n<li>\n<p>那么依靠可见性的特点volatile可以用在哪些地方呢？<code>通常volatile用做保存某个</code> 状态<code> 的boolean值或者int值</code>。</p>\n</li>\n</ul>\n<blockquote>\n<p>由于volatile变量只能保证可见性，在<code>不符合以下两条规则的运算场景中，我们仍然要通过加锁</code>(使用synchronized、java.util.concurrenti中的锁或原子类)来保证原子性：</p>\n<ul>\n<li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li>\n<li>变量不需要与其他的状态变量共同参与不变约束。</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>什么叫保证有序性</p>\n<ul>\n<li>禁止指令重排\n<ul>\n<li>怎么实现禁止指令重排\n<ul>\n<li>通过内存屏障禁止重排</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>重排序有可能影响程序的执行和实现，</p>\n<p>对于编译器的重排序， JMM会根据重排序的规则， 禁止特定类型的编译器重排序。</p>\n<p>对于处理器的重排序， Java编译器在生成指令序列的适当位置， 插入内存屏障指令， 来禁止特定类型的处理器排序。</p>\n<p>重排序发生场景：</p>\n<ul>\n<li>不存在数据依赖关系，可以重排序；存在数据依赖关系 ，禁止重排序</li>\n</ul>\n<p>重排序的分类和执行流程</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306070051490.png\" alt=\"image-20230607005152427\" style=\"zoom:33%;\">\n<ul>\n<li>编译器优化的重排序： 编译器在不改变单线程串行语义的前提下，可以重新调整指令的执行顺序</li>\n<li>指令级并行的重排序： 处理器使用指令级并行技术来讲多条指令重叠执行，若不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序</li>\n<li>内存系统的重排序： 由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是乱序执行</li>\n<li>数据依赖性 ：若两个操作访问同一变量，且这两个操作中有一个为写操作，此时两操作间就存在数据依赖性。</li>\n</ul>\n</blockquote>\n<h4 id=\"指令禁重排-有序性\">指令禁重排(有序性)</h4>\n<h5 id=\"volatile的底层实现是通过内存屏障\">volatile的底层实现是通过内存屏障</h5>\n<table>\n<thead>\n<tr>\n<th>第一个操作</th>\n<th>第二个操作：普通读写</th>\n<th>第二个操作：volatile读</th>\n<th>第二个操作：volatile写</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>普通读写</td>\n<td>普通读写</td>\n<td>可以重排</td>\n<td>不可以重排</td>\n</tr>\n<tr>\n<td>volatile读</td>\n<td>不可以重排</td>\n<td>不可以重排</td>\n<td>不可以重排</td>\n</tr>\n<tr>\n<td>volatile写</td>\n<td>可以重排</td>\n<td>不可以重排</td>\n<td>不可以重排</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>当第一个操作为<code>volatilei读</code>时，不论第二个操作是什么，都<code>不能重排序</code>。这个操作保证了volatile<code>读之后</code>的操作<code>不会</code>被<code>重排</code>到volatile<code>读之前</code>。<br>\n当第二个操作为volatile写时，不论第一个操作是什么，都<code>不能重排序</code>。这个操作保证了volatile<code>写之前</code>的操作不会被<code>重排</code>到volatile<code>写之后</code>。<br>\n当第一个操作为volatile写时，第二个操作为volatile读时，不能重排。</p>\n</blockquote>\n<h5 id=\"四大屏障的插入情况\">四大屏障的插入情况</h5>\n<ul>\n<li>在每一个<code>volatile</code> <code>写操作前</code>面插入一个<code>StoreStore</code>屏障\n<ul>\n<li>StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作都<code>已经</code>刷新到主内存中。</li>\n</ul>\n</li>\n<li>在每一个<code>volatile </code> <code>写操作后面</code>插入一个<code>StoreLoad</code>屏障\n<ul>\n<li>StoreLoad屏障的作用是避免volatile写与后面可能有的volatile<code>读/写操作重排序</code></li>\n</ul>\n</li>\n<li>在每一个<code>volatile读操作后面</code>插入一个<code>LoadLoad</code>屏障\n<ul>\n<li>LoadLoad屏障用来禁止处理器把上面的volatile读与下面的普通读重排序。</li>\n</ul>\n</li>\n<li>在每一个<code>volatile读操作后面</code>插入一个<code>LoadStore</code>屏障\n<ul>\n<li>LoadStore屏障用来禁止处理器把上面的volatile读与下面的普通写重排序。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>深刻理解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//模拟一个单线程，什么顺序读？什么顺序写？</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">VolatileTest</span> &#123;</span><br><span class=\"line\"> <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"> <span class=\"keyword\">volatile</span> <span class=\"type\">boolean</span> <span class=\"variable\">flag</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">write</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">     i = <span class=\"number\">2</span>;</span><br><span class=\"line\">     flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">read</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(flag)&#123;</span><br><span class=\"line\">         System.out.println(<span class=\"string\">&quot;---i = &quot;</span> + i);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>加上volatile后顺序如下,不加的话可能会重排序,顺序不定</strong></p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306061242595.png\" alt=\"image-20230606124227542\" style=\"zoom:33%;\">\n</blockquote>\n<h5 id=\"如何正确使用volatile-使用场景\">如何正确使用volatile(使用场景)</h5>\n<ul>\n<li>\n<p>单一赋值可以，但是含复合运算赋值不可以(i++之类)          最好是int或者boolean类型</p>\n</li>\n<li>\n<p>状态标志的时候，判断业务是否结束/开始</p>\n</li>\n<li>\n<p>开销较低的读，写锁策略；当读远多于写，结合使用内部锁和 volatile 变量来减少同步的开销（利用volatile保证读取操作的可见性；利用synchronized保证复合操作的原子性）</p>\n</li>\n<li>\n<p>(单例模式)DCL双端锁的发布（双锁检查）</p>\n</li>\n</ul>\n<blockquote>\n<p><font color=\"red\">JVM层面上看待<code>未进行双锁检测</code>时的指令重排的问题:</font></p>\n<p>有问题的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SafeDoubleCheckSingleton</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span>  <span class=\"keyword\">static</span> SafeDoubleCheckSingleton singleton;</span><br><span class=\"line\"> <span class=\"comment\">//私有化构造方法</span></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"title function_\">SafeDoubleCheckSingleton</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"comment\">//双重锁设计</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SafeDoubleCheckSingleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (singleton == <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">         <span class=\"comment\">//1.多线程并发创建对象时，会通过加锁保证只有一个线程能创建对象</span></span><br><span class=\"line\">         <span class=\"keyword\">synchronized</span> (SafeDoubleCheckSingleton.class)&#123;</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (singleton == <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                 <span class=\"comment\">//隐患：多线程环境下，由于重排序，该对象可能还未完成初始化就被其他线程读取</span></span><br><span class=\"line\">                 singleton = <span class=\"keyword\">new</span> <span class=\"title class_\">SafeDoubleCheckSingleton</span>();   </span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"comment\">//2.对象创建完毕，执行getInstance()将不需要获取锁，直接返回创建对象</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>单线程看问题代码–&gt;没问题\n<ul>\n<li>单线程环境下(或者说正常情况下)，在&quot;问题代码处&quot;，会执行如下操作，保证能获取到已完成初始化的实例</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306061248679.png\" alt=\"image-20230606124807628\" style=\"zoom:55%;\">\n<ul>\n<li>由于存在指令重排序… —&gt;多线程看问题代码\n<ul>\n<li>隐患：多线程环境下，在&quot;问题代码处&quot;，会执行如下操作，由于重排序导致2,3乱序，后果就是其他线程得到的是null而不是完成初始化的对象</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306061248295.png\" alt=\"image-20230606124824245\" style=\"zoom:53%;\">\n<p><font color=\"red\">解决方案1:加volatile修饰</font></p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306061252966.png\" alt=\"image-20230606125231911\" style=\"zoom:50%;\">\n<p><font color=\"red\">解决方式2:采用静态内部类的方式实现单例</font></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SingletonDemo</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">SingletonDemo</span><span class=\"params\">()</span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SingletonDemoHandler</span>&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> SingletonDemo instance <span class=\"keyword\">new</span> <span class=\"title class_\">SingletonDemo</span>();</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SingletonDemo <span class=\"title function_\">getInstance</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> SingletonDemoHandler.instance;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>面试八股总结：</p>\n<ul>\n<li>\n<p><code>volatile</code>可见性</p>\n<ul>\n<li><code>volatile</code>关键字保证可见性：\n<ul>\n<li>对一个被<code>volatile</code>关键字修改的变量</li>\n<li>写操作的话，这个变量的最新值会立即刷新回到主内存中</li>\n<li>读操作的话，总是能够读取到这个变量的最新值，也就是这个变量最后被修改的值</li>\n<li>当某个线程收到通知，去读取volatile修饰的变量的值的时候，线程私有工作内存的数据失效，需要重新回到主内存中去读取最新的数据。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><code>volatile</code>没有原子性</p>\n</li>\n<li>\n<p>volatile禁重排</p>\n<ul>\n<li>\n<p>写指令</p>\n<ul>\n<li>\n<p>StoreStore屏障</p>\n</li>\n<li>\n<p>禁止上面的普通写和下面的volatile写操作重排序，前面所有的普通写的操作，数据都已经刷新到主内存，普通写和volatile写禁止重排；volatile写和volatile写禁止重排</p>\n</li>\n<li>\n<p>volatile写操作</p>\n</li>\n<li>\n<p>StoreLoad屏障</p>\n</li>\n<li>\n<p>禁止上面的volatile写和下面的volatile读/写或普通写操作重排序，前面volatile写的操作，数据都已经刷新到主内存，volatile写和普通写禁止重排；volatile写和volatile读/写禁止重排</p>\n</li>\n</ul>\n</li>\n<li>\n<p>读指令</p>\n<ul>\n<li>volatile读操作</li>\n<li>LoadLoad屏障</li>\n<li>禁止下面的普通读、volatile读和上面的volatile读重排序，volatile读和普通读禁止重排；volatile读和volatile读禁止重排</li>\n<li>LoadStore屏障</li>\n<li>禁止上面的volatile读和下面的volatile写或普通写重排序 ，volatile读和普通写禁止重排；volatile读和volatile写禁止重排</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>内存屏障能干嘛？\n<ul>\n<li>阻止<strong>屏障两边的</strong>指令重排序</li>\n<li>写数据时假如屏障，强制将线程私有工作内存的数据刷回主物理内存</li>\n<li>读数据时加入屏障，线程私有工作内存的数据失效，重新到主物理内存中获取最新数据</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>内存屏障是什么？\n<ul>\n<li>内存屏障是一种屏障指令，它使得CPU或编译器对屏障指令的前和后所发出的内存操作执行一个排序的约束。也叫内存栅栏或栅栏指令</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"CAS和原子类\">CAS和原子类</h2>\n<h3 id=\"CAS-2\">CAS</h3>\n<p>在未引入 <code>CAS</code>的时候，通过<code>锁机制 </code> <code>解决基本数据类型的线程安全</code></p>\n<p>引入之后：使用<code>原子类</code>保证线程安全i++（基本数据类型）</p>\n<p><code>CAS</code>-<code>compare and swap</code>的缩写，中文翻译成<strong>比较并交换</strong>；它包含三个操作数——<code>内存位置</code>、<code>预期原值</code>及<code>更新值</code></p>\n<h4 id=\"原理：-2\">原理：</h4>\n<p><code>CAS （CompareAndSwap）</code> CAS有3个操作数，位置内存值V，旧的预期值A，要修改的更新值B。当且仅当旧的预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做或重来</p>\n<blockquote>\n<p>执行CAS操作的时候，将内存位置的值与预期原值比较：</p>\n<ul>\n<li>如果<strong>相匹配</strong>，那么处理器会自动将该位置值<code>更新</code>为新值，</li>\n<li>如果<strong>不匹配</strong>，处理器<code>不做任何操作</code>，多个线程同时执行<strong>CAS操作只有一个会成功</strong>。</li>\n</ul>\n</blockquote>\n<h4 id=\"CAS实现的硬件级别保证\">CAS实现的硬件级别保证</h4>\n<ul>\n<li>CAS是JDK提供的非阻塞原子性操作，它通过硬件保证了<code>比较-更新</code>的原子性。\n<ul>\n<li>它是<code>非阻塞</code>的且自身原子性，效率更高且通过硬件保证，更可靠。</li>\n</ul>\n</li>\n<li>CAS是一条CPU的<code>原子指令</code>（cmpxchg指令-compare and change），不会造成所谓的数据不一致问题，是由Unsafe提供的CAS方法（如compareAndSwapXXX）底层实现即为CPU指令<code>cmpxchg</code>。\n<ul>\n<li>执行cmpxchg指令的时候，会<code>判断当前系统是否为多核系统</code>，\n<ul>\n<li>如果是就给总线加锁，只有一个线程会对总线加锁成功，加锁成功之后会执行cas操作，也就是说CAS的原子性实际上是CPU实现的， 其实在这一点上还是有排他锁的，只是比起用synchronized重锁， 这里的排他时间要短的多， 所以在多线程情况下性能会比较好</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"源码分析compareAndSet-int-expect-int-update\">源码分析compareAndSet(int expect,int update)</h4>\n<ul>\n<li><code>compareAndSet</code> 本质上调用的是<code>Unsafe</code>类的<code>compareAndSwapInt   compareAndSwapLong   compareAndSwapObject 三个的本地方法</code></li>\n</ul>\n<blockquote>\n<p><code>compareAndSet()</code>方法的源代码：<br>\n<code>public final native boolean compareAndswapObject(Object var1,long var2,Object var4,Object var5);</code><br>\n<code>public final native boolean compareAndSwapIntobject var1,long var2,int var4,int var5);</code><br>\n<code>public final native boolean compareAndSwapLong(object var1,long var2,long var4,long var6);</code><br>\n上面三个方法都是类似的，主要对4个参数做一下说明。<br>\n<code>var1:表示要操作的对象 var2:表示要操作对象中属性地址的偏移量 var4:表示需要修改数据的期望的值 var5/var6:表示需要修改为的新值</code></p>\n</blockquote>\n<h6 id=\"对UnSafe的理解\">对UnSafe的理解</h6>\n<ul>\n<li>\n<p>Unsafe是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问，Unsafe相当于一个后门，基于该类可以<code>直接操作</code>特定内存的数据。</p>\n</li>\n<li>\n<p>Unsafe类存在于<code>sun.misc</code>包中，其内部方法操作可以像C的指针一样直接操作内存，因为Java中CAS操作的执行依赖于Unsafe类的方法。</p>\n</li>\n</ul>\n<blockquote>\n<p>注意<code>Unsafe</code>类中的所有方法都是<code>native</code>修饰的，也就是说<code>Unsafe</code>类中的方法都<code>直接调用</code>操作系统底层资源执行相应任务</p>\n</blockquote>\n<ul>\n<li>\n<p>变量<code>valueOffset</code>，表示该变量值在内存中的<strong>偏移地址</strong>，因为Unsafe就是根据内存偏移地址获取数据的。</p>\n</li>\n<li>\n<p>变量<strong>value用volatile修饰，保证了多线程之间的内存可见性</strong>。</p>\n</li>\n</ul>\n<p>我们知道i++线程不安全的，那<code>atomicInteger.getAndIncrement()</code>为什么能够通过CAS保证原子性呢?</p>\n<ul>\n<li>CAS是一条CPU<code>并发原语</code>。它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的。</li>\n<li>AtomicInteger 类主要利用 CAS  + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</li>\n<li>CAS并发原语<code>体现在</code>JAVA语言中就是<code>sun.misc.Unsafe</code>类中的各个方法。</li>\n<li>调用UnSafe类中的CAS方法，JVM会帮我们实现出<code>CAS汇编指令</code>。这是一种<code>完全依赖于硬件的功能</code>，通过它实现了原子操作。</li>\n<li>由于CAS是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，所以不会造成所谓的数据不一致问题。</li>\n</ul>\n<blockquote>\n<h6 id=\"atomicInteger-getAndIncrement-源码分析\"><code>atomicInteger.getAndIncrement()</code>源码分析</h6>\n<p><code>getAndIncrement</code>本质上调用的是unsafe类的<code>getAndAddInt</code>方法;该方法中实现了通过调用<code>unsefe</code>类的<code>compareAndSwapInt</code>本地方法和<code>自旋</code>的方式来实现<code>CAS</code></p>\n</blockquote>\n<p>总结：</p>\n<ul>\n<li>CAS是靠硬件实现的从而在硬件层面提升效率，最底层还是交给硬件来保证原子性和可见性；</li>\n<li>实现方式是基于硬件平台的汇编指令，在intel的CPU中(X86机器上)，使用的是汇编指令<code>cmpxchg</code>指令；</li>\n<li><code>核心思想</code>就是：比较要<code>更新变量的值V和预期值E</code>（compare），相等才会将V的值设为新值N（swap）如果不相等自旋再来。</li>\n</ul>\n<blockquote>\n<p>在哪里用了volatile?</p>\n<ul>\n<li>在<code>AtomicReferenceFieldUpdater</code>中，因为是规定好的必须由<code>volatile</code>修饰的</li>\n<li>还有的话之前我们在<code>DCL</code>单例中，也用了<code>volatile</code>保证了可见性</li>\n</ul>\n</blockquote>\n<h5 id=\"原子引用AtomicReference\">原子引用<code>AtomicReference</code></h5>\n<ul>\n<li>作用是： 让我们自定义的类称为属性时也可以实现原子性</li>\n</ul>\n<h5 id=\"自旋锁：\">自旋锁：</h5>\n<ul>\n<li>\n<p>定义：</p>\n<ul>\n<li>尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，当线程发现锁被占用时，会不断循环判断锁的状态，直到获取。</li>\n</ul>\n</li>\n<li>\n<p>好处</p>\n<ul>\n<li>是减少线程上下文切换的消耗</li>\n</ul>\n</li>\n<li>\n<p>缺点</p>\n<ul>\n<li>是循环会消耗CPU</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"CAS缺点\">CAS缺点</h4>\n<ul>\n<li>循环时间长开销很大\n<ul>\n<li>如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会给CPU带来很大的开销。</li>\n</ul>\n</li>\n<li>ABA问题\n<ul>\n<li>描述\n<ul>\n<li>当线程A获取了原始值后a,此时因为CPU轮训机制或者其他因素导致线程A等待,**线程B拿到这个初始值a修改为b后又再次拿到b修改成了a,**此时线程a等待完成,发现初始值没有发生改变还是a,认为没有其他线程抢占.</li>\n</ul>\n</li>\n<li>解决ABA问题\n<ul>\n<li>版本号时间戳 原子引用(AtomicStampedReference)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"原子类\">原子类</h3>\n<h4 id=\"基本类型原子类\">基本类型原子类</h4>\n<p><code>AtomicInteger\tAtomicBoolean\t AtomicLong</code></p>\n<h5 id=\"常用api\">常用api</h5>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306061452613.png\" alt=\"image-20230606145241450\" style=\"zoom:33%;\">\n<blockquote>\n<p>countDownLatch</p>\n<ul>\n<li>作用：\n<ul>\n<li><code>等待所有子线程</code>都执行完成后再去取值</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h4 id=\"数组类型原子类\">数组类型原子类</h4>\n<p><code>AtomicIntegerArray    AtomicLongArray     AtomicReferenceArray</code></p>\n<blockquote>\n<p>使用举例：</p>\n</blockquote>\n<ul>\n<li><code> AtomicIntegerArray atomicIntegerArray = new AtomicIntegerArray(new int[5]);*//0 0 0 0 0*</code></li>\n</ul>\n<h5 id=\"常用api-2\">常用api</h5>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306061458799.png\" alt=\"image-20230606145819633\" style=\"zoom:33%;\">\n<h4 id=\"引用类型原子类\">引用类型原子类</h4>\n<p><code>AtomicReference     AtomicStampedReference         AtomicMarkableReference</code></p>\n<p>各自的作用：</p>\n<ul>\n<li><code>AtomicReference</code>\t\t\t\t\t\t\t\t\t\t让我们自定义的类称为属性时也可以实现原子性</li>\n<li><code>AtomicStampedReference</code>                         携带版本号的引用类型原子类，可以解决ABA问题</li>\n<li><code>AtomicMarkableReference</code>                      原子更新带有标记位的引用类型对象,解决<code>是否修改过</code>,将<code>状态戳</code>简化为<code>true|false</code></li>\n</ul>\n<h5 id=\"常用api-3\">常用api</h5>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306061505062.png\" alt=\"image-20230606150523898\" style=\"zoom:33%;\">\n<p><code>AtomicStampedReference</code>和<code>AtomicMarkableReference</code>的区别</p>\n<ul>\n<li>他们都解决了ABA的问题</li>\n<li><code>AtomicStampedReference</code>解决了<code>修改过几次</code></li>\n<li><code>AtomicMarkableReference</code>只解决<code>是否</code>修改过,一次性的</li>\n</ul>\n<h4 id=\"对象的属性修改原子类\">对象的属性修改原子类</h4>\n<ul>\n<li>\n<p>目的: 一种线程安全的方式操作非线程安全对象内的某些字段，它是<code>更加细粒度</code>的/影像某个字段，而<code>不用锁住整个对象</code></p>\n</li>\n<li>\n<p>使用：</p>\n<ul>\n<li>\n<p>更新的对象属性必须使用 <code>public volatile </code>修饰符。</p>\n<p>因为对象的属性修改类型原子类都是<code>抽象类</code>，每次使用都必须使用静态方法<code>newUpdater()</code>创建一个更新器，并且需要设置想要更新的类和属性。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><code>AtomicIntegerFieldUpdater       AtomicLongFieldUpdater       AtomicReferenceFieldUpdater</code></p>\n<ul>\n<li>\n<p>AtomicIntegerFieldUpdater<T>                        原子更新对象中<code>int</code>类型字段的值,基于反射的实用程序，可以对指定类的指定的<code>volatile int</code>字段进行原子更新。</T></p>\n</li>\n<li>\n<p>AtomicLongFieldUpdater<T>                            原子更新对象中<code>Long</code>类型字段的值,基于反射的实用程序，可以对指定类的指定的<code>volatile long</code>字段进行原子更新。</T></p>\n</li>\n<li>\n<p>AtomicReferenceFieldUpdater&lt;T,V&gt;               原子更新引用类型字段的值,基于反射的实用程序，可以对指定类的指定的<code>volatile volatile</code>引用原子更新。</p>\n</li>\n</ul>\n<h5 id=\"常用api-4\">常用api</h5>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306061509420.png\" alt=\"image-20230606150932254\" style=\"zoom:33%;\">\n<h4 id=\"原子操作增强类原理深度解析\">原子操作增强类原理深度解析</h4>\n<p><code>DoubleAdder\t\t\t\tDoubleAccumulator\t\t\t\tLongAdder     LongAccumulator </code></p>\n<h5 id=\"LongAdder常用API\">LongAdder常用API:</h5>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306061511162.png\" alt=\"image-20230606151143994\" style=\"zoom:33%;\">\n<p>为什么LongAdder比AtomicLong性能更好</p>\n<ul>\n<li>volatile解决多线程内存不可见问题。对于<code>一写多读</code>，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。</li>\n<li>说明：\n<ul>\n<li>如果是<code>count++</code>操作，使用如下类实现：<code>AtomicInteger count=new AtomicInteger(); count.addAndGet(1);</code></li>\n<li>如果是JDK8,推荐使用<code>LongAdder</code>对象，比<code>AtomicLong</code>性能更好（减少乐观锁的重试次数)。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"longAdder源码分析-为什么这么快\">longAdder源码分析-为什么这么快?</h4>\n<blockquote>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306061515451.png\" alt=\"image-20230606151516287\" style=\"zoom:33%;\">\n</blockquote>\n<ul>\n<li>\n<p><code>longAdder</code>继承于<code>Striped64</code>类,而<code>Striped64</code>又继承于<code>Number</code>类</p>\n</li>\n<li>\n<p><code>Striped64</code>有几个比较重要的成员函数</p>\n<p><code>transient  volatile Cell[] cells;</code>     <code>transient  volatile   long  base;</code></p>\n<ul>\n<li>\n<p><code>Cell[]</code> 是 <code>java.util.concurrent.atomic</code> 下 <code>Striped64</code> 的一个内部类</p>\n</li>\n<li>\n<p><code>Cell[]数组</code>：竞态条件下，累加个各个线程自己的槽<code>Cell[i]</code>中</p>\n</li>\n<li>\n<p><code>base</code>变量：非竞态条件下，直接累加到该变量上</p>\n</li>\n</ul>\n</li>\n<li>\n<p><code>Striped64</code>中一些变量或者方法的定义</p>\n<ul>\n<li><code>base</code>:类似于<code>AtomicLong</code>中全局的<code>value</code>值。在没有竟争情况下数据直接累加到<code>base</code>上，或者<code>cells</code>扩容时，也需要将数据写入到<code>base</code>上</li>\n<li><code>collide</code>:表示扩容意向，false一定不会扩容，true可能会扩容。</li>\n<li><code>cellsBusy</code>:初始化cells或者扩容cells需要获取锁，0：表示无锁状态1：表示其他已经持有了锁</li>\n<li><code>casCellsBusy()</code>:通过CAS操作修改ceIlsBusy的值，CAS成功代表获取锁，true</li>\n<li><code>NCPU</code>:当前计算机CPU数量，Cell数组扩容时会使用到</li>\n<li><code>getProbe()</code>:获取当前线程的hash值</li>\n<li><code>advanceProbe()</code>:重置当前线程的hash值</li>\n</ul>\n</li>\n<li>\n<p><code>Striped64</code>重要的成员函数</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Number of CPUS, to place bound on table size       </span></span><br><span class=\"line\"><span class=\"comment\">// CPU数量，即cells数组的最大长度 </span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">NCPU</span> <span class=\"operator\">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Table of cells. When non-null, size is a power of 2.</span></span><br><span class=\"line\"><span class=\"comment\">//单元格数组|cells数组，为2的幂，2,4,8,16.....，方便以后位运算</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> Cell[] cells;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//基础value值，当并发较低时，只累加该值主要用于没有竞争的情况，通过CAS更新。</span></span><br><span class=\"line\"><span class=\"comment\">//Base value, used mainly when there is no contention, but also as</span></span><br><span class=\"line\"><span class=\"comment\">//a fallback during table initialization races. Updated via CAS.</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> <span class=\"type\">long</span> base;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建或者扩容Cells数组时使用的自旋锁变量调整单元格大小（扩容），创建单元格时使用的锁。</span></span><br><span class=\"line\"><span class=\"comment\">//Spinlock (locked via CAS) used when resizing and/or creating Cells. </span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> <span class=\"type\">int</span> cellsBusy;</span><br></pre></td></tr></table></figure>\n<h5 id=\"longadder-快的原因\"><code>longadder 快的原因</code></h5>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306061520297.png\" alt=\"image-20230606152052128\" style=\"zoom:33%;\">\n<p><code>LongAdder</code>基本思路:</p>\n<ul>\n<li>\n<p>分散热点，将value值分散到一个Cell数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行CAS操作，这样热点就被分散了，冲突的概率就小很多。如果要获取真正的long值，只要将各个槽中的变量值累加返回。</p>\n</li>\n<li>\n<p><code>sum()</code>会将所有Cell数组中的<code>value</code>和<code>base</code>累加作为返回值，核心的思想就是将之前<code>AtomicLong</code>一个value的<code>更新压力分散</code>到多个value中去，从而<code>降级更新热点</code></p>\n</li>\n<li>\n<p>值得一提的是：在高并发情况下，在<code>AtomicLong</code>中，等待的线程会<code>不停的自旋</code>，导致效率比较低；</p>\n</li>\n</ul>\n<h5 id=\"longAdder-increment-源码解读\">==longAdder.increment()源码解读==</h5>\n<p>[参考地址][<a href=\"https://blog.csdn.net/dolpin_ink/article/details/125506217#t24\">https://blog.csdn.net/dolpin_ink/article/details/125506217#t24</a>]</p>\n<p><code>longAdder.increment()本质上是调用了add(1L)</code></p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306061524520.png\" alt=\"image-20230606152407355\" style=\"zoom:33%;\">\n<p>步骤解析:</p>\n<p>如果<code>Cells</code>表为空，尝试用CAS更新base宁段，成功则退出;<br>\n如果<code>Cells</code>表为空，CAS更新base宁段失败，出现竞争,<code>uncontended</code>为true，调用<code>longAccumulate</code>;<br>\n如果<code>Cells</code>表非空，但当前线程映射的楼为空，<code>uncontended</code>为true，调用<code>longAccumulate</code>;<br>\n如果<code>Cells</code>表非空，且前线程映射的槽非空，CAS更新CelI的值，成功则返回，否则，<code>uncontended</code>设为false，调用<code>longAccumulate</code>。</p>\n<p>总结:</p>\n<ol>\n<li>最初无竞争时只更新base</li>\n<li>如果更新base失败后，首次新建一个Cell[]数组</li>\n<li>当多个线程竞争同一个Cell比较激烈时，可能就要对Cell[]扩容</li>\n</ol>\n<h5 id=\"longAccumulate\"><code>longAccumulate</code></h5>\n<p>参数说明：</p>\n<ul>\n<li><code>long x</code>需要增加的值，一般默认都是<code>1</code></li>\n<li><code>LongBinaryOperator fn</code>默认传递的是<code>null</code></li>\n<li><code>wasUncontended</code>竞争标识，如果是false则代表有竞争。只有cells初始化之后，并且当前线程CAS竞争修改失败，才会是false</li>\n</ul>\n<p>源码分析</p>\n<blockquote>\n<p>LongAdder在无竞争的情况，跟AtomicLong一样，对同一个base进行操作，当出现竞争关系时则是采用化整为零的做法，从空间换时间，用一个数组 <code>cell[]</code>，将一个<code>value</code>拆分进这个数组<code>cells</code>。</p>\n<p>多个线程需要同时对value进行操作时候，可以对线程id进行hash得到hash值，再根据hash值映射到这个数组cells的某个下标，再对该下标所对应的值进行自增操作。</p>\n<p>当所有线程操作完毕，将数组cells的所有值和无竞争值base都加起来作为最终结果。</p>\n</blockquote>\n<ul>\n<li><strong>得到线程的hash值：probe</strong></li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306061530318.png\" alt=\"image-20230606153001132\" style=\"zoom:33%;\">\n<ul>\n<li><strong>自旋</strong></li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306061530826.png\" alt=\"image-20230606153041637\" style=\"zoom:33%;\">\n<ul>\n<li>\n<p><strong>case1:cell[]数组已经初始化完成</strong></p>\n<ul>\n<li>\n<p>该阶段总体代码:</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306061531504.png\" alt=\"image-20230606153138323\" style=\"zoom:33%;\">\n</li>\n</ul>\n</li>\n<li>\n<p>该阶段六种情况源码解析</p>\n<ul>\n<li>\n<p>情况一: cells已经被初始化了</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306061532066.png\" alt=\"image-20230606153226885\" style=\"zoom:33%;\">\n<blockquote>\n<p>上面代码判断当前线程hash后指向的数据位置元素是否为空，如果为空则将Cell数据放入数组中，跳出循环。如果不空则继续循环</p>\n</blockquote>\n</li>\n<li>\n<p>情况二: 当前线程竞争失败,wasUncontended设为true继续自旋重试</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306061534358.png\" alt=\"image-20230606153411294\" style=\"zoom:33%;\">\n</li>\n<li>\n<p><strong>情况三: 这时通过CAS操作尝试对当前数中的value值进行累加x操作，x默认为1，如果CAS成功则直接跳出循环。</strong></p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306061534871.png\" alt=\"image-20230606153426804\" style=\"zoom:33%;\">\n</li>\n<li>\n<p><strong>情况四: 判断线程数是否大于cpu核数最大数量(n大于cpu核数最大数量不允许扩容)</strong></p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306061534574.png\" alt=\"image-20230606153436379\" style=\"zoom:33%;\">\n</li>\n<li>\n<p><strong>情况五: 当前线程下数组长度小于CPU核数并且数组未扩容</strong></p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306061534008.png\" alt=\"image-20230606153453944\" style=\"zoom:33%;\">\n</li>\n</ul>\n</li>\n<li>\n<p><strong>情况六: 扩容操作,扩容原来两倍</strong></p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306061535977.png\" alt=\"image-20230606153504910\" style=\"zoom:33%;\">\n</li>\n</ul>\n<blockquote>\n<p>总结</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306061535622.png\" alt=\"image-20230606153547450\" style=\"zoom: 33%;\">\n</blockquote>\n<ul>\n<li><strong>case2:cell[]数组未初始化(首次新建)</strong>\n<ul>\n<li>未初始化过<code>Cell[]</code>数组，尝试占有锁并首次初始化cells数组</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306061536718.png\" alt=\"image-20230606153630658\" style=\"zoom:33%;\">\n<ul>\n<li>\n<p><strong>case3:cell[]数组正在初始化中</strong></p>\n<ul>\n<li>\n<p>多个线程尝试CAS修改失败的线程会走到这个分支</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306061536259.png\" alt=\"image-20230402110117975\" style=\"zoom: 50%;\">\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"sum方法\"><code>sum方法</code></h5>\n<ul>\n<li>\n<p><code>sum()</code>会将所有Cell数组中的<code>value</code>和<code>base</code>累加作为返回值。</p>\n<ul>\n<li>核心的思想:就是将之前<code>AtomicLong</code>一个<code>value</code>的更新压力分散到多个value中去，从而降级更新热点。</li>\n</ul>\n</li>\n<li>\n<p>sum执行时，并<code>没有限制</code>对base和cells的更新(一句要命的话)。所以<code>LongAdder</code>不是强一致性的，它是最终一致性的。</p>\n<ul>\n<li>首先，最终返回的sum局部变量，初始被复制为base，而最终返回时，很可能base已经被更新了，而此时局部变量sum不会更新，造成不一致。</li>\n<li>其次，这里对cell的读取也无法保证是最后一次写入的值。所以，sum方法在没有并发的情况下，可以获得正确的结果。</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306061542692.png\" alt=\"image-20230606154211509\" style=\"zoom:33%;\">\n<h5 id=\"volatile的使用场景\">volatile的使用场景</h5>\n<ul>\n<li>对象的属性修改原子类更新的对象属性必须使用 <code>public volatile</code> 修饰符。</li>\n<li>双端解锁的单例模式</li>\n</ul>\n<blockquote>\n<h5 id=\"LongAdder-和AtomicLong-的对比\"><code>LongAdder</code> 和<code>AtomicLong</code> 的对比</h5>\n<p><code>AtomicLong</code></p>\n<ul>\n<li>\n<p>线程安全，可允许一些性能损耗，要求高精度时可使用,保证精度，性能代价</p>\n</li>\n<li>\n<p>是多个线程针对单个热点值value进行原子操作</p>\n</li>\n</ul>\n<p><code>LongAdder</code></p>\n<ul>\n<li>\n<p>当需要在高并发下有较好的性能表现，且对值的精确度要求不高时，可以使用,保证性能，精度代价</p>\n</li>\n<li>\n<p>LongAdder是每个线程拥有自己的槽，各个线程一般只对自己槽中的那个值进行CAS操作</p>\n</li>\n</ul>\n<p><code>AtomicLong</code></p>\n<ul>\n<li>\n<p>原理</p>\n<ul>\n<li>\n<p>CAS+自旋</p>\n</li>\n<li>\n<p><code>incrementAndGet</code></p>\n</li>\n</ul>\n</li>\n<li>\n<p>场景</p>\n<ul>\n<li>低并发下的全局计算 (AtomicLong能保证并发情况下计数的准确性，其内部通过CAS来解决并发安全性的问题)</li>\n</ul>\n</li>\n<li>\n<p>缺陷</p>\n<ul>\n<li>高并发后性能急剧下降\n<ul>\n<li>why\n<ul>\n<li>AtomicLong的<code>自旋</code>会称为瓶颈（N个线程CAS操作修改线程的值，每次只有一个成功过，其它N - 1失败，失败的不停的自旋直到成功，这样大量失败自旋的情况，一下子cpu就打高了。）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><code>LongAdder</code></p>\n<ul>\n<li>\n<p>原理</p>\n<ul>\n<li>CAS+Base+Cell数组分散</li>\n<li>空间换时间并分散了热点数据</li>\n</ul>\n</li>\n<li>\n<p>场景</p>\n<ul>\n<li>高并发的全局计算</li>\n</ul>\n</li>\n<li>\n<p>缺陷</p>\n<ul>\n<li>sum求和后还有计算线程修改结果的话，最后结果不够准确</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"ThreadLocal线程局部变量\">ThreadLocal线程局部变量</h2>\n<ul>\n<li>是什么</li>\n</ul>\n<p><code>ThreadLocal</code>为线程提供局部变量。这些变量与正常的变量不同，因为每一个线程在访问ThreadLocal实例的时候（通过其get或set方法）都有自己的、独立初始化的变量副本。ThreadLocal实例通常是类中的私有静态字段，使用它的目的是希望将状态（例如，用户ID或事务ID）与线程关联起来。</p>\n<ul>\n<li>作用</li>\n</ul>\n<p>使得每一个线程都有自己专属的本地变量副本，主要<strong>解决了让每个线程绑定自己的值，通过使用get()和set()方法，获取默认值或将其值更改为当前线程所存的副本的值从而避免了线程安全问题。</strong></p>\n<h4 id=\"API-2\">API</h4>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306061602378.png\" alt=\"image-20230606160202201\" style=\"zoom:33%;\">\n<p>之前： 未使用  <code>ThreadLocal</code>之前解决线程安全的问题</p>\n<ul>\n<li><code>synchronized</code>加锁的方式来解决并发问题</li>\n</ul>\n<p>现在： 使用  <code>ThreadLocal</code>之前解决线程安全的问题</p>\n<ul>\n<li>不加锁同样也可以解决线程安全问题</li>\n</ul>\n<h4 id=\"创建方式\">创建方式</h4>\n<ul>\n<li>方式一：<code>new ThreadLocal&lt;&gt;()</code>这种方式需要以匿名内部类的方式重写<code>initialValue</code>方法初始化值&lt;<code>initialValue()</code>这个api已经淘汰了&gt;</li>\n<li>方式二：<code>ThreadLocal.withInitial(() -&gt; 0);</code>这种方式直接用<code>lambda</code>表达式的方式初始化值 并且 <code>withInitial</code>是静态方法</li>\n</ul>\n<p><code>ThreadLocal</code>类与<code>Synchonized</code>对象锁的异同</p>\n<ul>\n<li>\n<p>相同点</p>\n<ul>\n<li><code>ThreadLocal</code>和<code>Synchonized</code>都用于解决多线程并发访问</li>\n</ul>\n</li>\n<li>\n<p>不同点:</p>\n<ul>\n<li><code>synchronized</code>是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问,用于在多个线程间通信时能够获得数据共享。</li>\n<li>ThreadLocal为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象，隔离了多个线程对数据的数据共享。</li>\n</ul>\n</li>\n<li>\n<p>ThreadLocal总结:</p>\n<ul>\n<li>每个 Thread 内有自己的<code>实例副本</code>且该副本<code>只由</code>当前线程自己使用</li>\n<li>其它 线程 不可访问本线程的变量，就<code>不存在多线程间</code>共享的问题</li>\n<li>可以统一设置初始值，但是每个线程对这个值的修改都是各自线程互相独立的</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>必须回收自定义的<code>ThreadLocal</code>变量，尤其在<strong>线程池场景</strong>下，线程经常会被<strong>复用</strong>，如果不清理自定义的<code>ThreadLocal</code>变量，可能会影响后序业务逻辑和造成<strong>内存泄露</strong>等问题。尽量在代理中使用<code>try-finally</code>块进行回收。</p>\n<p>为什么需要使用remove方法</p>\n<p><strong>如果<code>ThreadLocal</code>在线程复用的情况下执行完成后<code>不</code>进行<code>remove</code>,那么当该线程再次拿到任务时,上一次的<code>ThreadLocal</code>还在该线程中,出现如下效果,<code>数字越来越大</code>,最后<code>极端情况线程会爆</code></strong></p>\n</blockquote>\n<h4 id=\"ThreadLocal源码分析-Thread，ThreadLocal，ThreadLocalMap-关系\">ThreadLocal源码分析-Thread，ThreadLocal，ThreadLocalMap 关系</h4>\n<p>[源码分析][<a href=\"https://blog.csdn.net/dolpin_ink/article/details/125840626#t12\">https://blog.csdn.net/dolpin_ink/article/details/125840626#t12</a>]</p>\n<ul>\n<li>每个Thread对象自带一个ThreadLocalMap</li>\n<li><code>Thread</code>是程序中执行的线程；<code>ThreadLocal</code>类提供线程 局部变量</li>\n<li><code>ThreadLocalMap</code>是<code>ThreadLocal</code>的<code>静态内部类</code></li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306061644156.png\" alt=\"image-20230606164429978\" style=\"zoom:33%;\">\n<blockquote>\n<ul>\n<li>\n<p><code>ThreadLocalMap</code>从字面上就可以看出这是一个保存<code>ThreadLocal</code>对象的<code>map</code>(其实是以<code>ThreadLocal</code>为<code>Key</code>),不过是经过了两层包装的<code>ThreadLocal</code>对象</p>\n<ul>\n<li>\n<p>第一层包装是使用 <code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt; </code>将<code>ThreadLocal</code>对象变成一个弱引用的对象；</p>\n</li>\n<li>\n<p>第二层包装是定义了一个专门的类 <code>Entry</code> 来扩展<code> WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code>：</p>\n</li>\n</ul>\n</li>\n<li>\n<p><code>threadLocalMap</code>实际上就是一个以<code>threadLocal</code>实例为<code>key</code>，任意对象为<code>value</code>的<code>Entry</code>对象。</p>\n</li>\n<li>\n<p>当我们为<code>threadLocal</code>变量赋值，实际上就是以当前<code>threadLocal</code>实例为<code>key</code>，值为<code>value</code>的<code>Entry</code>往这个<code>threadLocalMap</code>中存放</p>\n</li>\n<li>\n<p>JVM内部维护了一个线程版的<code>Map&lt;Thread,T&gt;</code>(通过ThreadLocal对象的set方法，结果把ThreadLocal对象自己当做key，放进了ThreadLoalMap中),每个线程要用到这个T的时候，用当前的线程去Map里面获取，通过这样让每个线程都拥有了自己独立的变量，竞争条件被彻底消除，在并发模式下是绝对安全的变量</p>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>三者之间的关系</p>\n</blockquote>\n<ul>\n<li>每个<code>Thread</code>对象维护着一个<code>ThreadLocalMap</code>的引用</li>\n<li><code>ThreadLocalMap</code>是<code>ThreadLocal</code>的内部类，用<code>Entry</code>来进行存储</li>\n<li>调用<code>ThreadLocal</code>的<code>set()</code>方法时，实际上就是往<code>ThreadLocalMap</code>设置值，<code>key</code>是<code>ThreadLocal</code>对象，值<code>Value</code>是传递进来的对象</li>\n<li>调用<code>ThreadLocal</code>的<code>get()</code>方法时，实际上就是往<code>ThreadLocalMap</code>获取值，<code>key</code>是<code>ThreadLocal</code>对象</li>\n<li><code>ThreadLocal</code>本身并不存储值，它只是自己作为一个<code>key</code>来让线程从<code>ThreadLocalMap</code>获取<code>value</code>，正因为这个原理，所以<code>ThreadLocal</code>能够实现<code>数据隔离</code>，获取当前线程的局部变量值，不受其他线程影响</li>\n</ul>\n<h4 id=\"ThreadLocal内存泄露问题\">ThreadLocal内存泄露问题</h4>\n<p>什么是内存泄漏?</p>\n<ul>\n<li>不再会被使用的对象或者变量<code>占用的内存不能被回收</code>，就是内存泄露</li>\n</ul>\n<p>为什么会导致内存泄漏?</p>\n<ul>\n<li><code>ThreadLocalMap</code> 中有一个静态内部类<code>Entry</code> ,而这个类继承了<code>弱引用</code>,那么这个类的实例对象就是<code>弱引用</code>的</li>\n</ul>\n<h4 id=\"强引用、软引用、弱引用、虚引用分别是什么？\">强引用、软引用、弱引用、虚引用分别是什么？</h4>\n<h5 id=\"强引用-默认支持模式\">强引用(默认支持模式)</h5>\n<ul>\n<li>\n<p>当内存不足，JVM开始垃圾回收，对于强引用的对象，==就算是出现了OOM也不会对该对象进行回收。==因此<code>强引用</code>是造成Java<code>内存泄漏</code>的主要原因之一。</p>\n</li>\n<li>\n<p>强引用是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。在 Java 中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到JVM也不会回收。因此强引用是造成Java内存泄漏的主要原因之一</p>\n</li>\n<li>\n<p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，一般认为就是<code>可以被垃圾收集</code>的了(当然具体回收时机还是要看垃圾收集策略)。</p>\n</li>\n</ul>\n<h5 id=\"软引用\">软引用</h5>\n<ul>\n<li>\n<p>软引用是一种相对强引用弱化了一些的引用，需要用<code>java.lang.ref.SoftReference</code>类来实现，可以让对象减少一些垃圾收集。</p>\n</li>\n<li>\n<p>对于只有软引用的对象来说，当系统内存充足时它 <strong>不会</strong> 被回收，当系统内存不足时它 <strong>会</strong> 被回收。</p>\n</li>\n<li>\n<p>软引用通常用在对内存敏感的程序中，比如高速缓存就有用到软引用，内存够用的时候就保留，不够用就回收！</p>\n</li>\n</ul>\n<h5 id=\"弱引用\">弱引用</h5>\n<ul>\n<li>\n<p>弱引用需要用java.lang.ref.WeakReference类来实现，它比软引用的生存期更短，</p>\n</li>\n<li>\n<p>对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，都会回收该对象占用的内存。</p>\n</li>\n</ul>\n<h5 id=\"虚引用\">虚引用</h5>\n<ul>\n<li>\n<p><strong>虚引用必须和引用队列 (ReferenceQueue)联合使用</strong></p>\n<ul>\n<li>与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收，它不能单独使用也不能通过它访问对象，虚引用必须和引用队列 (ReferenceQueue)联合使用。</li>\n</ul>\n</li>\n<li>\n<p><strong>get方法总是返回null</strong></p>\n<ul>\n<li>虚引用的主要作用是跟踪对象被垃圾回收的状态。 仅仅是提供了一种确保对象被 finalize以后，做某些事情的机制。 <code>PhantomReference</code>的get方法总是返回null，因此无法访问对应的引用对象。</li>\n</ul>\n</li>\n<li>\n<p>其意义在于：说明一个对象已经进入<code>finalization</code>阶段，可以被<code>gc回收</code>，用来实现比<code>finalization</code>机制更灵活的回收操作。</p>\n</li>\n</ul>\n<h5 id=\"ThreadLocalMap源码中为什么要使用弱引用\"><code> ThreadLocalMap</code>源码中为什么要使用弱引用?</h5>\n<ul>\n<li>\n<p>当方法执行完毕后，栈帧销毁<code>强引用</code> t1 也就没有了。但此时线程的<code>ThreadLocalMap</code>里某个<code>entry</code>的<code>key</code>引用还指向这个对象</p>\n<ul>\n<li>若这个<code>key</code>引用是<code>强</code>引用，就会导致<code>key</code>指向的<code>ThreadLocal</code>对象及指向的对象不能<code>被gc回收</code>，造成内存泄漏；</li>\n<li>若这个<code>key</code>引用是<code>弱</code>引用就大概率会减少内存泄漏的问题(但还有一个key为null的雷)。使用弱引用，就可以使ThreadLocal对象在方法执行完毕后顺利被回收且Entry的key引用指向为null。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"弱引用会产生key为null的-脏Entry\">弱引用会产生key为null的-脏Entry</h5>\n<ul>\n<li>\n<p>产生原因</p>\n<ul>\n<li>\n<p>当我们为threadLocal变量赋值，实际上就是当前的Entry(threadLocal实例为key，值为value)往这个threadLocalMap中存放。Entry中的key是弱引用，当threadLocal外部强引用被置为null(tl=null),那么系统 GC 的时候，根据可达性分析，这个threadLocal实例就没有任何一条链路能够引用到它，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：<code>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</code>永远无法回收，造成内存泄漏。</p>\n<p>当然，如果当前thread运行结束，threadLocal，threadLocalMap,Entry没有引用链可达，在垃圾回收的时候都会被系统进行回收。</p>\n<p>但在实际使用中我们有时候会用线程池去维护我们的线程，比如在Executors.newFixedThreadPool()时创建线程的时候，为了复用线程是不会结束的，所以threadLocal内存泄漏就值得我们小心</p>\n</li>\n</ul>\n</li>\n<li>\n<p>解决方案:</p>\n<ul>\n<li>\n<p>此后我们调用get,set或remove方法时，就会尝试删除key为null的entry，可以释放value对象所占用的内存。</p>\n<p>虽然弱引用，保证了key指向的ThreadLocal对象能被及时回收，但是v指向的value对象是需要ThreadLocalMap调用get、set时发现key为null时才会去回收整个entry、value，因此弱引用不能100%保证内存不泄露。我们要在不使用某个ThreadLocal对象后，手动调用remove方法来删除它，尤其是在线程池中，不仅仅是内存泄露的问题，因为线程池中的线程是重复使用的，意味着这个线程的ThreadLocalMap对象也是重复使用的，如果我们不手动调用remove方法，那么后面的线程就有可能获取到上个线程遗留下来的value值，造成bug。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"key为null的entry，原理解析\">key为null的entry，原理解析</h5>\n<ul>\n<li>在不使用某个<code>ThreadLocal</code>对象后，手动调用<code>remove</code>方法来删除它（尤其是防止线程池下的复用）</li>\n<li><code>ThreadLocalMap</code>使用<code>ThreadLocal</code>的弱引用作为<code>key</code>，如果一个<code>ThreadLocal</code>没有外部强引用引用他，那么系统<code>gc</code>的时候，这个<code>ThreadLocal</code>势必会被回收，这样一来，<code>ThreadLocalMap</code>中就会出现<code>key</code>为<code>null</code>的<code>Entry</code>，就没有办法访问这些key为null的Entry的value，</li>\n<li>如果当前线程再迟迟不结束的话(比如正好用在线程池)，这些key为null的Entry的value就会一直存在一条强引用链。</li>\n<li>虽然弱引用，保证了key指向的ThreadLocal对象能被及时回收，但是<code>v</code>指向的value对象是需要<code>ThreadLocalMap</code>调用<code>get、set</code>时发现<code>key</code>为<code>null</code>时才会去回收整个<code>entry、value</code>，因此弱引用不能100%保证内存不泄露。</li>\n<li>我们要在不使用某个<code>ThreadLocal</code>对象后，手动调用方法来删除它，尤其是在线程池中，不仅仅是内存泄露的问题，因为线程池中的线程是重复使用的，意味着这个线程的<code>ThreadLocalMap</code>对象也是重复使用的，如果我们不手动调用<code>remove</code>方法，那么后面的线程就有可能获取到上个线程遗留下来的<code>value</code>值，造成<code>bug</code></li>\n</ul>\n<h5 id=\"set、get方法会去检查所有键为null的Entry对象如何实现\">set、get方法会去检查所有键为null的Entry对象如何实现</h5>\n<blockquote>\n<p>这些方法都对key== null 也就是脏Entry进行了处理，防止内存泄漏</p>\n</blockquote>\n<h5 id=\"为什么调用get-set或remove方法时，就会尝试删除key为null的entry，可以释放value对象所占用的内存\">为什么调用<code>get,set或remove</code>方法时，就会尝试删除key为null的entry，可以释放value对象所占用的内存?</h5>\n<ul>\n<li>\n<p>从<code>set,getEntry,remove</code>方法看出，在<code>threadLocal</code>的生命周期里，针对threadLocal<code>存在的内存泄漏</code>的问题，都会通过<code>expungeStaleEntry</code>，<code>cleanSomeSlots</code>,<code>replaceStaleEntry</code>这三个方法<code>清理掉</code>key为null的脏entry。</p>\n</li>\n<li>\n<p>实现方法</p>\n<ul>\n<li>\n<p>前置方法-<code>cleanSomeSlots</code>方法</p>\n<ul>\n<li>\n<p>判断Entry的key值是否为空,为空即调用<code>expungeStaleEntry</code>方法，清空为key为null的value</p>\n</li>\n<li>\n<p>前置方法-<code>expungeStaleEntry</code>方法<br>\n清空key值和value值</p>\n</li>\n</ul>\n</li>\n<li>\n<p>set方法</p>\n<ul>\n<li>set(T value)–&gt;set(ThreadLocal&lt;?&gt; key, Object value)–&gt;replaceStaleEntry–&gt;cleanSomeSlots–&gt;expungeStaleEntry</li>\n</ul>\n</li>\n<li>\n<p>get方法</p>\n<ul>\n<li>get()–&gt;getEntry–&gt;getEntryAfterMiss–&gt;expungeStaleEntry</li>\n</ul>\n</li>\n<li>\n<p>remove方法</p>\n<ul>\n<li>remove(ThreadLocal&lt;?&gt; key)–&gt;expungeStaleEntry</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"使用建议\">使用建议</h4>\n<ul>\n<li>\n<p>创建 <code>ThreadLocal threadLocalField=ThreadLocal.withInitial(()-&gt;初始化值);</code>，一定要进行初始化<code>避免</code><strong>空指针问题</strong></p>\n</li>\n<li>\n<p>建议将 <code>ThreadLocal</code>修饰为<code>static</code></p>\n</li>\n<li>\n<p>用完记得手动remove</p>\n</li>\n</ul>\n<blockquote>\n<p><code>ThreadLocal</code>能实现了线程的<code>数据隔离</code>，<code>不在于</code>它自己本身，<code>而在于</code>Thread的<code>ThreadLocalMap</code>所以，ThreadLocal可以只初始化一次，只分配一块存储空间就足以了，没必要作为成员变量多次被初始化。</p>\n</blockquote>\n<h4 id=\"总结-2\">总结</h4>\n<ul>\n<li><code>ThreadLocal</code> 并不解决线程间共享数据的问题</li>\n<li><code>ThreadLocal</code> 适用于<code>变量</code>在线程间隔离且在方法间共享的场景</li>\n<li><code>ThreadLocal</code> 通过隐式的在不同线程内创建独立实例副本避免了实例线程安全的问题</li>\n<li>每个线程持有一个只属于自己的专属<code>Map</code>并维护了<code>ThreadLocal</code>对象与具体实例的映射，该<code>Map</code>由于只被持有它的线程访问，故不存在线程安全以及锁的问题</li>\n<li><code>ThreadLocalMap</code>的<code>Entry</code>对<code>ThreadLocal</code>的引用为弱引用，避免了<code>ThreadLocal</code>对象无法被回收的问题</li>\n<li>都会通过<code>expungeStaleEntry，cleanSomeSlots,replaceStaleEntry</code>这三个方法回收键为 <code>null</code> 的 <code>Entry</code> 对象的值（即为具体实例）以及 <code>Entry</code> 对象本身从而防止内存泄漏，属于安全加固的方法</li>\n</ul>\n<h2 id=\"Java对象内存布局和对象头-2\">Java对象内存布局和对象头</h2>\n<ul>\n<li>在HotSpot虚拟机里，对象在<code>堆内存</code>中的存储布局可以划分为三个部分:<code>对象头(Header）</code>、<code>实例数据（Instance Data）</code>和<code>对齐填充(Padding)</code>（保证8个字节的倍数） 。\n<ul>\n<li><strong>对象头</strong>分为**对象标记（markOpp）**和 <strong>类元信息 (klassOop)</strong>\n<ul>\n<li><strong>类元信息</strong>存储的是指向该对象类元数据（klass）的首地址,其实可以说是<strong>模板</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>数组对象的对象头比常规对象多一个<code>length</code>,用于<code>记录数组长度</code></p>\n</blockquote>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306061709718.png\" alt=\"image-20230606170922562\" style=\"zoom:33%;\">\n<blockquote>\n<p><code>对象布局、GC回收和后面的锁升级</code>实际上就是对象标记<code>MarkWord</code>里面<code>标志位的变化</code></p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306061712324.png\" alt=\"image-20230606171229273\" style=\"zoom:33%;\">\n</blockquote>\n<p>对象头多大?</p>\n<ul>\n<li>在64位系统中，Mark Word占了8个字节，类型指针占了8个字节，一共是16个字节。</li>\n</ul>\n<p>实例数据</p>\n<ul>\n<li><strong>存放类的属性(Field)数据信息，包括父类的属性信息</strong></li>\n</ul>\n<p>对齐填充</p>\n<ul>\n<li>填充数据不是必须存在的，仅仅是为了字节对齐,这部分内存按8字节补充对齐。</li>\n</ul>\n<h2 id=\"Synchronized与锁升级\">Synchronized与锁升级</h2>\n<h4 id=\"synchronized-锁优化的背景\">synchronized 锁优化的背景</h4>\n<ul>\n<li><code>用锁</code>能够实现数据的<strong>安全性</strong>，但是会带来<strong>性能下降</strong>。</li>\n<li><code>无锁</code>能够基于线程并行提升程序性能，但是会带来<strong>安全性下降</strong>。</li>\n</ul>\n<p>为求平衡，将<code>synchronized</code>优化为不在是<code>无锁</code>和<code>重锁</code>两个状态,新增<code>偏向锁</code>和<code>轻量级锁</code>来平衡安全性和性能问题</p>\n<blockquote>\n<p>锁升级的过程</p>\n</blockquote>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306061744465.png\" alt=\"image-20230606174440288\" style=\"zoom:33%;\">\n<p>重量级锁为什么比较消耗性能?</p>\n<ul>\n<li>重量级锁涉及到<code>用户态</code>和<code>内核态</code>之间的切换</li>\n</ul>\n<p>为什么每一个对象都可以成为一个锁？</p>\n<ul>\n<li><code>Monitor</code>可以理解为一种<code>同步工具</code>，也可理解为一种同步机制，常常被描述为<code>一个Java对象</code>。Java对象是天生的<code>Monitor</code>，每一个Java对象都有成为<code>Monitor</code>的潜质，因为在Java的设计中 ，每一个Java对象都是有一把锁的，它叫做内部锁或者Monitor锁。</li>\n<li><code>Monitor</code>的本质是依赖于底层操作系统的==Mutex Lock==实现，操作系统实现线程之间的切换需要从<code>用户态到内核态</code>的转换，成本非常高。</li>\n</ul>\n<p><code>Monitor</code>与<code>java</code>对象以及线程是如何关联</p>\n<ul>\n<li>\n<p>如果一个java对象被某个线程锁住，则该java对象的<code>Mark Word</code>字段中<code>LockWord</code>指向<code>monitor</code>的起始地址</p>\n</li>\n<li>\n<p>Monitor的<strong>Owner字段会存放拥有相关联对象锁的线程id</strong></p>\n</li>\n</ul>\n<p>多线程访问的4种情况：</p>\n<ol>\n<li>所有线程都可以来访问 ----&gt;无锁</li>\n<li>只有一个线程来访问，有且唯一Only One —&gt;偏向锁</li>\n<li>有2个线程A、B来交替访问 —&gt;轻量锁</li>\n<li>竞争激烈，多个线程来访问 —&gt;重锁</li>\n</ol>\n<p>锁的指向</p>\n<ul>\n<li>偏向锁:MarkWord存储的是<strong>偏向的线程ID</strong></li>\n<li>轻量锁:MarkWord存储的是<strong>指向线程栈中Lock Record的指针</strong></li>\n<li>重量锁:MarkWord存储的是<strong>指向堆中的monitor对象的指针</strong></li>\n</ul>\n<h4 id=\"偏向锁：\">偏向锁：</h4>\n<p>[参考地址1][<a href=\"https://blog.csdn.net/dolpin_ink/article/details/126491185#t28\">https://blog.csdn.net/dolpin_ink/article/details/126491185#t28</a>]</p>\n<p>[参考地址2][<a href=\"https://www.yuque.com/gongxi-wssld/csm31d/cwpdcrqqy3r8mhyd\">https://www.yuque.com/gongxi-wssld/csm31d/cwpdcrqqy3r8mhyd</a>]</p>\n<ul>\n<li>如果锁总是被第一个占用他的线程拥有，这个线程就是锁的偏向线程。</li>\n<li>那么只需要在锁第一次被拥有的时候，记录下偏向线程ID。这样偏向线程就一直持有着锁(后续这个线程进入和退出这段加了同步锁的代码块时，不需要再次加锁和释放锁。而是直接比较对象头里面是否存储了指向当前线程的偏向锁)。\n<ul>\n<li>如果相等表示偏向锁是偏向于当前线程的，就不需要再尝试获得锁了，**直到竞争发生才释放锁。**以后每次同步，检查锁的偏向线程ID与当前线程ID是否一致，如果一致直接进入同步。无需每次加锁解锁都去<code>CAS</code>更新对象头。如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。</li>\n<li>如果不一致意味着发生了竞争，锁已经不是总是偏向于同一个线程了，这时候可能需要升级变为轻量级锁，才能保证线程间公平竞争锁。偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的。\n<ul>\n<li><strong>竞争成功</strong>，表示之前的线程不存在了，MarkWord里面的线程1D为新线程的ID，锁不会升级，仍然为偏向锁；</li>\n<li><strong>竞争失败</strong>，这时候可能需要升级变为轻量级锁，才能保证线程间公平竞争锁。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>注意，偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的。</strong></p>\n<h5 id=\"作用：\">作用：</h5>\n<ul>\n<li>当一段同步代码一直被同一个线程多次访问，由于只有一个线程那么该线程在后续访问时便会自动获得锁</li>\n</ul>\n<h5 id=\"偏向锁的撤销–开始有第2个线程来抢夺了\">偏向锁的撤销–开始有第2个线程来抢夺了</h5>\n<ul>\n<li>偏向锁使用一种等到<strong>竞争出现才释放锁的机制</strong>，只有当其他线程竞争锁时，持有偏向锁的原来线程才会被撤销。</li>\n<li>竞争线程尝试CAS更新对象头失败，**会等待到全局安全点（此时不会执行任何代码,类似JVM垃圾搜集的STW）撤销偏向锁。**同时检查持有偏向锁的线程是否还在执行</li>\n</ul>\n<p>流程：</p>\n<ul>\n<li>第一个线程正在执行<code>synchronized</code>方法(处于同步块)，它还没有执行完，其它线程来抢夺，该偏向锁会被取消掉并出现锁升级。\n<ul>\n<li>此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程会进入自旋等待获得该轻量级锁。</li>\n</ul>\n</li>\n<li>第一个线程执行完成synchronized方法(退出同步块)，则将对象头设置成无锁状态并撤销偏向锁，重新偏向 。</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306061807484.png\" alt=\"image-20230606180706322\" style=\"zoom:33%;\">\n<h5 id=\"偏向锁在Java15后逐步废除偏向锁\">偏向锁在Java15后逐步废除偏向锁</h5>\n<ul>\n<li>性能影响</li>\n</ul>\n<p>Java 应用通常使用的都是 HashTable、Vector 等比较老的集合库，这类集合库大量使用了 synchronized 来保证线程安全。如果在单线程的情景下使用这些集合库就会有不必要的加锁操作，从而导致性能下降。而偏向锁可以保证即使是使用了这些老的集合库，也不会产生很大的性能损耗，因为 JVM 知道访问临界区的线程始终是同一个，也就避免了加锁操作。</p>\n<p>但是：新的 Java 应用基本都已经使用了无锁的集合库，比如 HashMap、ArrayList 等，这些集合库在单线程场景下比老的集合库性能更好。</p>\n<p>即使是在多线程场景下，Java 也提供了 <code>ConcurrentHashMap、CopyOnWriteArrayList </code>等性能更好的线程安全的集合库。</p>\n<p>综上，对于使用了新类库的 Java 应用来说，偏向锁带来的收益已不如过去那么明显，而且在当下多线程应用越来越普遍的情况下，偏向锁带来的锁升级操作反而会影响应用的性能。</p>\n<ul>\n<li>代码侵入</li>\n</ul>\n<p><strong>偏向锁</strong>为整个「同步子系统」引入了大量的复杂度，并且这些复杂度也入侵到了 <code>HotSpot</code> 的其它组件。这导致了系统代码难以理解，难以进行大的设计变更，降低了子系统的演进能力</p>\n<p>总结下来其实就是 ROI （投资回报率）太低了，考虑到兼容性，所以决定先废弃该特性，最终的目标是移除它。</p>\n<h4 id=\"轻量级锁-自旋锁-CAS\">轻量级锁 -自旋锁(CAS)</h4>\n<p>作用：</p>\n<ul>\n<li>有线程来参与锁的竞争，但是获取锁的冲突时间极短</li>\n<li>本质就是自旋锁<code>(CAS)</code></li>\n<li>轻量级锁是为了在线程近乎交替执行同步块时提高性能。</li>\n<li>主要目的： 在没有多线程竞争的前提下，通过<code>CAS</code>减少重量级锁使用操作系统互斥量产生的性能消耗，说白了<code>先自旋再阻塞</code></li>\n<li>升级时机： 当关闭偏向锁功能或多线程竞争偏向锁会导致偏向锁升级为轻量级锁</li>\n</ul>\n<h5 id=\"轻量级锁的加锁\">轻量级锁的加锁</h5>\n<p><code>JVM</code>会为<code>每个线程</code>在当前线程的栈帧中创建用于存储锁记录的空间。若一个线程获得锁时发现是轻量级锁，会把锁的<code>MarkWord</code>复制到自己的<code>Displaced Mark Word</code>里面。然后线程尝试用<code>CAS</code>将锁的<code>MarkWord</code>替换为指向锁记录的指针</p>\n<ul>\n<li>如果成功，当前线程获得锁，</li>\n<li>如果失败，表示<code>Mark Word</code>已经被替换成了其他线程的锁记录，说明在与其它线程竞争锁，当前线程就尝试使用自旋来获取锁。</li>\n</ul>\n<h5 id=\"轻量级锁的释放\">轻量级锁的释放</h5>\n<p>在释放锁时，当前线程会使用CAS操作将Displaced Mark Word的内容复制回锁的Mark Word里面。</p>\n<ul>\n<li>\n<p>如果没有发生竞争，那么这个复制的操作会成功。</p>\n</li>\n<li>\n<p>如果有其他线程因为自旋多次导致轻量级锁升级成了重量级锁，那么CAS操作会失败，此时会释放锁并唤醒被阻察的线程。</p>\n</li>\n</ul>\n<h5 id=\"轻量级锁升级为重量级锁\">轻量级锁升级为重量级锁</h5>\n<ul>\n<li>\n<p>升级条件——<code>自旋达到一定次数和程度</code></p>\n</li>\n<li>\n<p><strong>JDK6之前</strong></p>\n<ul>\n<li>默认启用，默认情况下自旋的次数是 10 次</li>\n<li>自旋线程数超过cpu核数一半</li>\n</ul>\n</li>\n<li>\n<h5 id=\"Java6之后\">Java6之后</h5>\n<ul>\n<li>自适应；意味着自旋的次数不是固定不变的</li>\n<li>而是根据：\n<ul>\n<li>同一个锁上一次自旋的时间</li>\n<li>拥有锁线程的状态来决定</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"轻量锁与偏向锁的区别和不同\">轻量锁与偏向锁的区别和不同</h5>\n<ul>\n<li>争夺轻量级锁失败时，自旋尝试抢占锁</li>\n<li>轻量级锁每次退出同步块都需要释放锁，而偏向锁是在竞争发生时才释放锁</li>\n</ul>\n<h4 id=\"重量级锁\">重量级锁</h4>\n<p>有大量的线程参与锁的竞争，冲突性很高</p>\n<h5 id=\"原理-6\">原理</h5>\n<p><code>Java</code>中<code>synchronized</code>的重量级锁，是基于进入和退出<code>Monitor</code>对象实现的。在编译时会将同步块的开始位置插入<code>monitor enter</code>指令，在结束位置插入<code>monitor exit</code>指令。</p>\n<p>当线程执行到<code>monitor enter</code>指令时，会尝试获取对象所对应的<code>Monitor</code>所有权，如果获取到了，即获取到了锁，会在<code>Monior</code>的<code>owner</code>中存放当前线程的id，这样它将处于锁定状态，除非退出同步块，否则其他线程无法获取到这个Monitor。</p>\n<p>锁升级hashCode去那了</p>\n<blockquote>\n<p>锁升级为<strong>轻量级或重量级锁后，Mark Word中保存的分别是线程栈帧里的锁记录指针和重量级锁指针</strong>，已经没有位置再保存哈希码、GC年龄了，那么这些信息被移动到哪里去了呢?</p>\n</blockquote>\n<ul>\n<li>\n<p>在无锁状态下，<code>Mark Word</code>中可以存储对象的<code>identity hash code</code>值。当对象的<code>hashCode()</code>方法第一次被调用时，JVM会生成对应的<code>identity hash code</code>值并将该值存储到<code>Mark Word</code>中。</p>\n</li>\n<li>\n<p>对于偏向锁，在线程获取偏向锁时，会用<code>Thread ID</code>和<code>epoch</code>值覆盖<code>identity hash code</code>所在的位置。**如果一个对象的<code>hashCode()</code>方法已经被调用过一次之后，这个对象不能被设置偏向锁。**因为如果可以的话，那<code>Mark Word</code>中的<code>identity hash code</code>必然会被偏向线程ld给覆盖，这就会造成同一个对象前后两次调用<code>hashCode()</code>方法得到的结果不一致。</p>\n<ul>\n<li>当一个对象已经计算过<code>identity hashcode</code>，它就无法进入偏向锁状态，跳过偏向锁，直接升级轻量级锁</li>\n<li>偏向锁过程中遇到一致性哈希计算请求，立马撤销偏向模式，膨胀为重量级锁</li>\n</ul>\n</li>\n<li>\n<p>升级为轻量级锁时，JVM会在当前线程的栈帧中创建一个锁记录(Lock Record)空间，用于存储锁对象的Mark Word拷贝，该拷贝中可以包含<code>identity hash code</code>，所以轻量级锁可以和<code>identity hash code</code>共存，哈希码和GC年龄自然保存在此，释放锁后会将这些信息写回到对象头。</p>\n</li>\n<li>\n<p>升级为重量级锁后，<code>Mark Word</code>保存的重量级锁指针，代表重量级锁的<code>Object Monitor</code>类里有字段记录非加锁状态下的<code>Mark Word</code>，锁释放后也会将信息写回到对象头。</p>\n</li>\n</ul>\n<h4 id=\"各种锁优缺点、synchronized锁升级和实现原理\">各种锁优缺点、synchronized锁升级和实现原理</h4>\n<h5 id=\"锁的优缺点的对比\">锁的优缺点的对比</h5>\n<table>\n<thead>\n<tr>\n<th>锁</th>\n<th>优点</th>\n<th>缺点</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>偏向锁</td>\n<td>加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距</td>\n<td>如果线程间存在锁竞争,会带来额外的锁撤销的消耗</td>\n<td>适用于只有一个线程访问同步块的场景</td>\n</tr>\n<tr>\n<td>轻量级锁</td>\n<td>竞争的线程不会阻塞，提高了程序的响应速度</td>\n<td>如果始终得不到锁竞争的线程，使用自旋会消耗CPU</td>\n<td>追求响应时间<br>同步块执行速度非常快</td>\n</tr>\n<tr>\n<td>重量级锁</td>\n<td>线程竞争不使用自旋，不会消耗CPU</td>\n<td>线程阻塞，响应时间缓慢</td>\n<td>追求吞吐量，同步块执行速度较长</td>\n</tr>\n</tbody>\n</table>\n<p>synchronized<code>锁升级过程</code>总结：就是先自旋，不行再阻塞。</p>\n<p>实际上是把之前的悲观锁（重量级锁）变成在<code>一定条件下</code>使用偏向锁以及使用轻量级（自旋锁CS)的形式</p>\n<p>synchronized在修饰方法和代码块在字节码上实现方式有很大差异，但是<code>内部实现</code>还是基于对象头的<code>MarkWord</code>来实现的。</p>\n<ul>\n<li>JDK1.6之前<code>synchronized</code>使用的是重量级锁，JDK1.6之后进行了优化，拥有了<code>无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</code>的升级过程，而不是无论什么情况都使用重量级锁。</li>\n<li>偏向锁：适用单线程适用的情况，在不存在锁竞争的时候进入<code>同步方法/代码块</code>则使用偏向锁。</li>\n<li>轻量级锁：适用竞争不激烈的情况（这和乐观锁的使用范围类似），存在竞争时升级为轻量级锁，轻量级锁采用的是自旋锁，如果同步方法代码块执行时间很短的话，采用轻量级锁虽然会占用cpu资源但是相对比使用重量级锁还是更高效。</li>\n<li>重量级锁：适用于竞争激烈的情沉，如果同步方法/代码块执行时间很长，那么使用轻量级锁自旋带来的性能消耗就比使用重量级锁更严重，这时候就需要升级为重量级锁</li>\n</ul>\n<h4 id=\"JIT编译器对锁的优化\">JIT编译器对锁的优化</h4>\n<h5 id=\"锁消除-2\">锁消除</h5>\n<p>从<code>JIT</code>角度看相当于无视它，<code>synchronized (o)</code>不存在了,这个锁对象并没有被共用扩散到其它线程使用，极端的说就是根本没有<code>加这个锁对象的底层机器码</code>，<code>消除了锁的使用</code>；其实就是每个线程使用的锁对象都不一样(每次加锁都是用的新new 的对象),只对一个线程加锁没事作用;所以IT编译器就会把锁去掉了</p>\n<h5 id=\"锁粗化-2\">锁粗化</h5>\n<p>假如方法中首尾相接，前后相邻的都是同一个锁对象，那<code>JIT</code>编译器就会把这几个<code>synchronized</code>块<code>合并</code>成一个大块，加粗加大范围，一次申请锁使用即可，避免每次都要申请和释放锁，提升了性能</p>\n<h2 id=\"并发加锁原理之AbstractQueuedSynchronizer-AQS\">并发加锁原理之AbstractQueuedSynchronizer(AQS)</h2>\n<h3 id=\"入门\">入门</h3>\n<p>Abstract Queued Synchronizer----抽象的队列同步器</p>\n<ul>\n<li>是用来<code>构建锁</code>或者<code>其它同步器组件</code>的<strong>重量级基础框架及整个JUC体系的基石,主要用于解决锁分配给&quot;谁&quot;的问题</strong></li>\n<li>通过内置的<strong>FIFO队列</strong>来完成资源获取线程的排队工作，并通过一个<strong>int类 变量表示持有锁的状态</strong></li>\n</ul>\n<h4 id=\"和AQS关联的技术\">和AQS关联的技术</h4>\n<blockquote>\n<p>CountDownLatch:</p>\n</blockquote>\n<ul>\n<li>通过一个计数器来实现，计数器的初始值是线程的数量，每当一个线程执行完葬后，计数器的值就<code>-1</code>，当计数器的值为0时，表示所有线程都执行完毕</li>\n<li><code>await()</code>:调用await()方法的出程会被挂起，它会等待直到count值为<code>0</code>才继续执行</li>\n<li><code>await(long timeout,TimeUnit unit)</code>:  等待一定的时间后count值还没变为<code>0</code>的话就会继续执行</li>\n<li><code>countDown()</code>:将count值<code>-1</code></li>\n</ul>\n<blockquote>\n<p>Semaphore信号量</p>\n</blockquote>\n<ul>\n<li>又被称为信号灯，在多线程环境下用于协调各个线程，以保证它们能够正确、合理的使用资源，</li>\n<li>关健方法\n<ul>\n<li><code>acquire</code>:线程通过acquire0方法获取到一个许可，然后对共享资源进行操作，如果许可集已分配完了，那么线程将进入等特状态，直到其他线程用放许可才有机会再获取许可。</li>\n<li><code>release</code>:线程得放一个许可，许可将被归还给<code>Semaphore</code></li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>CyclicBarrier</p>\n</blockquote>\n<ul>\n<li>\n<p><code>CyclicBarrier</code> 类似于<code>CountDownLatch</code>,.它旋阻塞一组线程直到某个事件的发生，<code>CyclicBarier</code>与<code>CountDownLatch</code>的关键区别在于，所有的线程必须同时到达栅栏位置，才能继续执行。CountDownLatch用于等待事件，而栅栏用于等待其他线程。</p>\n</li>\n<li>\n<p>await():await方法的线程告诉<code>CyclicBarrier</code>自己已经到达同步点，然后当前线程被阻塞，<code>CyclicBarrierl</code>同样提供带超时时间的<code>await</code>和不带超时时间的<code>await</code>方法</p>\n</li>\n<li>\n<p>CountDownLatch基于AQS的共享模式的使用,而CyclicBarrier基于Condition来实现的.</p>\n</li>\n</ul>\n<blockquote>\n<p>ReentrantLock</p>\n</blockquote>\n<ul>\n<li>\n<p>与<code>Synchronized</code>的对比：</p>\n<ul>\n<li>\n<p><code>synchronized</code>获取锁无法设置超时;<code>ReentrantLock</code>可以设置获取锁的超时时间</p>\n</li>\n<li>\n<p><code>synchronized</code>无法实现公平锁，<code>ReentrantLock</code>可以实现公平锁</p>\n</li>\n<li>\n<p><code>Synchronized</code>是Java中的关键字，无法提供外部方法，使用的都是<code>Object</code>类的方法;<code>ReentrantLock</code>是<code>juc</code>中锁的一种实现，提供的方法会多一些</p>\n</li>\n<li>\n<p><code>Synchronized</code>在加锁代码块执行完或者出现异常，自动释放锁：ReentrantLock不会自动释放锁，需要 <code>finally&#123;&#125;</code>代码块显示释放</p>\n</li>\n</ul>\n</li>\n<li>\n<p>锁实现</p>\n<ul>\n<li>公平锁 <code>FairSync</code>        每个线程公平的获取锁，不会出现线程饥饿情况</li>\n<li>非公平锁<code>NonFairSync</code>       每个线程抢占式获取锁，容易出现线程饥饿情况</li>\n</ul>\n</li>\n<li>\n<p>Condition</p>\n<ul>\n<li><code>Condition</code>维护了一个线程等待队列，也是多线程间协调通信的工具类，使得某个线程一起等待某个条件，满足条件才能唤醒，唤醒后，还需要重新竞争锁</li>\n<li><code>ReentrantLock</code>与<code>Condition</code> 一起实现了</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>ReentrantReadWriteLock</p>\n</blockquote>\n<ul>\n<li>\n<p>Java的并发包提供了读写锁<code>ReentrantReadWriteLock</code>,它表示两个锁，一个是读操作相关的锁，称为共享锁：一个是写相关的锁，称为排他锁</p>\n</li>\n<li>\n<p>读写锁有以下三个重要的特性</p>\n<ul>\n<li>公平选择性：支持非公平（默认）和公平的锁获取方式，吞吐量也是非公平优于公平。</li>\n<li>重入：读锁和写锁都支持线程重入。</li>\n<li>锁降级：遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级成为读锁</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306062001482.png\" alt=\"image-20230606200147311\" style=\"zoom:33%;\">\n<h4 id=\"锁和同步器的关系\">锁和同步器的关系</h4>\n<ul>\n<li>锁，面向锁的<code>使用者</code>\n<ul>\n<li>定义了程序员和锁交互的使用层API，隐藏了实现细节，调用即可。</li>\n</ul>\n</li>\n<li>同步器，面向锁的<code>实现者</code>\n<ul>\n<li>比如Java并发大神DougLee，提出统一规范并简化了锁的实现，屏蔽了同步状态管理、阻塞线程排队和通知、唤醒机制等。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"作用-2\">作用</h4>\n<ul>\n<li>因为加锁会导致阻塞，所以有阻塞就需要排队，实现排队必然需要队列</li>\n<li>如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。</li>\n<li>这个机制主要用的是<code>CLH</code>队列的变体实现的，将<strong>暂时获取不到锁的线程加入到队列中</strong>，这个队列就是AQS的抽象表现。</li>\n<li>它将请求共享资源的线程封装<code>成队列的结点</code>（Node），通过<code>CAS</code>、<code>自旋</code>以及<code>LockSupport.park()</code>的方式，维护state变量的状态，使并发达到同步的效果。</li>\n</ul>\n<h4 id=\"AQS结构\">AQS结构</h4>\n<h5 id=\"AQS的int变量state-volatile修饰\">AQS的int变量<code>state-volatile</code>修饰</h5>\n<p><code>state</code>代表同步状态标志位</p>\n<ul>\n<li><code>0</code>代表资源没有被线程占用,资源现在是<code>空闲状态</code></li>\n<li><code>1</code>代表资源被线程占用,资源现在不是<code>空闲状态</code></li>\n</ul>\n<h5 id=\"Node对象两种模式\">Node对象两种模式</h5>\n<ul>\n<li>\n<p>SHARED(共享模式)</p>\n<ul>\n<li>标志节点正在<code>等待共享模式</code>的标记</li>\n</ul>\n</li>\n<li>\n<p>EXCLUSIVE(独占模式)</p>\n<ul>\n<li>标志节点正在<code>独占模式等待</code>的标记</li>\n</ul>\n</li>\n<li>\n<p>Node的<code>Node</code>的int变量<code>waitState-volatile</code>修饰</p>\n<ul>\n<li><code>CANCELLED</code>(取消)=<code>1</code>   表示该Node节点为取消状态,需要出队</li>\n<li><code>SIGNAL</code>(标志)=<code>-1 </code>        表示该节点的后一个节点需要<code>unparking</code>(<code>LockSupport</code>里的知识)</li>\n<li><code>CONDITION</code>(条件)=<code>-2 </code>  表示该节点正在等待某种条件激活</li>\n<li><code>PROPAGATE</code>(传播)=<code>-3 </code>  指示下一个 <code>acquireShared</code> 应该无条件传播的 <code>waitStatus</code> 值</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"prev-next-双向链表\">prev&amp;next 双向链表</h5>\n<ul>\n<li>记录该节点的<code>前一个节点</code>和<code>后一个节点</code></li>\n</ul>\n<blockquote>\n<p>总结：</p>\n<p>AQS<code>同步队列</code>的基本结构</p>\n<ul>\n<li>CLH：Craig、Landin and Hagersten 队列，是个单向链表，AQS中的队列是CLH变体的虚拟双向队列（FIFO）</li>\n</ul>\n</blockquote>\n<h4 id=\"AQS源码分析之ReentranLock\">AQS源码分析之ReentranLock</h4>\n<ul>\n<li>\n<p>架构</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306062032850.png\" alt=\"image-20230606203213662\" style=\"zoom:33%;\">\n<ul>\n<li><code>ReentranLock</code>实现了<code>Lock接口</code></li>\n<li><code>ReentranLock</code>中的内部类<code>NonfairSync(非公平锁)</code>和<code>FairSync(公平锁)</code>继承了<code>Sync</code></li>\n<li><code>Sync</code>又继承了<code>AQS</code>抽象类</li>\n</ul>\n</li>\n<li>\n<p>公平锁与非公平锁</p>\n<ul>\n<li><code>new ReentranLock()</code>和<code>new ReentranLock(false)</code>都是非公平锁</li>\n<li><code>new ReentranLock(true) </code>表示公平锁</li>\n</ul>\n</li>\n<li>\n<p><code>acquire</code>方法</p>\n<ul>\n<li>因为非公平的的<code>tryAcquire</code>不会排队，所以我们在抢锁之前需要看看锁的状态<code>status</code>是否为0,不然队列中所有节点不管<code>status</code>是否为0都去抢的话就会太耗费性能</li>\n<li>而公平锁在<code>tryAcquire</code>的时候会排队,只有成为头结点才会去抢,所以直接<code>acquire</code></li>\n</ul>\n</li>\n</ul>\n<p>代码上解释：</p>\n<blockquote>\n<p>非公平锁和公平锁的区别</p>\n<ul>\n<li>\n<p>非公平锁会CAS； AQS的<code>status</code>如果等于0，修改<code>status</code>为1，然后设置<code>拥有者</code>为当前线程;如果<code>status</code>为1的话那么就获取锁</p>\n</li>\n<li>\n<p>公平锁会直接获取锁</p>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li>\n<p><code>tryAcquire</code></p>\n<ul>\n<li>非公平锁<code>tryAcquire</code>返回值:\n<ul>\n<li>当AQS status为0返回true</li>\n<li>是重入锁的情况下返回true</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306062046040.png\" alt=\"image-20230606204615847\" style=\"zoom:33%;\">\n<ul>\n<li>\n<p>公平锁<code>tryAcquire</code>返回值:</p>\n<ul>\n<li>当AQS status为0<code>并且</code>当前节点是头结点时返回<code>true</code></li>\n<li>是重入锁的情况下返回true</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306062049507.png\" style=\"zoom:33%;\">\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><code>!hasQueuedPredecessors()</code>的意思就是如果在当前线程之前有排队的线程就不尝试去抢锁了,老老实实的排队,这不就是公平锁吗?</p>\n<ul>\n<li>非公平锁没有这个条件约束,所以不管是排在那个位置的线程都会去抢</li>\n</ul>\n</blockquote>\n<ul>\n<li>\n<p><code>hasQueuedPredecessors()</code>方法</p>\n<ul>\n<li>\n<p>如果在当前线程之前有<code>排队的线程</code>，则为<code>true</code></p>\n</li>\n<li>\n<p>如果当前线程位于队列的<code>头部或队列为空</code>，则为<code>false</code></p>\n</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306062053881.png\" alt=\"image-20230606205350771\" style=\"zoom:43%;\">\n<blockquote>\n<p>总结：</p>\n<ul>\n<li>可以看出公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：<br>\nhasQueuedPredecessors():<br>\n<strong>hasQueuedPredecessors是公平锁加锁时判断等待队列中是否存在有效节点的方法</strong></li>\n</ul>\n</blockquote>\n<blockquote>\n<p>以非公平锁为例继续后面的源码分析</p>\n</blockquote>\n<p>下面针对 <code>tryAcquire</code>方法</p>\n<ul>\n<li><code>addWaiter</code></li>\n<li><code>acquireQueued</code></li>\n<li><code>selfInterrupt</code></li>\n</ul>\n<p>接下来对以上三个方法进行分析</p>\n<ul>\n<li>\n<p><code>acquire</code>方法总流程</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306062103891.png\" alt=\"image-20230606210329779\" style=\"zoom:33%;\">\n</li>\n</ul>\n<p><code>addWaiter(Node.EXCLUSIVE)</code>      将加锁失败的节点加入队列</p>\n<ul>\n<li>\n<p>当<code>tryAcquire()</code>返回false的情况下才会执行<code>addWaiter</code></p>\n<p>公平锁:  以下条件只要包含一个就返回false</p>\n<ul>\n<li>status不等于0</li>\n<li>当前节点不是头结点</li>\n<li>也不是可重入锁</li>\n</ul>\n<p>非公平锁: 以下条件只要包含一个就返回false</p>\n<ul>\n<li>\n<p>status不等于0</p>\n</li>\n<li>\n<p>也不是可重入锁</p>\n</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306062105829.png\" alt=\"image-20230606210554595\" style=\"zoom:33%;\">\n<ul>\n<li><code>enq(Node node) </code></li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306062106700.png\" alt=\"image-20230606210629482\" style=\"zoom:33%;\">\n<ul>\n<li><code>acquireQueued(final Node node, int arg)</code>\n<ul>\n<li>将队列中各节点的等待状态<code>waitStatus</code>进行管理\n<ul>\n<li><code>waitStatus</code>为<code>-1</code>的节点<code>park</code></li>\n<li><code>waitStatus</code>为<code>1</code>的移出队列</li>\n<li>其他状态值会逐步修改为<code>-1</code></li>\n<li>最后将<code>waitStatus</code>为<code>-1</code>的节点对应的线程<code>park</code></li>\n</ul>\n</li>\n<li>在<code>addWaiter</code>的大自旋中会不断<code>tryAcquire()</code>,检测共享资源是否解锁</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><code>addWaiter</code>后会返回最新的尾节点</p>\n</blockquote>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306062108654.png\" alt=\"image-20230606210852432\" style=\"zoom:25%;\">\n<blockquote>\n<p><code>predecessor()</code>方法 返回尾结点的前置节点</p>\n</blockquote>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306062109310.png\" alt=\"image-20230606210929076\" style=\"zoom:33%;\">\n<blockquote>\n<p><code>shouldParkAfterFailedAcquire(Node pred, Node node)</code></p>\n<p>该方法主要作用</p>\n<ul>\n<li>就是将修改抢锁失败的节点<code>waitStatus</code>为<code>-1</code>等待状态,或者将想要取消的节点从队列中移除</li>\n<li>如果前驱节点的 <code>waitStatus</code> 是 <code>SIGNAL</code>状态，即 <code>shouldParkAfterFailedAcquire </code>方法会返回 <code>true</code> 程序会继续向下执行<code>parkAndCheckInterrupt</code> 方法，用于将当前线程挂起</li>\n</ul>\n</blockquote>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306062110668.png\" alt=\"image-20230606211021443\" style=\"zoom:33%;\">\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306062115016.png\" alt=\"image-20230606211510906\" style=\"zoom:33%;\">\n<blockquote>\n<p><code>parkAndCheckInterrupt()</code>  阻塞当前节点</p>\n</blockquote>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306062115504.png\" alt=\"image-20230606211532282\" style=\"zoom:33%;\">\n<ul>\n<li>selfInterrupt()</li>\n</ul>\n<blockquote>\n<p>抢锁失败,加入队列成功,那么就中断当前线程</p>\n</blockquote>\n<h4 id=\"unlock解锁源码分析\"><code>unlock</code>解锁源码分析</h4>\n<blockquote>\n<p>解锁操作,主要作用是将头结点后为等待状态<code>-1</code>的节点<code>unpark</code>,然后<code>唤醒阻塞</code>的线程,<code>以及一些异常处理</code></p>\n</blockquote>\n<blockquote>\n<p><code>unlock</code>主要就是调用<code>AQS</code>的释放方法<code>release</code></p>\n</blockquote>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306062118366.png\" alt=\"image-20230606211829252\" style=\"zoom:33%;\">\n<blockquote>\n<p><code>release</code>开始会<code>tryAcquire</code>尝试解锁</p>\n</blockquote>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306062118013.png\" alt=\"image-20230606211845788\" style=\"zoom:30%;\">\n<blockquote>\n<p><code>tryAcquire</code>尝试解锁</p>\n</blockquote>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306062119049.png\" alt=\"image-20230606211914816\" style=\"zoom:30%;\">\n<blockquote>\n<p><code>unparkSuccessor</code>方法将中断节点恢复至正常状态</p>\n</blockquote>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306062119435.png\" alt=\"image-20230606211940198\" style=\"zoom:33%;\">\n<h2 id=\"ReentrantLock、ReentrantReadWriteLock、StampedLock\"><code>ReentrantLock、ReentrantReadWriteLock、StampedLock</code></h2>\n<h4 id=\"读写锁（ReentrantReadWriteLock）\">读写锁（<code>ReentrantReadWriteLock</code>）</h4>\n<blockquote>\n<p>读写锁定义为一个资源能够被多个读线程访问，或者被一个写线程访问，但是不能同时存在读写线程</p>\n</blockquote>\n<p>由<code>ReentrantLock</code>与<code>ReentrantReadWriteLock</code>的对比</p>\n<p><code>ReentrantLock</code>实现的是<code>Lock</code>接口<br>\n<code>ReentrantReadWriteLock</code>实现的是<code>ReadWriteLock</code>接口</p>\n<blockquote>\n<p>ReadWriteLock接口</p>\n<ul>\n<li>有一个<code>读锁</code>    和  一个<code>写锁</code></li>\n</ul>\n</blockquote>\n<h5 id=\"读写锁演变\">读写锁演变</h5>\n<blockquote>\n<p><code>无锁无序-&gt;加锁-&gt;读写锁</code></p>\n</blockquote>\n<ul>\n<li>\n<p>无锁时期一旦多线程,肯定会<code>出现线程安全</code>问题</p>\n</li>\n<li>\n<p>加锁时期<code>读读操作</code>也只能单线程操作-----<code>解决了线程安全问题但是性能太低</code></p>\n</li>\n<li>\n<p>读写锁时期:高并发的情况下大部分的请求都是查询请求,即<code>读多写少</code>的情况,如果读读也互斥了那么效率极低,而且读操作不会影响数据一致性可以不互斥—读写锁诞生.</p>\n<ul>\n<li>缺点:\n<ul>\n<li>因为<code>读写锁读写互斥</code>,假设100个线程99个都是读线程只有一个写线程,写线程很难抢到机会,就会出现锁<code>饥饿问题</code></li>\n<li><code>锁降级</code>:为了让当前线程感知到数据的变化，目的是保证数据可见性,写锁会降级为读锁(写后立刻读)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"『读写锁』意义和特点\">『读写锁』意义和特点</h5>\n<ul>\n<li>读写锁<code>ReentrantReadWriteLock</code>并不是真正意义上的读写分离，它只允许<code>读读共存</code>，而<code>读写和写写依然是互斥</code>的</li>\n<li>大多实际场景是<code>读/读</code>线程间并不存在互斥关系，只有&quot;读/写&quot;线程或&quot;写/写&quot;线程间的操作需要互斥的。因此引入<code>ReentrantReadWriteLock</code></li>\n<li>一个ReentrantReadWriteLock同时只能存在一个写锁但是可以存在多个读锁，但不能同时存在写锁和读锁\n<ul>\n<li>也即一个资源可以被多个读操作访问或一个写操作访问，但两者不能同时进行。</li>\n<li>只有在读多写少情况之下，读写锁才具有较高的性能体现</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"读写锁的锁降级\">读写锁的锁降级</h5>\n<blockquote>\n<p>锁的<code>严苛程度</code>变强叫做升级，反之叫做降级</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>公平性选择</td>\n<td>支持非公平（默认）和公平的锁获取方式，吞吐量还是非公平优于公平</td>\n</tr>\n<tr>\n<td>可重入</td>\n<td>该锁支持重进入，以读写线程为例：<br>读线程在获取了读锁之后，能够再次获取读锁。<br>而写线程在获取了写锁之后能够再次获取写锁，同时也可以获取读锁</td>\n</tr>\n<tr>\n<td>锁降级</td>\n<td>遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级成为读锁</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"读写锁降级规则\">读写锁降级规则</h5>\n<blockquote>\n<ul>\n<li><code>锁降级</code>：遵循获取<code>写锁→再获取读锁→再释放写锁</code>的次序，<code>写锁</code>能够<code>降级</code>成为<code>读锁</code></li>\n<li>如果一个线程占有了写锁，在不释放写锁的情况下，它还能占有读锁，即<code>写锁降级为读锁</code></li>\n</ul>\n</blockquote>\n<p><code>重入</code>允许通过<code>获取写入锁定，然后读取锁  然后   释放写锁    从写锁到读取锁</code>，但是，从读锁定<code>升级</code>到写锁是<code>不可能</code>的。</p>\n<h5 id=\"读写锁降级的作用\">读写锁降级的作用</h5>\n<blockquote>\n<p>锁降级是为了让当前线程感知到数据的变化，目的是<code>保证数据可见性</code></p>\n</blockquote>\n<h5 id=\"锁不可升级\">锁不可升级</h5>\n<blockquote>\n<p><strong>如果有线程在读，那么写线程是无法获取写锁的，是悲观锁的策略</strong></p>\n</blockquote>\n<ul>\n<li>\n<p>线程获取读锁是不能直接升级为写入锁的，所以在<code>ReentrantReadWriteLock</code>中，当读锁被使用时，如果有线程尝试获取写锁，该写线程会被阻塞。<br>\n所以，需要<code>释放所有读锁</code>，才可<code>获取写锁</code></p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306062139200.png\" alt=\"image-20230606213919080\" style=\"zoom:33%;\">\n</li>\n</ul>\n<h5 id=\"总结-3\">总结</h5>\n<ul>\n<li>写锁和读锁是互斥的（这里的互斥是指线程间的互斥，当前线程可以获取到写锁又获取到读锁，但是获取到了读锁不能继续获取写锁），这是因为读写锁要保持写操作的可见性。</li>\n<li>因为，<strong>如果允许读锁在被获取的情况下对写锁的获取，那么正在运行的其他读线程无法感知到当前写线程的操作。</strong></li>\n</ul>\n<p>分析读写锁ReentrantReadWriteLock，会发现它有个潜在的问题：<code>读锁全完，写锁有望；写锁独占，读写全堵；</code></p>\n<p>如果有线程正在读，写线程需要等待读线程释放锁后<code>才能</code>获取写锁;即<code>ReadWriteLock</code> <code>读的过程中不允许写</code>，只有等待线程都<code>释放了读锁</code>，当前线程才能<code>获取写锁</code>，也就是<code>写入必须等待</code>，这是一种<code>悲观的读锁</code></p>\n<h5 id=\"源码解析\">源码解析</h5>\n<ul>\n<li>代码中声明了一个<code>volatile</code>类型的<code>cacheValid</code>变量，保证其<code>可见性</code></li>\n<li>首先<code>获取读锁</code>，如果<code>cache</code>不可用，则<code>释放读锁</code>，获取<code>写锁</code>，在更改数据之前，再检查一次<code>cacheValid</code>的值，然后修改数据，将<code>cacheValid</code>置为<code>true</code>,然后在释放写锁前获取读锁；此时，cache中数据可用，处理cache中数据，最后释放读锁。这个过程就是一个完整的锁降级的过程，目的是保证数据可见性。</li>\n<li>如果违背锁降级的步骤\n<ul>\n<li>如果当前的线程C在修改完<code>cache</code>中的数据后，没有获取读锁而是直接释放了写锁，那么假设此时另一个线程D获取了写锁并修改了数据，那么<br>\nC线程无法感知到数据已被修改，则数据出现错误。</li>\n</ul>\n</li>\n<li>如果遵循锁降级的步骤\n<ul>\n<li>线程C在释放写锁之前获取读锁，那么线程D在获取写锁时将被阻塞，直到线程C完成数据处理过程，释放读锁。这样可以保证返回的数据是这次<br>\n更新的数据，该机制是<code>专门为了缓存设计</code>的。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"邮戳锁StampedLock-也叫票据锁\">邮戳锁<code>StampedLock</code> 也叫票据锁</h4>\n<blockquote>\n<p>是JDK1.8中新增的一个读写锁，也是对JDK1.5中的<strong>读写锁<code>ReentrantReadWriteLock</code>的优化</strong></p>\n<p><code>stamp</code>（戳记，long类型）</p>\n<ul>\n<li>代表了锁的状态。<strong>当stamp返回零时，表示线程获取锁失败</strong>。并且，<strong>当释放锁或者转换锁的时候，都要传入最初获取的stamp值</strong></li>\n</ul>\n<p>它是由<code>锁饥饿问题</code>引出</p>\n</blockquote>\n<h5 id=\"锁饥饿问题\">锁饥饿问题</h5>\n<p><code>ReentrantReadWriteLock</code>实现了读写分离，但是一旦读操作比较多的时候，想要获取写锁就变得比较困难了</p>\n<blockquote>\n<p>假如当前1000个线程，999个读，1个写，有可能999个读取线程长时间抢到了锁，那1个写线程就悲剧了 因为当前有可能会一直存在读锁，而无法获得写锁，根本没机会写</p>\n</blockquote>\n<h5 id=\"如何缓解锁饥饿问题？\">如何缓解锁饥饿问题？</h5>\n<ul>\n<li>使用<code>“公平”策略</code>可以一定程度上缓解这个问题;但是“公平”策略是<code>以牺牲系统吞吐量为代价</code>的</li>\n<li>邮戳锁:      乐观读来解决问题</li>\n</ul>\n<h5 id=\"StampedLock-和ReentrantReadWriteLock的区别\"><code>StampedLock</code> 和<code>ReentrantReadWriteLock</code>的区别</h5>\n<ul>\n<li>\n<p><code>ReentrantReadWriteLock</code></p>\n<ul>\n<li>允许<code>多个线程同时读</code>，但是<code>只允许一个线程写</code>，在线程获取到写锁的时候，其他写操作和读操作都会处于阻塞状态，读锁和写锁也是互斥的，所以在读的时候是不允许写的，读写锁比传统的<code>synchronized</code>速度要快很多，原因就是在于<code>ReentrantReadWriteLock</code>支持<code>读并发</code></li>\n</ul>\n</li>\n<li>\n<p><code>StampedLock</code></p>\n<ul>\n<li><code>ReentrantReadWriteLock</code>的读锁被占用的时候，其他线程尝试获取写锁的时候会被阻塞。但是，<code>StampedLock</code>采取乐观获取锁后，其他线程尝试获取写锁时不会被阻塞，这其实是对读锁的优化，所以，在获取乐观读锁后，还需要对结果进行校验。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"StampedLock的特点\">StampedLock的特点</h5>\n<ul>\n<li>所有获取锁的方法，都返回一个<code>邮戳（Stamp）</code>，Stamp为<code>零</code>表示获取<code>失败</code>，其余都表示成功；</li>\n<li>所有释放锁的方法，都需要一个<code>邮戳（Stamp）</code>，这个Stamp必须是和成功获取锁时得到的Stamp一致；</li>\n<li>StampedLock是不可重入的，危险  (如果一个线程已经持有了写锁，再去获取写锁的话就会造成死锁)</li>\n<li>StampedLock有三种访问模式\n<ul>\n<li>①Reading（读模式）：功能和<code>ReentrantReadWriteLock</code>的<code>读锁</code>类似</li>\n<li>②Writing（写模式）：功能和<code>ReentrantReadWriteLock</code>的<code>写锁</code>类似</li>\n<li>③Optimistic reading（乐观读模式）：<code>无锁机制</code>，类似于数据库中的<code>乐观锁</code>，支持<code>读写并发</code>，很乐观认为读取时没人修改，假如被修改再实现升级为悲观读模式</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"StampedLock缺点\">StampedLock缺点</h5>\n<ul>\n<li><code>StampedLock</code> 不支持重入，没有Re开头</li>\n<li><code>StampedLock</code> 的悲观读锁和写锁都不支持条件变量（<code>Condition</code>）</li>\n<li>使用 <code>StampedLock</code>一定不要调用中断操作，即不要调用<code>interrupt() </code>方法</li>\n</ul>\n","_path":"post/2da05edf.html","_link":"http://rycan.top/post/2da05edf.html","_id":"cloioo9ds001eni0pakg7gx3b"}}