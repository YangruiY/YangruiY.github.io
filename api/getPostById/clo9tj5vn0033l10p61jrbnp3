{"type":"getPostById","data":{"title":"SpringBoot","date":"2023-09-13T15:42:02.000Z","description":"面试精选","categories":[{"name":"FaceToFace","_id":"clo9tj5ve001bl10phwsc3bgw"}],"tags":[{"name":"SpringBoot","_id":"clo9tj5w3006ql10p7yth67fx"}],"content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n\n\n<h3 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h3><ul>\n<li><code>@RestController</code>的作用相当于Controller加ResponseBody共同作用的结果，但采用RestController请求方式一般会采用Restful风格的形式。</li>\n<li><code>@Controller</code>的作用：声明该类是Controller层的Bean，将该类声明进入Spring容器中进行管理</li>\n<li><code>@ResponseBody</code>的作用：表明该类的所有方法的返回值都直接进行提交而不经过视图解析器，且返回值的数据自动封装为json的数据格式</li>\n</ul>\n<h4 id=\"组件添加\"><a href=\"#组件添加\" class=\"headerlink\" title=\"组件添加\"></a>组件添加</h4><ul>\n<li>@Bean  默认单实例，默认的id与方法名相同，也可以自行定义如：@Bean(“tom”) tom就代表该容器<code>@Bean //给容器中添加组件。以方法名作为组件的id。返回类型就是组件类型。返回的值，就是组件在容器中的实例</code></li>\n</ul>\n<ul>\n<li><code>@Configuration</code>  两种 模式Full模式与Lite模式     <code>@Configuration(proxyBeanMethods = false)</code> :</li>\n</ul>\n<p>​            <code>Full</code>(proxyBeanMethods = true)（保证每个@Bean方法被调用多少次返回的组件都是<code>单实例</code>的）（默认）;</p>\n<p>​            <code>Lite</code>(proxyBeanMethods = false)（保证每个@Bean方法被调用多少次返回的组件都是新<code>创建的</code>）;</p>\n<p>​       使用推荐：</p>\n<p>​                配置类组件之间<strong>无依赖关系用Lite模式</strong>，可以加速容器启动过程，减少判断</p>\n<p>​                配置类组件之间<strong>有依赖关系用Full模式</strong>，方法会被调用，得到之前单实例组件</p>\n<ul>\n<li><p><code>@Import(&#123;User.class, DBHelper.class&#125;)</code>  //会给容器中自动创建出这两个类型的组件、默认组件的名字就是全类名</p>\n</li>\n<li><p><code>@ComponentScan</code>   规定扫描的位置</p>\n</li>\n<li><p><code>@Conditional</code>       满足Conditional指定的条件，则进行组件注入</p>\n</li>\n<li><p><code>@Bean、@Component、@Controller、@Service、@Repository</code>:Spring为Controller-Service-Dao的分层模型分别提供了@Controller、@Service、@Repository注解，除此之外的组件使用@Component注解。</p>\n</li>\n</ul>\n<h4 id=\"原生配置文件引入\"><a href=\"#原生配置文件引入\" class=\"headerlink\" title=\"原生配置文件引入\"></a>原生配置文件引入</h4><p><code>@ImportResource</code>是原生配置文件引入；比如之前使用bean.xml文件生成配置bean，想继续复用bean.xml，可以使用<code>@ImportResource(&quot;classpath:beans.xml&quot;)</code></p>\n<h4 id=\"配置绑定\"><a href=\"#配置绑定\" class=\"headerlink\" title=\"配置绑定\"></a>配置绑定</h4><p><code>@ConfigurationProperties</code> : 使用Java读取到<code>properties文件</code>中的内容，并且把它封装到JavaBean中，以供随时使用</p>\n<ul>\n<li><p>方式一：<code>@ConfigurationProperties(prefix = &quot;mycar&quot;)   + @Component</code></p>\n</li>\n<li><p>方式二：<code>@EnableConfigurationProperties(Car.class) 「等价于在car.java上配置@component」 + @ConfigurationProperties</code></p>\n</li>\n</ul>\n<h4 id=\"请求参数\"><a href=\"#请求参数\" class=\"headerlink\" title=\"请求参数\"></a>请求参数</h4><p><code>@GetMapping(&quot;/car/&#123;id&#125;/owner/&#123;ownerName&#125;&quot;)</code></p>\n<p><code>@PathVariable</code> 路径变量                            <code>@PathVariable(&quot;id&quot;) Integer id</code></p>\n<p><code>@RequestParam</code>获取请求参数（指问号后的参数，url?a=1&amp;b=2）</p>\n<p>@RequestHeader<code>获取请求头</code>@RequestHeader(“User-Agent”) String userAgent`</p>\n<p><code>@CookieValue</code>获取Cookie值                        <code>@CookieValue(&quot;Idea-df9e4e8c&quot;) String Idea</code></p>\n<p><code>@RequestBody</code> 获取请求体[POST]                <code>@RequestBody String content</code></p>\n<p><code>@RequestAttribute</code>获取request域属性       <code>@RequestAttribute(value = &quot;msg&quot;,required = false) String msg</code></p>\n<p><code>@MatrixVariable</code>矩阵变量 （默认禁用，需要手动开启）             之前的请求方式： <code>/cars/&#123;path&#125;?xxx=xxx&amp;aaa=ccc</code> 使用<code>@RequestParam</code>查询字符串的方式获取请求参数<code>/cars/sell;low=34;brand=byd,audi,yd</code>       路径中出现以分号；的方式分割字符串就是<code>矩阵变量</code>               <code>@MatrixVariable(&quot;low&quot;) Integer low</code></p>\n<h4 id=\"请求映射\"><a href=\"#请求映射\" class=\"headerlink\" title=\"请求映射\"></a>请求映射</h4><p><code>@GetMapping、@PostMapping、@PutMapping、@DeleteMapping</code></p>\n<h3 id=\"原理类\"><a href=\"#原理类\" class=\"headerlink\" title=\"原理类\"></a>原理类</h3><h4 id=\"自动装配原理\"><a href=\"#自动装配原理\" class=\"headerlink\" title=\"自动装配原理\"></a>自动装配原理</h4><p><code>@SpringBootApplication</code>等同于<code>@SpringBootConfiguration  + @EnableAutoConfiguration  + @ComponentScan(&quot;com.ry&quot;)</code></p>\n<p>对于<code>`@SpringBootApplication</code>的分析重点是要分析<code>@SpringBootConfiguration</code>、<code>@EnableAutoConfiguration</code>  、<code>@ComponentScan</code></p>\n<h5 id=\"初始加载自动配置类\"><a href=\"#初始加载自动配置类\" class=\"headerlink\" title=\"初始加载自动配置类\"></a>初始加载自动配置类</h5><p>1、<code>@SpringBootConfiguration   @Configuration</code>；代表当前类是一个配置类</p>\n<p>2、<code>@ComponentScan</code> 指定扫描哪些Spring注解；</p>\n<p>3、<code>@EnableAutoConfiguration</code></p>\n<ul>\n<li><p><code>@Import(AutoConfigurationImportSelector.class)</code></p>\n</li>\n<li><p><code>@AutoConfigurationPackage</code>  自动配置包，指定了默认的包规则</p>\n</li>\n</ul>\n<p>虽然我们127个场景的所有自动配置启动的时候默认全部加载，但是<code>xxxxAutoConfiguration</code>按照条件装配规则（<code>@Conditional</code>），最终会按需配置。</p>\n<h5 id=\"自动配置流程\"><a href=\"#自动配置流程\" class=\"headerlink\" title=\"自动配置流程\"></a>自动配置流程</h5><p>1、首先SpringBoot默认会在底层配好所有的组件，但是<strong>如果用户自己配置了就会以用户配置的优先</strong></p>\n<p>2、定制化配置中，用户会先直接将自己@Bean替换底层的组件，用户去看这个组件是获取的配置文件什么值就去修改。</p>\n<h4 id=\"静态资源配置原理\"><a href=\"#静态资源配置原理\" class=\"headerlink\" title=\"静态资源配置原理\"></a>静态资源配置原理</h4><p>1、SpringBoot启动默认加载  xxxAutoConfiguration 类（自动配置类）</p>\n<p>2、SpringMVC功能的自动配置类<code>WebMvcAutoConfiguration</code>会生效</p>\n<p>3、给容器中配置 配置文件的相关属性：WebMvcProperties\\==<strong>spring.mvc</strong>、ResourceProperties==<strong>spring.resources</strong></p>\n<p>4、根据资源处理的默认规则，我们可以配置禁止所有静态资源规则</p>\n<h4 id=\"请求映射原理\"><a href=\"#请求映射原理\" class=\"headerlink\" title=\"请求映射原理\"></a>请求映射原理</h4><p>所有的请求映射都在HandlerMapping中：</p>\n<p>1、SpringBoot自动配置欢迎页的 WelcomePageHandlerMapping 。访问 /能访问到index.html；</p>\n<p>2、SpringBoot自动配置了默认 的 RequestMappingHandlerMapping</p>\n<p>​    2.1、请求进来，挨个尝试所有的HandlerMapping看是否有请求信息。</p>\n<p>​        如果有就找到这个请求对应的handler</p>\n<p>​        如果没有就是下一个 HandlerMapping</p>\n<p>3、要是我们需要一些自定义的映射处理，我们也可以自己给容器中放<strong>HandlerMapping</strong>。自定义 <strong>HandlerMapping</strong></p>\n<h4 id=\"内容协商原理\"><a href=\"#内容协商原理\" class=\"headerlink\" title=\"内容协商原理\"></a>内容协商原理</h4><p>1、判断当前响应头中是否已经有确定的媒体类型<code>MediaType</code>。</p>\n<p>2、获取客户端（PostMan、浏览器）支持接收的内容类型。（获取客户端Accept请求头字段application/xml）</p>\n<ul>\n<li><code>contentNegotiationManager</code> 内容协商管理器 默认使用基于请求头的策略</li>\n<li><code>HeaderContentNegotiationStrategy</code>  确定客户端可以接收的内容类型</li>\n</ul>\n<p>3、遍历循环所有当前系统的 <code>MessageConverter</code>，看谁支持操作这个对象（Person）</p>\n<p>4、找到支持操作Person的converter，把converter支持的媒体类型统计出来。</p>\n<p>5、客户端需要application/xml，服务端有10种MediaType。</p>\n<p>6、进行内容协商的最佳匹配媒体类型</p>\n<p>7、用 支持 将对象转为 最佳匹配媒体类型 的converter。调用它进行转化 。</p>\n<h4 id=\"拦截器的时机和原理：\"><a href=\"#拦截器的时机和原理：\" class=\"headerlink\" title=\"拦截器的时机和原理：\"></a>拦截器的时机和原理：</h4><p>​    1、根据当前请求，找到<code>HandlerExecutionChain</code>（可以处理请求的handler以及handler的所有 拦截器）</p>\n<p>​    2、先顺序执行 所有拦截器的 <code>preHandle()</code>方法。</p>\n<ul>\n<li>如果当前拦截器<code>preHandle()</code>返回为<code>true</code>。则执行下一个拦截器的<code>preHandle()</code></li>\n<li>如果当前拦截器返回为<code>false</code>。直接倒序执行所有已经执行了的拦截器的  <code>afterCompletion();</code>。</li>\n</ul>\n<p>​    3、如果任何一个拦截器返回<code>false</code>，直接跳出不执行目标方法。</p>\n<p>​    4、所有拦截器都返回<code>true</code>，才执行目标方法。</p>\n<p>​    5、倒序执行所有拦截器的<code>postHandle()</code>方法。</p>\n<p>​    6、前面的步骤有任何异常都会直接倒序触发 <code>afterCompletion()</code>。</p>\n<p>​    7、页面成功渲染完成以后，也会倒序触发 <code>afterCompletion()</code>。</p>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202303071838024.png\" alt=\"image-20230307183815985\" style=\"zoom:25%;\"></p>\n<h4 id=\"文件上传的原理\"><a href=\"#文件上传的原理\" class=\"headerlink\" title=\"文件上传的原理\"></a>文件上传的原理</h4><p>文件上传自动配置类-MultipartAutoConfiguration-MultipartProperties是自动配置好了StandardServletMultipartResolver   【文件上传的参数解析器】</p>\n<p><strong>原理步骤</strong></p>\n<p><strong>1、请求进来使用文件上传解析器判断（</strong>isMultipart<strong>）并封装（</strong>resolveMultipart，<strong>返回</strong>MultipartHttpServletRequest<strong>）文件上传请求</strong></p>\n<p><strong>2、参数解析器来解析请求中的文件内容封装成MultipartFile</strong></p>\n<p><strong>3、将request中文件信息封装为一个Map；MultiValueMap<String, multipartfile>FileCopyUtils</String,></strong>,实现文件流的拷贝</p>\n<h4 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h4><p>方式一：<code>@ControllerAdvice</code>+<code>@ExceptionHandler</code>处理全局异常；底层是 <code>ExceptionHandlerExceptionResolver</code> 支持的</p>\n<blockquote>\n<p><code>@ControllerAdvice   public class GlobalExceptionHandler &#123;@ExceptionHandler(&#123;ArithmeticException.class,NullPointerException.class&#125;) ...&#125; //处理异常</code></p>\n</blockquote>\n<p>方式二：<code>@ResponseStatus</code>+自定义异常 ；底层是 <code>ResponseStatusExceptionResolver</code> ，把responseStatus注解的信息底层调用</p>\n<blockquote>\n<p><code>@ResponseStatus(value= HttpStatus.FORBIDDEN,reason = &quot;用户数量太多&quot;)</code></p>\n</blockquote>\n<p>方式三:  自定义实现 <code>HandlerExceptionResolver</code> 处理异常；可以作为默认的全局异常处理规则</p>\n<h4 id=\"Web原生组件注入（Servlet、Filter、Listener）\"><a href=\"#Web原生组件注入（Servlet、Filter、Listener）\" class=\"headerlink\" title=\"Web原生组件注入（Servlet、Filter、Listener）\"></a>Web原生组件注入（Servlet、Filter、Listener）</h4><h5 id=\"使用原生的注解\"><a href=\"#使用原生的注解\" class=\"headerlink\" title=\"使用原生的注解\"></a>使用原生的注解</h5><p>1、<code>@ServletComponentScan(basePackages = &quot;com.example.demo&quot;):</code>指定原生Servlet组件都放在那里；</p>\n<p>2、<code>@WebServlet(urlPatterns = &quot;/my&quot;)：</code>效果：直接响应，<strong>没有经过Spring的拦截器</strong> ；</p>\n<p>3、<code>@WebFilter(urlPatterns=&#123;&quot;/css/*&quot;,&quot;/images/*&quot;&#125;)</code>；</p>\n<p>4、 <code>@WebListener</code></p>\n<blockquote>\n<p>原生注解要 在主启动类添加注解<code>@ServletComponentScan</code>    <code>ServletComponentScan(basePackages = &quot;com.example.demo&quot;)</code></p>\n</blockquote>\n<h5 id=\"Spring方式注入\"><a href=\"#Spring方式注入\" class=\"headerlink\" title=\"Spring方式注入\"></a><strong>Spring方式注入</strong></h5><p>1、<code>ServletRegistrationBean</code>,</p>\n<p>2、 <code>FilterRegistrationBean</code>,</p>\n<p>3、  <code>ServletListenerRegistrationBean</code></p>\n<blockquote>\n<p>Spring方式注入 仍要用相同的类，但是不要在类上加配置和也不要在启动程序上面加配置了</p>\n</blockquote>\n<h3 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h3><h5 id=\"配置文件查找位置\"><a href=\"#配置文件查找位置\" class=\"headerlink\" title=\"配置文件查找位置\"></a>配置文件查找位置</h5><ol>\n<li>classpath 根路径。</li>\n<li>classpath 根路径下config目录。</li>\n<li>jar包当前目录。</li>\n<li>jar包当前目录的config目录。</li>\n<li>/config子目录的直接子目录。</li>\n</ol>\n<h5 id=\"配置文件加载顺序：\"><a href=\"#配置文件加载顺序：\" class=\"headerlink\" title=\"配置文件加载顺序：\"></a>配置文件加载顺序：</h5><ol>\n<li>当前jar包内部的<code>application.properties</code>和<code>application.yml</code>。</li>\n<li>当前jar包内部的<code>application-&#123;profile&#125;.properties</code> 和 <code>application-&#123;profile&#125;.yml</code>。</li>\n<li>引用的外部jar包的<code>application.properties</code>和<code>application.yml</code>。</li>\n<li>引用的外部jar包的<code>application-&#123;profile&#125;.properties</code>和<code>application-&#123;profile&#125;.yml</code>。</li>\n</ol>\n<blockquote>\n<p>指定环境优先，外部优先，后面的可以覆盖前面的同名配置项。</p>\n</blockquote>\n<h3 id=\"starter\"><a href=\"#starter\" class=\"headerlink\" title=\"starter\"></a>starter</h3><h5 id=\"starter启动原理\"><a href=\"#starter启动原理\" class=\"headerlink\" title=\"starter启动原理\"></a>starter启动原理</h5><p>starter的pom.xml引入 autoconfigure 依赖；autoconfigure包中配置使用<code>META-INF/spring.factories</code>中<code>EnableAutoConfiguration</code>的值，使得项目启动加载指定的自动配置类</p>\n<p>引入starter —- <code>xxxAutoConfiguration</code> —- 容器中放入组件 —— <code>绑定xxxProperties</code> —— 配置项</p>\n<h3 id=\"SpringBoot启动过程\"><a href=\"#SpringBoot启动过程\" class=\"headerlink\" title=\"SpringBoot启动过程\"></a>SpringBoot启动过程</h3><p>==TODO==</p>\n","_path":"post/6f2612a2.html","_link":"http://rycan.top/post/6f2612a2.html","_id":"clo9tj5vn0033l10p61jrbnp3"}}