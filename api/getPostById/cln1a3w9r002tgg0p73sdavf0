{"type":"getPostById","data":{"title":"SpringBoot","date":"2023-09-13T15:42:02.000Z","description":"面试精选","categories":[{"name":"FaceToFace","_id":"cln1a3w9f000kgg0pg1jj2cur"}],"tags":[{"name":"SpringBoot","_id":"cln1a3wa2005qgg0p3c3d6cwu"}],"content":"<meta name=\"referrer\" content=\"no-referrer\">\n<h3 id=\"注解\">注解</h3>\n<ul>\n<li><code>@RestController</code>的作用相当于Controller加ResponseBody共同作用的结果，但采用RestController请求方式一般会采用Restful风格的形式。</li>\n<li><code>@Controller</code>的作用：声明该类是Controller层的Bean，将该类声明进入Spring容器中进行管理</li>\n<li><code>@ResponseBody</code>的作用：表明该类的所有方法的返回值都直接进行提交而不经过视图解析器，且返回值的数据自动封装为json的数据格式</li>\n</ul>\n<h4 id=\"组件添加\">组件添加</h4>\n<ul>\n<li>\n<p>@Bean  默认单实例，默认的id与方法名相同，也可以自行定义如：@Bean(“tom”) tom就代表该容器<code>@Bean //给容器中添加组件。以方法名作为组件的id。返回类型就是组件类型。返回的值，就是组件在容器中的实例</code></p>\n</li>\n<li>\n<p><code>@Configuration</code>  两种 模式Full模式与Lite模式     <code>@Configuration(proxyBeanMethods = false)</code> :</p>\n</li>\n</ul>\n<p>​\t\t\t<code>Full</code>(proxyBeanMethods = true)（保证每个@Bean方法被调用多少次返回的组件都是<code>单实例</code>的）（默认）;</p>\n<p>​\t\t\t<code>Lite</code>(proxyBeanMethods = false)（保证每个@Bean方法被调用多少次返回的组件都是新<code>创建的</code>）;</p>\n<p>​       使用推荐：</p>\n<p>​\t\t\t\t配置类组件之间<strong>无依赖关系用Lite模式</strong>，可以加速容器启动过程，减少判断</p>\n<p>​\t\t\t\t配置类组件之间<strong>有依赖关系用Full模式</strong>，方法会被调用，得到之前单实例组件</p>\n<ul>\n<li>\n<p><code>@Import(&#123;User.class, DBHelper.class&#125;) </code>  //会给容器中自动创建出这两个类型的组件、默认组件的名字就是全类名</p>\n</li>\n<li>\n<p><code>@ComponentScan</code>   规定扫描的位置</p>\n</li>\n<li>\n<p><code>@Conditional</code>       满足Conditional指定的条件，则进行组件注入</p>\n</li>\n<li>\n<p><code>@Bean、@Component、@Controller、@Service、@Repository</code>:Spring为Controller-Service-Dao的分层模型分别提供了@Controller、@Service、@Repository注解，除此之外的组件使用@Component注解。</p>\n</li>\n</ul>\n<h4 id=\"原生配置文件引入\">原生配置文件引入</h4>\n<p><code>@ImportResource</code>是原生配置文件引入；比如之前使用bean.xml文件生成配置bean，想继续复用bean.xml，可以使用<code>@ImportResource(&quot;classpath:beans.xml&quot;)</code></p>\n<h4 id=\"配置绑定\">配置绑定</h4>\n<p><code>@ConfigurationProperties</code> : 使用Java读取到<code>properties文件</code>中的内容，并且把它封装到JavaBean中，以供随时使用</p>\n<ul>\n<li>\n<p>方式一：<code>@ConfigurationProperties(prefix = &quot;mycar&quot;)   + @Component</code></p>\n</li>\n<li>\n<p>方式二：<code>@EnableConfigurationProperties(Car.class) 「等价于在car.java上配置@component」 + @ConfigurationProperties</code></p>\n</li>\n</ul>\n<h4 id=\"请求参数\">请求参数</h4>\n<p><code>@GetMapping(&quot;/car/&#123;id&#125;/owner/&#123;ownerName&#125;&quot;)</code></p>\n<p><code>@PathVariable</code> 路径变量\t\t\t\t\t\t\t<code>@PathVariable(&quot;id&quot;) Integer id</code></p>\n<p><code>@RequestParam </code>获取请求参数（指问号后的参数，url?a=1&amp;b=2）</p>\n<p>@RequestHeader<code> 获取请求头\t\t\t\t\t\t</code>@RequestHeader(“User-Agent”) String userAgent`</p>\n<p><code>@CookieValue </code>获取Cookie值\t\t\t\t\t\t<code>@CookieValue(&quot;Idea-df9e4e8c&quot;) String Idea</code></p>\n<p><code>@RequestBody</code> 获取请求体[POST]\t\t\t\t<code>@RequestBody String content</code></p>\n<p><code>@RequestAttribute </code>获取request域属性   \t<code>@RequestAttribute(value = &quot;msg&quot;,required = false) String msg</code></p>\n<p><code>@MatrixVariable</code>矩阵变量 （默认禁用，需要手动开启）\t\t\t 之前的请求方式： <code>/cars/&#123;path&#125;?xxx=xxx&amp;aaa=ccc </code> 使用<code>@RequestParam</code>查询字符串的方式获取请求参数<code>/cars/sell;low=34;brand=byd,audi,yd  </code>       路径中出现以分号；的方式分割字符串就是<code>矩阵变量</code>               <code>@MatrixVariable(&quot;low&quot;) Integer low</code></p>\n<h4 id=\"请求映射\">请求映射</h4>\n<p><code> @GetMapping、@PostMapping、@PutMapping、@DeleteMapping</code></p>\n<h3 id=\"原理类\">原理类</h3>\n<h4 id=\"自动装配原理\">自动装配原理</h4>\n<p><code>@SpringBootApplication</code>等同于<code>@SpringBootConfiguration  + @EnableAutoConfiguration  + @ComponentScan(&quot;com.ry&quot;)</code></p>\n<p>对于``@SpringBootApplication<code>的分析重点是要分析</code>@SpringBootConfiguration<code>、</code>@EnableAutoConfiguration<code>  、</code>@ComponentScan`</p>\n<h5 id=\"初始加载自动配置类\">初始加载自动配置类</h5>\n<p>1、<code>@SpringBootConfiguration   @Configuration</code>；代表当前类是一个配置类</p>\n<p>2、<code>@ComponentScan </code> 指定扫描哪些Spring注解；</p>\n<p>3、<code>@EnableAutoConfiguration</code></p>\n<ul>\n<li>\n<p><code>@Import(AutoConfigurationImportSelector.class)</code></p>\n</li>\n<li>\n<p><code>@AutoConfigurationPackage </code>  自动配置包，指定了默认的包规则</p>\n</li>\n</ul>\n<p>虽然我们127个场景的所有自动配置启动的时候默认全部加载，但是<code>xxxxAutoConfiguration</code>按照条件装配规则（<code>@Conditional</code>），最终会按需配置。</p>\n<h5 id=\"自动配置流程\">自动配置流程</h5>\n<p>1、首先SpringBoot默认会在底层配好所有的组件，但是<strong>如果用户自己配置了就会以用户配置的优先</strong></p>\n<p>2、定制化配置中，用户会先直接将自己@Bean替换底层的组件，用户去看这个组件是获取的配置文件什么值就去修改。</p>\n<h4 id=\"静态资源配置原理\">静态资源配置原理</h4>\n<p>1、SpringBoot启动默认加载  xxxAutoConfiguration 类（自动配置类）</p>\n<p>2、SpringMVC功能的自动配置类<code>WebMvcAutoConfiguration</code>会生效</p>\n<p>3、给容器中配置 配置文件的相关属性：WebMvcProperties==<strong>spring.mvc</strong>、ResourceProperties==<strong>spring.resources</strong></p>\n<p>4、根据资源处理的默认规则，我们可以配置禁止所有静态资源规则</p>\n<h4 id=\"请求映射原理\">请求映射原理</h4>\n<p>所有的请求映射都在HandlerMapping中：</p>\n<p>1、SpringBoot自动配置欢迎页的 WelcomePageHandlerMapping 。访问 /能访问到index.html；</p>\n<p>2、SpringBoot自动配置了默认 的 RequestMappingHandlerMapping</p>\n<p>​\t2.1、请求进来，挨个尝试所有的HandlerMapping看是否有请求信息。</p>\n<p>​\t\t如果有就找到这个请求对应的handler</p>\n<p>​\t\t如果没有就是下一个 HandlerMapping</p>\n<p>3、要是我们需要一些自定义的映射处理，我们也可以自己给容器中放<strong>HandlerMapping</strong>。自定义 <strong>HandlerMapping</strong></p>\n<h4 id=\"内容协商原理\">内容协商原理</h4>\n<p>1、判断当前响应头中是否已经有确定的媒体类型<code>MediaType</code>。</p>\n<p>2、获取客户端（PostMan、浏览器）支持接收的内容类型。（获取客户端Accept请求头字段application/xml）</p>\n<ul>\n<li><code>contentNegotiationManager</code> 内容协商管理器 默认使用基于请求头的策略</li>\n<li><code>HeaderContentNegotiationStrategy</code>  确定客户端可以接收的内容类型</li>\n</ul>\n<p>3、遍历循环所有当前系统的 <code>MessageConverter</code>，看谁支持操作这个对象（Person）</p>\n<p>4、找到支持操作Person的converter，把converter支持的媒体类型统计出来。</p>\n<p>5、客户端需要application/xml，服务端有10种MediaType。</p>\n<p>6、进行内容协商的最佳匹配媒体类型</p>\n<p>7、用 支持 将对象转为 最佳匹配媒体类型 的converter。调用它进行转化 。</p>\n<h4 id=\"拦截器的时机和原理：\">拦截器的时机和原理：</h4>\n<p>​\t1、根据当前请求，找到<code>HandlerExecutionChain</code>（可以处理请求的handler以及handler的所有 拦截器）</p>\n<p>​\t2、先顺序执行 所有拦截器的 <code>preHandle()</code>方法。</p>\n<ul>\n<li>如果当前拦截器<code>preHandle()</code>返回为<code>true</code>。则执行下一个拦截器的<code>preHandle()</code></li>\n<li>如果当前拦截器返回为<code>false</code>。直接倒序执行所有已经执行了的拦截器的  <code>afterCompletion();</code>。</li>\n</ul>\n<p>​\t3、如果任何一个拦截器返回<code>false</code>，直接跳出不执行目标方法。</p>\n<p>​\t4、所有拦截器都返回<code>true</code>，才执行目标方法。</p>\n<p>​\t5、倒序执行所有拦截器的<code>postHandle()</code>方法。</p>\n<p>​\t6、前面的步骤有任何异常都会直接倒序触发 <code>afterCompletion()</code>。</p>\n<p>​\t7、页面成功渲染完成以后，也会倒序触发 <code>afterCompletion()</code>。</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202303071838024.png\" alt=\"image-20230307183815985\" style=\"zoom:25%;\">\n<h4 id=\"文件上传的原理\">文件上传的原理</h4>\n<p>文件上传自动配置类-MultipartAutoConfiguration-MultipartProperties是自动配置好了StandardServletMultipartResolver   【文件上传的参数解析器】</p>\n<p><strong>原理步骤</strong></p>\n<p><strong>1、请求进来使用文件上传解析器判断（<strong>isMultipart</strong>）并封装（<strong>resolveMultipart，<strong>返回</strong>MultipartHttpServletRequest</strong>）文件上传请求</strong></p>\n<p><strong>2、参数解析器来解析请求中的文件内容封装成MultipartFile</strong></p>\n<p><strong>3、将request中文件信息封装为一个Map；MultiValueMap&lt;String, MultipartFile&gt;FileCopyUtils</strong>,实现文件流的拷贝</p>\n<h4 id=\"异常处理\">异常处理</h4>\n<p>方式一：<code>@ControllerAdvice</code>+<code>@ExceptionHandler</code>处理全局异常；底层是 <code>ExceptionHandlerExceptionResolver</code> 支持的</p>\n<blockquote>\n<p><code>@ControllerAdvice   public class GlobalExceptionHandler &#123;@ExceptionHandler(&#123;ArithmeticException.class,NullPointerException.class&#125;) ...&#125; //处理异常</code></p>\n</blockquote>\n<p>方式二：<code>@ResponseStatus</code>+自定义异常 ；底层是 <code>ResponseStatusExceptionResolver</code> ，把responseStatus注解的信息底层调用</p>\n<blockquote>\n<p><code>@ResponseStatus(value= HttpStatus.FORBIDDEN,reason = &quot;用户数量太多&quot;)</code></p>\n</blockquote>\n<p>方式三:  自定义实现 <code>HandlerExceptionResolver</code> 处理异常；可以作为默认的全局异常处理规则</p>\n<h4 id=\"Web原生组件注入（Servlet、Filter、Listener）\">Web原生组件注入（Servlet、Filter、Listener）</h4>\n<h5 id=\"使用原生的注解\">使用原生的注解</h5>\n<p>1、<code>@ServletComponentScan(basePackages = &quot;com.example.demo&quot;):</code>指定原生Servlet组件都放在那里；</p>\n<p>2、<code>@WebServlet(urlPatterns = &quot;/my&quot;)：</code>效果：直接响应，<strong>没有经过Spring的拦截器</strong> ；</p>\n<p>3、<code>@WebFilter(urlPatterns=&#123;&quot;/css/*&quot;,&quot;/images/*&quot;&#125;)</code>；</p>\n<p>4、 <code>@WebListener</code></p>\n<blockquote>\n<p>原生注解要 在主启动类添加注解<code>@ServletComponentScan</code>    <code>ServletComponentScan(basePackages = &quot;com.example.demo&quot;)</code></p>\n</blockquote>\n<h5 id=\"Spring方式注入\"><strong>Spring方式注入</strong></h5>\n<p>1、<code>ServletRegistrationBean</code>,</p>\n<p>2、 <code>FilterRegistrationBean</code>,</p>\n<p>3、  <code>ServletListenerRegistrationBean</code></p>\n<blockquote>\n<p>Spring方式注入 仍要用相同的类，但是不要在类上加配置和也不要在启动程序上面加配置了</p>\n</blockquote>\n<h3 id=\"配置文件\">配置文件</h3>\n<h5 id=\"配置文件查找位置\">配置文件查找位置</h5>\n<ol>\n<li>classpath 根路径。</li>\n<li>classpath 根路径下config目录。</li>\n<li>jar包当前目录。</li>\n<li>jar包当前目录的config目录。</li>\n<li>/config子目录的直接子目录。</li>\n</ol>\n<h5 id=\"配置文件加载顺序：\">配置文件加载顺序：</h5>\n<ol>\n<li>当前jar包内部的<code>application.properties</code>和<code>application.yml</code>。</li>\n<li>当前jar包内部的<code>application-&#123;profile&#125;.properties</code> 和 <code>application-&#123;profile&#125;.yml</code>。</li>\n<li>引用的外部jar包的<code>application.properties</code>和<code>application.yml</code>。</li>\n<li>引用的外部jar包的<code>application-&#123;profile&#125;.properties</code>和<code>application-&#123;profile&#125;.yml</code>。</li>\n</ol>\n<blockquote>\n<p>指定环境优先，外部优先，后面的可以覆盖前面的同名配置项。</p>\n</blockquote>\n<h3 id=\"starter\">starter</h3>\n<h5 id=\"starter启动原理\">starter启动原理</h5>\n<p>starter的pom.xml引入 autoconfigure 依赖；autoconfigure包中配置使用<code>META-INF/spring.factories</code>中<code>EnableAutoConfiguration</code>的值，使得项目启动加载指定的自动配置类</p>\n<p>引入starter — <code>xxxAutoConfiguration</code> — 容器中放入组件 ---- <code>绑定xxxProperties</code> ---- 配置项</p>\n<h3 id=\"SpringBoot启动过程\">SpringBoot启动过程</h3>\n<p>==TODO==</p>\n","_path":"post/6f2612a2.html","_link":"http://rycan.top/post/6f2612a2.html","_id":"cln1a3w9r002tgg0p73sdavf0"}}