{"type":"getPostByPath","data":{"title":"Netty 学习(黑马)","date":"2023-07-03T12:25:57.000Z","description":"Netty-2","categories":[{"name":"框架","_id":"cljn5lv40000cmi13cmr9964n"}],"tags":[{"name":"Netty","_id":"cljn5lv4d002vmi134pmu3050"}],"content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n\n<h1 id=\"NIO\"><a href=\"#NIO\" class=\"headerlink\" title=\"NIO\"></a>NIO</h1><h2 id=\"三大组件\"><a href=\"#三大组件\" class=\"headerlink\" title=\"三大组件\"></a>三大组件</h2><h3 id=\"1-Channel\"><a href=\"#1-Channel\" class=\"headerlink\" title=\"1. Channel\"></a>1. Channel</h3><blockquote>\n<p>基本介绍</p>\n</blockquote>\n<ul>\n<li><code>channel</code> 有一点类似于 <code>stream</code>，它就是读写<code>数据的双向通道</code>，可以从 <code>channel</code> 将数据读入 <code>buffer</code>，也可以将 buffer 的数据写入 <code>channel</code>，而之前的 <code>stream</code> 要么是输入，要么是输出，<code>channel</code> 比 <code>stream</code>更为底层</li>\n<li>通道可以<code>同时进行读写</code>，而<code>流</code> <code>只能读或者只能写</code>,通道可以<code>实现异步读写数据</code></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">channel --&gt; buffer</span><br><span class=\"line\">buffer --&gt; channel</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>常见的Channel</p>\n</blockquote>\n<ul>\n<li>FileChannel                       <code>文件的数据读写</code></li>\n<li>DatagramChannel           <code>UDP 的数据读</code></li>\n<li>SocketChannel                 <code>TCP 的数据读写</code></li>\n<li>ServerSocketChannel     <code>TCP 的数据读写</code></li>\n</ul>\n<blockquote>\n<p><code>ServerSocketChanne</code> 类似 <code>ServerSocket</code>、<code>SocketChannel</code> 类似 <code>Socket</code></p>\n</blockquote>\n<h4 id=\"文件编程\"><a href=\"#文件编程\" class=\"headerlink\" title=\"文件编程\"></a><em>文件编程</em></h4><h5 id=\"FileChannel\"><a href=\"#FileChannel\" class=\"headerlink\" title=\"FileChannel\"></a>FileChannel</h5><ul>\n<li><p>只能工作在阻塞模式下</p>\n</li>\n<li><p>方法</p>\n<ul>\n<li><p>获取</p>\n<ul>\n<li><code>不能直接打开</code> FileChannel，<code>必须</code>通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法<ul>\n<li>通过 <code>FileInputStream</code> 获取的 channel <code>只能读</code></li>\n<li>通过 <code>FileOutputStream</code> 获取的 channel <code>只能写</code></li>\n<li>通过 RandomAccessFile 是否能读写根据构造 <code>RandomAccessFile</code>时的<code>读写模式</code>决定</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>读取</p>\n<ul>\n<li><p><code>read</code>  会从 <code>channel</code> 读取数据填充 <code>ByteBuffer</code>，返回值表示读到了多少字节，<code>-1</code> 表示到达了文件的末尾</p>\n<p>使用方式：<code>channel.read(buffer);</code></p>\n</li>\n</ul>\n</li>\n<li><p>写入</p>\n<ul>\n<li>使用方式：<code>channel.write(buffer);</code> 一般会使用<code>while</code>循环的调用<code>write</code> ，只有这样才能确保一定能将所有的数据都写到channel中</li>\n</ul>\n</li>\n<li><p>关闭</p>\n<ul>\n<li><code>channel</code> 必须<code>关闭</code>，不过调用了 FileInputStream、FileOutputStream 或者 RandomAccessFile 的 <code>close</code> 方法会间接地调用 channel 的 <code>close</code> 方法</li>\n</ul>\n</li>\n<li><p>位置</p>\n<ul>\n<li>获取当前位置   <code>long pos  = channel.position();</code></li>\n<li>设置当前位置   <code>channel.position(newPosition);</code></li>\n<li><p>设置当前位置时，如果设置为文件的末尾</p>\n<ul>\n<li>这时读取会返回<code>-1</code></li>\n<li>这时写入，会追加内容，但要注意如果 <code>position</code> 超过了文件末尾，再写入时在<code>新内容和原末尾之间</code>会有空洞（00）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>大小</p>\n<p>使用 <code>size</code> 方法获取文件的大小</p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>强制写入</p>\n<p>操作系统出于性能的考虑，会将数据缓存，不是立刻写入磁盘。可以调用 <code>force(true)</code> 方法将文件内容和元数据（文件的权限等信息）立刻写入磁盘</p>\n</li>\n</ul>\n<h5 id=\"Path\"><a href=\"#Path\" class=\"headerlink\" title=\"Path\"></a>Path</h5><ul>\n<li>类： <code>path,paths</code></li>\n<li><code>Path</code> 用来表示<code>文件路径</code></li>\n<li><code>Paths</code> 是工具类，用来<code>获取 Path 实例</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Path</span> <span class=\"variable\">source</span> <span class=\"operator\">=</span> Paths.get(<span class=\"string\">&quot;1.txt&quot;</span>); <span class=\"comment\">// 相对路径 使用 user.dir 环境变量来定位 1.txt</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Path</span> <span class=\"variable\">source</span> <span class=\"operator\">=</span> Paths.get(<span class=\"string\">&quot;d:\\\\1.txt&quot;</span>); <span class=\"comment\">// 绝对路径 代表了  d:\\1.txt</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Path</span> <span class=\"variable\">source</span> <span class=\"operator\">=</span> Paths.get(<span class=\"string\">&quot;d:/1.txt&quot;</span>); <span class=\"comment\">// 绝对路径 同样代表了  d:\\1.txt</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Path</span> <span class=\"variable\">projects</span> <span class=\"operator\">=</span> Paths.get(<span class=\"string\">&quot;d:\\\\data&quot;</span>, <span class=\"string\">&quot;projects&quot;</span>); <span class=\"comment\">// 代表了  d:\\data\\projects</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>.</code> 代表了当前路径</li>\n<li><code>..</code> 代表了上一级路径</li>\n</ul>\n<p>例如目录结构如下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">d:</span><br><span class=\"line\">\t|- data</span><br><span class=\"line\">\t\t|- projects</span><br><span class=\"line\">\t\t\t|- a</span><br><span class=\"line\">\t\t\t|- b</span><br></pre></td></tr></table></figure>\n<p>代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Path</span> <span class=\"variable\">path</span> <span class=\"operator\">=</span> Paths.get(<span class=\"string\">&quot;d:\\\\data\\\\projects\\\\a\\\\..\\\\b&quot;</span>);</span><br><span class=\"line\">System.out.println(path);</span><br><span class=\"line\">System.out.println(path.normalize()); <span class=\"comment\">// 正常化路径</span></span><br></pre></td></tr></table></figure>\n<p>会输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">d:\\data\\projects\\a\\..\\b</span><br><span class=\"line\">d:\\data\\projects\\b</span><br></pre></td></tr></table></figure>\n<h5 id=\"Files\"><a href=\"#Files\" class=\"headerlink\" title=\"Files\"></a>Files</h5><p><code>Path path = Paths.get(&quot;......&quot;);</code></p>\n<ul>\n<li>检查是否存在：<code>System.out.println(Files.exists(path));</code></li>\n<li>创建一级目录：<code>Files.createDirectory(path);</code><ul>\n<li>如果目录<code>已存在</code>，会抛异常 <code>FileAlreadyExistsException</code></li>\n<li><code>不能一次创建多级目录</code>，否则会抛异常 <code>NoSuchFileException</code></li>\n</ul>\n</li>\n<li>创建多级目录: <code>Files.createDirectories(path);</code></li>\n<li>拷贝文件  <code>Files.copy(source, target);</code>   其中 <code>source target</code>都要进行获取<ul>\n<li>如果文件已存在，会抛异常 <code>FileAlreadyExistsException</code></li>\n<li>用 <code>source</code> 覆盖掉 <code>target</code>，需要用 <code>StandardCopyOption</code> 来控制<code>Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);</code></li>\n</ul>\n</li>\n<li>移动文件<ul>\n<li><code>Files.move(source, target, StandardCopyOption.ATOMIC_MOVE);</code>  <code>StandardCopyOption.ATOMIC_MOVE</code> 保证文件移动的原子性</li>\n</ul>\n</li>\n<li><p>删除文件<code>Files.delete(target);</code></p>\n<ul>\n<li>如果文件不存在，会抛异常 <code>NoSuchFileException</code></li>\n</ul>\n</li>\n<li><p>删除目录<code>Files.delete(target);</code></p>\n<ul>\n<li>如果目录还有内容，会抛异常 <code>DirectoryNotEmptyException</code></li>\n</ul>\n</li>\n<li>遍历目录文件<code>Files.walkFileTree(Paths.get(&quot;/Users/yangrui/Downloads/&quot;), new SimpleFileVisitor&lt;Path&gt;()</code></li>\n<li>统计文件数目<code>Files.walkFileTree(Paths.get(&quot;/Users/yangrui/Pictures&quot;), new SimpleFileVisitor&lt;Path&gt;()</code></li>\n<li>删除多级目录 <code>Files.walkFileTree(Paths.get(&quot;E:\\\\aio1 - 副本 - 副本&quot;), new SimpleFileVisitor&lt;Path&gt;()</code></li>\n</ul>\n<p>​    ⚠️ 删除很危险⚠️     删除是危险操作，确保要递归删除的文件夹没有重要内容</p>\n<ul>\n<li>拷贝多级目录 <code>Files.walk(Paths.get(source)).forEach(path -&gt; &#123;...&#125;</code></li>\n</ul>\n<h3 id=\"2-Buffer\"><a href=\"#2-Buffer\" class=\"headerlink\" title=\"2. Buffer\"></a>2. Buffer</h3><blockquote>\n<p>基本介绍</p>\n</blockquote>\n<p>buffer 则用来<code>缓冲读写数据</code></p>\n<p>常见的 buffer 有<code>ByteBuffer</code>（MappedByteBuffer、DirectByteBuffer、HeapByteBuffer）| <code>ShortBuffer</code>| <code>IntBuffer</code>|<code>LongBuffer</code>|<code>FloatBuffer</code>|<code>DoubleBuffer</code>|<code>CharBuffer</code></p>\n<h5 id=\"ByteBuffer\"><a href=\"#ByteBuffer\" class=\"headerlink\" title=\"ByteBuffer\"></a><code>ByteBuffer</code></h5><blockquote>\n<p><code>ByteBuffer</code>结构：</p>\n<ul>\n<li><code>capacity</code>&lt;容量&gt;</li>\n<li><code>position</code>&lt;读到哪/写到哪 的 指针/索引下标&gt;</li>\n<li><code>limit</code>&lt;限制&gt;</li>\n</ul>\n<p><span style=\"color:red\">一开始</span></p>\n</blockquote>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306141856487.png\" alt=\"image-20230614185614467\" style=\"zoom:33%;\"></p>\n<blockquote>\n<p><span style=\"color:red\">写模式下，position 是写入位置，limit 等于容量，下图表示写入了 4 个字节后的状态</span></p>\n<p>==注意：根据<code>读写模式</code>的不同 <code>position</code>的数值也是不同的==</p>\n</blockquote>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306141856067.png\" alt=\"image-20230614185623653\" style=\"zoom:33%;\"></p>\n<blockquote>\n<p><span style=\"color:red\">此时要读了 ，调用flip 切换为读 ，flip 动作发生后，position 切换为读取位置，limit 切换为读取限制</span></p>\n</blockquote>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306141906794.png\" style=\"zoom:33%;\"></p>\n<blockquote>\n<p><span style=\"color:red\">读取 4 个字节后，状态</span></p>\n</blockquote>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306141856617.png\" alt=\"image-20230614185649599\" style=\"zoom:33%;\"></p>\n<blockquote>\n<p><span style=\"color:red\"> 从头开始写，调用  clear()，clear 动作发生后，状态</span></p>\n</blockquote>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306141856944.png\" alt=\"image-20230614185657928\" style=\"zoom:33%;\"></p>\n<blockquote>\n<p><span style=\"color:red\">开始上次未读完的地方继续写，调用 compact 方法，是把未读完的部分向前压缩，然后切换至写模式</span></p>\n</blockquote>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306141857030.png\" alt=\"image-20230614185733003\" style=\"zoom:33%;\"></p>\n<blockquote>\n<p>使用方式：</p>\n</blockquote>\n<ol>\n<li>向 <code>buffer</code> 写入数据，例如调用<code>channel.read(buffer)</code></li>\n<li>调用 <code>flip()</code> 切换至<strong>读模式</strong></li>\n<li>从 <code>buffer</code> 读取数据，例如调用 <code>buffer.get()</code></li>\n<li>调用 <code>clear()</code> 或 <code>compact()</code>切换至<strong>写模式</strong></li>\n<li>重复 1~4 步骤</li>\n</ol>\n<blockquote>\n<p>常见方法：</p>\n</blockquote>\n<ul>\n<li><p>分配空间——<code>allocate()</code>                     <code>Bytebuffer buf = ByteBuffer.allocate(16);</code></p>\n</li>\n<li><p>向<code>buffer</code> 中写数据</p>\n<ul>\n<li>调用 <code>channel</code> 的 <code>read</code> 方法         <code>int readBytes = channel.read(buf);</code></li>\n<li>调用 <code>buffer</code> 自己的 <code>put</code> 方法      <code>buf.put((byte)127);</code></li>\n</ul>\n</li>\n<li><p>从 <code>buffer</code> 读取数据</p>\n<ul>\n<li><p>调用 <code>channel</code> 的 <code>write</code> 方法        <code>int writeBytes = channel.write(buf);</code></p>\n</li>\n<li><p>调用 <code>buffer</code> 自己的 <code>get</code> 方法       <code>byte b = buf.get();</code></p>\n<blockquote>\n<p>注意：<code>get</code> 方法会让 <code>position</code> 读指针向后走，如果想重复读取数据</p>\n<ul>\n<li>可以调用 <code>rewind</code> 方法将 <code>position</code> 重新置为 <code>0</code></li>\n<li>或者调用<code>get(int i)</code>含参的方法获取索引<code>i</code> 的内容，它不会移动读指针</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p><code>mark</code> &amp; <code>reset</code></p>\n<ul>\n<li><code>mark</code> 是在读取时，做一个标记，即使 <code>position</code> 改变，只要调用 <code>reset</code> 就能回到 <code>mark</code> 的位置</li>\n<li><code>rewind</code> 和 <code>flip</code> 都会清除 mark 位置</li>\n</ul>\n</li>\n<li><p>切换<code>读写</code>模式——<code>flip</code>    <code>compact</code></p>\n<ul>\n<li><p><code>buffer.flip(); // 切换至</code>读<code>模式 [position指针才指向开头，limit指向写入的最后位置 (内存长度)]</code></p>\n</li>\n<li><p><code>buffer.compact(); // 未读完的部分向前压缩，然后切换至</code>写<code>模式,下标position到压缩后的字符长度的位置，limit到写入限制</code></p>\n</li>\n</ul>\n</li>\n<li><p>分配空间</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(ByteBuffer.allocate(<span class=\"number\">10</span>).getClass()); </span><br><span class=\"line\"><span class=\"comment\">//class java.nio.HeapByteBuffer --java 堆内存，在堆中，读写效率较低，会受到gc的影响</span></span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(ByteBuffer.allocateDirect(<span class=\"number\">10</span>).getClass());</span><br><span class=\"line\"><span class=\"comment\">//class java.nio.DirectByteBuffer -- 在直接内存中，在内存中读写效率较高，不会受到gc的影响，分配内存的效率较低，可能会内存泄漏,所以在使用完后，需要彻底的释放，以免内存泄露</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>字符串</code>与 <code>ByteBuffer</code> 互转</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ByteBuffer</span> <span class=\"variable\">bu1</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">16</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//方式一： nio提供的工具类 wrap 方法， 将字节数组 ===&gt; 包装成ByteBuffer  也会自动切换为 读模式了</span></span><br><span class=\"line\"><span class=\"type\">ByteBuffer</span> <span class=\"variable\">bu3</span> <span class=\"operator\">=</span> ByteBuffer.wrap(<span class=\"string\">&quot;buffer&quot;</span>.getBytes());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//方式二： 字符串 转 字节数组 ===&gt; 使用put方法放 进去</span></span><br><span class=\"line\">bu1.put(<span class=\"string\">&quot;buffer&quot;</span>.getBytes());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//方式三： 使用 字符集类 Charset</span></span><br><span class=\"line\"> <span class=\"type\">ByteBuffer</span> <span class=\"variable\">bu4</span> <span class=\"operator\">=</span> Charset.forName(<span class=\"string\">&quot;utf-8&quot;</span>).encode(<span class=\"string\">&quot;Charset.format()&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//方式四： 使用 字符集类 Charset , 它本身就支持 和 ByteBuffer 相互转换 会自动切换为 读模式了</span></span><br><span class=\"line\"><span class=\"type\">ByteBuffer</span> <span class=\"variable\">bu2</span> <span class=\"operator\">=</span> StandardCharsets.UTF_8.encode(<span class=\"string\">&quot;你好,buffer&quot;</span>);  <span class=\"comment\">//此处中文在字符数组中不显示</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>分散读——<code>Scattering Reads</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">FileChannel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RandomAccessFile</span>(<span class=\"string\">&quot;/Users/yangrui/Downloads/A_Java学习资源/Java_Netty/black-horse-netty-master/netty-1-nio/words.txt&quot;</span>, <span class=\"string\">&quot;rw&quot;</span>).getChannel();</span><br><span class=\"line\"><span class=\"type\">ByteBuffer</span> <span class=\"variable\">bu1</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">3</span>); <span class=\"comment\">// one</span></span><br><span class=\"line\">        <span class=\"type\">ByteBuffer</span> <span class=\"variable\">bu2</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">3</span>); <span class=\"comment\">// two</span></span><br><span class=\"line\">        <span class=\"type\">ByteBuffer</span> <span class=\"variable\">bu3</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">5</span>); <span class=\"comment\">// three</span></span><br><span class=\"line\">        channel.read(<span class=\"keyword\">new</span> <span class=\"title class_\">ByteBuffer</span>[]&#123;bu1,bu2,bu3&#125;);</span><br><span class=\"line\">        bu1.flip();</span><br><span class=\"line\">        bu2.flip();</span><br><span class=\"line\">        bu3.flip();</span><br><span class=\"line\">        <span class=\"comment\">//写的时候才能debugAll()</span></span><br><span class=\"line\">        debugAll(bu1);</span><br><span class=\"line\">        debugAll(bu2);</span><br><span class=\"line\">        debugAll(bu3);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>集中写——<code>Gathering Writes</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ByteBuffer</span> <span class=\"variable\">b1</span> <span class=\"operator\">=</span> StandardCharsets.UTF_8.encode(<span class=\"string\">&quot;Hello&quot;</span>); <span class=\"comment\">// 5字节</span></span><br><span class=\"line\"><span class=\"type\">ByteBuffer</span> <span class=\"variable\">b2</span> <span class=\"operator\">=</span> StandardCharsets.UTF_8.encode(<span class=\"string\">&quot;world&quot;</span>);  <span class=\"comment\">// 5字节</span></span><br><span class=\"line\"><span class=\"type\">ByteBuffer</span> <span class=\"variable\">b3</span> <span class=\"operator\">=</span> StandardCharsets.UTF_8.encode(<span class=\"string\">&quot;你好&quot;</span>);   <span class=\"comment\">// 6字节</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">FileChannel</span> <span class=\"variable\">ch</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RandomAccessFile</span>(<span class=\"string\">&quot;/Users/yangrui/Downloads/A_Java学习资源/Java_Netty/black-horse-netty-master/netty-1-nio/writes1.txt&quot;</span>, <span class=\"string\">&quot;rw&quot;</span>).getChannel();</span><br><span class=\"line\">            ch.write(<span class=\"keyword\">new</span> <span class=\"title class_\">ByteBuffer</span>[]&#123;b1, b2, b3&#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 另一例</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> (<span class=\"type\">RandomAccessFile</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RandomAccessFile</span>(<span class=\"string\">&quot;/Users/yangrui/Downloads/A_Java学习资源/Java_Netty/black-horse-netty-master/netty-1-nio/words.txt&quot;</span>, <span class=\"string\">&quot;rw&quot;</span>)) &#123;</span><br><span class=\"line\">    <span class=\"type\">FileChannel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> file.getChannel();</span><br><span class=\"line\">    <span class=\"type\">ByteBuffer</span> <span class=\"variable\">d</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">4</span>);</span><br><span class=\"line\">    <span class=\"type\">ByteBuffer</span> <span class=\"variable\">e</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">4</span>);</span><br><span class=\"line\">    channel.position(<span class=\"number\">11</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    d.put(<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"string\">&#x27;f&#x27;</span>, <span class=\"string\">&#x27;o&#x27;</span>, <span class=\"string\">&#x27;u&#x27;</span>, <span class=\"string\">&#x27;r&#x27;</span>&#125;);</span><br><span class=\"line\">    e.put(<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"string\">&#x27;f&#x27;</span>, <span class=\"string\">&#x27;i&#x27;</span>, <span class=\"string\">&#x27;v&#x27;</span>, <span class=\"string\">&#x27;e&#x27;</span>&#125;);</span><br><span class=\"line\">    d.flip();</span><br><span class=\"line\">    e.flip();</span><br><span class=\"line\">    debug(d);</span><br><span class=\"line\">    debug(e);</span><br><span class=\"line\">    channel.write(<span class=\"keyword\">new</span> <span class=\"title class_\">ByteBuffer</span>[]&#123;d, e&#125;);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>Buffer</code>是<code>非线程安全的</code></p>\n</blockquote>\n<h3 id=\"3-Selector\"><a href=\"#3-Selector\" class=\"headerlink\" title=\"3. Selector\"></a>3. Selector</h3><h5 id=\"3-1-多线程版本\"><a href=\"#3-1-多线程版本\" class=\"headerlink\" title=\"3.1 多线程版本\"></a>3.1 多线程版本</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD</span><br><span class=\"line\">subgraph 多线程版</span><br><span class=\"line\">t1(thread) --&gt; s1(socket1)</span><br><span class=\"line\">t2(thread) --&gt; s2(socket2)</span><br><span class=\"line\">t3(thread) --&gt; s3(socket3)</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<ul>\n<li>缺点<ul>\n<li>内存占用高</li>\n<li>线程上下文切换成本高</li>\n<li>只适合连接数少的场景</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"3-2线程池版本\"><a href=\"#3-2线程池版本\" class=\"headerlink\" title=\"3.2线程池版本\"></a>3.2线程池版本</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD</span><br><span class=\"line\">subgraph 线程池版</span><br><span class=\"line\">t4(thread) --&gt; s4(socket1)</span><br><span class=\"line\">t5(thread) --&gt; s5(socket2)</span><br><span class=\"line\">t4(thread) -.-&gt; s6(socket3)</span><br><span class=\"line\">t5(thread) -.-&gt; s7(socket4)</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<ul>\n<li>缺点<ul>\n<li><code>socket工作在阻塞模式下</code>，线程仅能处理一个 socket 连接</li>\n<li>仅适合[短连接] [<code>就是链接之后处理完时间就立即断开</code>]场景</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"3-2-Selector版本\"><a href=\"#3-2-Selector版本\" class=\"headerlink\" title=\"3.2 Selector版本\"></a>3.2 Selector版本</h5><ul>\n<li><p><code>selector</code> 的作用就是配合<code>一个线程</code>来管理<code>多个 channel</code>，获取这些 <code>channel</code> 上发生的事件，这些 <code>channel 工作在非阻塞模式</code>下，不会让线程只在一个 <code>channel</code> 上工作。</p>\n</li>\n<li><p>适合连接数特别多，但流量低<code>[就是非频繁]</code>的场景（low traffic）</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD</span><br><span class=\"line\">subgraph selector 版</span><br><span class=\"line\">thread --&gt; selector</span><br><span class=\"line\">selector --&gt; c1(channel)</span><br><span class=\"line\">selector --&gt; c2(channel)</span><br><span class=\"line\">selector --&gt; c3(channel)</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<ul>\n<li>好处<ul>\n<li>一个线程配合 <code>selector</code> 就可以监控多个 <code>channel</code> 的事件，事件发生线程才去处理。避免非阻塞模式下所做无用功</li>\n<li>让这个线程能够被充分利用</li>\n<li>节约了线程的数量</li>\n<li>减少了线程上下文切换</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>思想流程就是：</p>\n<p>调用 <code>selector</code> 的 <code>select()</code>会进行阻塞，直到 <code>channel</code> 发生了<code>读写就绪</code>事件，<code>select</code> 方法才会返回<code>这些事件</code>并交给 <code>thread</code> 来处理</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Selector</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Closeable</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Selector <span class=\"title function_\">open</span><span class=\"params\">()</span>; <span class=\"comment\">//得到一个选择器对象</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">select</span><span class=\"params\">(<span class=\"type\">long</span> timeout)</span>);<span class=\"comment\">//监控所有注册的通道，当其中有IO操作可以进行时，将对应的SelectionKey加入到内部集合中并返回，参数用来设置超时时间</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Set&lt;SelectionKey&gt;selectedKeys();<span class=\"comment\">//从内部集合中得到所有的SelectionKey</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Selector</code> 相关方法说明</p>\n<ul>\n<li><code>selector.select();</code> //阻塞</li>\n<li><code>selector.select(1000);</code> //阻塞 1000 毫秒，在 1000 毫秒后返回</li>\n<li><code>selector.wakeup();</code> //唤醒 selector</li>\n<li><p><code>selector.selectNow();</code> //不阻塞，立马返还</p>\n</li>\n<li><p>创建：<code>Selector selector = Selector.open();</code></p>\n</li>\n<li>绑定<code>Channel</code>事件： 注册事件，绑定的事件 selector 才会关心<ul>\n<li><code>channel.configureBlocking(false);     SelectionKey key = channel.register(selector, 绑定事件);</code></li>\n<li><code>channel</code> 必须工作在<code>非阻塞</code>模式</li>\n<li><code>FileChannel</code> 没有<code>非阻塞</code>模式，因此不能配合 selector 一起使用</li>\n<li>绑定的事件类型可以有<ul>\n<li><code>connect - 客户端连接成功时触发</code></li>\n<li><code>accept - 服务器端成功接受连接时触发</code></li>\n<li><code>read - 数据可读入时触发，有因为接收能力弱，数据暂不能读入的情况</code></li>\n<li><code>write - 数据可写出时触发，有因为发送能力弱，数据暂不能写出的情况</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>监听 <code>Channel</code> 事件<ul>\n<li>可以通过下面三种方法来监听是否有事件发生，方法的返回值代表有多少 channel 发生了事件<ul>\n<li>阻塞直到绑定事件发生<code>int count = selector.select();</code></li>\n<li>阻塞直到绑定事件发生，或是超时（时间单位为 ms）<code>int count = selector.select(long timeout);</code></li>\n<li>不会阻塞，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件<code>int count = selector.selectNow();</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>select()</code>何时不会阻塞<ul>\n<li>事件发生时<ul>\n<li>客户端发起连接请求，会触发 <code>accept</code> 事件</li>\n<li>客户端发送数据过来、客户端正常、异常关闭时，都会触发 <code>read</code> 事件，另外如果发送的数据大于 <code>buffer</code> 缓冲区也会触发多次读取事件</li>\n<li><code>channel</code> 可写，会触发 <code>write</code> 事件</li>\n<li>在 <code>linux</code> 下 <code>nio bug</code> 发生时</li>\n</ul>\n</li>\n<li>调用<code>selector.wakeup()</code></li>\n<li>调用 <code>selector.close()</code></li>\n<li><code>selector</code> 所在线程<code>interrupt</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"网络编程\"><a href=\"#网络编程\" class=\"headerlink\" title=\"网络编程\"></a>网络编程</h2><h3 id=\"阻塞与非阻塞\"><a href=\"#阻塞与非阻塞\" class=\"headerlink\" title=\"阻塞与非阻塞\"></a>阻塞与非阻塞</h3><ul>\n<li>阻塞：&lt;所谓的<code>阻塞</code> :   就是 线程<code>没有得到 连接</code>就会 <code>停止运行</code>   线程<code>没有得到数据</code>的时候 也会<code>停止运行</code>&gt;<ul>\n<li><code>阻塞模式</code>下，下面的方法都会导致线程<code>暂停</code><ul>\n<li><code>ServerSocketChannel.accept</code> 会在<code>没有连接建立</code>时让线程暂停</li>\n<li><code>SocketChannel.read</code> 会在<code>没有数据可读</code>时让线程暂停</li>\n<li>阻塞的表现其实就是线程暂停了，<code>暂停期间不会占用 cpu</code>，线程相当于闲置</li>\n</ul>\n</li>\n<li>单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持</li>\n<li>但多线程下，有新的问题，体现在以下方面<ul>\n<li>32 位 <code>jvm</code> 一个线程 <code>320k</code>，64 位 <code>jvm</code> 一个线程 <code>1024</code>k，如果连接数过多，必然导致 <code>OOM</code>，并且线程太多，反而会因为频繁上下文切换导致性能降低</li>\n<li>可以采用<code>线程池技术</code>来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间 <code>inactive</code>，会阻塞线程池中所有线程，因此不适合长连接，<code>只适合短连接</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>流程模拟</p>\n<p>服务端：</p>\n<ul>\n<li>创建一个全局<code>ByteBuffer</code>的缓冲区，进行存储数据，可读可写</li>\n<li>创建一个通道类型为<code>ServerSocketChannel</code>的通道，进行监听客户端连接请求和接受客户端发送过来的数据，并进行绑定端口</li>\n<li>创建一个<code>Channel</code>的类型的数组，使用<code>ArrayList</code>进行存储，便于管理</li>\n<li>建立 客户端连接,使用 TCP 三次握手, 使用<code>acccept</code>的方法，其默认是阻塞的，就是会让线程暂停，等待客户端连接，要是只启动了客户端那么会在这里进行阻塞，直到客户端也启动了才结束阻塞，产生一个 <code>SocketChannel</code> 的读写通道<code>sc</code>，方便与客户端通信 进行数据读写</li>\n<li>接收 <code>客户端</code>的数据， 进行遍历处理，按照通道顺序进行遍历，==但是要是第一个通道没数据就会一直阻塞，第二个有数据也读不到（下面的非阻塞会对其进行改进）==</li>\n<li>调用<code>read</code> 的方法进行读取<code>channel</code>的数据到<code>buffer</code>中，切换为<code>写</code>模式</li>\n<li>将 <code>ByteBuffer</code> 类型的 <code>buffer</code> 转换为 <code>CharBuffer</code> 类型的 <code>string</code>，并且使用默认字符集进行解码</li>\n<li>在写模式下继续循环写</li>\n</ul>\n<p>客户端：</p>\n<ul>\n<li>创建<code>SocketChannel</code> 并指定连接的<code>端口号</code>和<code>服务器</code></li>\n</ul>\n</blockquote>\n<ul>\n<li><p>非阻塞：</p>\n<ul>\n<li><p>非阻塞模式下，下面到的相关方法都不会让线程暂停</p>\n<ul>\n<li><p>在 <code>ServerSocketChannel.accept</code> 在没有连接建立时，会返回 <code>null</code>，继续运行</p>\n</li>\n<li><p><code>SocketChannel.read</code> 在没有数据可读时，会返回<code>0</code>，但线程不必阻塞，可以去执行其它 <code>SocketChannel</code> 的 <code>read</code> 或是去执行 <code>ServerSocketChannel.accept</code></p>\n</li>\n<li><p>写数据时，线程只是等待数据写入 <code>Channel</code> 即可，无需等 <code>Channel</code> 通过网络把数据发送出去</p>\n</li>\n</ul>\n</li>\n<li><p>弊端</p>\n<ul>\n<li>但非阻塞模式下，即使没有连接建立，和可读数据，线程仍然在不断运行，白白浪费了 cpu</li>\n<li>数据复制过程中，线程实际还是阻塞的（AIO 改进的地方）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>服务端：</p>\n<ul>\n<li>创建一个全局<code>ByteBuffer</code>的缓冲区，进行存储数据，可读可写</li>\n<li>创建一个通道类型为<code>ServerSocketChannel</code>的通道，进行监听客户端连接请求和接受客户端发送过来的数据，并进行绑定端口</li>\n<li>切换 <code>ServerSocketChannel</code> 为 非阻塞 模式， 默认<code>true</code>是阻塞的,将  <code>accept</code> 设置为 非阻塞方法<code>ssc.configureBlocking(false)</code></li>\n<li>创建一个<code>Channel</code>的类型的数组，使用<code>ArrayList</code>进行存储，便于管理</li>\n<li>建立 客户端连接,使用 TCP 三次握手, 使用<code>acccept</code>的方法，此时<code>acccept</code>是非阻塞方法【如果没建立连接，程序继续跑，但是<code>sc=null</code>】</li>\n<li>切换 <code>SocketChannel</code> 为 <code>非阻塞</code> 模式， 默认<code>true</code>是<code>阻塞</code>的,将 <code>read</code> 变成 <code>非阻塞方法</code> <code>sc.configureBlocking(false);</code></li>\n<li>接收 <code>客户端</code>的数据， 进行遍历处理，按照通道顺序进行遍历</li>\n<li>此时<code>read</code>是 非阻塞方法,【如果没读到数据返回 0】,否则返回读取到的长度</li>\n<li>调用<code>read</code> 的方法进行读取<code>channel</code>的数据到<code>buffer</code>中，切换为<code>写</code>模式</li>\n<li>将 <code>ByteBuffer</code> 类型的 <code>buffer</code> 转换为 <code>CharBuffer</code> 类型的 <code>string</code>，并且使用默认字符集进行解码</li>\n<li>在写模式下继续循环写</li>\n</ul>\n<p>客户端：</p>\n<ul>\n<li>同上，不变</li>\n</ul>\n</blockquote>\n<h3 id=\"多路复用\"><a href=\"#多路复用\" class=\"headerlink\" title=\"多路复用\"></a>多路复用</h3><p>单线程可以配合 <code>Selector</code> 完成对多个 <code>Channel</code> 可读写<code>事件的监控</code>，这称之为<code>多路复用</code></p>\n<ul>\n<li><code>多路复用</code>仅针对<code>网络 IO</code>,普通文件 IO <code>无法</code>利用多路复用</li>\n<li>如果不用 <code>Selector</code> 的非阻塞模式，线程大部分时间都在做无用功，而 <code>Selector</code> 能够保证<ul>\n<li>有可连接事件时才去连接</li>\n<li>有可读事件才去读取</li>\n<li>有可写事件才去写入<ul>\n<li>限于网络传输能力，<code>Channel</code> 未必时时可写，一旦 <code>Channel</code> 可写，会触发 <code>Selector</code> 的可写事件</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"处理-accept-事件\"><a href=\"#处理-accept-事件\" class=\"headerlink\" title=\"处理 accept 事件\"></a>处理 accept 事件</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 判断事件类型</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (key.isAcceptable()) &#123;</span><br><span class=\"line\">   <span class=\"type\">ServerSocketChannel</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> (ServerSocketChannel) key.channel();</span><br><span class=\"line\">   <span class=\"comment\">// 必须处理</span></span><br><span class=\"line\">   <span class=\"type\">SocketChannel</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> c.accept();</span><br><span class=\"line\">   sc.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\">   sc.register(selector, SelectionKey.OP_READ);</span><br><span class=\"line\">   log.debug(<span class=\"string\">&quot;连接已建立: &#123;&#125;&quot;</span>, sc);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">   <span class=\"comment\">// 处理完毕，必须将事件移除</span></span><br><span class=\"line\">   iter.remove();</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>事件发生后，要么处理，要么取消（<code>cancel</code>），不能什么都不做，否则下次该事件仍会触发，这是因为 nio 底层使用的是<code>水平触发</code></p>\n</blockquote>\n<h3 id=\"处理-read-事件\"><a href=\"#处理-read-事件\" class=\"headerlink\" title=\"处理 read 事件\"></a>处理 read 事件</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (key.isReadable()) &#123;</span><br><span class=\"line\">    <span class=\"type\">SocketChannel</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> (SocketChannel) key.channel();</span><br><span class=\"line\">    <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">128</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">read</span> <span class=\"operator\">=</span> sc.read(buffer);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(read == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        key.cancel();</span><br><span class=\"line\">        sc.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 处理完毕，必须将事件移除</span></span><br><span class=\"line\">     iter.remove();</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>为何要 <code>iter.remove()</code></strong></p>\n<p>因为 <code>select</code> 在事件发生后，就会将相关的 <code>key</code> 放入 <code>selectedKeys</code> 集合，但不会在处理完后从 <code>selectedKeys</code> 集合中移除，需要<code>我们自己编码删除</code>。例如</p>\n<ul>\n<li>第一次触发了 <code>ssckey</code> 上的 <code>accept</code> 事件，没有移除 <code>ssckey</code></li>\n<li>第二次触发了 <code>sckey</code> 上的 <code>read</code> 事件，但这时 <code>selectedKeys</code> 中还有上次的 <code>ssckey</code> ，在处理时因为没有真正的 <code>serverSocket</code> 连上了，就会导致<code>空指针异常</code></li>\n</ul>\n<p><strong>cancel的作用</strong></p>\n<p><code>cancel</code> 会取消注册在 <code>selector</code> 上的 <code>channel</code>，并从 <code>keys</code> 集合中<code>删除 key</code>后续不会再监听事件</p>\n<p><strong>不处理边界</strong></p>\n<ul>\n<li><p>问题：会导致边界会被拆分</p>\n</li>\n<li><p>解决：==&lt;具体见进阶部分&gt;==</p>\n<ul>\n<li>方案一： 固定消息长度，数据包大小一样，服务器按预定长度读取，<code>缺点</code>是浪费带宽</li>\n<li>方案二： 按分隔符<code>\\n</code>拆分，<code>缺点</code>是效率低</li>\n<li>方案三： TLV 格式，即 Type 类型、Length 长度、Value 数据，类型和长度已知的情况下，就可以方便获取消息大小，分配合适的 buffer，<code>缺点</code>是 <code>buffer</code> 需要提前分配，如果内容过大，则影响 <code>server</code> 吞吐量</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305231301015.png\" alt=\"image-20230523130146931\" style=\"zoom:53%;\"></p>\n<p><strong>ByteBuffer 大小分配</strong></p>\n<ul>\n<li>每个 channel 都需要记录可能被切分的消息，<code>因为 ByteBuffer 不能被多个 channel 共同使用 所以不考虑多线程问题</code>，因此需要为每个 channel 维护一个独立的 ByteBuffer</li>\n<li><code>ByteBuffer</code> 不能太大，比如一个<code>ByteBuffer 1Mb</code>的话，要支持百万连接就要 1Tb 内存，因此需要设计大小可变的 <code>ByteBuffer</code><ul>\n<li>一种思路是首先分配一个较小的 <code>buffer</code><ul>\n<li>例如 4k，如果发现数据不够，再分配 8k 的 buffer，将 4k buffer 内容拷贝至 8k buffer，优点是消息连续容易处理，缺点是数据拷贝耗费性能，[参考实现][<a href=\"http://tutorials.jenkov.com/java-performance/resizable-array.html\">http://tutorials.jenkov.com/java-performance/resizable-array.html</a>]</li>\n</ul>\n</li>\n<li>另一种思路是用多个数组组成 <code>buffer</code>，一个数组不够，把多出来的内容写入新的数组，与前面的区别(缺点是)是消息存储<code>不连续</code>,解析复杂，优点是避免了拷贝引起的性能损耗</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"处理-write-事件\"><a href=\"#处理-write-事件\" class=\"headerlink\" title=\"处理 write 事件\"></a>处理 write 事件</h3><h5 id=\"一次性无法写完例子\"><a href=\"#一次性无法写完例子\" class=\"headerlink\" title=\"一次性无法写完例子\"></a>一次性无法写完例子</h5><ul>\n<li><code>非阻塞模式</code>下，无法保证把 <code>buffer</code> 中所有数据都写入 <code>channel</code>，因此需要<code>追踪</code> <code>write</code> 方法的返回值（代表实际写入字节数）</li>\n<li>用 <code>selector</code> 监听所有 <code>channel</code> 的可写事件，每个 <code>channel</code> 都需要一个 <code>key</code> 来跟踪 <code>buffer</code>，但这样又会导致占用内存过多，就有<code>两阶段策略</code><ul>\n<li>当消息处理器第一次写入消息时，才将 <code>channel</code> 注册到 <code>selector</code> 上</li>\n<li><code>selector</code> 检查 <code>channel</code> 上的可写事件，如果所有的数据写完了，就取消 <code>channel</code> 的注册</li>\n<li>如果不取消，会每次写时，均会触发 <code>write</code> 事件</li>\n</ul>\n</li>\n</ul>\n<p>==注意==</p>\n<blockquote>\n<p><code>ssc.register(selector, SelectionKey.OP_ACCEPT);\n     等价于：\nSelectionKey sscKey = ssc.register(selector, 0, null);\nsscKey.interestOps(SelectionKey.OP_ACCEPT);// 指明 SelectionKey  绑定的事件 selector 才会关心</code></p>\n<p> <strong>write 为何要取消</strong>   <code>key.interestOps(key.interestOps() - SelectionKey.OP_WRITE);</code></p>\n<p> 只要向 <code>channel</code> 发送数据时，<code>socket</code> 缓冲可写，这个事件会频繁触发，因此应当只在 <code>socket</code> 缓冲区<code>写不下</code>时<code>再关注可写</code>事件，数据<code>写完之后再取消关注</code></p>\n</blockquote>\n<h3 id=\"多线程的优化\"><a href=\"#多线程的优化\" class=\"headerlink\" title=\"多线程的优化\"></a>多线程的优化</h3><p>总结：</p>\n<ul>\n<li><p>多线程的使用的时候需要设置多个选择器进行分工</p>\n<ul>\n<li><p>单线程配一个选择器   <code>boss</code>，专门处理 accept 事件</p>\n</li>\n<li><p>创建 cpu 核心数的线程是   <code>worker</code>，每个线程配一个选择器，轮流处理 <code>read</code> 事件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MultiThreadServer</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException, InterruptedException &#123;</span><br><span class=\"line\">        Thread.currentThread().setName(<span class=\"string\">&quot;boss&quot;</span>);<span class=\"comment\">// 创建主线程 命名为 boss</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">ServerSocketChannel</span> <span class=\"variable\">ssc</span> <span class=\"operator\">=</span> ServerSocketChannel.open();</span><br><span class=\"line\">        ssc.configureBlocking(<span class=\"literal\">false</span>);<span class=\"comment\">//  selector必须 工作在 非阻塞模式， 影响accept() 编程非阻塞方法</span></span><br><span class=\"line\">        ssc.bind(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"number\">8080</span>));</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">Selector</span> <span class=\"variable\">boss</span> <span class=\"operator\">=</span> Selector.open();<span class=\"comment\">// 创建 selector来管理多个channel</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">SelectionKey</span> <span class=\"variable\">bossKey</span> <span class=\"operator\">=</span> ssc.register(boss, <span class=\"number\">0</span>, <span class=\"literal\">null</span>);<span class=\"comment\">// 将 服务器 通道注册到 selector</span></span><br><span class=\"line\">        bossKey.interestOps(SelectionKey.OP_ACCEPT); <span class=\"comment\">// 关注连接事件</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">Worker</span> <span class=\"variable\">worker</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Worker</span>(<span class=\"string\">&quot;worker-0&quot;</span>);<span class=\"comment\">// 1. 创建固定数量的 worker 并初始化</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">            boss.select();</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Iterator&lt;SelectionKey&gt; iter = boss.selectedKeys().iterator();</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(iter.hasNext())&#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> <span class=\"type\">SelectionKey</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> iter.next();</span><br><span class=\"line\">                iter.remove();</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(key.isAcceptable()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">final</span> <span class=\"type\">SocketChannel</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> ssc.accept();<span class=\"comment\">// 与客户端  读写通道</span></span><br><span class=\"line\">                    sc.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\">                   </span><br><span class=\"line\"><span class=\"comment\">//注意：这里必须先 sc.register关注 read事件，然后 再 静态内部类 里执行 selector.select() 才能顺利完成读取</span></span><br><span class=\"line\">                    <span class=\"comment\">//但是,select() 先执行的话，会将 register阻塞住</span></span><br><span class=\"line\"><span class=\"comment\">//多线程的初步解决</span></span><br><span class=\"line\">                    worker.register(); <span class=\"comment\">// 这里 将 开启 多线程 并 和 下面方法 同步执行</span></span><br><span class=\"line\">                    <span class=\"comment\">// 关联 worker 里的 选择器 selector</span></span><br><span class=\"line\">                    <span class=\"comment\">// 这里的 客户端读写通道  注册到 内部类worker里的 selector</span></span><br><span class=\"line\">                    sc.register(worker.selector, SelectionKey.OP_READ, <span class=\"literal\">null</span>); <span class=\"comment\">// 可以直接访问 内部类 的 私有变量</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">//worker 的内部类;有独立的线程 和 自己的 selector</span></span><br><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Worker</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Thread thread;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Selector  selector;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> String name; <span class=\"comment\">// 每个 selector的名字</span></span><br><span class=\"line\"><span class=\"comment\">//volatile的回顾</span></span><br><span class=\"line\"><span class=\"comment\">//volatile 声明变量的值可能随时会别的线程修改,修饰的变量会强制,将修改的值立即写入主存,主存中值的更新会使缓存中的值失效</span></span><br><span class=\"line\"><span class=\"comment\">//但是(非volatile变量不具备这样的特性，非volatile变量的值会被缓存，线程A更新了这个值，线程B读取这个变量的值时可能读到的并不是是线程A更新后的值)</span></span><br><span class=\"line\"><span class=\"comment\">//volatile具有可见性、有序性，不具备原子性</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"type\">boolean</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>; <span class=\"comment\">// 还未初始化</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"title function_\">Worker</span><span class=\"params\">(String name)</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">   <span class=\"comment\">//初始化 线程 和 selector，期望 一个 worker 使用一个线程，创建了 Thread就不再重复创建了</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">register</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 保证 这段代码 只执行一遍</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!start) &#123;</span><br><span class=\"line\">                thread = <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"built_in\">this</span>, name);</span><br><span class=\"line\">                <span class=\"comment\">// 先创建 selector,然后再start线程。不然selector会报空指针</span></span><br><span class=\"line\">                selector = Selector.open();</span><br><span class=\"line\">                thread.start();</span><br><span class=\"line\">                start = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">     <span class=\"comment\">//   先 select()   【因为在boss线程里面已经 强行wakeup() 了 所以 首次 不阻塞】</span></span><br><span class=\"line\">     <span class=\"comment\">//   再 register() 【先注册 关注了read事件，首次 有事件将继续，没事件将到下个循环   】</span></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                    selector.select();<span class=\"comment\">// 有未处理或未取消事件，不阻塞 继续运行 ； 否则 阻塞</span></span><br><span class=\"line\">                    <span class=\"keyword\">final</span> Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class=\"line\">                    <span class=\"keyword\">while</span>(iter.hasNext())&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">final</span> <span class=\"type\">SelectionKey</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> iter.next();</span><br><span class=\"line\">                        iter.remove();</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(key.isReadable())&#123;</span><br><span class=\"line\">                            <span class=\"keyword\">final</span> <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">16</span>);</span><br><span class=\"line\">                            <span class=\"keyword\">final</span> <span class=\"type\">SocketChannel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> (SocketChannel) key.channel();</span><br><span class=\"line\">                            log.debug(<span class=\"string\">&quot;read...... &#123;&#125;&quot;</span>, channel.getRemoteAddress());</span><br><span class=\"line\">                            channel.read(buffer);</span><br><span class=\"line\">                            buffer.flip();</span><br><span class=\"line\">                            ByteBufferUtil.debugAll(buffer);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>两个线程之间的消息传递问题</p>\n<ul>\n<li>利用<code>队列(ConcurrentLinkedQueue)</code> 解决</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 第一部分： 开一个分线程 ,使用 &quot;线程安全队列&quot;，进行分离 测试</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 多线程 的selector应用</span></span><br><span class=\"line\"><span class=\"comment\"> *  分工操作 （boss 和 worker 都有自己独立的线程和 selector）</span></span><br><span class=\"line\"><span class=\"comment\"> *      Boss   : 负责接待 连接操作</span></span><br><span class=\"line\"><span class=\"comment\"> *      worker : 负责读写，每个work负责 一或多个SockerChannel读写事件</span></span><br><span class=\"line\"><span class=\"comment\"> * 核心：模仿 netty的 操作步骤</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MultiThreadServer1</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//原来是：   worker.register();         sc.register(worker.selector, SelectionKey.OP_READ, null);</span></span><br><span class=\"line\">                    <span class=\"comment\">//...</span></span><br><span class=\"line\">                    worker.register(sc);  <span class=\"comment\">// work-0  被boss线程  调用</span></span><br><span class=\"line\">  \t                <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  worker 的内部类  有独立的线程 和 自己的 selector</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Worker</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//开一个分线程 ,使用 &quot;线程安全队列&quot;，进行分离 测试</span></span><br><span class=\"line\">    \t<span class=\"comment\">//...</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">register</span><span class=\"params\">(SocketChannel sc)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">     \t<span class=\"comment\">//...</span></span><br><span class=\"line\">\t    <span class=\"keyword\">private</span> ConcurrentLinkedQueue&lt;Runnable&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentLinkedQueue</span>&lt;&gt;();</span><br><span class=\"line\">\t\t<span class=\"comment\">//...</span></span><br><span class=\"line\">        <span class=\"comment\">// boss 线程 里 ： 向 队列里 添加任务 ，但是并没有执行</span></span><br><span class=\"line\">        <span class=\"comment\">// 任务内容：主线程的 读写通道 注册到 子线程的 selector，交给子线程管理</span></span><br><span class=\"line\">        queue.add(()-&gt;&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    sc.register(selector, SelectionKey.OP_READ, <span class=\"literal\">null</span>); <span class=\"comment\">//boss</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (ClosedChannelException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        selector.wakeup(); <span class=\"comment\">// 唤醒 select方法 为了执行 关注 read事件</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 这 先 select()   【因为在boss线程里面已经 强行wakeup() 了 所以 首次 不阻塞】</span></span><br><span class=\"line\"><span class=\"comment\">         * 再 register() 【先注册 关注了read事件，首次 有事件将继续，没事件将到下个循环   】</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">     <span class=\"meta\">@Override</span></span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">          <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">             selector.select();<span class=\"comment\">// 有未处理或未取消事件，不阻塞 继续运行 ； 否则 阻塞</span></span><br><span class=\"line\">             <span class=\"comment\">//从 队列里拿出 任务程序 进行执行   </span></span><br><span class=\"line\">             <span class=\"keyword\">final</span> <span class=\"type\">Runnable</span> <span class=\"variable\">task</span> <span class=\"operator\">=</span> queue.poll();</span><br><span class=\"line\">             <span class=\"keyword\">if</span>(task != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                task.run(); <span class=\"comment\">// worker-0 线程里执行了： sc.register(selector, SelectionKey.OP_READ, null);</span></span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">                   <span class=\"comment\">// 首次 到这里 可能还没 任务事件，但是 读事件 已经注册好了(就可以 关注 客户端是否传数据了)</span></span><br><span class=\"line\">                   <span class=\"comment\">//... </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>仅用<code>wakeup</code>解决</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MultiThreadOnlyWakeup</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    worker.register(sc); <span class=\"comment\">// 这里 将 开启 多线程 并 和 下面方法 同步执行</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">worker</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">register</span><span class=\"params\">(SocketChannel sc)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 保证 这段代码 只执行一遍</span></span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">         selector.wakeup(); <span class=\"comment\">// 唤醒 select方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 客户端读写通道  注册到 内部类worker里的 selector</span></span><br><span class=\"line\">        sc.register(selector, SelectionKey.OP_READ, <span class=\"literal\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   <span class=\"comment\">//... </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>多 worker  使用 数组保存多 内部类对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MultiThreadServerMultiWorker</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     1. 创建固定数量的 worker 并初始化</span></span><br><span class=\"line\"><span class=\"comment\">        数组的线程数 至少设置为 CPU 的核心数</span></span><br><span class=\"line\"><span class=\"comment\">        得到 CPU核心数 ： Runtime.getRuntime().availableProcessors() 【注意拿的不是容器申请的核心数，而是物理的CPU核心数，直到 JDK10才修复】</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">         建议 手工指定下 更好</span></span><br><span class=\"line\"><span class=\"comment\">         根据实际情况，如果是 CPU 密集型运算, 线程数 设为 CPU核心数</span></span><br><span class=\"line\"><span class=\"comment\">         如果 IO频繁， CPU用的少 ，参考 阿姆达尔定律 ，根据 IO跟 计算的比例 来确认 多少线程 ，一般是 大于 CPU核心的</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Worker[] workers = <span class=\"keyword\">new</span> <span class=\"title class_\">Worker</span>[<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; workers.length; i++) &#123;</span><br><span class=\"line\">            workers[i] = <span class=\"keyword\">new</span> <span class=\"title class_\">Worker</span>(<span class=\"string\">&quot;worker-&quot;</span> + i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 计数器</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">AtomicInteger</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>(); <span class=\"comment\">// 初始值 是 0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">          <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">            * 使用 round robin 轮流交替使用， 负载均衡的 方法</span></span><br><span class=\"line\"><span class=\"comment\">            *  index.getAndIncrement 获取索引 并 自增一次</span></span><br><span class=\"line\"><span class=\"comment\">            *</span></span><br><span class=\"line\"><span class=\"comment\">            * 0 % 2 = 0</span></span><br><span class=\"line\"><span class=\"comment\">            * 1 % 2 = 1</span></span><br><span class=\"line\"><span class=\"comment\">            * 2 % 2 = 0</span></span><br><span class=\"line\"><span class=\"comment\">            * 3 % 2 = 1</span></span><br><span class=\"line\"><span class=\"comment\">            * 4 % 2 = 0</span></span><br><span class=\"line\"><span class=\"comment\">            */</span></span><br><span class=\"line\">           workers[index.getAndIncrement() % workers.length] . register(sc);</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Worker</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">      * 创建 一个 线程安全的队列 ，用来 让两个线程之间传输数据</span></span><br><span class=\"line\"><span class=\"comment\">      *  目的：就是把 要注册的 channel传过来</span></span><br><span class=\"line\"><span class=\"comment\">      * &lt; 任务对象 &gt;</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> ConcurrentLinkedQueue&lt;Runnable&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentLinkedQueue</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">register</span><span class=\"params\">(SocketChannel sc)</span> <span class=\"keyword\">throws</span> IOException&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">         queue.add(()-&gt;&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    sc.register(selector, SelectionKey.OP_READ, <span class=\"literal\">null</span>);</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;*** 子线程 里 注册 读写通道 到 selector 并关注 读事件 ***&quot;</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (ClosedChannelException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        selector.wakeup(); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//....</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p><strong>如何拿到 cpu 个数</strong></p>\n<ul>\n<li><code>Runtime.getRuntime().availableProcessors()</code>如果工作在 <code>docker</code> 容器下，因为容器不是物理隔离的，会拿到物理 <code>cpu</code> 个数，而不是容器申请时的个数</li>\n<li>这个问题直到 jdk 10 才修复，使用 <code>jvm</code> 参数 <code>UseContainerSupport</code> 配置， 默认开启</li>\n</ul>\n</blockquote>\n<h3 id=\"UDP\"><a href=\"#UDP\" class=\"headerlink\" title=\"UDP\"></a>UDP</h3><ul>\n<li><code>UDP</code> 是无连接的，<code>client</code> 发送数据不会管 <code>server</code> 是否开启</li>\n<li><code>server</code> 这边的 <code>receive</code> 方法会将接收到的数据存入 <code>byte buffer</code>，但如果数据报文超过 <code>buffer</code> 大小，多出来的数据会被默默抛弃</li>\n</ul>\n<h1 id=\"NIO-VS-BIO\"><a href=\"#NIO-VS-BIO\" class=\"headerlink\" title=\"NIO VS BIO\"></a>NIO VS BIO</h1><h3 id=\"Stream-VS-channel\"><a href=\"#Stream-VS-channel\" class=\"headerlink\" title=\"Stream VS channel\"></a>Stream VS channel</h3><ul>\n<li><code>stream</code> 不会自动缓冲数据，<code>channel</code> 会利用系统提供的发送缓冲区、接收缓冲区（更为底层）</li>\n<li><code>stream</code> 仅支持阻塞 API，<code>channel</code> 同时支持阻塞、非阻塞 API，网络中  <code>channel</code> 可配合 <code>selector</code> 实现多路复用</li>\n<li>二者均为<code>全双工</code>，即读写可以<code>同时</code>进行</li>\n</ul>\n<h3 id=\"IO模型\"><a href=\"#IO模型\" class=\"headerlink\" title=\"IO模型\"></a>IO模型</h3><ul>\n<li>分类  <code>同步阻塞、同步非阻塞、同步多路复用、异步阻塞（没有此情况）、异步非阻塞</code></li>\n</ul>\n<ul>\n<li>同步：线程自己去获取结果（一个线程）</li>\n<li>异步：线程自己不去获取结果，而是由其它线程送结果（至少两个线程）</li>\n</ul>\n<p>当调用一次 <code>channel.read</code>或 <code>stream.read</code> 后，会切换至操作系统内核态来完成真正数据读取，而读取又分为两个阶段，分别为：</p>\n<ul>\n<li>等待数据阶段</li>\n<li>复制数据阶段</li>\n</ul>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306160104198.png\" alt=\"image-20230616010438166\" style=\"zoom:33%;\"></p>\n<blockquote>\n<p>阻塞 IO      &lt;指的就是用户程序被阻塞了  一次系统调用&gt;</p>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306160104711.png\" alt=\"image-20230616010452667\" style=\"zoom:33%;\"></p>\n<p>非阻塞  IO     &lt;指的就是等待阶段用户程序 不会阻塞，但是当有数据之后到达复制数据阶段还是阻塞了的&gt;</p>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306160105474.png\" alt=\"image-20230616010525429\" style=\"zoom:33%;\"></p>\n<p>多路复用   （等待数据阶段是阻塞的   复制数据的阶段也是阻塞的  两次系统调用）</p>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306160105408.png\" alt=\"image-20230616010552361\" style=\"zoom:33%;\"> </p>\n<p>异步 IO</p>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306160106873.png\" alt=\"image-20230616010613821\" style=\"zoom:33%;\"></p>\n<p>阻塞<code>IO</code> 与 多路复用</p>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306160108962.png\" alt=\"image-20230616010759817\" style=\"zoom:33%;\">      <img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305232047942.png\" alt=\"image-20230523204737809\" style=\"zoom:43%;\">    </p>\n</blockquote>\n<h3 id=\"零拷贝\"><a href=\"#零拷贝\" class=\"headerlink\" title=\"零拷贝\"></a>零拷贝</h3><h5 id=\"传统IO的流程\"><a href=\"#传统IO的流程\" class=\"headerlink\" title=\"传统IO的流程\"></a>传统IO的流程</h5><ul>\n<li><p>传统的 IO 将一个文件通过 socket 写出</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">File</span> <span class=\"variable\">f</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;helloword/data.txt&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">RandomAccessFile</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RandomAccessFile</span>(file, <span class=\"string\">&quot;r&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">byte</span>[] buf = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[(<span class=\"type\">int</span>)f.length()];</span><br><span class=\"line\">file.read(buf);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Socket</span> <span class=\"variable\">socket</span> <span class=\"operator\">=</span> ...;</span><br><span class=\"line\">socket.getOutputStream().write(buf);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>工作流程</p>\n<ul>\n<li><p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306160112802.png\" alt=\"image-20230616011241775\" style=\"zoom:33%;\"></p>\n</li>\n<li><p>上述<code>1、2、3、4</code>的说明</p>\n<ul>\n<li><p>java 本身并不具备 IO 读写能力，因此 <code>read</code> 方法调用后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，去调用操作系统内核（Kernel）的读能力，将数据读入<strong>内核缓冲区</strong>。这期间用户线程阻塞，操作系统使用 DMA（Direct Memory Access）来实现文件读，期间也不会使用 cpu</p>\n<blockquote>\n<p>DMA 也可以理解为硬件单元，用来解放 cpu 完成文件 IO</p>\n</blockquote>\n</li>\n<li><p>从<strong>内核态</strong>切换回<strong>用户态</strong>，将数据从<strong>内核缓冲区</strong>读入<strong>用户缓冲区</strong>（即 byte[] buf），这期间 cpu 会参与拷贝，无法利用 DMA</p>\n</li>\n<li><p>调用 write 方法，这时将数据从<strong>用户缓冲区</strong>（<code>即 byte[] buf</code>）写入 <strong>socket 缓冲区</strong>，cpu 会参与拷贝</p>\n</li>\n<li><p>接下来要向网卡写数据，这项能力 java 又不具备，因此又得从<strong>用户态</strong>切换至<strong>内核态</strong>，调用操作系统的写能力，使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 cpu</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>小结：</p>\n<ul>\n<li><p>可以看到的是 中间环节较多，java 的 IO 实际<code>是缓存的复制</code>，<code>底层的真正读写</code>是<code>操作系统</code>来完成的</p>\n<ul>\n<li>用户态与内核态的切换发生了 3 次(<code>1、2、4</code>)，这个操作比较重量级</li>\n<li>数据拷贝了共 4 次</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h5 id=\"NIO优化一\"><a href=\"#NIO优化一\" class=\"headerlink\" title=\"NIO优化一\"></a>NIO优化一</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//通过 `DirectByteBuf` </span></span><br><span class=\"line\">ByteBuffer.allocate(<span class=\"number\">10</span>)  `HeapByteBuffer 使用的还是 java 内存`</span><br><span class=\"line\">ByteBuffer.allocate`Direct`(<span class=\"number\">10</span>)  `DirectByteBuffer 使用的是操作系统内存`</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306160118148.png\" alt=\"image-20230616011834111\" style=\"zoom:33%;\"></p>\n<p>大部分步骤与优化前相同，不再赘述。</p>\n<p><code>唯有一点是有区别的：</code>java 可以使用 <code>DirectByteBuf</code> 将堆外内存映射到 jvm 内存中来直接访问使用</p>\n<ul>\n<li>这块内存不受 <code>jvm</code> 垃圾回收的影响，因此<code>内存地址固定</code>，有助于 <code>IO</code> 读写</li>\n<li>java 中的 <code>DirectByteBuf</code> 对象<code>仅维护</code>了此内存的<code>虚引用</code>，内存回收分成两步<ul>\n<li><code>DirectByteBuf</code> 对象被垃圾<code>回收</code>，将<code>虚引用加入引用队列</code></li>\n<li>通过专门线程<code>访问</code>引用队列，根据<code>虚引用释放堆外内存</code></li>\n</ul>\n</li>\n<li>减少了一次数据拷贝，用户态与内核态的<code>切换次数</code>没有减少</li>\n</ul>\n<h5 id=\"NIO优化二\"><a href=\"#NIO优化二\" class=\"headerlink\" title=\"NIO优化二\"></a>NIO优化二</h5><p>底层采用了 linux 2.1 后提供的 <code>sendFile</code> 方法；java 中对应着两个 <code>channel</code> 调用 <code>transferTo/transferFrom</code>方法拷贝数据</p>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306160127391.png\" alt=\"image-20230616012741314\" style=\"zoom:33%;\"></p>\n<ul>\n<li>java 调用 <code>transferTo</code> 方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 cpu</li>\n<li>数据从<strong>内核缓冲区</strong>传输到 <strong>socket 缓冲区</strong>，cpu 会参与拷贝</li>\n<li>最后使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 cpu</li>\n</ul>\n<p>可以看到</p>\n<ul>\n<li>只发生了<code>一次</code>用户态与内核态的切换</li>\n<li>数据拷贝了 <code>3</code> 次</li>\n</ul>\n<h5 id=\"NIO优化三\"><a href=\"#NIO优化三\" class=\"headerlink\" title=\"NIO优化三\"></a>NIO优化三</h5><p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306160129502.png\" alt=\"image-20230616012908471\" style=\"zoom:33%;\"></p>\n<ul>\n<li><p>java 调用<code>transferTo</code>方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 cpu</p>\n<p>只会将一些 offset 和 length 信息拷入 <strong>socket 缓冲区</strong>，几乎无消耗</p>\n</li>\n<li><p>使用 DMA 将 <strong>内核缓冲区</strong>的数据写入网卡，不会使用 cpu</p>\n</li>\n</ul>\n<p>整个过程仅只发生了一次用户态与内核态的切换，数据拷贝了 <code>2</code> 次。所谓的【<code>零拷贝</code>】，并不是真正无拷贝，而是在<code>不会拷贝重复数据到 jvm 内存中</code></p>\n<ul>\n<li><p>零拷贝的优点有</p>\n<ul>\n<li><p>更少的用户态与内核态的切换</p>\n</li>\n<li><p>不利用 cpu 计算，减少 cpu 缓存伪共享</p>\n</li>\n<li><p>零拷贝适合小文件传输</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"AIO\"><a href=\"#AIO\" class=\"headerlink\" title=\"AIO\"></a>AIO</h1><p>AIO 用来解决<code>数据复制阶段</code>的阻塞问题</p>\n<ul>\n<li><code>同步</code>意味着，在进行读写操作时，<code>线程</code>需要等待结果，<code>相当于闲置</code></li>\n<li><code>异步</code>意味着，在进行读写操作时，<code>线程</code>不必等待结果，而是将来由操作系统来通过回调方式由另外的线程来获得结果</li>\n</ul>\n<blockquote>\n<p><code>异步模型</code>需要底层操作系统内核（Kernel）提供支持</p>\n<ul>\n<li>Windows 系统通过 <code>IOCP</code> 实现了真正的异步<code>IO</code></li>\n<li>Linux 系统异步 <code>IO</code>在 2.6 版本引入，但其底层实现还是用多路复用模拟了异步 <code>IO</code>，性能没有优势</li>\n</ul>\n</blockquote>\n<h4 id=\"文件AIO\"><a href=\"#文件AIO\" class=\"headerlink\" title=\"文件AIO\"></a>文件AIO</h4><blockquote>\n<p>默认文件的<code>AIO</code> 使用的线程是守护线程，所以最后要执行 <code>System.in.read()</code> 以避免守护线程意外结束</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AioDemo1</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            <span class=\"type\">AsynchronousFileChannel</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> </span><br><span class=\"line\">                AsynchronousFileChannel.open(</span><br><span class=\"line\">                \tPaths.get(<span class=\"string\">&quot;1.txt&quot;</span>), StandardOpenOption.READ);</span><br><span class=\"line\">            <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">2</span>);</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;begin...&quot;</span>);</span><br><span class=\"line\">            s.read(buffer, <span class=\"number\">0</span>, <span class=\"literal\">null</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">CompletionHandler</span>&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">completed</span><span class=\"params\">(Integer result, ByteBuffer attachment)</span> &#123;</span><br><span class=\"line\">                    log.debug(<span class=\"string\">&quot;read completed...&#123;&#125;&quot;</span>, result);</span><br><span class=\"line\">                    buffer.flip();</span><br><span class=\"line\">                    debug(buffer);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">failed</span><span class=\"params\">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class=\"line\">                    log.debug(<span class=\"string\">&quot;read failed...&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;do other things...&quot;</span>);</span><br><span class=\"line\">        System.in.read();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"网络AIO\"><a href=\"#网络AIO\" class=\"headerlink\" title=\"网络AIO\"></a>网络AIO</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AioServer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">AsynchronousServerSocketChannel</span> <span class=\"variable\">ssc</span> <span class=\"operator\">=</span> AsynchronousServerSocketChannel.open();</span><br><span class=\"line\">        ssc.bind(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"number\">8080</span>));</span><br><span class=\"line\">        ssc.accept(<span class=\"literal\">null</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">AcceptHandler</span>(ssc));</span><br><span class=\"line\">        System.in.read();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">closeChannel</span><span class=\"params\">(AsynchronousSocketChannel sc)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            System.out.printf(<span class=\"string\">&quot;[%s] %s close\\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());</span><br><span class=\"line\">            sc.close();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ReadHandler</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">CompletionHandler</span>&lt;Integer, ByteBuffer&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AsynchronousSocketChannel sc;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"title function_\">ReadHandler</span><span class=\"params\">(AsynchronousSocketChannel sc)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.sc = sc;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">completed</span><span class=\"params\">(Integer result, ByteBuffer attachment)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (result == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    closeChannel(sc);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.printf(<span class=\"string\">&quot;[%s] %s read\\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());</span><br><span class=\"line\">                attachment.flip();</span><br><span class=\"line\">                System.out.println(Charset.defaultCharset().decode(attachment));</span><br><span class=\"line\">                attachment.clear();</span><br><span class=\"line\">                <span class=\"comment\">// 处理完第一个 read 时，需要再次调用 read 方法来处理下一个 read 事件</span></span><br><span class=\"line\">                sc.read(attachment, attachment, <span class=\"built_in\">this</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">failed</span><span class=\"params\">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class=\"line\">            closeChannel(sc);</span><br><span class=\"line\">            exc.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WriteHandler</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">CompletionHandler</span>&lt;Integer, ByteBuffer&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AsynchronousSocketChannel sc;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"title function_\">WriteHandler</span><span class=\"params\">(AsynchronousSocketChannel sc)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.sc = sc;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">completed</span><span class=\"params\">(Integer result, ByteBuffer attachment)</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果作为附件的 buffer 还有内容，需要再次 write 写出剩余内容</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (attachment.hasRemaining()) &#123;</span><br><span class=\"line\">                sc.write(attachment);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">failed</span><span class=\"params\">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class=\"line\">            exc.printStackTrace();</span><br><span class=\"line\">            closeChannel(sc);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AcceptHandler</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">CompletionHandler</span>&lt;AsynchronousSocketChannel, Object&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AsynchronousServerSocketChannel ssc;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"title function_\">AcceptHandler</span><span class=\"params\">(AsynchronousServerSocketChannel ssc)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.ssc = ssc;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">completed</span><span class=\"params\">(AsynchronousSocketChannel sc, Object attachment)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                System.out.printf(<span class=\"string\">&quot;[%s] %s connected\\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">16</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 读事件由 ReadHandler 处理</span></span><br><span class=\"line\">            sc.read(buffer, buffer, <span class=\"keyword\">new</span> <span class=\"title class_\">ReadHandler</span>(sc));</span><br><span class=\"line\">            <span class=\"comment\">// 写事件由 WriteHandler 处理</span></span><br><span class=\"line\">            sc.write(Charset.defaultCharset().encode(<span class=\"string\">&quot;server hello!&quot;</span>), ByteBuffer.allocate(<span class=\"number\">16</span>), <span class=\"keyword\">new</span> <span class=\"title class_\">WriteHandler</span>(sc));</span><br><span class=\"line\">            <span class=\"comment\">// 处理完第一个 accpet 时，需要再次调用 accept 方法来处理下一个 accept 事件</span></span><br><span class=\"line\">            ssc.accept(<span class=\"literal\">null</span>, <span class=\"built_in\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">failed</span><span class=\"params\">(Throwable exc, Object attachment)</span> &#123;</span><br><span class=\"line\">            exc.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Netty\"><a href=\"#Netty\" class=\"headerlink\" title=\"Netty\"></a>Netty</h1><h2 id=\"入门\"><a href=\"#入门\" class=\"headerlink\" title=\"入门\"></a>入门</h2><blockquote>\n<p>是什么</p>\n</blockquote>\n<ul>\n<li>Netty 是一个<code>异步的(多线程)、基于事件驱动</code>的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端，IO模型是<code>IO多路复用</code>的IO模型</li>\n<li>主要的作用就是 提供 高性能、可扩展的网络应用程序开发框架<ul>\n<li>高性能是因为它基于<code>NIO</code>的实现，使用了异步的方式进行网络数据处理，采用了零拷贝技术、内存池等一系列机制来提高网络数据的传输和处理效率，具有极高的并发性能和吞吐量</li>\n<li>简化网络编程：<code>Netty</code> 封装了很多底层的网络编程细节，提供了易于使用的 <code>API</code>，如事件驱动模型、高性能的编解码器、线程池等，使得开发者可以专注于业务逻辑的实现，而不必过度关注网络编程的底层实现</li>\n<li>可扩展性：<code>Netty</code> 提供了丰富的扩展点和插件机制，可以根据实际需要选择合适的插件</li>\n<li>协议支持：<code>Netty</code> 支持很多主流的网络协议，如 <code>TCP、UDP、HTTP/HTTPS、WebSocket</code> 等，可以满足不同场景下的网络通信需求</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>应用</p>\n</blockquote>\n<ul>\n<li>Cassandra - nosql 数据库</li>\n<li>Spark - 大数据分布式计算框架</li>\n<li>Hadoop - 大数据分布式存储框架</li>\n<li>RocketMQ - ali 开源的消息队列</li>\n<li>ElasticSearch - 搜索引擎</li>\n<li>gRPC - rpc 框架</li>\n<li>Dubbo - rpc 框架</li>\n<li>Spring 5.x - flux api 完全抛弃了 tomcat ，使用 netty 作为服务器端</li>\n<li>Zookeeper - 分布式协调框架</li>\n</ul>\n<blockquote>\n<p>优势</p>\n</blockquote>\n<ul>\n<li>与NIO进行对比的话； <code>NIO</code>工作量大，bug 多,需要自己构建协议，<code>epoll</code>的空转会导致<code>cpu</code>占用率达到100%</li>\n<li>与其他网络架构的对比：<code>Mina</code>的开发不如<code>netty</code>简洁，文档不如<code>netty</code>优秀</li>\n</ul>\n<h3 id=\"使用案例\"><a href=\"#使用案例\" class=\"headerlink\" title=\"使用案例\"></a>使用案例</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>io.netty<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>netty-all<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.1.39.Final<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>服务端的</code>配置举例说明</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrap</span>()</span><br><span class=\"line\">    <span class=\"comment\">//NioEventLoopGroup 简单理解：包含了线程 和 选择器 selector</span></span><br><span class=\"line\">    .group(<span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>()) </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//选择一个 通用的 基于 NIO  ServerSocketChannel的 实现</span></span><br><span class=\"line\">    .channel(NioServerSocketChannel.class) </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//childHandler 添加的各种处理器 给 每个子线程的 SocketChannel用的</span></span><br><span class=\"line\">    .childHandler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(NioSocketChannel ch)</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//将接收到的数据 ByteBuffer 解码 为 String</span></span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">StringDecoder</span>());</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">//自定义 的 handler</span></span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">SimpleChannelInboundHandler</span>&lt;String&gt;() &#123; </span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"comment\">//msg  是上一个处理器得到的 经由 ByteBuf 转为 String 之后的结果</span></span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx, String msg)</span> &#123;</span><br><span class=\"line\">                    System.out.println(msg);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .bind(<span class=\"number\">8080</span>); </span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>ServerBootstrap</code></li>\n<li><code>new NioEventLoopGroup()</code>  创建一个新的 <code>NIO EventLoopGroup</code>，用于处理服务器端的 I/O 操作。</li>\n<li><code>NioServerSocketChannel.class</code> 指定服务器监听的 <code>SocketChannel</code> 类型为 <code>NIO</code> 的 <code>ServerSocketChannel</code>。</li>\n<li><code>childHandler</code>的配置，用于给之后的<code>SocketChannel</code>使用<ul>\n<li><code>new ChannelInitializer&lt;NioSocketChannel&gt;() &#123; ... &#125;</code> 创建一个新的 <code>ChannelInitializer&lt;仅处理一次&gt;</code>，用于初始化客户端连接后的 <code>ChannelPipeline</code>，也就是说：待客户端 <code>SocketChannel</code> 建立连接后，执行 <code>initChannel</code> 以便添加更多的处理器</li>\n<li><code>&#123;...&#125;</code>中<ul>\n<li><code>ch.pipeline().addLast(new StringDecoder())</code> 向 <code>ChannelPipeline</code> 添加一个 <code>StringDecoder</code>，用于将客户端发送的 <code>ByteBuf</code> 数据<code>解码</code>成字符串。</li>\n<li><code>ch.pipeline().addLast(new SimpleChannelInboundHandler&lt;String&gt;() &#123; ... &#125;)</code> 向 <code>ChannelPipeline</code> 添加一个 <code>SimpleChannelInboundHandler</code>，是一个业务处理器，处理上一个处理器的结果，就是用于<code>处理</code>客户端发送过来的字符串消息。在此处，通过覆盖 <code>channelRead0()</code> 方法实现了对客户端消息的输出</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>.bind(8080)</code> 绑定服务器监听的端口号为 8080。</li>\n</ul>\n<blockquote>\n<p><code>客户端的</code>配置举例说明</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>()</span><br><span class=\"line\">    <span class=\"comment\">//设置客户端连接的EventLoopGroup</span></span><br><span class=\"line\">    .group(<span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>())</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//设置Channel类型及相关属性</span></span><br><span class=\"line\">    .channel(NioSocketChannel.class) </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//设置ChannelPipeline，即一组ChannelHandler链；</span></span><br><span class=\"line\">    .handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;Channel&gt;() &#123; </span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(Channel ch)</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//StringEncoder 把  发送的字符串 编码为   ByteBuffer</span></span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">StringEncoder</span>()); </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .connect(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">8080</span>) <span class=\"comment\">//等价于：.remoteAddress(new InetSocketAddress(&quot;localhost&quot;, 8080))</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//阻塞式的链接，等待至连接成功;sync为了让客户端先以同步的方式连上，然后再执行后面信息发送逻辑</span></span><br><span class=\"line\">    .sync() </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//获得连接成功后的 Channel 对象</span></span><br><span class=\"line\">    .channel() </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//将要发送的数据写入到 Channel 中，并刷新缓冲区，以确保数据被发送出去</span></span><br><span class=\"line\">    .writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>() + <span class=\"string\">&quot;: hello world!&quot;</span>);   </span><br></pre></td></tr></table></figure>\n<p>重要参数的介绍</p>\n<ul>\n<li><p>服务端连接的引导类<code>ServerBootstrap</code></p>\n<blockquote>\n<p>继承自 <code>AbstractBootstrap</code> 并基于其基础上扩展了一些服务器特有的方法。</p>\n</blockquote>\n<ul>\n<li><p>作用</p>\n<ul>\n<li><p><code>初始化服务器端启动参数</code>。<code>ServerBootstrap</code> 的实例化过程中，可以设置一些启动参数，例如 NIO 线程池、Channel 类型以及 ChannelHandler 等。</p>\n</li>\n<li><p><code>绑定服务器端口并启动服务器</code>。<code>ServerBootstrap</code> 提供了 <code>bind()</code> 方法，用于绑定服务器端口，并注册一个 ChannelFuture 对象保存启动状态。</p>\n</li>\n<li><p><code>设置处理客户端连接的 ChannelHandler</code>。<code>ServerBootstrap</code> 提供了 <code>childHandler()</code> 方法，用于为每个新连接的客户端创建一个 ChannelPipeline，以处理客户端的网络事件。</p>\n</li>\n<li><p>提供了一些<code>优雅停机</code>的方法。<code>ServerBootstrap</code> 提供了 <code>shutDownGracefully()</code> 等方法，用于关闭应用程序并释放资源。</p>\n</li>\n</ul>\n</li>\n<li><p>在使用 <code>ServerBootstrap</code> 的过程中需要注意以下几点：</p>\n<ul>\n<li><code>ServerBootstrap</code> 需要调用 <code>group()</code> 方法来指定处理 I/O 操作的线程池。</li>\n<li><code>ServerBootstrap</code> 需要调用 <code>channel()</code> 方法来指定传输协议的类型（TCP 或 UDP），同时也可以通过 <code>option()</code> 方法设置相应的选项。</li>\n<li><code>ServerBootstrap</code> 还需要调用 <code>handler()</code> 方法将自定义的 ChannelHandler 添加到 ChannelPipeline 中，以对服务器端的网络事件进行处理。</li>\n<li><code>ServerBootstrap</code> 需要调用 <code>childHandler()</code> 方法来设置处理客户端连接的 ChannelHandler。</li>\n<li>在完成所有 <code>ServerBootstrap</code> 的配置后，需要使用 <code>bind()</code> 方法绑定服务器端口，以启动服务器。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>客户端连接的引导类<code>Bootstrap</code></p>\n<ul>\n<li><p>作用：</p>\n<ul>\n<li>用于<code>初始化客户端和服务器端的启动参数</code>。<code>Bootstrap</code> 的实例化过程中，可以设置一些参数，例如 NIO 线程池、Channel 类型以及 ChannelHandler 等。</li>\n<li><code>开启、连接或绑定网络端口</code>。<code>Bootstrap</code> 提供了多种方法，例如 <code>bind()</code>、<code>connect()</code> 和 <code>accept()</code> 等方法，用于启动 Netty 应用程序并建立网络连接。</li>\n<li>提供了一些<code>优雅停机</code>的方法，例如 <code>shutdownGracefully()</code> 和 <code>awaitTermination()</code> 等，用于关闭应用程序并释放资源。</li>\n</ul>\n</li>\n<li><p>在使用 <code>Bootstrap</code> 的过程中需要注意以下几点：</p>\n<ul>\n<li><code>Bootstrap</code> 需要在 Netty 应用程序<code>启动时创建</code>，并在整个应用程序的<code>生命周期内保持不变</code>。</li>\n<li><code>Bootstrap</code> 需要调用 <code>group()</code> 方法来指定处理 I/O 操作的线程池。</li>\n<li><code>Bootstrap</code> 需要调用 <code>channel()</code> 方法来<code>指定传输协议的类型</code>（TCP 或 UDP），同时也可以通过 <code>option()</code> 方法设置相应的选项。</li>\n<li><code>Bootstrap</code> 还需要调用 <code>handler()</code> 方法将自定义的 <code>ChannelHandler</code> 添加到 <code>ChannelPipeline</code> 中，以对网络事件进行处理。</li>\n<li>在完成所有 Bootstrap 的配置后，需要使用 <code>connect()</code>、<code>bind()</code> 或 <code>accept()</code> 方法<code>启动 Netty</code> 应用程序</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>多线程时间循环处理器：<code>NioEventLoopGroup</code></p>\n<ul>\n<li><p>介绍</p>\n<ul>\n<li>封装了<code>NIO</code>中的<code>Selector</code>机制，在<code>Netty</code>中，每个<code>EventLoop</code>都对应一个<code>Selector</code>对象。当有I/O事件发生时，<code>EventLoop</code>会从<code>Selector</code>中选择处于就绪状态的<code>Channel</code>进行处理，并触发相应的事件<code>回调函数</code></li>\n<li>处理IO操作，内部维护了一个线程池，通过这个线程池来管理多个<code>NioEventLoop</code>对象。每个<code>NioEventLoop</code>负责管理一个或多个<code>Channel</code>的事件循环</li>\n<li>在<code>Netty</code>应用程序中，通常会创建两个<code>EventLoopGroup</code>。一个是<code>bossGroup</code>，用于接受客户端连接请求，另一个是<code>workerGroup</code>，用于处理客户端连接后的I/O事件。当然也可以只使用一个<code>EventLoopGroup</code>，但是会存在性能瓶颈。</li>\n</ul>\n</li>\n<li><p>特点</p>\n<ul>\n<li>它是多线程的，可以并发处理多个任务；</li>\n<li>它使用<code>Java NIO Selector</code>实现事件监听和分发，可以监控多个<code>Channel</code>的I/O事件；</li>\n<li>它支持异步化的、非阻塞的I/O操作，避免了I/O线程被阻塞的情况，提高了并发处理能力；</li>\n<li>它能够自动根据CPU数量和处理器核心数创建适当数量的线程池，最大程度地利用系统资源；</li>\n<li>它支持灵活的线程管理策略，可以自定义线程模型，满足不同场景下的需求</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>流程梳理</p>\n</blockquote>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306161259063.png\" alt=\"image-20230616125918990\"></p>\n<p>正确的流程理解的思路：</p>\n<ul>\n<li>把 <code>channel</code> 理解为数据的<code>通道</code></li>\n<li>把 <code>msg</code> 理解为流动的数据，最开始输入是 ByteBuf，但经过 <code>pipeline</code> 的<code>加工</code>，会变成<code>其它类型对象(此处是String)</code>，最后输出又变成 ByteBuf</li>\n<li>把 handler 理解为<code>数据的处理工序</code><ul>\n<li>工序有多道，合在一起就是 <code>pipeline</code>，<code>pipeline</code> 负责发布事件（读、读取完成…）传播给每个 <code>handler</code>， <code>handler</code> 对自己感兴趣的事件进行处理（重写了相应事件处理方法）</li>\n<li><code>handler</code> 分 <code>Inbound</code> 和 <code>Outbound</code> 两类</li>\n</ul>\n</li>\n<li>把 <code>eventLoop</code> 理解为处理数据的<code>工人</code> <eventLoop底层是`单线程的线程池`><ul>\n<li>工人可以管理多个 <code>channel</code> 的 <code>io</code> 操作，并且一旦工人负责了某个 channel，就要负责<code>到底</code>（绑定）&lt;可以保证线程安全&gt;</li>\n<li>工人既可以执行 <code>io 操作</code>，也可以进行<code>任务处理</code>，每位工人有任务队列，<code>队列</code>里可以堆放多个 <code>channel</code> 的待处理任务，任务分为普通任务、定时任务</li>\n<li>工人按照 <code>pipeline</code> 顺序，依次按照 <code>handler</code> 的规划（代码）处理数据，可以为每道工序指定不同的<code>工人</code></li>\n</ul>\n</eventLoop底层是`单线程的线程池`></li>\n</ul>\n<h3 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h3><h4 id=\"EventLoop\"><a href=\"#EventLoop\" class=\"headerlink\" title=\"EventLoop\"></a>EventLoop</h4><blockquote>\n<p>事件循环对象</p>\n</blockquote>\n<p>本质：</p>\n<ul>\n<li>是一个单线程执行器，同时维护了一个<code>selector</code>,里面的<code>run</code>方法处理 <code>Channel</code> 上源源不断的<code>io</code>事件。</li>\n<li>它的继承关系比较复杂<ul>\n<li>一条线是继承自<code>juc.ScheduledExecutorService</code> 因此包含了线程池中所有的方法</li>\n<li>另一条线是继承自 <code>netty</code> 自己的 <code>OrderedEventExecutor</code><ul>\n<li>提供了<code>boolean inEventLoop(Thread thread)</code>方法判断一个线程是否属于此 <code>EventLoop</code></li>\n<li>提供了 <code>parent</code> 方法来看看自己属于哪个 <code>EventLoopGroup</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"EventLoopGroup\"><a href=\"#EventLoopGroup\" class=\"headerlink\" title=\"EventLoopGroup\"></a>EventLoopGroup</h4><blockquote>\n<p>事件循环组</p>\n</blockquote>\n<p>一组 <code>EventLoop</code>，<code>Channel</code> 一般会调用 <code>EventLoopGroup</code> 的 <code>register</code> 方法来绑定其中一个 <code>EventLoop</code>，后续这个 <code>Channel</code> 上的 <code>io</code> 事件都由此 <code>EventLoop</code> 来处理（保证了<code>io</code>事件处理时的线程安全）</p>\n<ul>\n<li>继承自 <code>netty</code> 自己的 <code>EventExecutorGroup</code><ul>\n<li>实现了 <code>Iterable</code> 接口提供遍历 <code>EventLoop</code> 的能力</li>\n<li>另有 <code>next</code> 方法获取集合中下一个 <code>EventLoop</code></li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>创建<ul>\n<li>事件循环组 的时候： 未指定的话，则默认读取系统配置<code>io.netty.eventLoopThreads</code>，没有配置，则根据<code>cpu核心数*2</code>  创建线程    <code>EventLoopGroup group1 = new NioEventLoopGroup(2);</code></li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//普通任务 交给EventLoop 执行;提交到 事件循环组 中，让 某一个事件循环对象 去执行;作用： 譬如 某件耗时的工作交给子线程完成</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tgroup1.next().submit(()-&gt;&#123;  <span class=\"comment\">// 也可以 group1.next().execute(()-&gt;&#123;</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;1️⃣子线程运行。。。&quot;</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;2️⃣主线程 运行。。。&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 定时任务  初始延时事件0，间隔时间1， 时间单位 TimeUnit.SECONDS</span></span><br><span class=\"line\">        group1.next().scheduleAtFixedRate(()-&gt;&#123;</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;3️⃣子线程运行......&quot;</span>);</span><br><span class=\"line\">            &#125;, <span class=\"number\">0</span>, <span class=\"number\">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>方法：</p>\n<ul>\n<li><p><code>next()</code>                                                     获取下一个循环对象   ——可以达到<code>轮询效果</code></p>\n</li>\n<li><p><code>next().submit()</code>                                 普通任务</p>\n</li>\n<li><code>next().scheduleAtFixedRate()</code>     定时任务</li>\n</ul>\n</li>\n<li><p>优雅关闭</p>\n<ul>\n<li><code>shutdownGracefully</code> ：会首先切换 <code>EventLoopGroup</code> 到<code>关闭状态</code>从而<code>拒绝新的任务的加入</code>，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"NioEventLoop-处理-io-事件\"><a href=\"#NioEventLoop-处理-io-事件\" class=\"headerlink\" title=\"NioEventLoop 处理 io 事件\"></a>NioEventLoop 处理 io 事件</h5><blockquote>\n<p> <code>Channel</code>  建立连接之后 会和 <code>EventLoop</code> 绑定 ，随后都是由同一个<code>EventLoop</code>执行</p>\n</blockquote>\n<ul>\n<li><p>职责划分，为不<code>同的组分配不同的任务</code>： <code>.group(new NioEventLoopGroup(), new NioEventLoopGroup(2))</code>，此时，<code>一个线程 是可以管理 多个channel</code></p>\n</li>\n<li><p>创建一个独立的<code>EventLoopGroup</code> 去处理处理耗时较长的操作      <code>final DefaultEventLoopGroup defEventLoopGroup = new DefaultEventLoopGroup();</code>创建独立的   <code>EventLoopGroup</code></p>\n</li>\n<li><p>值得注意的是： 所有的<code>EentLoopGroup</code>都会和线程进行绑定</p>\n</li>\n</ul>\n<blockquote>\n<p><code>ChannelInboundHandlerAdapter</code>的介绍</p>\n<ul>\n<li>是 <code>Netty</code> 提供的用于处理网络事件的基础类之一</li>\n<li><code>ChannelInboundHandlerAdapter</code> 类中定义了一些可以被子类重写的方法，用于处理各种网络事件</li>\n</ul>\n<p><code>addLast()方法：</code>可以向 <code>ChannelPipeline</code> 的尾部添加一个新的 <code>ChannelHandler</code></p>\n<p><code>DefaultEventLoopGroup</code></p>\n<p><code>final DefaultEventLoopGroup defEventLoopGroup = new DefaultEventLoopGroup()</code></p>\n<ul>\n<li>一个用于<code>处理网络事件</code>的线程池组。它实现了 <code>EventLoopGroup</code> 接口，并且<code>使用默认的线程数量</code>来处理所有的网络事件</li>\n<li>由于<code>没有指定参数</code>，在创建时将使用默认的参数，即线程数为<code>CPU 核心数乘以 2</code></li>\n<li><code>defEventLoopGroup</code> 是一个线程池组，它包含<code>多个线程</code>来处理各种网络事件</li>\n<li>使用时，可以将其传递给 <code>Netty</code> 的 <code>Bootstrap</code> 或 <code>ServerBootstrap</code> 对象，用于处理各种网络连接</li>\n</ul>\n</blockquote>\n<h5 id=\"更换不同的handler\"><a href=\"#更换不同的handler\" class=\"headerlink\" title=\"更换不同的handler\"></a>更换不同的<code>handler</code></h5><blockquote>\n<p>源码分析</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class=\"string\">&quot;msg&quot;</span>), next);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 下一个 handler 的事件循环是否与当前的事件循环是同一个线程</span></span><br><span class=\"line\">   <span class=\"type\">EventExecutor</span> <span class=\"variable\">executor</span> <span class=\"operator\">=</span> next.executor();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 是，直接调用</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (executor.inEventLoop()) &#123;</span><br><span class=\"line\">       next.invokeChannelRead(m);</span><br><span class=\"line\">   &#125; </span><br><span class=\"line\">   <span class=\"comment\">// 不是，将要执行的代码作为任务提交给下一个事件循环处理（换人）</span></span><br><span class=\"line\">   <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">       executor.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">               next.invokeChannelRead(m);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li>如果两个 <code>handler</code> 绑定的<code>是同一个线程</code>，那么就<code>直接调用</code></li>\n<li>如果两个 <code>handler</code> 绑定的<code>不是同一个线程</code>，把要<code>调用的代码</code>封装为一个任务对象，由下一个 <code>handler</code> 的线程来调用</li>\n</ul>\n</blockquote>\n<h5 id=\"NioEventLoop处理任务\"><a href=\"#NioEventLoop处理任务\" class=\"headerlink\" title=\"NioEventLoop处理任务\"></a><code>NioEventLoop</code>处理任务</h5><ul>\n<li>定时任务</li>\n<li>普通任务</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">nioWorkers</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">nioWorkers.execute(()-&gt;&#123;  <span class=\"comment\">//NioEventLoop 除了可以处理 io 事件，同样可以向它提交普通任务,可以用来执行耗时较长的任务</span></span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;normal task...&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">nioWorkers.scheduleAtFixedRate(() -&gt; &#123; <span class=\"comment\">//NioEventLoop 处理定时任务,可以用来执行定时任务</span></span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;running...&quot;</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>, <span class=\"number\">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>\n<h4 id=\"Channel\"><a href=\"#Channel\" class=\"headerlink\" title=\"Channel\"></a>Channel</h4><blockquote>\n<p>主要作用：</p>\n</blockquote>\n<ul>\n<li><code>close</code>可以用来关闭<code>channel</code></li>\n<li><code>closeFuture()</code>用来处理 <code>channel</code> 的关闭<ul>\n<li><code>sync</code> 方法作用是<code>同步</code>等待 <code>channel</code> 关闭</li>\n<li>而 <code>addListener</code> 方法是<code>异步</code>等待 <code>channel</code> 关闭</li>\n</ul>\n</li>\n<li><code>pipeline()</code>方法添加处理器</li>\n<li><code>write()</code>方法将数据写入</li>\n<li><code>writeAndFlush()</code> 方法将数据写入并刷出</li>\n</ul>\n<h5 id=\"ChannelFuture\"><a href=\"#ChannelFuture\" class=\"headerlink\" title=\"ChannelFuture\"></a>ChannelFuture</h5><blockquote>\n<p>使用<code>ChannelFuture</code>  对该代码进行改进</p>\n<p>原来：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>()</span><br><span class=\"line\">    .group(<span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>())</span><br><span class=\"line\">    .channel(NioSocketChannel.class)</span><br><span class=\"line\">    .handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(Channel ch)</span> &#123;</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">StringEncoder</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .connect(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">8080</span>)</span><br><span class=\"line\">    .sync()</span><br><span class=\"line\">    .channel()</span><br><span class=\"line\">    .writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>() + <span class=\"string\">&quot;: hello world!&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>修改之后：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ChannelFuture</span> <span class=\"variable\">channelFuture</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>()</span><br><span class=\"line\">    .group(<span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>())</span><br><span class=\"line\">    .channel(NioSocketChannel.class)</span><br><span class=\"line\">    .handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(Channel ch)</span> &#123;</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">StringEncoder</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .connect(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">8080</span>); <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">channelFuture.sync().channel().writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>() + <span class=\"string\">&quot;: hello world!&quot;</span>);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>说明</p>\n</blockquote>\n<ul>\n<li><p><code>1</code> 处返回的是<code>ChannelFuture</code> 对象,作用是利用 <code>channel()</code>方法来获取 <code>Channel</code> 对象</p>\n</li>\n<li><p><strong>注意</strong> <code>connect</code> 方法是异步的，意味着不用等待连接的建立，方法执行就可以返回了。因此 <code>channelFuture</code> 对象中不能【立刻】获得到正确的 <code>Channel</code> 对象</p>\n</li>\n</ul>\n<blockquote>\n<p>除了用 <code>sync</code> 方法可以让<code>异步操作同步</code>以外，还可以使用<code>回调的方式</code>：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ChannelFuture</span> <span class=\"variable\">channelFuture</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>()</span><br><span class=\"line\">    .group(<span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>())</span><br><span class=\"line\">    .channel(NioSocketChannel.class)</span><br><span class=\"line\">    .handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(Channel ch)</span> &#123;</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">StringEncoder</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .connect(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">8080</span>);</span><br><span class=\"line\">System.out.println(channelFuture.channel()); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">//回调函数</span></span><br><span class=\"line\">channelFuture.addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class=\"line\">    System.out.println(future.channel()); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//ChannelFutureListener 会在连接建立时被调用（其中 operationComplete 方法），因此执行到 2 时，连接肯定建立了</span></span><br></pre></td></tr></table></figure>\n<p><strong>小结：异步操作同步</strong></p>\n<blockquote>\n<p> <code>方法一</code>同步处理结果：<code>channelFuture.sync();</code>   :  表示  【阻塞等待中…】，直到<code>nio</code>线程 连接建立完毕  再继续往下执行</p>\n<ul>\n<li>无阻塞的向下运行， 如果没有上面的 <code>sync()</code>方法 的话，这里获取的 <code>channel</code>还是<code>未建立好连接</code>的</li>\n<li><p>如果有上面的 <code>sync()</code>方法 的话，这里获取的 <code>channel</code>是 <code>建立好连接</code>的</p>\n<p><code>方法二</code> 使用 <code>addListener</code>(回调对象) 异步处理结果[<code>lambda</code>表达式的简化写见上]</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">channelFuture.addListener(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelFutureListener</span>() &#123;</span><br><span class=\"line\">          <span class=\"comment\">// nio 线程 建立好之后，会调用 此方法</span></span><br><span class=\"line\">          <span class=\"meta\">@Override</span></span><br><span class=\"line\">          <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">operationComplete</span><span class=\"params\">(ChannelFuture future)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">              <span class=\"keyword\">final</span> <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> future.channel();</span><br><span class=\"line\">              log.debug(<span class=\"string\">&quot;用addListener() 异步处理结果后 得到的 channel = &#123;&#125;&quot;</span>, channel);</span><br><span class=\"line\">              channel.writeAndFlush(<span class=\"string\">&quot;线程建立好后的回调对象addListener异步处理结果);</span></span><br><span class=\"line\"><span class=\"string\">          &#125;</span></span><br><span class=\"line\"><span class=\"string\">      &#125;);</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<h5 id=\"CloseFuture\"><a href=\"#CloseFuture\" class=\"headerlink\" title=\"CloseFuture\"></a>CloseFuture</h5><p>获取 <code>CloseFuture</code> 对象:   <code>ChannelFuture closeFuture = channel.closeFuture();</code></p>\n<ul>\n<li>同步处理关闭    : <code>closeFuture.sync();</code></li>\n<li>异步处理关闭    : <code>channelFuture.addListener((ChannelFutureListener) future -&gt; &#123;\nSystem.out.println(future.channel()); // 2\n&#125;);</code></li>\n</ul>\n<blockquote>\n<p>什么是优雅的关闭：</p>\n<ul>\n<li>首先切换 <code>EventLoopGroup</code> 到关闭状态 ,<code>拒绝新的任务的加入</code></li>\n<li>其次   任务队列的任务<code>都处理完成后</code>，<code>停止线程</code>的运行</li>\n</ul>\n</blockquote>\n<h5 id=\"异步提升的是什么\"><a href=\"#异步提升的是什么\" class=\"headerlink\" title=\"异步提升的是什么\"></a>异步提升的是什么</h5><blockquote>\n<p>提升的是：<code>效率</code>      <code>吞吐量</code>  <code>合理进行任务拆分</code></p>\n</blockquote>\n<ul>\n<li>单线程没法异步提高<code>效率</code>，必须配合多线程、多核 cpu 才能发挥异步的优势</li>\n<li>异步并没有缩短响应时间，反而有所增加,但是<code>吞吐量</code>有了很大的提升</li>\n<li><code>合理进行任务拆分</code> ，也是利用异步的关键</li>\n</ul>\n<h4 id=\"Future-amp-Promise\"><a href=\"#Future-amp-Promise\" class=\"headerlink\" title=\"Future &amp; Promise\"></a>Future &amp; Promise</h4><p>==注意==：<code>netty 中的 Future</code> 与<code>jdk 中的 Future</code> 同名，但是是<code>两个接口</code>，<code>netty 的 Future</code> 继承自 <code>jdk 的 Future</code>，而 <code>Promise</code> 又对 <code>netty Future</code> 进行了扩展</p>\n<ul>\n<li><code>jdk Future</code> 只能<code>同步等待任务结束</code>（或成功、或失败）才能得到结果</li>\n<li><code>netty Future</code> 可以<code>同步等待任务结束</code>得到结果，也可以<code>异步方式</code>得到结果，但都是<code>要等任务结束</code></li>\n<li><code>netty Promise</code> 不仅有 <code>netty Future</code>的功能，而且脱离了<code>任务独立存在</code>，只作为<code>两个线程间传递结果的容器</code></li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>功能/名称</th>\n<th>jdk Future</th>\n<th>netty Future</th>\n<th>Promise</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cancel</td>\n<td>取消任务</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>isCanceled</td>\n<td>任务是否取消</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>isDone</td>\n<td>任务是否完成，不能区分成功失败</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>get</td>\n<td>获取任务结果，<code>阻塞</code>等待</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>getNow</td>\n<td>-</td>\n<td>获取任务结果，<code>非阻塞</code> 还未产生结果时返回 <code>null</code></td>\n<td>-</td>\n</tr>\n<tr>\n<td>await</td>\n<td>-</td>\n<td>等待任务结束，如果任务失败，不会抛异常，而是通过 <code>isSuccess</code> 判断</td>\n<td>-</td>\n</tr>\n<tr>\n<td>sync</td>\n<td>-</td>\n<td>等待任务结束，如果任务失败，抛出异常</td>\n<td>-</td>\n</tr>\n<tr>\n<td>isSuccess</td>\n<td>-</td>\n<td>判断任务是否成功</td>\n<td>-</td>\n</tr>\n<tr>\n<td>cause</td>\n<td>-</td>\n<td>获取失败信息，非阻塞，如果没有失败，返回<code>null</code></td>\n<td>-</td>\n</tr>\n<tr>\n<td>addLinstener</td>\n<td>-</td>\n<td>添加回调，异步接收结果</td>\n<td>-</td>\n</tr>\n<tr>\n<td>setSuccess</td>\n<td>-</td>\n<td>-</td>\n<td>设置成功结果</td>\n</tr>\n<tr>\n<td>setFailure</td>\n<td>-</td>\n<td>-</td>\n<td>设置失败结果</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h5 id=\"JDK-FUTURE\"><a href=\"#JDK-FUTURE\" class=\"headerlink\" title=\"JDK FUTURE\"></a><code>JDK FUTURE</code></h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 创建线程池</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">ExecutorService</span> <span class=\"variable\">service</span> <span class=\"operator\">=</span> Executors.newFixedThreadPool(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 2. 提交任务 ，call()执行完毕，结果填充Future里，然后把下面 get() 阻塞方法 唤醒</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Future&lt;Integer&gt; future = service.submit(<span class=\"keyword\">new</span> <span class=\"title class_\">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> Integer <span class=\"title function_\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot;执行计算...&quot;</span>);</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">50</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 3. 主线程通过 future 来获取结果</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">Integer</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> future.get(); <span class=\"comment\">// 阻塞方法，等待 子线程运行完毕</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"NETTY-FUTURE\"><a href=\"#NETTY-FUTURE\" class=\"headerlink\" title=\"NETTY FUTURE\"></a><code>NETTY FUTURE</code></h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 1. EventLoopGroup 里包含 多个EventLoop      一个 EventLoop里面包含一个线程</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">group</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">EventLoop</span> <span class=\"variable\">eventLoop</span> <span class=\"operator\">=</span> group.next();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Future&lt;Integer&gt; future = eventLoop.submit(<span class=\"keyword\">new</span> <span class=\"title class_\">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> Integer <span class=\"title function_\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot;执行计算...&quot;</span>);</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">666</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 3. 主线程通过 future 来获取结果</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 方式一. 同步获取结果</span></span><br><span class=\"line\"><span class=\"comment\">//        final Integer i = future.get(); // 阻塞方法，等待 子线程运行完毕</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 方式二. 异步获取结果</span></span><br><span class=\"line\">        <span class=\"comment\">// 注意这里不能用 ChannelFutureListener，因为上面 NioEventLoopGroup 不属于channel的</span></span><br><span class=\"line\">        future.addListener(future1 -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// getNow非阻塞方法； get()阻塞方法也可以（因为当前回调方法执行了，说明子线程已经完成了）</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">Integer</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> (Integer) future1.getNow(); </span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"NETTY-PROMISE\"><a href=\"#NETTY-PROMISE\" class=\"headerlink\" title=\"NETTY PROMISE\"></a><code>NETTY PROMISE</code></h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t<span class=\"comment\">// 1. 准备 EventLoop 对象</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">EventLoop</span> <span class=\"variable\">eventLoop</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>().next();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 2. 创建 promise  的 结果容器</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> DefaultPromise&lt;Integer&gt; promise = <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultPromise</span>&lt;&gt;(eventLoop);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 3. 任意一线程 执行计算，计算完毕后向 promise 填充结果</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt;&#123;</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;开始计算......&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\"><span class=\"comment\">//                int i = 1/0;</span></span><br><span class=\"line\">                <span class=\"comment\">// 设置成功结果</span></span><br><span class=\"line\">                promise.setSuccess(<span class=\"number\">80</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 设置失败结果</span></span><br><span class=\"line\">                promise.setFailure(e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 4. 主线程接收 结果</span></span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;结果是： &#123;&#125;&quot;</span>, promise.get()); <span class=\"comment\">// get 同步阻塞</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>DefaultPromise&lt;Integer&gt; promise = new DefaultPromise&lt;&gt;(eventExecutors);</code></p>\n<p>==成功==</p>\n<ul>\n<li><p><code>promise.get());     get 同步阻塞      同步处理任务成功</code></p>\n</li>\n<li><p>`promise.addListener(promise -&gt; {</p>\n<pre><code>log.debug(&quot;&#123;&#125;&quot;,promise.getNow());\n</code></pre><p>}); 异步处理任务成功`</p>\n<p><code>promise.setSuccess(10);</code></p>\n</li>\n</ul>\n<p>==失败==</p>\n<ul>\n<li>同步处理任务失败 -<code>sync &amp; get</code>      <code>promise.get(); // sync() 也会出现异常，只是 get 会再用 ExecutionException 包一层异常</code></li>\n<li><p>同步处理任务失败 - <code>await</code>        <code>promise.await(); // 与 sync 和 get 区别在于，不会抛异常</code></p>\n</li>\n<li><p>异步处理任务失败   `promise.addListener(future -&gt; {</p>\n<pre><code>log.debug(&quot;result &#123;&#125;&quot;, (promise.isSuccess() ? promise.getNow() :           promise.cause()).toString());\n</code></pre><p>  });`</p>\n</li>\n</ul>\n<p>==死锁检查==</p>\n<ul>\n<li><code>await 死锁检查</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eventExecutors.submit(()-&gt;&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        promise.await();</span><br><span class=\"line\"><span class=\"comment\">// 注意不能仅捕获 InterruptedException 异常</span></span><br><span class=\"line\"><span class=\"comment\">// 否则 死锁检查抛出的 BlockingOperationException 会继续向上传播</span></span><br><span class=\"line\"><span class=\"comment\">// 而提交的任务会被包装为 PromiseTask，它的 run 方法中会 catch 所有异常 然后设置为 Promise 的失败结果而不会抛出</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123; </span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h4 id=\"Handler-amp-Pipeline\"><a href=\"#Handler-amp-Pipeline\" class=\"headerlink\" title=\"Handler &amp; Pipeline\"></a>Handler &amp; Pipeline</h4><p><code>ChannelHandler</code> 是用来处理<code>Channel</code>上的各种事件，分为<code>入站、出站</code>两种。所有 <code>ChannelHandler</code> 被连成一串，就是 <code>Pipeline</code></p>\n<ul>\n<li><p><code>入站</code>处理器： <code>ChannelInboundHandlerAdapter</code> 的子类，主要用来<code>读取客户端数据，写回结果</code></p>\n</li>\n<li><p><code>出站</code>处理器： <code>ChannelOutboundHandlerAdapter</code> 的子类，主要对<code>写回结果进行加工</code></p>\n</li>\n</ul>\n<blockquote>\n<p><code>入站</code> 里 调用 <code>ch.writeAndFlush()</code>方法 才能<code>触发出站</code> 动作   <code>ctx.alloc()</code>创建<code>Bytebuf</code> 对象</p>\n</blockquote>\n<ul>\n<li><p>创建<code>pipeline</code>：通过 <code>channel</code> 拿到 <code>pipeline</code>        <code>final ChannelPipeline pipeline = ch.pipeline();</code></p>\n</li>\n<li><p>添加<code>handler</code>:    添加处理器  <code>netty</code>加<code>handler</code>时 有两个 <code>handler  head -&gt; tail</code>       <code>addLast</code> 每次添加的位置 是 这两个中间 ：<code>head -&gt; handler1 handler2 handler3 -&gt; tail</code></p>\n<ul>\n<li><p>当添加多个<code>出站入站处理器</code>的时候要注意的是处理器之间需要进行唤醒：(二选一即可)</p>\n<ul>\n<li><p><code>ctx.fireChannelRead(student);</code> :一般出现在自定义的 <code>ChannelInboundHandler</code> 中的 <code>channelRead()</code>方法中</p>\n</li>\n<li><p><code>super.channelRead(ctx, student);</code>:在 <code>ChannelInboundHandlerAdapter</code> 的<code>channelRead()</code> 方法中调用的，用于将<code>从网络中读取的数据</code>向 <code>ChannelPipeline</code> 中的<code>下一个处理器</code>传递，并由<code>下一个处理器</code>对这个数据进行处理</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><code>ch.writeAndFlush(ctx.alloc().buffer().writeBytes(&quot;...&quot;.getBytes()));</code>是将字节数组<code>...</code>写入到 <code>Channel</code> 中并刷新的操作,主要的就是<code>通过 writeBytes()方法将 &quot;…&quot; 字节数组写入缓冲区中</code>,最后调用 <code>writeAndFlush()</code> 方法将缓冲区中的数据写入到 <code>Channel</code> 中并刷新；另外<code>ctx.alloc().buffer()</code> 用来分配一个 <code>ByteBuf</code> 缓冲区，用于存储要写入的数据</p>\n<p><strong>数据的传递和处理的：</strong></p>\n<ul>\n<li><code>super.write(ctx, msg, promise)</code> 方法与 <code>ctx.write()</code> 方法类似，是用于将数据写入到 <code>ChannelPipeline</code> 中的<code>下一个出站处理器进行处理的方法</code></li>\n<li><code>super.write</code>是从当前出站处理器<code>向前找上一个</code>出站处理器来处理数据的</li>\n<li>这个方法会将要写入的消息 <code>msg</code> 和异步操作结果 <code>promise</code> 传递给当前 <code>ChannelHandler</code> 类的<code>父类</code>（即 <code>ChannelOutboundHandlerAdapter</code>），由它来完成将消息写入到 <code>ChannelPipeline</code> 中的下一个出站处理器的操作。在写入过程中，如果数据被<code>阻塞</code>或<code>发送失败</code>，就会通过 <code>promise</code> 对象返回相应的错误信息</li>\n<li>该方法可以将数据从<code>出站处理器</code>传递到<code>下一个出站处理器</code>，并<code>最终写入到发送缓冲区</code>中等待发送</li>\n</ul>\n</blockquote>\n<p>入栈处理器是顺序的传递值给到下一个处理器进行处理任务，而出站处理器的逆序的处理处理器，具体的话有两种<code>出站</code>处理器的方法：</p>\n<ul>\n<li><b>ctx.<code>channel()</code>.write(msg,promise)</b> 从<code>尾部开始</code>向前查找出站处理器</li>\n<li><b>ctx.write(msg,promise)</b>           是从<code>当前节点</code>向前找到上一个出站处理器</li>\n</ul>\n<p>值得注意的是 入站和出站之间是需要进行数据传递的,使用的方法就是</p>\n<ul>\n<li><p>方式一：<code>ctx.channel().writeAndFlush(msg)</code>    ：先获取当前处理器所关联的 <code>Channel</code>，然后调用 <code>Channel</code> 对象的 <code>writeAndFlush()</code> 方法来将消息写入到 <code>Channel</code> 中并刷新;可以保证消息的<code>写入和刷新</code>操作发生在 <code>ChannelPipeline</code> 的出<code>站处理器</code>中，从而<code>使得其他的出站处理器</code>也能够对<code>数据进行处理</code>,从 最后一个handler往前找</p>\n</li>\n<li><p>方式二：<code>ctx.writeAndFlush(msg);</code>  ： 将消息写入到 <code>Channel</code> 中<code>并刷新</code>,由于调用 <code>writeAndFlush()</code> 方法时，实际上会将消息从当前的<code>出站处理器</code>开始一路传递到下一个出站处理器，从而最终写入到 <code>Channel</code>中并刷新。因此，这种方式也可以<code>完成消息的写入和刷新操作</code>，但是<code>它只能够保证消息被当前出站处理器处理</code>，从当前节点往上找 出站处理器</p>\n<blockquote>\n<p>如果想要保证<code>所有的出站处理器</code>都能够<code>对数据进行处理</code>，建议使用方式一；</p>\n<p>如果仅需要在<code>当前出站处理器</code>进行<code>数据的处理</code>，则可以使用方式二。</p>\n</blockquote>\n</li>\n</ul>\n<p>也就是说：</p>\n<p><code>`ChannelInboundHandlerAdapter</code> 是按照 <code>addLast</code> 的<code>顺序</code>执行的</p>\n<p>而 <code>ChannelOutboundHandlerAdapter</code> 是按照 <code>addLast</code> 的<code>逆序</code>执行的</p>\n<p><code>ChannelPipeline</code> 的实现是一个 <code>ChannelHandlerContext</code>（包装了 <code>ChannelHandler</code>） 组成的<code>双向链表</code></p>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306172057180.png\" alt=\"image-20230617205749098\"></p>\n<ul>\n<li><p>入站处理器中，<code>ctx.fireChannelRead(msg)</code>是 <strong>调用下一个入站处理器</strong></p>\n</li>\n<li><p>出站处理器中</p>\n<ul>\n<li><code>ctx.channel().write(msg)</code>会 <strong>从尾部开始触发</strong> 后续出站处理器的执行</li>\n<li><code>ctx.write(msg, promise)</code>  会 <strong>触发上一个出站处理器</strong></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"EmbeddedChannel\"><a href=\"#EmbeddedChannel\" class=\"headerlink\" title=\"EmbeddedChannel\"></a><code>EmbeddedChannel</code></h4><blockquote>\n<ul>\n<li>Netty 框架提供的一个<code>嵌入式 Channel</code>实现</li>\n<li>可以用于<code>在测试时</code>模拟 <code>Channel</code> 的行为和事件</li>\n<li>它<code>可以在不创建实际的网络连接的情况下</code>，对 <code>ChannelHandler</code> 进行测试</li>\n</ul>\n</blockquote>\n<p>使用注意：</p>\n<ul>\n<li>使用 <code>EmbeddedChannel</code> 来 ==创建==一个指定的 <code>ChannelPipeline</code>，并将需要测试的 <code>ChannelHandler</code> 添加到其中</li>\n<li>然后通过调用 <code>EmbeddedChannel.writeInbound()</code> 和 <code>EmbeddedChannel.writeOutbound()</code> 方法向 <code>ChannelPipeline</code> 中写入数据，从而触发 <code>ChannelHandler</code> 的相应操作    (==模拟入站==)</li>\n<li>并可以通过 <code>EmbeddedChannel.readInbound()</code> 和 <code>EmbeddedChannel.readOutbound()</code> 方法获取 <code>ChannelHandler</code> 处理后的结果，进而进行<code>断言和验证</code>                    ( ==模拟出站==)</li>\n</ul>\n<p>好处：</p>\n<ul>\n<li>可以避免创建真实的 <code>Channel</code>、编写繁琐的 <code>mock 测试</code></li>\n<li>并且<code>使测试更加快速和高效</code></li>\n<li>在测试中，我们可以通过创建多个 <code>EmbeddedChannel</code> 来模拟复杂的网络环境，比如同时存在多个客户端和服务器，以便测试我们的 <code>ChannelHandler</code> 在这样的场景下的正确性。</li>\n</ul>\n<h4 id=\"ByteBuf\"><a href=\"#ByteBuf\" class=\"headerlink\" title=\"ByteBuf\"></a>ByteBuf</h4><blockquote>\n<p>对<code>字节数据</code>的<code>封装</code></p>\n</blockquote>\n<h5 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h5><p><code>ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(10);</code></p>\n<ul>\n<li><p>上面代码创建了一个初始容量是 <code>10</code>的 <code>ByteBuf</code>（<code>池化基于直接内存的 ByteBuf</code>）</p>\n</li>\n<li><p>但是什么都不写的话就是 <code>256</code>   获取直接内存，获取<code>堆内存 heapBuffer</code></p>\n</li>\n</ul>\n<h5 id=\"直接内存-vs-堆内存\"><a href=\"#直接内存-vs-堆内存\" class=\"headerlink\" title=\"直接内存 vs 堆内存\"></a>直接内存 vs 堆内存</h5><ul>\n<li><p><code>创建池化基于直接内存的ByteBuf</code>          <code>ByteBuf buffer = ByteBufAllocator.DEFAULT.heapBuffer(10);</code></p>\n</li>\n<li><p><code>创建池化基于堆的 ByteBuf</code>                  <code>ByteBuf buffer = ByteBufAllocator.DEFAULT.directBuffer(10);</code></p>\n</li>\n</ul>\n<p>对比</p>\n<ul>\n<li>直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合<code>配合池化</code>功能一起用</li>\n<li>直接内存对<code>GC</code> 压力小，因为这部分内存不受<code>JVM</code> 垃圾回收的管理，但也要注意及时主动释放</li>\n</ul>\n<h5 id=\"池化-vs-非池化\"><a href=\"#池化-vs-非池化\" class=\"headerlink\" title=\"池化 vs 非池化\"></a>池化 vs 非池化</h5><ul>\n<li>池化的最大意义在于重用<code>ByteBuf</code></li>\n<li>优点<ul>\n<li>没有<code>池化</code>，则<code>每次都得创建</code>新的 <code>ByteBuf</code> 实例，这个操作<code>对直接内存</code>代价昂贵，就算<code>是堆内存</code>，也会增加 GC 压力</li>\n<li>有了<code>池化</code>，则可以<code>重用</code>池中 <code>ByteBuf</code> 实例，并且采用了与 <code>jemalloc</code> 类似的<code>内存分配算法提升分配效率</code></li>\n<li><code>高并发</code>时，池化功能更<code>节约内存</code>，<code>减少内存溢出的可能</code></li>\n</ul>\n</li>\n</ul>\n<p>池化功能是否开启，可以通过下面的系统环境变量来设置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Dio.netty.allocator.type=unpooled</span><br><span class=\"line\">    ||</span><br><span class=\"line\">-Dio.netty.allocator.type=pooled </span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>说明：</p>\n<ul>\n<li>Netty4.1 <code>以后</code>，<code>非 Android 平台默认启用池化</code>实现，<code>Android 平台启用非池化</code>实现</li>\n<li>Netty4.1 <code>之前</code>，池化功能还不成熟，默认是<code>非池化实现</code></li>\n</ul>\n</blockquote>\n<h5 id=\"组成\"><a href=\"#组成\" class=\"headerlink\" title=\"组成\"></a>组成</h5><blockquote>\n<p>ByteBuf 由<code>四部分组成</code></p>\n</blockquote>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306172205988.png\" alt=\"image-20230617220548955\" style=\"zoom:33%;\"></p>\n<p>最开始<code>读、写指针</code>都在 <code>0</code> 位置</p>\n<blockquote>\n<p><code>读写模式(指针)分离</code>  +  <code>读写分离</code></p>\n</blockquote>\n<h5 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h5><blockquote>\n<p>写入<code>buffer.writeBytes(new byte[]&#123;1, 2, 3, 4&#125;);...</code></p>\n</blockquote>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>方法签名</th>\n<th>含义</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>writeBoolean(boolean value)</td>\n<td>写入 boolean 值</td>\n<td>用一字节 01\\</td>\n<td>00 代表 true\\</td>\n<td>false</td>\n</tr>\n<tr>\n<td>writeByte(int value)</td>\n<td>写入 byte 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeShort(int value)</td>\n<td>写入 short 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeInt(int value)</td>\n<td>写入 int 值</td>\n<td><code>Big Endian</code>   即 0x250   写入后 00 00 02 50</td>\n</tr>\n<tr>\n<td>writeIntLE(int value)</td>\n<td>写入 int 值</td>\n<td><code>Little Endian</code> 即 0x250 写入后 50 02 00 00</td>\n</tr>\n<tr>\n<td>writeLong(long value)</td>\n<td>写入 long 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeChar(int value)</td>\n<td>写入 char 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeFloat(float value)</td>\n<td>写入 float 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeDouble(double value)</td>\n<td>写入 double 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeBytes(ByteBuf src)</td>\n<td>写入 netty 的 ByteBuf</td>\n<td></td>\n</tr>\n<tr>\n<td>writeBytes(byte[] src)</td>\n<td>写入 byte[]</td>\n<td></td>\n</tr>\n<tr>\n<td>writeBytes(ByteBuffer src)</td>\n<td>写入 nio 的 ByteBuffer</td>\n<td></td>\n</tr>\n<tr>\n<td>int writeCharSequence(CharSequence sequence, Charset charset)</td>\n<td>写入字符串</td>\n</tr>\n</tbody>\n</table>\n</div>\n<blockquote>\n<ul>\n<li>这些方法是<code>未指明返回值</code>的，其返回值都是 <code>ByteBuf</code>，意味着<code>可以链式调用</code></li>\n<li>网络传输，默认习惯是<code>Big Endian</code></li>\n<li>还有一类方法是 <code>set 开头</code>的一系列方法，也可以写入数据，但不会改变写指针位置</li>\n</ul>\n<p>扩容</p>\n</blockquote>\n<ul>\n<li>发生条件： 容量不够了（初始容量是 10），这时会引发扩容</li>\n<li>扩容规则：<ul>\n<li>如何写入后数据大小<code>未超过 512</code>，则选择<code>下一个 16 的整数倍</code>，例如写入后大小为 12 ，则扩容后 capacity 是 16</li>\n<li>如果写入后数据大小<code>超过 512</code>，则选择下一个 2^n^，例如写入后大小为 513，则扩容后 capacity 是 2^10^=1024（2^9^=512 已经不够了）</li>\n<li>扩容<code>不能超过 max capacity</code>（默认：<code>Integer.MAX_VALUE</code>） ,否则会报错</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>读取    <code>buffer.readByte()</code></p>\n</blockquote>\n<ul>\n<li><p>读过的内容，就属于废弃部分了，再读只能读那些<code>尚未读取</code>的部分</p>\n</li>\n<li><p>读取之前进行标记位置：     <code>buffer.markReaderIndex();</code></p>\n</li>\n<li><p>需要重复读取的话，重置到标记位置 ： <code>buffer.resetReaderIndex();</code></p>\n</li>\n<li><p>还有种办法是采用<code>get 开头</code>的一系列方法，这些方法不会改变 <code>readindex</code></p>\n</li>\n</ul>\n<blockquote>\n<p><code>retain &amp; release</code></p>\n</blockquote>\n<p>由于 Netty 中有<code>堆外内存</code>的 ByteBuf 实现，堆外内存最好是手动来释放，而不是等<code>GC垃圾回收</code>。</p>\n<ul>\n<li><code>UnpooledHeapByteBuf</code> 使用的是<code>JVM 内存</code>，只需等 <code>GC 回收内存</code>即可</li>\n<li><code>UnpooledDirectByteBuf</code> 使用的就是<code>直接内存</code>了，需要<code>特殊的方法来回收内存</code></li>\n<li><code>PooledByteBuf</code> 和它的子类使用了<code>池化机制</code>，需要更<code>复杂的规则来回收内存</code></li>\n</ul>\n<blockquote>\n<p>回收内存的源码实现，请关注下面方法的不同实现</p>\n<p><code>protected abstract void deallocate()</code></p>\n</blockquote>\n<p>Netty 这里采用了<code>引用计数法</code>来控制回收内存，每个 <code>ByteBuf</code>都实现了 <code>ReferenceCounted</code> 接口</p>\n<ul>\n<li>每个 <code>ByteBuf</code> 对象的初始计数为 1</li>\n<li>调用 <code>release</code> 方法计数<code>减 1</code>，如果计数为 <code>0</code>，<code>ByteBuf 内存被回收</code></li>\n<li>调用 <code>retain</code> 方法计数<code>加 1</code>，表示调用者没用完之前，其它 <code>handler</code> 即使调用了 <code>release</code> 也不会造成回收</li>\n<li>当计数为 <code>0</code> 时，底层内存会被回收，这时即使 <code>ByteBuf</code> 对象还在，其<code>各个方法均无法正常使用</code></li>\n</ul>\n<blockquote>\n<p>谁来负责 <code>release</code> 呢？</p>\n</blockquote>\n<p>基本规则是，<strong><code>谁是最后Bytebuf的使用者，谁负责 release</code></strong>，详细分析如下</p>\n<ul>\n<li><p>起点，对于 NIO 实现来讲，在<code>io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read</code>方法中首次创建 <code>ByteBuf</code> 放入 <code>pipeline</code>（line 163 pipeline.fireChannelRead(byteBuf)）</p>\n</li>\n<li><p>入站 ByteBuf 处理原则</p>\n<ul>\n<li><p>对原始 <code>ByteBuf</code> 不做处理，调用<code>ctx.fireChannelRead(msg)</code>向后传递，这时无须 <code>release</code></p>\n</li>\n<li><p>将原始 <code>ByteBuf</code> 转换为其它类型的<code>Java 对象</code>，这时 <code>ByteBuf</code> 就没用了，必须 <code>release</code></p>\n</li>\n<li><p>如果不调用<code>ctx.fireChannelRead(msg)</code>向后传递，那么也必须 <code>release</code></p>\n</li>\n<li><p>注意各种异常，如果 <code>ByteBuf</code> 没有成功传递到下一个 <code>ChannelHandler</code>，必须 <code>release</code></p>\n</li>\n<li><p>假设消息<code>一直向后传</code>，那么 <code>TailContext</code> 会负责<code>释放未处理消息</code>（原始的 <code>ByteBuf</code>）</p>\n<blockquote>\n<p>源码见下</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>出站 <code>ByteBuf</code> 处理原则</p>\n<ul>\n<li>出站消息最终都会转为 <code>ByteBuf</code> 输出，一直向前传，由 <code>HeadContext</code>    <code>flush</code> 后 <code>release</code></li>\n</ul>\n</li>\n<li><p>异常处理原则</p>\n<ul>\n<li>有时候不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以循环调用 release 直到返回 true</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306172239597.png\" alt=\"image-20230617223943504\"></p>\n<blockquote>\n<p> <code>TailContext</code> 会负责<code>释放未处理消息</code>的源码</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// io.netty.channel.DefaultChannelPipeline#onUnhandledInboundMessage(java.lang.Object)</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onUnhandledInboundMessage</span><span class=\"params\">(Object msg)</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">     logger.debug(</span><br><span class=\"line\">         <span class=\"string\">&quot;Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. &quot;</span> +</span><br><span class=\"line\">         <span class=\"string\">&quot;Please check your pipeline configuration.&quot;</span>, msg);</span><br><span class=\"line\"> &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">     ReferenceCountUtil.release(msg);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> <code>具体代码</code></p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// io.netty.util.ReferenceCountUtil#release(java.lang.Object)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">release</span><span class=\"params\">(Object msg)</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (msg <span class=\"keyword\">instanceof</span> ReferenceCounted) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> ((ReferenceCounted) msg).release();</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> <code>Head&lt;详见源码分析&gt;</code></p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">write</span><span class=\"params\">(Object msg, ChannelPromise promise)</span> &#123;</span><br><span class=\"line\">         assertEventLoop(); \t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"type\">ChannelOutboundBuffer</span> <span class=\"variable\">outboundBuffer</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.outboundBuffer;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (outboundBuffer == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">             <span class=\"comment\">// If the outboundBuffer is null we know the channel was closed and so</span></span><br><span class=\"line\">             <span class=\"comment\">// need to fail the future right away. If it is not null the handling of the rest</span></span><br><span class=\"line\">             <span class=\"comment\">// will be done in flush0()</span></span><br><span class=\"line\">             <span class=\"comment\">// See https://github.com/netty/netty/issues/2362</span></span><br><span class=\"line\">             safeSetFailure(promise, newClosedChannelException(initialCloseCause));</span><br><span class=\"line\">             <span class=\"comment\">// release message now to prevent resource-leak</span></span><br><span class=\"line\">             ReferenceCountUtil.release(msg);</span><br><span class=\"line\">             <span class=\"keyword\">return</span>;</span><br><span class=\"line\">         &#125;</span><br></pre></td></tr></table></figure>\n<p>slice</p>\n</blockquote>\n<p>【零拷贝】的体现之一，对原始 <code>ByteBuf</code> 进行<code>切片成多个 ByteBuf</code>，切片后的 <code>ByteBuf</code> 并没有发生<code>内存复制</code>，还是使用<code>原始 ByteBuf</code>的内存，切片后的 <code>ByteBuf</code> 维护独立的 <code>read，write 指针</code></p>\n<font color=\"red\">注意点：</font>\n\n<ol>\n<li><p>切片的 ByteBuf 将<code>已限制最大容量</code>，不得追加，就是内存已经满了之后就不能在向<code>ByteBuf</code> 中写数据了 ，否则会有异常<code>java.lang.IndexOutOfBoundsException:</code></p>\n</li>\n<li><p><code>ByteBuf</code> 和 <code>slice</code> 分别维护自己独立的<code>read，write</code> 指针</p>\n</li>\n<li>对 <code>ByteBuf release</code>【引用计数<code>-1</code>】操作之后，不得使用 <code>slice</code>切片的数据，除非 先使用 <code>retain</code>【引用计数+1】,否则会出现异常<code>io.netty.util.IllegalReferenceCountException: refCnt: 0</code></li>\n<li><p>正确用法：对单个切片进行 retain 和 release 成对处理，不会乱</p>\n</li>\n<li><p>无论 对 <code>原buf</code> 还是 <code>slice</code> 得到的 <code>ByteBuf</code> <code>引用计数</code> 都是一样的，都是对<code>物理内存</code>进行<code>引用计数</code></p>\n</li>\n<li><p>修改 <code>slice</code>  的 某个字节 将看到   原始<code>ByteBuf</code>值也被修改了</p>\n</li>\n</ol>\n<p>切片函数：</p>\n<ul>\n<li><code>无参 slice</code>是从原始 <code>ByteBuf</code> 的<code>read index</code>到<code>write index</code>之间的内容进行切片，切片后的 <code>max capacity</code>被固定为这个区间的大小，因此<code>不能追加 write</code></li>\n<li><p>之后对于原始数据的读写都不会对切片<code>slice</code>的数据产生影响，因为<code>slice</code>有独立的读写指针</p>\n</li>\n<li><p>但是如果 <code>slice</code> 的内容发生了更改,原始 ByteBuf 也会受影响，因为底层都是同一块内存</p>\n</li>\n</ul>\n<blockquote>\n<p>duplicate</p>\n</blockquote>\n<p>【零拷贝】的体现之一，就好比截取了原始 ByteBuf 所有内容，并且没有 max capacity 的限制，也是与原始 ByteBuf 使用同一块底层内存，只是读写指针是独立的</p>\n<blockquote>\n<p>copy</p>\n</blockquote>\n<p>会将底层内存数据进行<code>深拷贝</code>，因此无论读写，都与原始 ByteBuf 无关</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">ByteBuf</span> <span class=\"variable\">buf1</span> <span class=\"operator\">=</span> ByteBufAllocator.DEFAULT.buffer();</span><br><span class=\"line\">buf1.writeBytes(<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;);</span><br><span class=\"line\"><span class=\"comment\">//copy buf1</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">ByteBuf</span> <span class=\"variable\">bufferCopy</span> <span class=\"operator\">=</span> buf1.copy();</span><br><span class=\"line\"><span class=\"comment\">// 修改 buf1</span></span><br><span class=\"line\">buf1.setByte(<span class=\"number\">0</span>,<span class=\"number\">9</span>);</span><br><span class=\"line\">log(bufferCopy);  <span class=\"comment\">// 不会因为 buf1 的修改 而改变</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>CompositeByteBuf</p>\n</blockquote>\n<p>【零拷贝】的体现之一，可以将多个 ByteBuf <code>合并</code>为一个逻辑上的 ByteBuf，避免拷贝</p>\n<ul>\n<li><p>实现方式</p>\n<ul>\n<li><p>方式一：   不太好，会  进行 数据的内存复制操作</p>\n<p><code>ByteBuf buf3 = ByteBufAllocator.DEFAULT .buffer(buf1.readableBytes()+buf2.readableBytes());\nbuf3.writeBytes(buf1);\nbuf3.writeBytes(buf2);</code></p>\n<blockquote>\n<p> <code>writeBytes 链式赋值拷贝</code></p>\n<p> <code>readableBytes 返回可读取的字节数</code></p>\n</blockquote>\n</li>\n<li><p>方式二：</p>\n<p><code>CompositeByteBuf buf3 = ByteBufAllocator.DEFAULT.compositeBuffer();\n// true 表示增加新的 ByteBuf 自动递增 write index, 否则 write index 会始终为 0\nbuf3.addComponents(true, buf1, buf2);</code></p>\n<ul>\n<li><code>CompositeByteBuf</code> 是一个组合的 <code>ByteBuf</code>，它内部维护了一个 <code>Component</code> 数组，每个 <code>Component</code> 管理一个 <code>ByteBuf</code>，记录了这个 <code>ByteBuf</code> 相对于整体偏移量等信息，代表着整体中某一段的数据。<ul>\n<li><code>优点</code>，对外是一个虚拟视图，组合这些 ByteBuf 不会产生内存复制</li>\n<li><code>缺点</code>，复杂了很多，多次操作会带来性能的损耗</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//composite 【零拷贝-false】</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">CompositeByteBuf</span> <span class=\"variable\">compositeByteBuf1</span> <span class=\"operator\">=</span> ByteBufAllocator.DEFAULT.compositeBuffer();</span><br><span class=\"line\">compositeByteBuf1.addComponents(buf1, buf2);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//composite 【零拷贝-true】  布尔参数 true : 表示自动增长写指针</span></span><br><span class=\"line\"><span class=\"comment\">//此时: 修改源buf 还是会影响到 composite 之后的 ByteBuf 所得到的数据</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">CompositeByteBuf</span> <span class=\"variable\">compositeByteBuf1</span> <span class=\"operator\">=</span> ByteBufAllocator.DEFAULT.compositeBuffer();</span><br><span class=\"line\">compositeByteBuf1.addComponents(<span class=\"literal\">true</span>,buf1, buf2);</span><br><span class=\"line\"><span class=\"comment\">//这里的 true 参数表示，当真正使用 CompositeByteBuf 时，是否需要释放被合并的 ByteBuf 对象。</span></span><br><span class=\"line\"><span class=\"comment\">//如果将该参数设置为 true，表示合并后的 CompositeByteBuf 使用完毕后会   自动释放   其中的 ByteBuf 对象。</span></span><br><span class=\"line\"><span class=\"comment\">//而如果将该参数设置为 false（默认值），则需要   手动释放     CompositeByteBuf 和其中的 ByteBuf 对象。</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//值得注意的是</span></span><br><span class=\"line\"><span class=\"comment\">//使用 addComponents() 方法添加 ByteBuf 对象时，</span></span><br><span class=\"line\"><span class=\"comment\">//如果传入的第一个参数为 true，则需要确保所有的 ByteBuf 对象都是从事先分配的 ByteBufAllocator 中分配的，否则有可能导致内存泄漏或崩溃等问题</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Unpooled</p>\n</blockquote>\n<p><code>Unpooled</code> 是一个工具类，提供了<code>非池化的 ByteBuf 创建、组合、复制等操作</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 当包装 ByteBuf 个数超过一个时, 底层使用了 CompositeByteBuf</span></span><br><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">buf3</span> <span class=\"operator\">=</span> Unpooled.wrappedBuffer(buf1, buf2);</span><br><span class=\"line\">System.out.println(ByteBufUtil.prettyHexDump(buf3));</span><br><span class=\"line\"><span class=\"comment\">// 但是一旦改变 buf1 就会发现 引用地址的 buf3 数据改了</span></span><br><span class=\"line\">buf1.setByte(<span class=\"number\">0</span>,<span class=\"number\">16</span>); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//也可以用来包装普通字节数组，底层也不会有拷贝操作</span></span><br><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">buf4</span> <span class=\"operator\">=</span> Unpooled.wrappedBuffer(<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;, <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">ByteBuf</span> <span class=\"variable\">buf1</span> <span class=\"operator\">=</span> Unpooled.buffer(<span class=\"number\">5</span>);  <span class=\"comment\">// [--- 创建非池化 + 堆内存的 ByteBuf ---]</span></span><br><span class=\"line\">buf1.writeBytes(<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;);</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">ByteBuf</span> <span class=\"variable\">buf2</span> <span class=\"operator\">=</span> ByteBufAllocator.DEFAULT.buffer(<span class=\"number\">5</span>);</span><br><span class=\"line\">buf2.writeBytes(<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(buf1.getClass()); <span class=\"comment\">// : class io.netty.buffer.UnpooledByteBufAllocator$InstrumentedUnpooledUnsafeHeapByteBuf   非池化堆内存</span></span><br><span class=\"line\">System.out.println(buf2.getClass()); <span class=\"comment\">// : class io.netty.buffer.PooledUnsafeDirectByteBuf     池化直接内存</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 非池化堆内存 进行零拷贝</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">ByteBuf</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> buf1.slice(<span class=\"number\">0</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">System.out.println(s.getClass()); <span class=\"comment\">//  class io.netty.buffer.UnpooledSlicedByteBuf</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"ByteBuf-优势\"><a href=\"#ByteBuf-优势\" class=\"headerlink\" title=\"ByteBuf 优势\"></a>ByteBuf 优势</h4><ul>\n<li>池化 - 可以重用池中 <code>ByteBuf</code> 实例，更节约内存，减少内存溢出的可能</li>\n<li><code>读写指针分离</code>，不需要像 <code>ByteBuffer</code> 一样需要进行<code>切换读写模式</code></li>\n<li>可以<code>自动扩容</code></li>\n<li><code>支持链式调用</code>，使用更流畅</li>\n<li>很多地方体现<code>零拷贝</code>，例如 slice、duplicate、CompositeByteBuf</li>\n</ul>\n<h3 id=\"双向通信\"><a href=\"#双向通信\" class=\"headerlink\" title=\"双向通信\"></a>双向通信</h3><p>注意</p>\n<ul>\n<li><p>不推荐使用 <code>ByteBufAllocator.DEFAULT.buffer(5);</code>  创建<code>ByteBuf</code></p>\n</li>\n<li><p>推荐使用 <code>ctx.alloc().buffer();</code>  创建<code>ByteBuf</code></p>\n</li>\n</ul>\n<blockquote>\n<p>回声代码服务端</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrap</span>()</span><br><span class=\"line\">    .group(<span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>())</span><br><span class=\"line\">    .channel(NioServerSocketChannel.class)</span><br><span class=\"line\">    .childHandler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(NioSocketChannel ch)</span> &#123;</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class=\"line\">                    <span class=\"type\">ByteBuf</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> (ByteBuf) msg;</span><br><span class=\"line\">                    System.out.println(buffer.toString(Charset.defaultCharset()));</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 建议使用 ctx.alloc() 创建 ByteBuf</span></span><br><span class=\"line\">                    <span class=\"type\">ByteBuf</span> <span class=\"variable\">response</span> <span class=\"operator\">=</span> ctx.alloc().buffer();</span><br><span class=\"line\">                    response.writeBytes(buffer);</span><br><span class=\"line\">                    ctx.writeAndFlush(response);</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 思考：需要释放 buffer 吗</span></span><br><span class=\"line\">                    <span class=\"comment\">// 思考：需要释放 response 吗</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;).bind(<span class=\"number\">8080</span>);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>回声代码客户端</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">group</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\"><span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>()</span><br><span class=\"line\">    .group(group)</span><br><span class=\"line\">    .channel(NioSocketChannel.class)</span><br><span class=\"line\">    .handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(NioSocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">StringEncoder</span>());</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class=\"line\">                    <span class=\"type\">ByteBuf</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> (ByteBuf) msg;</span><br><span class=\"line\">                    System.out.println(buffer.toString(Charset.defaultCharset()));</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 思考：需要释放 buffer 吗</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;).connect(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">8080</span>).sync().channel();</span><br><span class=\"line\"></span><br><span class=\"line\">channel.closeFuture().addListener(future -&gt; &#123;</span><br><span class=\"line\">    group.shutdownGracefully();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"type\">Scanner</span> <span class=\"variable\">scanner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">line</span> <span class=\"operator\">=</span> scanner.nextLine();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"string\">&quot;q&quot;</span>.equals(line)) &#123;</span><br><span class=\"line\">            channel.close();</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        channel.writeAndFlush(line);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;).start();</span><br></pre></td></tr></table></figure>\n<p>误区❌</p>\n<blockquote>\n<p>只有在 <code>netty，nio</code>这样的<code>多路复用 IO 模型</code>时，<code>读写才不会相互阻塞</code>，才可以实现高效的双向通信</p>\n</blockquote>\n<p>正解✅</p>\n<blockquote>\n<p><code>Java Socket</code> 是<code>全双工</code>的：在任意时刻，线路上存在<code>A 到 B</code> 和 <code>B 到 A</code> 的双向信号传输。即使是阻塞 IO，读和写是可以同时进行的，只要分别采用读线程和写线程即可，读不会阻塞写、写也不会阻塞读</p>\n</blockquote>\n<h2 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h2><h3 id=\"黏包半包\"><a href=\"#黏包半包\" class=\"headerlink\" title=\"黏包半包\"></a>黏包半包</h3><ul>\n<li>复现半包现象的时候： 使用 <code>serverBootstrap.option(ChannelOption.SO_RCVBUF, 10)</code>实惠影响底层接收缓冲区（即滑动窗口）的大小的，仅决定了 <code>netty</code> 读取的<code>最小单位</code>，<code>netty</code> 实际<code>每次读取的一般是它的整数倍</code></li>\n</ul>\n<h4 id=\"现象复现\"><a href=\"#现象复现\" class=\"headerlink\" title=\"现象复现\"></a>现象复现</h4><h5 id=\"粘包\"><a href=\"#粘包\" class=\"headerlink\" title=\"粘包\"></a>粘包</h5><blockquote>\n<p>服务器代码</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HelloWorldServer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> LoggerFactory.getLogger(HelloWorldServer.class);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">start</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">boss</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">worker</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">ServerBootstrap</span> <span class=\"variable\">serverBootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrap</span>();</span><br><span class=\"line\">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class=\"line\">            serverBootstrap.group(boss, worker);</span><br><span class=\"line\">            serverBootstrap.option(ChannelOption.SO_RCVBUF, <span class=\"number\">10</span>);</span><br><span class=\"line\">            serverBootstrap.childHandler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> &#123;</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                            <span class=\"comment\">// 连接建立时会执行该方法</span></span><br><span class=\"line\">                            log.debug(<span class=\"string\">&quot;connected &#123;&#125;&quot;</span>, ctx.channel());</span><br><span class=\"line\">                            <span class=\"built_in\">super</span>.channelActive(ctx);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelInactive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                            <span class=\"comment\">// 连接断开时会执行该方法</span></span><br><span class=\"line\">                            log.debug(<span class=\"string\">&quot;disconnect &#123;&#125;&quot;</span>, ctx.channel());</span><br><span class=\"line\">                            <span class=\"built_in\">super</span>.channelInactive(ctx);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"type\">ChannelFuture</span> <span class=\"variable\">channelFuture</span> <span class=\"operator\">=</span> serverBootstrap.bind(<span class=\"number\">8080</span>);</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;&#123;&#125; binding...&quot;</span>, channelFuture.channel());</span><br><span class=\"line\">            channelFuture.sync();</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;&#123;&#125; bound...&quot;</span>, channelFuture.channel());</span><br><span class=\"line\">            <span class=\"comment\">// 关闭channel</span></span><br><span class=\"line\">            channelFuture.channel().closeFuture().sync();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;server error&quot;</span>, e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;stopped&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">StudyServer</span>().start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p> 客户端代码</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HelloWorldClient</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">worker</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Bootstrap</span> <span class=\"variable\">bootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>();</span><br><span class=\"line\">            bootstrap.channel(NioSocketChannel.class);</span><br><span class=\"line\">            bootstrap.group(worker);</span><br><span class=\"line\">            bootstrap.handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                    log.debug(<span class=\"string\">&quot;connected...&quot;</span>);</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                            log.debug(<span class=\"string\">&quot;sending...&quot;</span>);</span><br><span class=\"line\">                            <span class=\"comment\">// 每次发送16个字节的数据，共发送10次</span></span><br><span class=\"line\">                            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                                <span class=\"type\">ByteBuf</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ctx.alloc().buffer(<span class=\"number\">16</span>);</span><br><span class=\"line\">                                buffer.writeBytes(<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>, <span class=\"number\">12</span>, <span class=\"number\">13</span>, <span class=\"number\">14</span>, <span class=\"number\">15</span>&#125;);</span><br><span class=\"line\">                                ctx.writeAndFlush(buffer);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"type\">ChannelFuture</span> <span class=\"variable\">channelFuture</span> <span class=\"operator\">=</span> bootstrap.connect(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">8080</span>).sync();</span><br><span class=\"line\">            channelFuture.channel().closeFuture().sync();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;client error&quot;</span>, e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            worker.shutdownGracefully();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"半包\"><a href=\"#半包\" class=\"headerlink\" title=\"半包\"></a>半包</h5><blockquote>\n<p>对<code>服务器代码</code>进行修改即可,添加下面这句</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 调整channel的容量</span></span><br><span class=\"line\">serverBootstrap.option(ChannelOption.SO_RCVBUF, <span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure>\n<h4 id=\"现象分析\"><a href=\"#现象分析\" class=\"headerlink\" title=\"现象分析\"></a>现象分析</h4><ul>\n<li><p>粘包：</p>\n<ul>\n<li><p>现象： 发送 abc def，接收 abcdef</p>\n</li>\n<li><p>原因</p>\n<ul>\n<li><p>应用层：接收方 <code>ByteBuf</code> 设置太大（Netty 默认 1024）</p>\n</li>\n<li><p>滑动窗口：<code>假设</code>发送方 256 bytes 表示一个完整报文，但由于<code>接收方处理不及时</code>且<code>窗口大小足够大</code>，这 256 bytes 字节<code>就会缓冲在接收方的滑动窗口中</code>，当滑动窗口中<code>缓冲了多个报文就会粘包</code></p>\n</li>\n<li><p>Nagle 算法：会造成粘包</p>\n<blockquote>\n<p><code>Nagle 算法</code></p>\n<p>引入的目的是：<code>通过将多个小数据包</code>合并成<code>较大的数据包</code>来减少网络上的流量和提高网络传输效率</p>\n<p>实现机制: 在发送缓冲区中积累尽可能多的数据，直到达到<code>下列条件之一</code>才将<code>数据发送出去</code>：</p>\n<ul>\n<li><p>缓冲区中的数据量已经达到了MSS（最大报文段大小）</p>\n</li>\n<li><p>之前发送出去的广播、多播或已确认的数据块的确认已经全部收到</p>\n</li>\n<li>应用程序主动调用<code>TCP_NODELAY</code>选项禁止Nagle算法</li>\n</ul>\n<p>Nagle算法采用这种方式发送数据的<code>好处</code>在于</p>\n<ul>\n<li>它可以充分利用网络带宽，并减少网络拥塞的发生</li>\n</ul>\n<p>问题是：</p>\n<ul>\n<li>但是，如果应用程序发送的数据包含大量较小的数据块，则Nagle算法会将这些数据块合并成一个大的数据包后再传输，这样会导致数据<code>传输的时延增加</code>，<code>从而降低实时性</code>。此时，应该使用<code>TCP_NODELAY</code>选项进行关闭</li>\n</ul>\n<p>注意：</p>\n<ul>\n<li><code>Nagle</code>算法并不是完全适用于所有情况</li>\n<li>对于某些<code>交互性强</code>的应用程序，例如远程终端、游戏等，需要实时性进行控制，此时<code>禁用Nagle算法是必要</code>的</li>\n<li>在数据传输量<code>非常巨大</code>的情况下，Nagle算法可能会降低网络传输的效率，因此也需要<code>根据具体的应用场景进行针对性的调整</code></li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>半包</p>\n<ul>\n<li><p>现象：发送 <code>abcdef</code>，接收 <code>abc</code>  + <code>def</code></p>\n</li>\n<li><p>原因</p>\n<ul>\n<li>应用层：接收方 ByteBuf <code>小于</code>实际发送数据量</li>\n<li>滑动窗口：<code>假设</code>接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时放不下了，只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包</li>\n<li><code>MSS 限制</code>：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包</li>\n</ul>\n<blockquote>\n<ul>\n<li><p><code>MSS（Maximum Segment Size）限制</code>  是指 <code>TCP</code>协议中的窗口大小，它表示在 TCP 协议中，每个数据包可以传输的最大有效载荷大小</p>\n</li>\n<li><p><code>MSS</code> 取决于网络链路的 <code>MTU（Maximum Transmission Unit，最大传输单元）</code>和<code>TCP 的头部大小</code>。例如，在一个 MTU 为 1500 字节的以太网中，TCP 每个数据包的头部大小为 20 字节，此时 MSS 的值就为 1480 字节。</p>\n</li>\n<li><p><code>MSS 主要作用是</code>用于控制 <code>TCP</code> 流量，确保在网络中不会出现过大的数据包，从而减少拥塞和丢包等问题，提高数据传输的效率和稳定性。<code>MSS</code> 的大小可以通过协商双方的 <code>TCP</code> 标识字段进行约定，如果两端都支持 <code>Path MTU Discovery（PMTUD）</code>协议，则可以通过发送 <code>ICMP</code>包来自适应地调整 <code>MSS</code> 的大小。</p>\n</li>\n<li><p>一般来说，在高速网络中可以使用较大的 <code>MSS</code> 值，在低速网络或者网络质量较差的情况下，可以适当地减小 <code>MSS</code> 值</p>\n</li>\n<li><code>MSS</code> 的默认值可以在操作系统或者网络设备中进行配置，以满足具体的应用场景需要。</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<p>发生的本质原因是：</p>\n<ul>\n<li>TCP 是<code>流式协议，消息无边界</code></li>\n</ul>\n<blockquote>\n<p>滑动窗口的介绍：</p>\n</blockquote>\n<ul>\n<li>TCP 以一个<code>段（segment）</code>为单位，每发送一个段就需要进行一次确认应答（ack）处理，但如果这么做，缺点是包的往返时间越长性能就越差</li>\n</ul>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306180041356.png\" alt=\"image-20230618004100237\" style=\"zoom:33%;\"></p>\n<ul>\n<li>引入了窗口概念，<code>窗口大小</code>即<code>决定了无需等待应答而可以继续发送的数据最大值</code></li>\n</ul>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306180042940.png\" alt=\"image-20230618004230838\" style=\"zoom:33%;\"></p>\n<ul>\n<li><p>窗口实际就起到一个<code>缓冲区</code>的作用，同时也能起到<code>流量控制</code>的作用</p>\n<ul>\n<li><p>图中深色的部分即要发送的数据，高亮的部分即窗口</p>\n</li>\n<li><p>窗口内的数据才允许被发送，当<code>应答</code>未到达前，窗口<code>必须停止滑动</code></p>\n</li>\n<li><p>如果 1001~2000 这个段的数据 ack 回来了，窗口就可以向前滑动</p>\n</li>\n<li><p>接收方也会维护一个窗口，只有落在窗口内的数据才能允许接收</p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><ul>\n<li>短链接，发一个包建立一次连接，这样连接建立到连接断开之间就是消息的边界，<code>缺点</code>效率太低</li>\n<li>每一条消息采用固定长度，<code>缺点</code>浪费空间</li>\n<li>每一条消息采用分隔符，例如<code>\\n</code>，<code>缺点</code>需要转义</li>\n<li>每一条消息分为 <code>head</code> 和 <code>body</code>，<code>head</code> 中包含 <code>body</code> 的长度</li>\n</ul>\n<blockquote>\n<p>短链接 —— 可以去解决<code>粘包</code>问题,但是难以解决<code>半包</code>问题,因为接收方的缓冲区大小是有限的</p>\n</blockquote>\n<p><strong>客户端</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 【使 每发完一次消息 就关闭一次 ，这样连接建立到连接断开之间就是消息的边界】</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;sending...&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">ByteBuf</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ctx.alloc().buffer(<span class=\"number\">16</span>);</span><br><span class=\"line\">    buffer.writeBytes(<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>, <span class=\"number\">12</span>, <span class=\"number\">13</span>, <span class=\"number\">14</span>, <span class=\"number\">15</span>&#125;);</span><br><span class=\"line\">    ctx.writeAndFlush(buffer);</span><br><span class=\"line\">    <span class=\"comment\">// 使用短链接，每次发送完毕后就断开连接</span></span><br><span class=\"line\">    ctx.channel().close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>服务端</strong></p>\n<p>不再指定缓冲区大小： 即有<code>serverBootstrap.option(ChannelOption.SO_RCVBUF, 10);</code>的话就将其注释掉</p>\n<blockquote>\n<p>固定长度:<code>定长解码器</code></p>\n<ul>\n<li><code>缺点</code>是，数据包的大小不好把握<ul>\n<li>长度定的太大，浪费</li>\n<li>长度定的太小，对某些数据包又显得不够</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li>让所有数据包长度固定（假设长度为 8 字节）</li>\n</ul>\n<p><strong>服务器端</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">FixedLengthFrameDecoder</span>(<span class=\"number\">8</span>));     <span class=\"comment\">//可以查看 源码： FixedLengthFrameDecoder</span></span><br></pre></td></tr></table></figure>\n<p><strong>客户端</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 约定最大长度为16</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">maxLength</span> <span class=\"operator\">=</span> <span class=\"number\">16</span>;</span><br><span class=\"line\"><span class=\"comment\">// 被发送的数据</span></span><br><span class=\"line\"><span class=\"type\">char</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 向服务器发送10个报文</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"type\">ByteBuf</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ctx.alloc().buffer(maxLength);</span><br><span class=\"line\">    <span class=\"comment\">// 定长byte数组，未使用部分会以0进行填充</span></span><br><span class=\"line\">    <span class=\"type\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[maxLength];</span><br><span class=\"line\">    <span class=\"comment\">// 生成长度为0~15的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; (<span class=\"type\">int</span>)(Math.random()*(maxLength-<span class=\"number\">1</span>)); j++) &#123;</span><br><span class=\"line\">        bytes[j] = (<span class=\"type\">byte</span>) c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    buffer.writeBytes(bytes);</span><br><span class=\"line\">    c++;</span><br><span class=\"line\">    <span class=\"comment\">// 将数据发送给服务器</span></span><br><span class=\"line\">    ctx.writeAndFlush(buffer);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p> 固定分隔符</p>\n<ul>\n<li>可以通过<code>LineBasedFrameDecoder(int maxLength)</code>来拆分以<strong>换行符(\\n)</strong>为分隔符的数据，也可以通过<code>DelimiterBasedFrameDecoder(int maxFrameLength, ByteBuf... delimiters)</code>来<strong>指定通过什么分隔符来拆分数据（可以传入多个分隔符）</strong></li>\n<li><p>两种解码器<strong>都需要传入数据的最大长度</strong>，若超出最大长度，会抛出<code>TooLongFrameException</code>异常</p>\n</li>\n<li><p>缺点，处理字符数据比较合适，但如果内容本身包含了分隔符（字节数据常常会有此情况），那么就会解析错误</p>\n</li>\n</ul>\n</blockquote>\n<p><strong>服务端</strong></p>\n<ul>\n<li>默认以<code>\\n</code> 或<code>\\r\\n</code> 作为分隔符，如果超出指定长度仍未出现分隔符，则抛出异常</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">LineBasedFrameDecoder</span>(<span class=\"number\">1024</span>)); <span class=\"comment\">// 超出1024报错</span></span><br></pre></td></tr></table></figure>\n<p><strong>客户端</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> StringBuilder <span class=\"title function_\">getStr</span><span class=\"params\">(<span class=\"type\">char</span> c, <span class=\"type\">int</span> len)</span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">final</span> <span class=\"type\">StringBuilder</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>(len + <span class=\"number\">2</span>);</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">           s.append(c);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       s.append(<span class=\"string\">&#x27;\\n&#x27;</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">         log.debug(<span class=\"string\">&quot;sending...&quot;</span>);</span><br><span class=\"line\">         <span class=\"keyword\">final</span> <span class=\"type\">ByteBuf</span> <span class=\"variable\">buf</span> <span class=\"operator\">=</span> ctx.alloc().buffer();</span><br><span class=\"line\">         <span class=\"keyword\">final</span> <span class=\"type\">Random</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Random</span>();</span><br><span class=\"line\">         <span class=\"type\">char</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">         <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">final</span> <span class=\"type\">StringBuilder</span> <span class=\"variable\">tmpStr</span> <span class=\"operator\">=</span> getStr(c, r.nextInt(<span class=\"number\">256</span>) + <span class=\"number\">1</span>); <span class=\"comment\">// 随机生成 1-257 长度的 字符串</span></span><br><span class=\"line\">         c++;</span><br><span class=\"line\">          buf.writeBytes(tmpStr.toString().getBytes());</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       ctx.writeAndFlush(buf);</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p> 自定义定界符 帧解码器</p>\n</blockquote>\n<p><strong>服务端</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将分隔符放入ByteBuf中</span></span><br><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">bufSet</span> <span class=\"operator\">=</span> ch.alloc().buffer().writeBytes(<span class=\"string\">&quot;\\\\c&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class=\"line\"><span class=\"comment\">// 通过行解码器对粘包数据进行拆分，以 \\c 为分隔符</span></span><br><span class=\"line\">ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">DelimiterBasedFrameDecoder</span>(<span class=\"number\">64</span>, ch.alloc().buffer().writeBytes(bufSet)));</span><br><span class=\"line\">ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG));</span><br></pre></td></tr></table></figure>\n<p><strong>客户端</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 数据以 \\c 结尾</span></span><br><span class=\"line\">sb.append(<span class=\"string\">&quot;\\\\c&quot;</span>);</span><br><span class=\"line\">buffer.writeBytes(sb.toString().getBytes(StandardCharsets.UTF_8));</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>预设长度:</p>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306180425682.png\" alt=\"image-20230618042512634\" style=\"zoom:33%;\"></p>\n<p><code>源码： LengthFieldBasedFrameDecoder.java</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LengthFieldBasedFrameDecoder(</span><br><span class=\"line\">        <span class=\"type\">int</span> maxFrameLength,     <span class=\"comment\">//限制最大长度，超过他 没找到分隔符报错</span></span><br><span class=\"line\">        <span class=\"type\">int</span> lengthFieldOffset,  <span class=\"comment\">//长度字段 的 偏移量</span></span><br><span class=\"line\">        <span class=\"type\">int</span> lengthFieldLength,  <span class=\"comment\">//长度字段 本身长度</span></span><br><span class=\"line\">        <span class=\"type\">int</span> lengthAdjustment,   <span class=\"comment\">//长度字段 为基准，跳过几个字节 才是内容</span></span><br><span class=\"line\">        <span class=\"type\">int</span> initialBytesToStrip <span class=\"comment\">//从头剥离 几个字节，解析后将不出现</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>服务端</strong></p>\n<ul>\n<li>在发送消息前，先约定用<code>定长字节</code>表示接下来数据的长度</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 最大长度，长度偏移，长度占用字节，长度调整，剥离字节数</span></span><br><span class=\"line\">ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">LengthFieldBasedFrameDecoder</span>(<span class=\"number\">1024</span>,<span class=\"number\">0</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">7</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">send</span><span class=\"params\">(ByteBuf buf, String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">byte</span>[] bytes = s.getBytes();        <span class=\"comment\">// 实际内容</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> bytes.length;    <span class=\"comment\">// 实际内容长度</span></span><br><span class=\"line\">        <span class=\"comment\">// 指定长度 和 存储模式为： 大端模式  【writeInt本身长度 4字节】 【服务端 lengthFieldLength设为4】</span></span><br><span class=\"line\">        buf.writeInt(length);</span><br><span class=\"line\">        <span class=\"comment\">// 版本号 100，  【服务端 lengthAdjustment 设为 3】 【注意：如果设0 会报错(除非主体内容最后四位都是0)】</span></span><br><span class=\"line\">        buf.writeBytes(<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"string\">&#x27;1&#x27;</span>,<span class=\"string\">&#x27;0&#x27;</span>,<span class=\"string\">&#x27;0&#x27;</span>&#125;);</span><br><span class=\"line\">        buf.writeBytes(bytes);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>完整代码</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestLengthFieldDecoder</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*###############################*/</span></span><br><span class=\"line\">        <span class=\"comment\">/*###       当成 服务器端       ###*/</span></span><br><span class=\"line\">        <span class=\"comment\">/*###############################*/</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">EmbeddedChannel</span> <span class=\"variable\">ch</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">EmbeddedChannel</span>(</span><br><span class=\"line\">                <span class=\"comment\">// 注意：解码器 放debug上面</span></span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">LengthFieldBasedFrameDecoder</span>(</span><br><span class=\"line\">                        <span class=\"number\">1024</span>, <span class=\"number\">0</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG)</span><br><span class=\"line\">        );</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/*###############################*/</span></span><br><span class=\"line\">        <span class=\"comment\">/*###       当成 客户端        ###*/</span></span><br><span class=\"line\">        <span class=\"comment\">/*###############################*/</span></span><br><span class=\"line\">        <span class=\"comment\">// 指定：长度字段-4字节；</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">ByteBuf</span> <span class=\"variable\">buf</span> <span class=\"operator\">=</span> ByteBufAllocator.DEFAULT.buffer();</span><br><span class=\"line\">        send(buf, <span class=\"string\">&quot;hello, world&quot;</span>);</span><br><span class=\"line\">        send(buf, <span class=\"string\">&quot;hi&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 将消息 写入 Channel</span></span><br><span class=\"line\">        ch.writeInbound(buf);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">send</span><span class=\"params\">(ByteBuf buf, String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">byte</span>[] bytes = s.getBytes();        <span class=\"comment\">// 实际内容</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> bytes.length;    <span class=\"comment\">// 实际内容长度</span></span><br><span class=\"line\">        <span class=\"comment\">// 指定长度 和 存储模式为： 大端模式  【writeInt本身长度 4字节】 【服务端 lengthFieldLength设为4】</span></span><br><span class=\"line\">        buf.writeInt(length);</span><br><span class=\"line\">        <span class=\"comment\">// 版本号 100，  【服务端 lengthAdjustment 设为 3】 【注意：如果设0 会报错(除非主体内容最后四位都是0)】</span></span><br><span class=\"line\">        buf.writeBytes(<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"string\">&#x27;1&#x27;</span>,<span class=\"string\">&#x27;0&#x27;</span>,<span class=\"string\">&#x27;0&#x27;</span>&#125;);</span><br><span class=\"line\">        buf.writeBytes(bytes);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"协议设计与解析\"><a href=\"#协议设计与解析\" class=\"headerlink\" title=\"协议设计与解析\"></a>协议设计与解析</h3><h4 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h4><ul>\n<li><p>重要性</p>\n<ul>\n<li><p><code>TCP/IP</code> 中消息传输基于流的方式，没有边界。</p>\n</li>\n<li><p>协议的<code>目的</code>就是划定消息的边界，制定通信双方要共同遵守的通信规则</p>\n</li>\n</ul>\n</li>\n<li><p>如何设计协议</p>\n<ul>\n<li><code>定长字节  表示内容长度   +   实际内容</code></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Redis协议\"><a href=\"#Redis协议\" class=\"headerlink\" title=\"Redis协议\"></a>Redis协议</h4><p>就是 向Redis服务器发送一条<code>set name Nyima</code>的指令，需要遵守协议符合一定的格式才可以</p>\n<h4 id=\"Http协议\"><a href=\"#Http协议\" class=\"headerlink\" title=\"Http协议\"></a>Http协议</h4><ul>\n<li><p>HTTP协议在请求行请求头中都有很多的内容，可以使用<code>HttpServerCodec</code>作为<strong>服务器端的解码器与编码器，来处理HTTP请求</strong></p>\n<ul>\n<li>代码中添加：<code>ch.pipeline().addLast(new HttpServerCodec());</code></li>\n</ul>\n</li>\n<li><p>服务器负责处理请求并响应浏览器。所以<strong>只需要处理HTTP请求</strong>即可</p>\n<ul>\n<li>代码中添加：<code>ch.pipeline().addLast(new SimpleChannelInboundHandler&lt;HttpRequest&gt;() //服务器只处理HTTPRequest</code></li>\n</ul>\n</li>\n<li><p>获得请求后，需要返回响应给浏览器。需要创建响应对象<code>DefaultFullHttpResponse</code>，设置HTTP版本号及状态码，为避免浏览器获得响应后，因为获得<code>CONTENT_LENGTH</code>而一直空转，需要添加<code>CONTENT_LENGTH</code>字段，表明响应体中数据的<code>具体长度</code></p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获得完整响应，设置版本号与状态码</span></span><br><span class=\"line\"><span class=\"type\">DefaultFullHttpResponse</span> <span class=\"variable\">response</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultFullHttpResponse</span>(msg.protocolVersion(), HttpResponseStatus.OK);</span><br><span class=\"line\"><span class=\"comment\">// 设置响应内容</span></span><br><span class=\"line\"><span class=\"type\">byte</span>[] bytes = <span class=\"string\">&quot;&lt;h1&gt;Hello, World!&lt;/h1&gt;&quot;</span>.getBytes(StandardCharsets.UTF_8);</span><br><span class=\"line\"><span class=\"comment\">// 设置响应体长度，避免浏览器一直接收响应内容</span></span><br><span class=\"line\">response.headers().setInt(CONTENT_LENGTH, bytes.length);</span><br><span class=\"line\"><span class=\"comment\">// 设置响应体</span></span><br><span class=\"line\">response.content().writeBytes(bytes);</span><br></pre></td></tr></table></figure>\n<h4 id=\"自定义协议\"><a href=\"#自定义协议\" class=\"headerlink\" title=\"自定义协议\"></a>自定义协议</h4><ul>\n<li>要素<ul>\n<li><code>魔数</code>，用来在第一时间判定是否是无效数据包</li>\n<li><code>版本号</code>，可以支持协议的升级</li>\n<li><code>序列化算法</code>，消息正文到底采用哪种序列化反序列化方式，可以由此扩展，例如：json、protobuf、hessian、jdk</li>\n<li><code>指令类型</code>，是登录、注册、单聊、群聊… 跟业务相关</li>\n<li><code>请求序号</code>，为了双工通信，提供异步能力</li>\n<li><code>正文长度</code></li>\n<li><code>消息正文</code></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"什么时候可以加-Sharable\"><a href=\"#什么时候可以加-Sharable\" class=\"headerlink\" title=\"什么时候可以加 @Sharable\"></a>什么时候可以加 @Sharable</h4><blockquote>\n<p>就是说什么时候应该让<code>handler</code>可以<code>共享使用</code></p>\n</blockquote>\n<ul>\n<li>当 <code>handler</code> 不保存状态时，就可以<code>安全地在多线程下被共享</code></li>\n<li>但要注意对于<code>编解码器类</code>，不能继承 <code>ByteToMessageCodec</code> 或 <code>CombinedChannelDuplexHandler</code> 父类，他们的构造方法对<code>@Sharable</code> 有限制</li>\n<li>如果能确保编解码器<code>不会保存状态</code>的时候，就可以继承 <code>MessageToMessageCodec</code> 父类</li>\n</ul>\n<blockquote>\n<p> 源码上中添加<code>@Sharable</code>  就是可以共享使用的，创建的时候只要创建一个实例就可以了</p>\n</blockquote>\n<h2 id=\"强化\"><a href=\"#强化\" class=\"headerlink\" title=\"强化\"></a>强化</h2><h3 id=\"聊天室\"><a href=\"#聊天室\" class=\"headerlink\" title=\"聊天室\"></a>聊天室</h3><h4 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h4><ul>\n<li><p>客户端</p>\n<ul>\n<li><font color=\"blue\">1.</font>将与业务无关的代码先准备好，并在<code>pipline</code>中加入三个 <code>handler</code>   ，分别是：<code>处理半包的，打印日志的，对发送的消息编解码的 handler</code></li>\n<li><font color=\"blue\">2.</font>加上处理器<code>ChannelInboundHandlerAdapter</code>  重写 <code>channelActive</code> &lt;关心连接建立事件&gt;，并在该方法中新启一个线程，接受用户的登录消息(密码，用户名)，并将输入构造成一个<code>LoginRequestMessage 的消息对象</code>发送到<code>服务端</code>上</li>\n<li><font color=\"blue\">5.</font>重写<code>channelRead()</code> 的方法，获取到<code>服务器</code>传来的结果</li>\n<li><font color=\"blue\">6.</font> 使用<code>CountDownLatch</code>的进行设置倒计时锁，实现在线程之间通信【发送的<code>channelActive</code>方法使用<code>await()</code> 方法进行等待,这个方法有一个<code>新启的线程</code>； 接受的<code>channelRead()</code>方法使用<code>countDown()</code>方法进行唤醒<code>新启的线程</code>；这个方法的线程是一个<code>NIO</code>线程 】，设置倒计时锁的初始基数为1，直到<code>减为零</code>才继续往下运行，否则等待  【倒计时锁的两个方法：<code>countDown()</code>  倒计时<code>-1</code> ，唤醒新的线程；<code>await()</code> 进行等待被唤醒】</li>\n<li><font color=\"blue\">7.</font> 使用<code>AtomicBoolean</code> 设定变量表示 线程的<code>登录状态</code></li>\n<li><font color=\"blue\">8.</font> 在<code>channelRead</code>中接受并处理登录传来的消息是不是<code>success</code>的，是的话就登录状态设置为<code>true</code>，随后在<code>channelRead</code>方法中使用<code>countDown()</code>方法唤醒<code>新启的线程</code></li>\n<li><font color=\"blue\">9.</font> <code>channelActive()</code>中判断如果<code>登录失败</code>的话就应该关闭<code>新启的线程</code>的连接，停止运行，退出整个客户端;；如果<code>登录成功</code>的话执行后续流程</li>\n<li><font color=\"blue\">10.</font>在后续的流程中，有控制台进行输入<code>Scanner()</code>,并对输入的值进行<code>swictch...case</code> 的判断解析得到对应的处理方式（这里写了很多的<code>XXXmessage</code>的类进行解析<code>message</code>）</li>\n<li><font color=\"blue\">17.</font><code>假死连接</code><ul>\n<li>同样的在客户端也要加上<code>IdleStateHandler</code>空闲状态检测器判断<code>假死连接</code></li>\n<li>判断指定时间要是<code>没有向服务器</code>写数据，就会触发一个<code>WRITER_IDLE</code>的事件,自主发送指定的<code>心跳消息包</code>(就是<code>一般自定义的消息</code>)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>服务端</p>\n<ul>\n<li><font color=\"blue\">3.</font>服务端同样的可以在<code>pipline</code>中加入三个 <code>handler</code>   ，分别是：<code>处理半包的，打印日志的，对发送的消息编解码的 handler</code></li>\n<li><font color=\"blue\">4.</font>《登录功能》<ul>\n<li>添加<code>SimpleChannelInboundHandler</code>  对接受的信息<code>LoginRequestMessage</code>进行处理，重写<code>channelRead0()</code>的方法获取到传过来的<code>密码和用户名</code>，并判断是否成功获取到用户的信息，并做相应的处理，返回结果给客户端</li>\n</ul>\n</li>\n<li><font color=\"blue\">11.</font>通过用户会话管理器进行绑定<code>channel</code> 和<code>username</code></li>\n<li><font color=\"blue\">12.</font>  《单聊——聊天功能》<ul>\n<li>简单的定义<code>事件的处理器ChatRequestMessageHandler</code>  并加入到<code>pipline</code>中<ul>\n<li>思路就是获取<code>msg 就是 用户名</code>   并通过会话管理器将得到对应<code>msg</code>的<code>channel</code> ,<ul>\n<li><code>channel</code>如果不是<code>null</code> ，就进行发送消息</li>\n<li>否则发送失败</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>此时测试的时候要启动多个<code>Client</code></p>\n</blockquote>\n<ul>\n<li><font color=\"blue\">13.</font>《群聊——创建群聊组》<ul>\n<li>简单的定义<code>事件的处理器XXXMessageHandler</code>  并加入到<code>pipline</code>中，具体思路和上面的类似</li>\n<li>简单的定义<code>事件的处理器GroupCreateRequestMessageHandler</code>  并加入到<code>pipline</code>中<ul>\n<li>定义类<code>GroupCreateRequestMessageHandler</code>的逻辑<ul>\n<li>群管理器创建聊天组<ul>\n<li>判断聊天组是否存在，不存在创建成功，并向所有发送组成员发送拉群消息；否则创建失败</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><font color=\"blue\">14. </font>《群聊——聊天功能》</p>\n<ul>\n<li>根据组名得到所有组员姓名及对应的绑定的<code>channel</code>，并经过<code>channel</code>发送信息给对应的组员</li>\n</ul>\n</li>\n<li><p><font color=\"blue\">15.</font>《处理退出》</p>\n<ul>\n<li><code>QuitHandler</code><ul>\n<li>当连接断开时触发 <code>inactive</code> 事件<ul>\n<li>取消<code>username</code>绑定 的 <code>channel</code></li>\n</ul>\n</li>\n<li>当出现异常时触发<ul>\n<li>取消<code>username</code>绑定 的 <code>channel</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><font color=\"blue\">16.</font>假死连接<ul>\n<li>解决：判断但是不是读空闲或者写空闲时间过长，<code>IdleStateHandler</code> 空闲状态检测器判断<code>假死连接</code></li>\n<li>可以通过设置处理器中的<code>IdleStateHandler</code>中的参数指定时间进行判断是否没有收到<code>channel</code>的数据，没有的话会触发该处理器的<code>Read_IDLE</code>事件</li>\n<li>向<code>pipeline</code>中加上<code>ChannelDuplexHandler</code>处理器，其可以同时作为出站和入站处理器，可以用来处理出发特殊的事件<ul>\n<li>处理<code>读空闲</code>的事件</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<h4 id=\"连接假死\"><a href=\"#连接假死\" class=\"headerlink\" title=\"连接假死\"></a>连接假死</h4><p>原因</p>\n<ul>\n<li>网络设备出现故障，例如网卡，机房等，底层的 TCP 连接已经断开了，但应用程序没有感知到，仍然占用着资源。</li>\n<li>公网网络不稳定，出现丢包。如果连续出现丢包，这时现象就是客户端数据发不出去，服务端也一直收不到数据，就这么一直耗着</li>\n<li>应用程序线程阻塞，无法进行数据读写</li>\n</ul>\n<p>问题</p>\n<ul>\n<li>假死的连接占用的资源不能自动释放</li>\n<li>向假死的连接发送数据，得到的反馈是发送超时</li>\n</ul>\n<p>服务器端解决</p>\n<ul>\n<li>如果能收到客户端数据，说明没有假死。因此策略就可以定为，每隔一段时间就检查这段时间内是否接收到客户端数据，没有就可以判定为连接假死</li>\n</ul>\n<p>客户端定时心跳</p>\n<ul>\n<li>客户端可以定时向服务器端发送数据，只要这个时间间隔小于服务器定义的空闲检测的时间间隔，那么就能防止前面提到的误判，客户端可以定义如下心跳处理器</li>\n</ul>\n</blockquote>\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><h3 id=\"序列化算法\"><a href=\"#序列化算法\" class=\"headerlink\" title=\"序列化算法\"></a>序列化算法</h3><p>序列化，反序列化主要用在消息正文的转换上</p>\n<ul>\n<li><code>序列化时</code>，需要将 Java 对象变为要传输的数据（可以是 byte[]，或 json 等， <code>最终</code>都需要变成 <code>byte[]</code>）</li>\n<li><code>反序列化时</code>，需要将传入的正文数据<code>还原成</code> Java 对象，便于处理</li>\n</ul>\n<ul>\n<li><p>目前的代码仅支持 <code>Java</code> 自带的序列化，反序列化机制</p>\n</li>\n<li><p>为了支持更多序列化算法，可以将所有的序列化算法抽象成一个 <code>Serializer</code> 接口</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Serializer</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 反序列化方法</span></span><br><span class=\"line\">    &lt;T&gt; T <span class=\"title function_\">deserialize</span><span class=\"params\">(Class&lt;T&gt; clazz, <span class=\"type\">byte</span>[] bytes)</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 序列化方法</span></span><br><span class=\"line\">    &lt;T&gt; <span class=\"type\">byte</span>[] serialize(T object);</span><br><span class=\"line\">    <span class=\"keyword\">enum</span> <span class=\"title class_\">Algorithm</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Serializer</span> &#123;</span><br><span class=\"line\">        Java &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> &lt;T&gt; T <span class=\"title function_\">deserialize</span><span class=\"params\">(Class&lt;T&gt; clazz, <span class=\"type\">byte</span>[] bytes)</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"type\">ObjectInputStream</span> <span class=\"variable\">ois</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectInputStream</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayInputStream</span>(bytes));</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> (T) ois.readObject();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;反序列化失败&quot;</span>, e);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"type\">byte</span>[] serialize(T object) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"type\">ByteArrayOutputStream</span> <span class=\"variable\">bos</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayOutputStream</span>();</span><br><span class=\"line\">                    <span class=\"type\">ObjectOutputStream</span> <span class=\"variable\">oos</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectOutputStream</span>(bos);</span><br><span class=\"line\">                    oos.writeObject(object);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> bos.toByteArray();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;序列化失败&quot;</span>, e);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        Json &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> &lt;T&gt; T <span class=\"title function_\">deserialize</span><span class=\"params\">(Class&lt;T&gt; clazz, <span class=\"type\">byte</span>[] bytes)</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">Gson</span> <span class=\"variable\">gson</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">GsonBuilder</span>().registerTypeAdapter(Class.class, <span class=\"keyword\">new</span> <span class=\"title class_\">Serializer</span>.ClassCodec()).create();</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">json</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(bytes, StandardCharsets.UTF_8);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> gson.fromJson(json, clazz);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"type\">byte</span>[] serialize(T object) &#123;</span><br><span class=\"line\">                <span class=\"type\">Gson</span> <span class=\"variable\">gson</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">GsonBuilder</span>().registerTypeAdapter(Class.class, <span class=\"keyword\">new</span> <span class=\"title class_\">Serializer</span>.ClassCodec()).create();</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">json</span> <span class=\"operator\">=</span> gson.toJson(object);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> json.getBytes(StandardCharsets.UTF_8);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">ClassCodec</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">JsonSerializer</span>&lt;Class&lt;?&gt;&gt;, JsonDeserializer&lt;Class&lt;?&gt;&gt; &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> Class&lt;?&gt; deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) <span class=\"keyword\">throws</span> JsonParseException &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> json.getAsString();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> Class.forName(str);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JsonParseException</span>(e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span>             <span class=\"comment\">//   String.class</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> JsonElement <span class=\"title function_\">serialize</span><span class=\"params\">(Class&lt;?&gt; src, Type typeOfSrc, JsonSerializationContext context)</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// class -&gt; json</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JsonPrimitive</span>(src.getName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数调优\"><a href=\"#参数调优\" class=\"headerlink\" title=\"参数调优\"></a>参数调优</h3><ol>\n<li><p><code>CONNECT_TIMEOUT_MILLIS</code></p>\n<ul>\n<li><p>属于 <code>SocketChannal</code> 参数</p>\n</li>\n<li><p>用在<code>客户端</code>建立连接时，如果在指定毫秒内无法连接，会抛出 <code>timeout</code> 异常</p>\n</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Boostrap</span>().option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class=\"number\">300</span>)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>注意：<ul>\n<li><code>客户端</code>： 通过<code>.option()</code>方法配置参数 给 <code>SocketChannel</code> 配置参数 (因为对于客户端来说就一个<code>Socket</code>)</li>\n<li><code>服务端</code><br><code>new ServerBootstrap().option()</code>       // 给 <code>ServerSocketChannel</code> 配置参数<br><code>new ServerBootstrap().childHandler()</code> // 给 <code>SocketChannel</code> 配置参数</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<ol>\n<li><code>SO_BACKLOG</code><ul>\n<li>属于 <code>ServerSocketChannal</code> 参数</li>\n<li><code>SO_TIMEOUT</code>主要用在<code>阻塞 IO</code>，阻塞 IO 中 <code>accept</code>，<code>read</code> 等都是无限等待的，如果<code>不希望永远阻塞</code>，使用它<code>调整超时时间</code></li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>TCP的是<code>三次握手</code></p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sequenceDiagram</span><br><span class=\"line\"></span><br><span class=\"line\">participant c as client</span><br><span class=\"line\">participant s as server</span><br><span class=\"line\">participant sq as syns queue&lt;半连接队列&gt;</span><br><span class=\"line\">participant aq as accept queue&lt;全连接队列&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">s -&gt;&gt; s : bind()</span><br><span class=\"line\">s -&gt;&gt; s : listen()</span><br><span class=\"line\">c -&gt;&gt; c : connect()</span><br><span class=\"line\">c -&gt;&gt; s : 1. SYN</span><br><span class=\"line\">Note left of c : SYN_SEND</span><br><span class=\"line\">s -&gt;&gt; sq : put</span><br><span class=\"line\">Note right of s : SYN_RCVD</span><br><span class=\"line\">s -&gt;&gt; c : 2. SYN + ACK</span><br><span class=\"line\">Note left of c : ESTABLISHED</span><br><span class=\"line\">c -&gt;&gt; s : 3. ACK</span><br><span class=\"line\">sq -&gt;&gt; aq : put</span><br><span class=\"line\">Note right of s : ESTABLISHED</span><br><span class=\"line\">aq --&gt;&gt; s : </span><br><span class=\"line\">s -&gt;&gt; s : accept()</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>三次握手</code>详解</p>\n<ol>\n<li>第一次握手，client 发送 SYN 到 server，状态修改为 SYN_SEND，server 收到，状态改变为 SYN_REVD，并将该请求放入 sync queue 队列</li>\n<li>第二次握手，server 回复 SYN + ACK 给 client，client 收到，状态改变为 ESTABLISHED，并发送 ACK 给 server</li>\n<li>第三次握手，server 收到 ACK，状态改变为 ESTABLISHED，将该请求从 sync queue 放入 accept queue</li>\n</ol>\n<p>其中</p>\n<ul>\n<li><p>在 <code>linux 2.2</code> 之前，<code>backlog</code> 大小包括了<code>两个队列的大小</code>，在 <code>2.2 之后</code>，分别用下面<code>两个参数来控制</code></p>\n</li>\n<li><p><code>sync queue</code> - 半连接队列</p>\n<ul>\n<li>大小通过<code>/proc/sys/net/ipv4/tcp_max_syn_backlog</code> 指定，在 <code>syncookies</code> 启用的情况下，逻辑上没有最大值限制，这个设置便被忽略</li>\n</ul>\n</li>\n<li><code>accept queue</code>- 全连接队列<ul>\n<li>其大小通过<code>/proc/sys/net/core/somaxconn</code>指定，在使用 listen 函数时，内核会根据传入的 <code>backlog</code> 参数【程序中】与<code>系统参数</code>【配置文件】，取二者的较小值</li>\n<li>如果 <code>accpet queue</code>队列满了，<code>server</code> 将发送一个拒绝连接的错误信息到 <code>client</code></li>\n</ul>\n</li>\n</ul>\n<p><code>Netty</code> :  可以通过  <code>option(ChannelOption.SO_BACKLOG, 值)</code>来设置大小</p>\n</blockquote>\n<ol>\n<li><code>ulimit -n</code><ul>\n<li>属于操作系统参数</li>\n</ul>\n</li>\n</ol>\n<ol>\n<li><code>TCP_NODELAY</code><ul>\n<li>属于 <code>SocketChannal</code> 参数</li>\n<li>设置为<code>false</code> 表示开启了<code>Nagle</code>算法，建议设为<code>true</code></li>\n</ul>\n</li>\n</ol>\n<ol>\n<li><p><code>SO_SNDBUF &amp; SO_RCVBUF</code>&lt;是发送缓冲区 &amp; 接受缓冲区，间接的影响到滑动窗口的大小；现在的<code>OS</code>会自动根据发送接收的双方设置大小&gt;</p>\n<ul>\n<li><p><code>SO_SNDBUF</code> 属于 <code>SocketChannal</code> 参数</p>\n</li>\n<li><p><code>SO_RCVBUF</code> 既可用于 <code>SocketChannal</code> 参数，也可以用于 <code>ServerSocketChannal</code> 参数（建议设置到 <code>ServerSocketChannal</code> 上）</p>\n</li>\n</ul>\n</li>\n</ol>\n<ol>\n<li><p><code>ALLOCATOR</code>==(<code>涉及源码</code>)==</p>\n<ul>\n<li><p>属于 <code>SocketChannal</code> 参数</p>\n</li>\n<li><p>用来分配 <code>ByteBuf， ctx.alloc()</code></p>\n</li>\n<li><code>alloc 创建的buf</code> 是一个池化的直接内存的，可以在<code>VM option</code>中进行设置<code>是否池化</code>，是否<code>直接内存还是堆内存</code></li>\n</ul>\n</li>\n</ol>\n<ol>\n<li><p><code>RCVBUF_ALLOCATOR</code>==(<code>涉及源码</code>)==</p>\n<ul>\n<li><p>属于 <code>SocketChannal</code> 参数1</p>\n</li>\n<li><p>可以用来控制 <code>netty</code> 接收缓冲区大小</p>\n</li>\n<li><p>负责入站数据的分配，决定入站缓冲区的大小（并可动态调整），统一采用 direct 直接内存，具体池化还是非池化由 allocator 决定</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"基于聊天的RPC\"><a href=\"#基于聊天的RPC\" class=\"headerlink\" title=\"基于聊天的RPC\"></a>基于聊天的RPC</h2><h4 id=\"实现消息通信的思路\"><a href=\"#实现消息通信的思路\" class=\"headerlink\" title=\"实现消息通信的思路\"></a>实现消息通信的思路</h4><p><strong>客户端</strong></p>\n<ul>\n<li><font color=\"blue\">1.</font>向<code>pipline</code>中加上<code>粘包半包，日志，消息解码编码,RpcRequestMessageHandler</code>的处理器，随后建立与<code>服务端</code>的连接</li>\n<li><font color=\"blue\">2.</font>向服务端发送请求消息，该请求消息找到<code>pipline</code> 的所有出站处理器（<code>下-&gt; 上</code>），并发送数据<ul>\n<li>使用<code>异步的回调方法  addListener()</code>处理发送失败的消息</li>\n</ul>\n</li>\n<li><font color=\"blue\">6.</font> 将 1.2. 步骤进行疯转，然后将<code>channel.closeFuture().sync();</code> 修改为<code>异步</code>的<code>channel.closeFuture().addListener(future -&gt; &#123;&#125;)</code></li>\n<li><font color=\"blue\">7.</font>获取唯一的 <code>channel</code> 对象，此处是要进行<code>双重检查锁</code>的单例模式的方式创建获取</li>\n<li><p><font color=\"blue\">8.</font> 创建代理类<code>getProxyService</code>，将发送的消息格式进行简化</p>\n<ul>\n<li><strong>发送消息：</strong>将方法调用转换为 <code>消息对象</code> 随后在再将消息对象<code>发送出去</code></li>\n<li><font color=\"blue\">10.</font><strong>接收消息：</strong> 准备一个空 <code>Promise</code> 对象，来异步的接收结果  ；调用<code>await()</code>等待 <code>promise</code> 结果<ul>\n<li>接收成功：获取成功，拿到结果<code>getNow</code>，并返回</li>\n<li>接受失败：抛出异常</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><font color=\"blue\">9.</font> 在<code>RpcResponseMessageHandler</code>中定义接收结果的<code>promise</code>对象集合<code>ConcurrentHashMap&lt;&gt;()</code></p>\n<ul>\n<li>进行保护性编程：拿到 空的 <code>promise</code>，之后 随机进行销毁，减少集合中的<code>promise</code>对象</li>\n<li><p><code>promise</code> 非空就表示获取到，否则抛出异常</p>\n<ul>\n<li><p>判断获取到的对象是否有值</p>\n<ul>\n<li>有：获取成功并取得该值</li>\n<li>无 ：获取失败</li>\n</ul>\n</li>\n<li><p>最后让上述<code>await()</code>结束等待</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>服务端</strong></p>\n<ul>\n<li><font color=\"blue\">3.</font>同样的也要向<code>pipline</code>中加上<code>粘包半包，日志，消息解码编码,RpcResponseMessageHandler</code>的处理器</li>\n<li><font color=\"blue\">4.</font>随后拿到客户端传来的消息之后需要对接收的消息进行<code>入站的处理（就是上面的入站处理器）</code>（<code>上-&gt; 下</code></li>\n<li><font color=\"blue\">5.</font>最后交给请求的<code>Handler</code> ——<code>RpcRequestMessageHandler</code><ul>\n<li><code>RpcRequestMessageHandler</code> 中的处理是;<code>远程调用方法主要是通过反射实现的</code><ul>\n<li>拿到<code>rpc请求消息</code>之后，根据消息的接口得到真正调用的实现对象，找到要调用的方法，反射进行调用</li>\n<li>将结果（<code>无论成功还是异常</code>）都将封装成<code>response</code>的对象，并通过<code>ctx</code> 进行返回,若有<strong>异常需要捕获，并放入响应消息中</strong></li>\n<li>随后响应消息经过服务器端的<code>pipline</code> 的所有出站处理器（<code>下-&gt; 上</code>），并发送数据,最后交给客户端的<code>RPCHandler</code>——<code>RpcResponseMessageHandler</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","_path":"post/7d3cd9cc.html","_link":"http://rycan.top/post/7d3cd9cc.html","_id":"cljn5lv47001imi1306oe80y7"}}