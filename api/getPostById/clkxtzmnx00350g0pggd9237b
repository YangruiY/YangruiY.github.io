{"type":"getPostById","data":{"title":"redis的线程","date":"2023-07-03T08:42:57.000Z","description":"redis的单线程、多线程、IO多路复用、epoll机制","categories":[{"name":"redis","_id":"clkxtzmnr001k0g0papsiguyh"}],"tags":[{"name":"redis","_id":"clkxtzmny003a0g0pghdt2c9p"}],"content":"<meta name=\"referrer\" content=\"no-referrer\">\n<h2 id=\"Redis单线程与多线程\">Redis单线程与多线程</h2>\n<h3 id=\"redis单线程\">redis单线程</h3>\n<h4 id=\"定义：\">定义：</h4>\n<p>主要是指Redis的网络IO和键值对读写是由一个线程来完成的，Redis在处理客户端的请求时包括获取(socket 读)、解析、执行、内容返回(socket 写) 等都由一个顺序串行的主线程处理，这就是所谓的“单线程”</p>\n<h4 id=\"优点：\">优点：</h4>\n<ul>\n<li>使用单线程模型使 Redis 的开发和维护更简单，因为单线程模型方便开发和调试;</li>\n<li>即使使用单线程模型也并发的处理多客户端的请求，主要使用的是<code>IO多路复用和非阻塞IO</code>；</li>\n<li>对于Redis系统来说，主要的<code>性能瓶颈</code>是内存或者网络带宽而并非 CPU。</li>\n</ul>\n<h4 id=\"问题\">问题</h4>\n<ul>\n<li>大key删除会陷入等待   [因为是单线程原子命令操作，这就会导致 Redis 服务卡顿]</li>\n<li>随着网络硬件的性能提升，Redis的性能瓶颈有时会出现在网络IO的处理上,单个主线程处理网络请求的速度跟不上底层网络硬件的速度</li>\n</ul>\n<h3 id=\"redis多线程\">redis多线程</h3>\n<blockquote>\n<p>Redis的<code>多线程</code>只是用来处理网络请求的，<strong>对于读写操作命令Redis仍然使用单线程来处理</strong></p>\n</blockquote>\n<h4 id=\"原因：\">原因：</h4>\n<ul>\n<li>Redis处理请求时，网络处理经常是瓶颈，通过多个IO线程并行处理网络操作，可以提升实例的整体处理性能。</li>\n<li>而继续使用单线程执行命令，就不用为了保证Lua脚本、事务的原子性，额外开发多线程$\\textcolor{red}{互斥加锁机制了(不管加锁操作处理)}$，这样一来，Redis线程模型实现就简单了</li>\n</ul>\n<h4 id=\"主线程和IO线程协作完成请求处理的过程\">主线程和IO线程协作完成请求处理的过程</h4>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202307031639240.png\" alt=\"image-20230525204935302\" style=\"zoom:33%;\">\n<h3 id=\"多线程下操作Redis不会有线程安全问题\">多线程下操作Redis不会有线程安全问题</h3>\n<ul>\n<li>\n<p>对于<code>网络数据读写、请求协议解析</code> 是通过多个IO线程的来处理</p>\n<p>而命令的执行依旧是由主线程串行执行的</p>\n<p>因此在多线程下操作Redis不会出现线程安全的问题</p>\n</li>\n</ul>\n<p><strong>为什么Redis要选择单线程？</strong></p>\n<ul>\n<li>抛开持久化不谈，Redis是<code>纯内存</code>操作，执行速度非常快，它的性能瓶颈是网络延迟而不是执行速度，因此多线程并不会带来巨大的性能提升。</li>\n<li>多线程会导致过多的上下文切换，带来不必要的开销</li>\n<li>引入多线程会面临线程安全问题，必然要引入线程锁这样的安全手段，实现复杂度增高，而且性能也会大打折扣</li>\n</ul>\n<blockquote>\n<p>Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器。</p>\n<p>Reactor 模式，是指通过一个或多个输入同时传递给服务处理器的服务请求的事件驱动处理模式。服务端程序处理传入多路请求，并将它们同步分派给请求对应的处理线程，Reactor 模式也叫 Dispatcher 模式</p>\n</blockquote>\n<h2 id=\"redis-为什么快\">redis 为什么快</h2>\n<p><span style=\"color:red\">IO多路复用  + epoll  + 存于内存之中+ 单线程命令+ 提供的数据结构</span></p>\n<h2 id=\"IO多路复用和epoll\">IO多路复用和epoll</h2>\n<h3 id=\"入门\">入门</h3>\n<ul>\n<li>\n<p>IO多路复用是什么</p>\n<p>一种同步的IO模型，实现<font color=\"red\">一个线程</font>监视<font color=\"green\"><code>多个</code>文件句柄(文件描述符),一旦某个文件句柄就绪</font>就能够通知到对应的应用程序进行相应的读写操作，<font color=\"red\">没有文件句柄就绪时</font>就会阻塞应用程序从而释放CPU资源</p>\n<ul>\n<li>多路：多个客户端连接(连接就是套接字描述符，即 socket 或者 channel)</li>\n<li>复用：复用一个或几个线程</li>\n<li>IO多路复用：就是一个或一组线程处理多个TCP连接，使用单进程就能够实现同时处理多个客户端的连接，<font color=\"red\">无需创建或者维护过多的进程/线程</font></li>\n<li>实现IO多路复用的模型有3种: 可以分<code>select-&gt;poll-&gt;epoll</code>三个阶段来描述。</li>\n</ul>\n</li>\n</ul>\n<p>IO多路复用原理: 有请求就响应，没请求不打扰</p>\n<p>采用多路/O复用技术可以让单个线程高效的处理多个连接请求一个服务端进程可以同时处理多个套接字描述符。</p>\n<ul>\n<li>浅谈<code>epoll</code>是什么</li>\n</ul>\n<blockquote>\n<p>浅记：你站在讲台上等，谁解答完谁举手。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案然后继续回到讲台上等] 此时E、A又举手，然后去处理E和A。。。这种就是IO复用模型。</p>\n</blockquote>\n<ul>\n<li>\n<p>工作原理：</p>\n<ul>\n<li>\n<p>将用户socket对应的文件描述符(FileDescriptor)注册进epoll，然后epoll帮你监听哪些socket上有消息到达，这样就避免了大量的无用操作。</p>\n</li>\n<li>\n<p>此时的socket应该采用<font color=\"red\">非阻塞模式</font>。这样，整个过程只在调用<code>select、poll、epoll</code>这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的<code>reactor反应模式</code></p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"深入\">深入</h3>\n<h4 id=\"font-color-red-是什么-font\"><font color=\"red\">是什么</font></h4>\n<p>I/O  : 网络 I/O</p>\n<p>多路 : 多个客户端连接（连接就是套接字描述符，即socket 或者 channel），指的是多条 TCP 连接</p>\n<p>复用:    用一个进程来处理多条的连接，使用单进程就能实现同时处理多个客户端的连接</p>\n<p>IO多路复用: 实现了用一个进程来处理大量的用户连接</p>\n<p>文件描述符（File Descriptor）：简称FD，是一个从0 开始的无符号整数，用来关联Linux中的一个文件。在Linux中，一切皆文件。</p>\n<h4 id=\"font-color-red-定义-font\"><font color=\"red\">定义</font></h4>\n<p>IO多路复用是<code>利用单个线程</code>来同时<code>监听多个FD</code>，并在某个FD可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。不过<code>监听FD的方式、通知的方式又有多种实现</code>，常见的有：</p>\n<ul>\n<li><code>select</code></li>\n<li><code>poll</code></li>\n<li><code>epoll</code></li>\n</ul>\n<p>其中select和pool相当于<code>是当被监听的数据准备好之后</code>，会把你监听的FD整个数据都发给你，你需要到整个FD中去找，哪些是处理好了的，需要通过遍历的方式，所以性能也并不是那么好</p>\n<p>而epoll，则相当于内核准备好了之后，他会把准备好的数据，直接发给你，省去了遍历的动作。</p>\n<h4 id=\"font-color-red-差异-font\"><font color=\"red\">差异</font></h4>\n<ul>\n<li><code>select和poll</code>只会通知用户进程有FD就绪，但不确定具体是哪个FD,需要用户进程逐个遍历FD来确认</li>\n<li><code>epol</code>则会在通知用户进程FD就绪的同时，把已就绪的FD写入用户空间</li>\n</ul>\n<h4 id=\"Select\"><code>Select</code></h4>\n<p>存在的问题：</p>\n<ul>\n<li>需要将整个<code>fd_set</code>从用户空间拷贝到内核空间，select结束还要再次拷贝回用户空间<code>2次拷贝</code></li>\n<li>select无法得知具体是哪个fd就绪，需要遍历整个<code>fd_set</code>    就是说他<code>知道有几个就绪 但是不知道具体是谁就绪了</code></li>\n<li><code>fd_set</code>监听的fd数量不能超过1024  <code>数量上有限制</code></li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202307031639980.png\" alt=\"image-20230527214058848\" style=\"zoom:55%;\">\n<h4 id=\"poll\"><code>poll</code></h4>\n<p>IO流程： &lt;和select差不多,唯一的改进就是 增加了监听的fd 数量，但是  监听FD越多，每次遍历消耗时间也越久，性能反而会下降 &gt;</p>\n<ul>\n<li>创建<code>pollfd数组</code>，向其中添加关注的fd信息，数组大小自定义</li>\n<li>调用<code>poll函数</code>，将<code>pollfd数组</code>拷贝到内核空间，转链表存储，<code>无上限</code></li>\n<li>内核遍历fd，判断是否就绪</li>\n<li>数据就绪或超时后，拷贝<code>pollfd</code>数组到用户空间，返回就绪fd数量n</li>\n<li>用户进程判断n是否大于0,大于0则遍历pollfd数组，找到就绪的fd数量</li>\n</ul>\n<h4 id=\"epoll\"><code>epoll</code></h4>\n<ul>\n<li>\n<p>是非阻塞的</p>\n</li>\n<li>\n<p>大大减少了fd拷贝的次数，大大减少了fd拷贝的数量</p>\n</li>\n<li>\n<p>监听的FD理论上无上限</p>\n</li>\n</ul>\n<blockquote>\n<p>多路复用快的原因在于，操作系统提供了<code>epoll</code>系统调用，使得原来的whi训e循环里多次系统调用，变成了<code>一次系统调用+内核层遍历这些文件描述符</code></p>\n<p>epoll 将拷贝与等待分开了</p>\n<p>epoll_ctl:  进行拷贝，只会拷贝一次</p>\n<p>epoll_wait:  等待就绪，之后每次只调用<code>epoll_wait</code>进行等待就可以了，无需再次拷贝</p>\n</blockquote>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202307031639013.jpg\" alt></p>\n<h4 id=\"总结\"><code>总结</code></h4>\n<blockquote>\n<p>select模式存在的三个问题：</p>\n</blockquote>\n<ul>\n<li>能监听的FD最大不超过1024</li>\n<li>每次select都需要把所有要监听的FD都拷贝到内核空间</li>\n<li>每次都要遍历所有FD来判断就绪状态</li>\n</ul>\n<blockquote>\n<p>poll模式的问题：</p>\n</blockquote>\n<ul>\n<li>poll利用链表解决了select中监听FD上限的问题，但依然要遍历所有FD，如果监听较多，性能会下降</li>\n</ul>\n<blockquote>\n<p>epoll模式中如何解决这些问题的？</p>\n</blockquote>\n<ul>\n<li>基于epoll实例中的<code>红黑树</code>保存要监听的FD，理论上无上限，而且增删改查效率都非常高</li>\n<li>每个FD只需要执行一次<code>epoll_ctl</code>添加到<code>红黑树</code>，以后每次<code>epol_wait</code>无需传递任何参数，无需重复拷贝<code>FD</code>到内核空间</li>\n<li>利用<code>ep_poll_callback</code>机制来监听FD状态，无需遍历所有FD，因此性能不会随监听的FD数量增多而下降</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202307031639480.png\" alt=\"image-20230528000644005\" style=\"zoom: 43%;\">\n<h4 id=\"font-color-red-事件通知机制-font\"><font color=\"red\">事件通知机制</font></h4>\n<p>当FD有数据可读时，我们调用<code>epoll_wait（或者select、poll）</code>可以得到通知。但是事件通知的模式有两种：</p>\n<ul>\n<li>LevelTriggered：简称LT，也叫做<code>水平触发</code>。只要某个FD中有数据可读，每次调用<code>epoll_wait</code>都会得到通知。</li>\n<li>EdgeTriggered：简称ET，也叫做<code>边沿触发</code>。只有在某个FD有状态变化时，调用<code>epoll_wait</code>才会被通知。</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202307031639760.png\" alt=\"image-20230527220918750\" style=\"zoom:45%;\">\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305272214385.png\" alt=\"image-20230527221455305\" style=\"zoom:43%;\">\n<h2 id=\"redis网络模型\"><code>redis网络模型</code></h2>\n","_path":"post/eca5e3e6.html","_link":"http://rycan.top/post/eca5e3e6.html","_id":"clkxtzmnx00350g0pggd9237b"}}