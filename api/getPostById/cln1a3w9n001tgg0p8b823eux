{"type":"getPostById","data":{"title":"RPC","date":"2023-09-13T15:45:50.000Z","description":"面试精选","categories":[{"name":"FaceToFace","_id":"cln1a3w9f000kgg0pg1jj2cur"}],"tags":[{"name":"RPC","_id":"cln1a3w9v0042gg0p7udh52ye"}],"content":"<meta name=\"referrer\" content=\"no-referrer\">\n<h1>RPC</h1>\n<blockquote>\n<p>Remote Procedure Call  ；远程过程调用</p>\n</blockquote>\n<h3 id=\"原理\">原理</h3>\n<ul>\n<li>\n<p>客户端（服务调用端）以本地调用的方式调用远程服务；</p>\n</li>\n<li>\n<p>客户端 Stub（桩）：本质是代理类，将调用的方法、类、参数等<code>序列化</code>之后，传递到服务端，找到远程服务的地址，并将消息发送到服务提供端；并在 接收到服务端发来的消息后会将消息<code>反序列化</code>为 Java 对象作为最终结果。</p>\n</li>\n<li>\n<p>网络传输 ： 作用于客户端sub  和服务端 Stub之间，  网络传输就是把调用的方法的信息传输到服务端，然后服务端执行完之后再把返回结果通过网络 传输回来。<code>「</code>网络传输的实现方式有很多种比如最基本的 Socket 或者性能以及封装更加优秀的 Netty（推荐）<code>」</code></p>\n</li>\n<li>\n<p>服务端 Stub（桩）：收到消息将消息<code>反序列化</code>为 Java 对象，然后通过类、方法、方法参数等信息调用本地的方法；随后将得到的结果组装成能够进行网络传输的消息体，然后发送至调用方；</p>\n</li>\n<li>\n<p>服务端（服务提供端） ：提供远程方法的一端</p>\n</li>\n</ul>\n<blockquote>\n<p>RPC框架的目标就是将上述过程都进行封装，这些细节对用户来说是透明的，不可见的。</p>\n</blockquote>\n<h3 id=\"一些概念\">一些概念</h3>\n<ul>\n<li><strong>响应时间</strong>：指执行一个请求从开始到最后收到响应数据所花费的总体时间。</li>\n<li><strong>并发数</strong>：指系统同时能处理的请求数量。</li>\n<li><strong>并发连接数</strong>：指的是客户端向服务器发起请求，并建立了TCP连接。每秒钟服务器连接的总TCP数量</li>\n<li><strong>请求数</strong>：也称为QPS(Query Per Second) 指每秒多少请求.</li>\n<li><strong>并发用户数</strong>：单位时间内有多少用户</li>\n<li><strong>吞吐量</strong>：指单位时间内系统能处理的请求数量。</li>\n<li><strong>QPS</strong>：Query Per Second 每秒查询数。</li>\n<li><strong>TPS</strong>：Transactions Per Second 每秒事务数。</li>\n<li>一个事务是：指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。</li>\n<li>一个页面的一次访问，只会形成一个TPS；但一次页面请求，可能产生多次对服务器的请求，就会有多个QPS</li>\n</ul>\n<blockquote>\n<p>QPS &gt;= 并发连接数 &gt;= TPS</p>\n</blockquote>\n<h3 id=\"集群-VS-分布式\">集群 VS. 分布式</h3>\n<p>集群：很多“人”一起 ，<code>干一样</code>的事。</p>\n<p>分布式：很多“人”一起，干<code>不一样</code>的事。这些不一样的事，合起来是一件大事。</p>\n<h3 id=\"架构演化\">架构演化</h3>\n<p>1、单体架构「关键在于简化 CRUD 的<strong>ORM框架</strong>」</p>\n<p>2、垂直架构「关键在于 加速前端开发的<strong>web框架(MVC)</strong>」：是指将单体架构中的多个模块拆分为多个独立的项目。形成多个独立的单体架构，但是重复功能太多</p>\n<p>3、分布式架构「关键在于 提高业务复用及整合的<strong>分布式服务框架(RPC)</strong>」：将公共业务模块抽取出来，作为独立的服务，供其他调用者消费，以实现服务的共享和重用，但是服务提供方一旦产生变更，所有消费方都需要变更。</p>\n<p>4、SOA架构「关键在于用于<strong>提高机器利用率的资源调度和治理中心(SOA)[ Service Oriented Architecture]</strong>」：它将应用程序的不同功能单元（称为服务）进行拆分，并通过这些服务之间定义良好的接口和契约联系起来，就是通过一个调度中心<code>基于访问压力</code>实时管理集群容量，提高集群利用率,通常这个服务中心就是：<code>ESB(Enterparise Servce Bus) 企业服务总线</code>，服务中介。主要是提供了一个服务与服务之间的交互。ESB 包含的功能如：负载均衡，流量控制，加密处理，服务的监控，异常处理，监控告急等等。</p>\n<p>5、微服务架构「关键在于 业务需要彻底的组件化和服务化」：原有的单个业务系统会拆分为多个可以独立开发、设计、运行的小应用。这些小应用之间通过服务完成交互和集成。服务组件化、去中心化、自动化部署</p>\n<h1>DUBBO</h1>\n<p>是一个 高性能、轻量级的 Java<code> RPC 框架</code>。致力于提供高性能和透明化的 RPC 远程服务调用方案，以及 SOA 服务治理方案。</p>\n<h3 id=\"架构\">架构</h3>\n<img src=\"/Users/yangrui/Library/Application Support/typora-user-images/image-20230831095544363.png\" alt=\"image-20230831095544363\" style=\"zoom:60%;\">\n<h3 id=\"流程\">流程</h3>\n<p>1、服务容器 Container 负责启动，加载，运行服务提供者；</p>\n<p>2、服务提供者 Provider 在启动时，向注册中心注册自己提供的服务；</p>\n<p>3、服务消费者 Consumer 在启动时，向注册中心订阅自己所需的服务；</p>\n<p>4、注册中心 Registry 返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者；</p>\n<p>5、服务消费者 Consumer，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用；</p>\n<p>6、服务消费者 Consumer 和提供者 Provider，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心 Monitor</p>\n<h3 id=\"功能\">功能</h3>\n<p>1、透明化的 RPC 调用</p>\n<p>2、容错机制和软负载均衡</p>\n<p>3、服务自动注册和发现</p>\n<p>4、高度可扩展能力</p>\n<p>5、运行期流量调度</p>\n<p>6、可视化的服务治理与运维</p>\n<h3 id=\"SpringCloud-VS-Dubbo\">SpringCloud  VS. Dubbo</h3>\n<p>Dubbo 是 SOA 时代的产物，它的关注点主要在于服务的调用，流量分发、流量监控和熔断。Dubbo 底层是使用 Netty 这样的 NIO 框架，是基于 TCP 协议传输的，配合以 Hession 序列化完成 RPC 通信。</p>\n<p>Spring Cloud 诞生于微服务架构时代，考虑的是微服务治理的方方面面，另外由于依托了 Spring、Spring Boot 的优势之上，两个框架在开始目标就不一致。Spring Cloud 是基于 Http 协议 Rest 接口调用远程过程的通信，相对来说 Http 请求会有更大的报文，占的带宽也会更多。REST 相比 RPC 更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖</p>\n<h3 id=\"Spring整合dubbo\">Spring整合dubbo</h3>\n<h4 id=\"原理-2\">原理</h4>\n<p>Spring 容器在启动的时候，会读取到 Spring 默认的一些 schema 以及 Dubbo 自定义的 schema，每个 schema 都会对应一个自己的 NamespaceHandler，NamespaceHandler 里面通过 BeanDefinitionParser 来解析配置信息并转化为需要加载的 bean 对象！</p>\n<h4 id=\"超时\">超时</h4>\n<p>dubbo可以在提供者端设置超时时间，也可以在消费者端设置超时时间，如果在消费者端设置了超时时间，以消费者端为主，即优先级更高。</p>\n<p>在调用超时的时候默认是会重试两次</p>\n<h3 id=\"集群\">集群</h3>\n<p>1、Dubbo 的注册中心集群挂掉，发布者和订阅者之间还能通信，因为启动 Dubbo 时，消费者会从 Zookeeper 拉取注册的生产者的地址接口等数据，缓存在本地。每次调用时，按照本地存储的地址进行调用。</p>\n<p>2、在集群负载均衡时，Dubbo 提供了多种均衡策略，默认为 random 随机调用。我们还可以自行扩展负载均衡策略</p>\n<p>3、负载均衡策略：</p>\n<p>​\t3.1、<code>RandomLoadBalance</code>：权重随机选择。默认的负载均衡策略。具体的实现原理非常简单，假如有两个提供相同服务的服务器 S1,S2，S1 的权重为 7，S2 的权重为 3。我们把这些权重值分布在坐标区间会得到：S1-&gt;[0, 7) ，S2-&gt;(7, 10]。我们生成 [0, 10) 之间的随机数，随机数落到对应的区间，我们就选择对应的服务器来处理请求。</p>\n<p>​\t3.2、<code>LeastActiveLoadBalance</code> ：最小活跃数负载均衡。初始状态下所有服务提供者的活跃数均为 0（每个服务提供者的中特定方法都对应一个活跃数），每收到一个请求后，对应的服务提供者的活跃数 +1，当这个请求处理完之后，活跃数 -1。因此，Dubbo 认为谁的活跃数越少，谁的处理速度就越快，性能也越好，这样的话，就优先把请求给活跃数少的服务提供者处理。如果有多个服务提供者的活跃数相等就再走一遍 RandomLoadBalance</p>\n<p>​\t3.3、<code>ConsistentHashLoadBalance</code> :一致性 Hash 负载均衡策略。没有权重的概念，具体是哪个服务提供者处理请求是由请求的参数决定的，也就是说相同参数的请求总是发到同一个服务提供者。Dubbo为了避免数据倾斜问题（节点不够分散，大量请求落到同一节点），还引入了虚拟节点的概念。通过虚拟节点可以让节点更加分散，有效均衡各个节点的请求</p>\n<p>​\t3.4、<code>RoundRobinLoadBalance</code> 即加权轮询负载均衡。轮询就是把请求依次分配给每个服务提供者。加权轮询就是在轮询的基础上，让更多的请求落到权重更大的服务提供者上。比如假如有两个提供相同服务的服务器 S1,S2，S1 的权重为 7，S2 的权重为 3。如果有 10 次请求，那么 7 次会被 S1 处理，3 次被 S2 处理。但是，如果是 RandomLoadBalance 的话，很可能存在 10 次请求有 9 次都被 S1 处理的情况（概率性问题）。</p>\n<h3 id=\"分布式\">分布式</h3>\n<p>Dubbo暂时不支持分布式事务，可通过 tcc-transaction 框架实现，tcc-transaction 是开源的 TCC 补偿性分布式事务框架，TCC-Transaction 通过 Dubbo 隐式传参的功能，避免自己对业务代码的入侵。</p>\n<h3 id=\"高级特性\">高级特性</h3>\n<p>1、<strong>两个机器传输数据，如何传输Java对象?</strong>：dubbo 内部已经将序列化和反序列化的过程内部封装了；我们只需要在定义pojo类时实现Serializable接口即可</p>\n<p>2、<strong>地址缓存：注册中心挂了，服务是否可以正常访问？</strong>  可以，因为dubbo服务消费者在第一次调用时，会将服务提供方地址缓存到本地，以后在调用则不会访问注册中心；当服务提供者地址发生变化时，注册中心会通知服务消费者。</p>\n<p>3、<strong>超时</strong>：</p>\n<p>​\t产生现象：消费者在调用服务提供者的时候发生了阻塞、等待的情形，这个时候，服务消费者会一直等待下去；在某个峰值时刻，大量的请求都在同时请求服务消费者，会造成线程的大量堆积，势必会造成雪崩</p>\n<p>​\t解决：使用超时机制来解决这个问题，设置一个超时时间，在这个时间段内，无法完成服务访问，则自动断开连接。使用<code>timeout</code>属性配置超时时间，<code>默认值1000</code>，单位毫秒。</p>\n<p>​\t冲突:要是<code>提供方@Service</code>注解超时3秒生效，还是<code>消费方 @Reference</code>注解超时1秒生效？    —答： <code>是超时 1秒生效</code>；服务<code>提供方</code>的超时时间会覆盖<code>消费方</code>的超时时间，但是超时时间在服务的生产方或者消费方单独地都会生效，所以建议把超时时间配置在服务的<code>提供方</code></p>\n<p>4、<strong>重试</strong></p>\n<p>​\t设置了超时时间，在这个时间段内，无法完成服务访问，则自动断开连接。如果出现网络抖动，则这一次请求就会失败。Dubbo 提供==重试==机制来避免类似问题的发生。通过 <code>retries</code> 属性来设置重试次数。<code>默认为 2 次</code>。</p>\n<p>5、<strong>多版本</strong></p>\n<p>​\t灰度发布：当出现新功能时，会让一部分用户先使用新功能，用户反馈没问题时，再将所有用户迁移到新功能。dubbo 中使用version 属性来设置和调用同一个接口的不同版本</p>\n<p>6、<strong>负载均衡</strong></p>\n<ul>\n<li>\n<p>Random ：按权重随机，默认值。按权重设置随机概率</p>\n</li>\n<li>\n<p>RoundRobin ：按权重轮询（上面的轮询方式就是 <code>   1 2 3 2</code>）</p>\n</li>\n<li>\n<p>LeastActive：最少活跃调用数，相同活跃数的随机</p>\n</li>\n</ul>\n<p>7、<strong>集群容错</strong></p>\n<p>​\t1、模式   （设置<code>@Reference(cluster = &quot;failover&quot;)</code>）</p>\n<ul>\n<li>Failover Cluster：<code>失败重试</code>。<code>默认值</code>。当出现失败，重试其它服务器 ，默认重试2次，使用 retries 配置。一般用于读操作</li>\n<li>Failfast Cluster ：快速失败，只发起一次调用，失败立即报错。通常用于写操作。</li>\n<li>Failsafe Cluster ：失败安全，出现异常时，直接忽略。返回一个空结果。</li>\n<li>Failback Cluster ：失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</li>\n<li>Forking Cluster ：并行调用多个服务器，只要一个成功即返回。</li>\n<li>Broadcast Cluster ：广播调用所有提供者，逐个调用，任意一台报错则报错。</li>\n</ul>\n<p>8、<strong>服务降级</strong></p>\n<p>1、降级的方式</p>\n<ul>\n<li>mock=force:return null 表示消费方对该服务的方法调用都<code>直接</code>返回null值，不发起远程调用。用来<code>屏蔽</code> <code>不重要服务不可用时</code>对调用方的影响。</li>\n<li>mock=fail:return null 表示消费方应对该服务的方法调用在<code>失败后</code>，再返回null值，不抛异常。用来<code>容忍</code> <code>不重要服务不稳定时</code>对调用方的影响。</li>\n</ul>\n<h3 id=\"原理-3\">原理</h3>\n<h4 id=\"Invoker\"><code>Invoker</code></h4>\n<p>分为服务提供 Invoker和服务消费 Invoker；就是 Dubbo 对远程调用的抽象。可以提供动态代理来屏蔽远程调用的细节， Invoker 实现了真正的远程服务调用。</p>\n<h4 id=\"Monitor-实现原理\">Monitor 实现原理</h4>\n<p>Consumer 端在发起调用之前会先走 filter 链；provider 端在接收到请求时也是先走 filter 链，然后才进行真正的业务逻辑处理。默认情况下，在 consumer 和 provider 的 filter 链中都会有 Monitorfilter。</p>\n<ul>\n<li>MonitorFilter 向 DubboMonitor 发送数据；</li>\n<li>DubboMonitor 将数据进行聚合后（默认聚合 1min 中的统计数据）暂存到 ConcurrentMap&lt;Statistics, AtomicReference&gt; statisticsMap，然后使用一个含有 3 个线程（线程名字：DubboMonitorSendTimer）的线程池每隔 1min 调用 SimpleMonitorService 遍历发送 statisticsMap 中的统计数据，每发送完毕一个，就重置当前的 Statistics 的 AtomicReference；</li>\n<li>SimpleMonitorService 将这些聚合数据塞入 BlockingQueue queue 中（队列大小为 100000）；</li>\n<li>SimpleMonitorService 使用一个后台线程（线程名为：DubboMonitorAsyncWriteLogThread）将 queue 中的数据写入文件（该线程以死循环的形式来写）；</li>\n<li>SimpleMonitorService 还会使用一个含有 1 个线程（线程名字：DubboMonitorTimer）的线程池每隔 5min 钟，将文件中的统计数据画成图表。</li>\n</ul>\n<h4 id=\"Dubbo提供的线程模型\">Dubbo提供的线程模型</h4>\n<ul>\n<li>all：所有消息都派发到线程池，包括请求，响应，连接事件，断开事件，心跳等。</li>\n<li>direct：所有消息都不派发到线程池，全部在 IO 线程上直接执行。</li>\n<li>execution：只请求消息派发到线程池，不含响应，响应和其它连接断开事件，心跳等消息，直接在 IO 线程上执行。</li>\n<li>connection：在 IO 线程上，将连接断开事件放入队列，有序逐个执行，其它消息派发到线程池。</li>\n</ul>\n<h4 id=\"Dubbo的-内部是怎么转换的\">Dubbo的 内部是怎么转换的</h4>\n<p>1、服务提供方实现类到 Invoker 的转换，是通过 ProxyFactory 类的 getInvoker 方法使用 服务实现类 生成一个 AbstractProxyInvoker 实例，其中使用 wrapper 类消除反射，提高性能。</p>\n<p>2、服务提供方实现 Invoker 到 Exporter 的转换，主要是打开创建一个 Netty Server 侦听服务，并接收客户端发来的各种请求，通讯细节由 Dubbo 自己实现，然后注册服务到服务注册中心。</p>\n<p>3、服务消费方远程服务到 Invoker 的转换，是通过 ReferenceConfig 类的 init 方法调用 Protocol 的 refer 方法生成 Invoker 实例，这是服务消费的关键。</p>\n<p>4、服务消费方 Invoker 到客户端接口的转换，是通过  ProxyFactory 类的 getProxy  方法是实现的</p>\n<h4 id=\"Dubbo的注册中心\">Dubbo的注册中心</h4>\n<p>1、Multicast 注册中心：Multicast 注册中心不需要任何中心节点，只要广播地址，就能进行服务注册和发现，基于网络中组播传输实现。</p>\n<p>2、Zookeeper 注册中心：基于分布式协调系统 Zookeeper 实现，采用 Zookeeper 的 <code>watch</code> 机制实现数据变更。（推荐）</p>\n<p>3、Redis 注册中心：基于 Redis 实现，采用 key/map 存储，key 存储服务名和类型，map 中 key 存储服务 url，value 服务过期时间。基于 Redis 的发布 / 订阅模式通知数据变更。</p>\n<p>4、Simple 注册中心。</p>\n<ul>\n<li>\n<p>注册的时候可以直连某一个服务吗？ 可以点对点直连，修改配置即可，也可以通过 telnet 直接某个服务。</p>\n</li>\n<li>\n<p>服务提供者能实现失效踢出是什么原理？服务失效踢出基于 zookeeper 的临时节点原理。</p>\n</li>\n</ul>\n<h4 id=\"Dubbo-的协议和序列化\">Dubbo 的协议和序列化</h4>\n<p>默认使用 Netty 作为通讯框架。Dubbo 默认使用的序列化方式是 hession2。</p>\n<p>支持的协议：Dubbo「单一长连接和 NIO 异步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议 TCP，异步 Hessian 序列化。Dubbo 推荐使用 dubbo 协议」、RMI、WebServic、HTTP、Hessian、Memcache、Redis：基于 Redis 实现的 RPC 协议。</p>\n<p>支持多种序列化方式：JDK 自带的序列化、hessian2、JSON、Kryo、FST、Protostuff，ProtoBuf 等等。</p>\n<h4 id=\"Dubbo-的设计模式\">Dubbo 的设计模式</h4>\n<p>工厂模式「Provider 在 export 服务时，会调用 ServiceConfig 的 export 方法」、装饰器模式「启动和调用阶段都大量使用了装饰器模式」、观察者模式「Dubbo 的 Provider 启动时，需要与注册中心交互，先注册自己的服务，再订阅自己的服务，订阅时，采用了观察者模式，开启一个 listener」、动态代理模式「Dubbo 扩展 JDK SPI 的类 ExtensionLoader 的 Adaptive 实现」</p>\n<h4 id=\"Dubbo-的服务调用\">Dubbo 的服务调用</h4>\n<p>默认是阻塞的，可以异步调用，没有返回值的可以这么做。Dubbo 是基于 NIO 的非阻塞实现并行调用，客户端不需要启动多线程即可完成并行调用多个远程服务，相对多线程开销较小，异步调用会返回一个 Future 对象。</p>\n<h4 id=\"Dubbo的SPI\">Dubbo的SPI</h4>\n<blockquote>\n<p>什么是<code>SPI(Service Provider Interface)</code>: 一种服务提供者接口机制。允许开发人员定义一个服务接口，然后为该接口提供不同的实现。通过SPI机制，应用程序可以在运行时动态地加载和使用不同的服务提供者，而无需在代码中显式指定具体的实现类。</p>\n<p>原理就是: 将接口的实现类放在配置文件中，我们在程序运行过程中读取配置文件，通过反射加载实现类。这样，可以在运行的时候，动态替换接口的实现类。和 IOC 的解耦思想是类似的。</p>\n</blockquote>\n<p>1、JDK SPI：JDK 标准的 SPI 会一次性加载所有的扩展实现，如果有的扩展很耗时，但也没用上，很浪费资源。所以只希望加载某个的实现，就不现实了。核心思想是在classpath下的<code>META-INF/services</code>目录中提供一个以服务接口全限定名命名的文件，文件内容为服务接口的具体实现类的全限定名，每行一个。这样，当应用程序需要使用某个服务接口时，Java运行时环境会根据<code>META-INF/services</code>目录下的文件加载并实例化相应的服务提供者。</p>\n<p>2、DUBBO SPI：对 Dubbo 进行扩展，不需要改动 Dubbo 的源码；延迟加载，可以一次只加载自己想要加载的扩展实现；增加了扩展点对 <code>IOC</code> 和 <code>AOP</code> 的支持，使得一个扩展点可以直接 <code>setter</code> 注入其它扩展点；Dubbo 的扩展机制能很好的支持第三方 IOC 容器，默认支持 Spring Bean。也是对 Java 原生的 SPI 机制进行了增强，以便更好满足自己的需求</p>\n<h4 id=\"架构设计图\">架构设计图</h4>\n<h4 id=\"启动解析加载配置信息的原理：\">启动解析加载配置信息的原理：</h4>\n<h4 id=\"服务暴露：\">服务暴露：</h4>\n<h4 id=\"服务引用：\">服务引用：</h4>\n<h4 id=\"服务调用\">服务调用</h4>\n","_path":"post/c5176eb2.html","_link":"http://rycan.top/post/c5176eb2.html","_id":"cln1a3w9n001tgg0p8b823eux"}}