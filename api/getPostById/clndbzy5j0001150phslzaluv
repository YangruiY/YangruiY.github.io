{"type":"getPostById","data":{"title":"Docker","date":"2023-07-03T12:49:53.000Z","description":"Docker","categories":[{"name":"中间件","_id":"clndbzy5n0004150pfwrx0sg4"}],"tags":[{"name":"Docker","_id":"clndbzy5o0005150pacqmdoso"}],"content":"<meta name=\"referrer\" content=\"no-referrer\">\n<h2 id=\"Docker基础\">Docker基础</h2>\n<h3 id=\"Docker理念\">Docker理念</h3>\n<p>Docker的主要目标是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到“一次镜像，处处运行”。</p>\n<h3 id=\"Docker-和传统虚拟化方式的不同之处：\">Docker 和传统虚拟化方式的不同之处：</h3>\n<p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；</p>\n<p>容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p>\n<p>每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。</p>\n<h3 id=\"网站\">网站</h3>\n<p>docker官网：<a href=\"http://www.docker.com\">http://www.docker.com</a></p>\n<p>Docker Hub官网: <a href=\"https://hub.docker.com/\">https://hub.docker.com/</a></p>\n<h3 id=\"Docker的基本组成\">Docker的基本组成</h3>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011147288.png\" alt=\"image-20230401114755268\" style=\"zoom:25%;\">\n<p>Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上， 然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。 容器，是一个运行时环境。</p>\n<h4 id=\"镜像-image\">镜像(image)</h4>\n<p>Docker 镜像（Image）就是一个只读的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。</p>\n<h4 id=\"容器-container\">容器(container)</h4>\n<p>Docker 利用容器（Container）独立运行的一个或一组应用，应用程序或服务运行在容器里面，容器就类似于一个虚拟化的运行环境，容器是用镜像创建的运行实例；可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011147698.png\" alt=\"image-20230401114736676\" style=\"zoom: 25%;\">\n<h4 id=\"仓库-repository\">仓库(repository)</h4>\n<p>仓库（Repository）是集中存放镜像文件的场所</p>\n<h3 id=\"总结：\">总结：</h3>\n<ul>\n<li>\n<p>Docker 本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就是image镜像文件。只有通过这个镜像文件才能生成Docker容器实例(类似Java中new出来一个对象)。</p>\n</li>\n<li>\n<p>image镜像文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p>\n</li>\n<li>\n<p>镜像文件</p>\n<ul>\n<li>image 文件生成的容器实例，本身也是一个文件，称为镜像文件。</li>\n</ul>\n</li>\n<li>\n<p>容器实例</p>\n<ul>\n<li>一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一个对应的运行实例，也就是我们的容器</li>\n</ul>\n</li>\n<li>\n<p>仓库</p>\n<ul>\n<li>就是放一堆镜像的地方，我们可以把镜像发布到仓库中，需要的时候再从仓库中拉下来就可以了。</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011151654.png\" alt=\"image-20230401115107633\" style=\"zoom:25%;\">\n<h3 id=\"run过程\">run过程</h3>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011154284.png\" alt=\"image-20230401115411260\" style=\"zoom:20%;\">\n<h3 id=\"Docker底层原理\">Docker底层原理</h3>\n<h4 id=\"为什么Docker会比VM虚拟机快\">为什么Docker会比VM虚拟机快</h4>\n<p><strong>(1)docker有着比虚拟机更少的抽象层</strong></p>\n<p>由于docker不需要Hypervisor(虚拟机)实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。</p>\n<p><strong>(2)docker利用的是宿主机的内核,而不需要加载操作系统OS内核</strong></p>\n<p>当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。进而避免引寻、加载操作系统内核返回等比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载OS,返回新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了返回过程,因此新建一个docker容器只需要几秒钟。</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011156374.png\" style=\"zoom:25%;\">\n<h3 id=\"Docker命令\">Docker命令</h3>\n<h4 id=\"帮助启动类命令\">帮助启动类命令</h4>\n<ul>\n<li>\n<p>启动docker： <code>systemctl start docker</code></p>\n</li>\n<li>\n<p>停止docker： <code>systemctl stop docker</code></p>\n</li>\n<li>\n<p>重启docker： <code>systemctl restart docker</code></p>\n</li>\n<li>\n<p>查看docker状态： <code>systemctl status docker</code></p>\n</li>\n<li>\n<p>开机启动： <code>systemctl enable docker</code></p>\n</li>\n<li>\n<p>查看docker概要信息： <code>docker info</code></p>\n</li>\n<li>\n<p>查看docker总体帮助文档： <code>docker --help</code></p>\n</li>\n<li>\n<p>查看docker命令帮助文档：<code> docker 具体命令 --help</code></p>\n</li>\n</ul>\n<h4 id=\"镜像命令\">镜像命令</h4>\n<ul>\n<li>列出本地主机上的镜像<code>docker images</code></li>\n</ul>\n<blockquote>\n<p>各个选项说明:</p>\n<ul>\n<li>\n<p>REPOSITORY：表示镜像的仓库源</p>\n</li>\n<li>\n<p>TAG：镜像的标签版本号</p>\n</li>\n<li>\n<p>IMAGE ID：镜像ID</p>\n</li>\n<li>\n<p>CREATED：镜像创建时间</p>\n</li>\n<li>\n<p>SIZE：镜像大小</p>\n</li>\n</ul>\n<p>同一仓库源可以有多个 TAG版本，代表这个仓库源的不同个版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。</p>\n<p>如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像</p>\n<ul>\n<li>\n<p>OPTIONS说明：</p>\n</li>\n<li>\n<p>-a :列出本地所有的镜像（含历史映像层）</p>\n</li>\n<li>\n<p>-q :只显示镜像ID。</p>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li><code>docker search</code>某个XXX镜像名字</li>\n</ul>\n<blockquote>\n<ul>\n<li>\n<p>docker search [OPTIONS] 镜像名字</p>\n</li>\n<li>\n<p>OPTIONS说明：</p>\n</li>\n<li>\n<p>–limit : 只列出N个镜像，默认25个</p>\n</li>\n<li>\n<p>docker search --limit 5 redis</p>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li><code>docker pull </code>某个XXX镜像名字</li>\n</ul>\n<blockquote>\n<ul>\n<li>下载镜像</li>\n</ul>\n<p>docker pull 镜像名字[:TAG]<br>\ndocker pull 镜像名字</p>\n<ul>\n<li>没有TAG就是最新版</li>\n</ul>\n<p>等价于</p>\n<p>docker pull 镜像名字:latest<br>\ndocker pull ubuntu</p>\n</blockquote>\n<ul>\n<li>\n<p>查看镜像/容器/数据卷所占的空间 <code>docker system df </code></p>\n</li>\n<li>\n<p><code>docker rmi</code> 某个XXX镜像名字ID</p>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>删除单个</li>\n</ul>\n<p><code>docker rmi -f 镜像ID</code></p>\n<ul>\n<li>删除多个</li>\n</ul>\n<p><code>docker rmi -f 镜像名1:TAG 镜像名2:TAG </code></p>\n<ul>\n<li>删除全部</li>\n</ul>\n<p><code>docker rmi -f $(docker images -qa)</code></p>\n</blockquote>\n<p>==注 ： Docker虚悬镜像==</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011205430.png\" alt=\"image-20230401120548407\" style=\"zoom:25%;\">\n<h4 id=\"新建-启动容器\">新建+启动容器</h4>\n<p><code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code></p>\n<blockquote>\n<ul>\n<li>OPTIONS说明</li>\n</ul>\n<p>OPTIONS说明（常用）：有些是一个减号，有些是两个减号</p>\n<ul>\n<li>\n<p>–name=“容器新名字”       为容器指定一个名称；</p>\n</li>\n<li>\n<p>-d:  后台运行容器并返回容器ID，也即<strong>启动守护式容器</strong>(后台运行)；</p>\n</li>\n<li>\n<p>-i： 以交互模式运行容器，通常与 -t 同时使用；</p>\n</li>\n<li>\n<p>-t： 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</p>\n</li>\n<li>\n<p>-it:  也即<strong>启动交互式容器</strong>(前台有伪终端，等待交互)；</p>\n</li>\n<li>\n<p>-P:  随机端口映射，大写P</p>\n</li>\n<li>\n<p>-p:  指定端口映射，小写p</p>\n</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011208457.png\" alt=\"image-20230401120800433\" style=\"zoom:25%;\">\n</blockquote>\n<ul>\n<li>使用镜像centos:latest以<strong>交互模式</strong>启动一个容器,在容器内执行/bin/bash命令<code>docker run -it centos /bin/bash </code></li>\n</ul>\n<blockquote>\n<ul>\n<li>\n<p>参数说明：</p>\n</li>\n<li>\n<p>-i: 交互式操作。</p>\n</li>\n<li>\n<p>-t: 终端。</p>\n</li>\n<li>\n<p>centos : centos 镜像。</p>\n</li>\n<li>\n<p>/bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。</p>\n</li>\n<li>\n<p>要退出终端，直接输入 exit:</p>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li>列出当前所有正在运行的容器 <code>docker ps [OPTIONS]</code></li>\n</ul>\n<blockquote>\n<ul>\n<li>\n<p>OPTIONS说明（常用）：</p>\n</li>\n<li>\n<p>-a :列出当前所有正在运行的容器+历史上运行过的</p>\n</li>\n<li>\n<p>-l :显示最近创建的容器。</p>\n</li>\n<li>\n<p>-n：显示最近n个创建的容器。</p>\n</li>\n<li>\n<p>-q :静默模式，只显示容器编号。</p>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li>退出容器</li>\n</ul>\n<blockquote>\n<p>两种退出方式</p>\n<ul>\n<li>\n<p>exit                run进去容器，exit退出，容器停止</p>\n</li>\n<li>\n<p>ctrl+p+q         run进去容器，ctrl+p+q退出，容器不停止</p>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li>\n<p>启动已停止运行的容器\t<code>docker start 容器ID或者容器名</code></p>\n</li>\n<li>\n<p>重启容器\t <code>docker restart 容器ID或者容器名</code></p>\n</li>\n<li>\n<p>停止容器      <code>docker stop 容器ID或者容器名</code></p>\n</li>\n<li>\n<p>强制停止容器      <code>docker kill 容器ID或容器名</code></p>\n</li>\n<li>\n<p>删除已停止的容器   <code> docker rm 容器ID</code></p>\n</li>\n<li>\n<p>一次性删除多个容器实例</p>\n</li>\n</ul>\n<blockquote>\n<p><code>docker rm -f $(docker ps -a -q) docker ps -a -q | xargs docker rm</code></p>\n</blockquote>\n<h4 id=\"启动守护式容器-后台服务器\">启动守护式容器(后台服务器)</h4>\n<p>在大部分的场景下，我们希望 docker 的服务是在后台运行的， 我们可以过 -d 指定容器的后台运行模式。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d 容器名</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>比如：使用镜像centos:latest以后台模式启动一个容器</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;docker run -d centos</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h5 id=\"问题：docker-ps-a-进行查看-会发现容器已经退出\">问题：docker ps -a 进行查看, 会发现容器已经退出</h5>\n<blockquote>\n<p>很重要的要说明的一点: <strong>Docker容器后台运行,就必须有一个前台进程。</strong></p>\n<p>容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），就是会自动退出的。</p>\n<p>这个是docker的机制问题,比如你的web容器,我们以nginx为例，正常情况下,我们配置启动服务只需要启动响应的service即可。例如service nginx start。但是,这样做,nginx为后台进程模式运行,就导致docker前台没有运行的应用，这样的容器后台启动后，会立即自杀因为他觉得他没事可做了。所以，最佳的解决方案是将你要运行的程序以  前台进程的形式运行，常见就是命令行模式，表示我还有交互操作，别中断。</p>\n</blockquote>\n<h5 id=\"redis-前后台启动演示case\">redis 前后台启动演示case</h5>\n<blockquote>\n<p><strong>前台交互式启动</strong></p>\n<p><code>docker run -it redis:6.0.8</code></p>\n<p><strong>后台守护式启动</strong></p>\n<p><code>docker run -d redis:6.0.8</code></p>\n<p><strong>查看容器日志</strong></p>\n<p><code>docker logs 容器ID</code></p>\n<p><strong>查看容器内运行的进程</strong></p>\n<p><code>docker top 容器ID</code></p>\n<p><strong>查看容器内部细节</strong></p>\n<p><code>docker inspect 容器ID</code></p>\n<p><strong>进入正在运行的容器并以命令行交互</strong></p>\n<p><code>docker exec -it 容器ID bashShell</code></p>\n<blockquote>\n<ul>\n<li>另一种重新进入的方法：</li>\n</ul>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>重新进入      <code>docker attach 容器ID</code></p>\n</blockquote>\n</blockquote>\n<blockquote>\n<ul>\n<li>两者的区别</li>\n<li>attach 直接进入容器启动命令的终端，不会启动新的进程 用exit退出，会导致容器的停止。</li>\n<li>exec 是在容器中打开新的终端，并且可以启动新的进程 用exit退出，不会导致容器的停止。</li>\n<li>推荐大家使用 docker exec 命令，因为退出容器终端，不会导致容器的停止；一般用-d后台启动的程序，再用exec进入对应容器实例</li>\n</ul>\n</blockquote>\n<p><strong>从容器内拷贝文件到主机上</strong></p>\n<p>容器→主机     <code>docker cp 容器ID:容器内路径 目的主机路径</code></p>\n<p><strong>导入和导出容器</strong></p>\n<ul>\n<li>\n<p><code>export </code>导出容器的内容留作为一个tar归档文件[对应import命令]</p>\n</li>\n<li>\n<p><code>import </code>从tar包中的内容创建一个新的文件系统再导入为镜像[对应export]</p>\n</li>\n</ul>\n<p><code>docker export 容器ID &gt; 文件名.tar</code></p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011221845.png\" alt=\"img\" style=\"zoom:25%;\">\n<blockquote>\n<p>cat 文件名.tar | docker import - 镜像用户/镜像名:镜像版本号</p>\n</blockquote>\n<blockquote>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011222875.png\" alt=\"image-20230401122231846\" style=\"zoom:25%;\">\n</blockquote>\n</blockquote>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011224695.png\" alt=\"image-20230401122443662\" style=\"zoom:45%;\">\n<h4 id=\"总结\">总结:</h4>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011225121.png\" alt></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">attach    Attach to a running container                 # 当前 shell 下 attach 连接指定运行镜像</span><br><span class=\"line\"></span><br><span class=\"line\">build     Build an image from a Dockerfile              # 通过 Dockerfile 定制镜像</span><br><span class=\"line\"></span><br><span class=\"line\">commit    Create a new image from a container changes   # 提交当前容器为新的镜像</span><br><span class=\"line\"></span><br><span class=\"line\">cp        Copy files/folders from the containers filesystem to the host path   #从容器中拷贝指定文件或者目录到宿主机中</span><br><span class=\"line\"></span><br><span class=\"line\">create    Create a new container                        # 创建一个新的容器，同 run，但不启动容器</span><br><span class=\"line\"></span><br><span class=\"line\">diff      Inspect changes on a container&#x27;s filesystem   # 查看 docker 容器变化</span><br><span class=\"line\"></span><br><span class=\"line\">events    Get real time events from the server          # 从 docker 服务获取容器实时事件</span><br><span class=\"line\"></span><br><span class=\"line\">exec      Run a command in an existing container        # 在已存在的容器上运行命令</span><br><span class=\"line\"></span><br><span class=\"line\">export    Stream the contents of a container as a tar archive   # 导出容器的内容流作为一个 tar 归档文件[对应 import ]</span><br><span class=\"line\"></span><br><span class=\"line\">history   Show the history of an image                  # 展示一个镜像形成历史</span><br><span class=\"line\"></span><br><span class=\"line\">images    List images                                   # 列出系统当前镜像</span><br><span class=\"line\"></span><br><span class=\"line\">import    Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]</span><br><span class=\"line\"></span><br><span class=\"line\">info      Display system-wide information               # 显示系统相关信息</span><br><span class=\"line\"></span><br><span class=\"line\">inspect   Return low-level information on a container   # 查看容器详细信息</span><br><span class=\"line\"></span><br><span class=\"line\">kill      Kill a running container                      # kill 指定 docker 容器</span><br><span class=\"line\"></span><br><span class=\"line\">load      Load an image from a tar archive              # 从一个 tar 包中加载一个镜像[对应 save]</span><br><span class=\"line\"></span><br><span class=\"line\">login     Register or Login to the docker registry server    # 注册或者登陆一个 docker 源服务器</span><br><span class=\"line\"></span><br><span class=\"line\">logout    Log out from a Docker registry server          # 从当前 Docker registry 退出</span><br><span class=\"line\"></span><br><span class=\"line\">logs      Fetch the logs of a container                 # 输出当前容器日志信息</span><br><span class=\"line\"></span><br><span class=\"line\">port      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT    # 查看映射端口对应的容器内部源端口</span><br><span class=\"line\"></span><br><span class=\"line\">pause     Pause all processes within a container        # 暂停容器</span><br><span class=\"line\"></span><br><span class=\"line\">ps        List containers                               # 列出容器列表</span><br><span class=\"line\"></span><br><span class=\"line\">pull      Pull an image or a repository from the docker registry server   # 从docker镜像源服务器拉取指定镜像或者库镜像</span><br><span class=\"line\"></span><br><span class=\"line\">push      Push an image or a repository to the docker registry server    # 推送指定镜像或者库镜像至docker源服务器</span><br><span class=\"line\"></span><br><span class=\"line\">restart   Restart a running container                   # 重启运行的容器</span><br><span class=\"line\"></span><br><span class=\"line\">rm        Remove one or more containers                 # 移除一个或者多个容器</span><br><span class=\"line\"></span><br><span class=\"line\">rmi       Remove one or more images       # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]</span><br><span class=\"line\"></span><br><span class=\"line\">run       Run a command in a new container              # 创建一个新的容器并运行一个命令</span><br><span class=\"line\"></span><br><span class=\"line\">save      Save an image to a tar archive                # 保存一个镜像为一个 tar 包[对应 load]</span><br><span class=\"line\"></span><br><span class=\"line\">search    Search for an image on the Docker Hub         # 在 docker hub 中搜索镜像</span><br><span class=\"line\"></span><br><span class=\"line\">start     Start a stopped containers                    # 启动容器</span><br><span class=\"line\"></span><br><span class=\"line\">stop      Stop a running containers                     # 停止容器</span><br><span class=\"line\"></span><br><span class=\"line\">tag       Tag an image into a repository                # 给源中镜像打标签</span><br><span class=\"line\"></span><br><span class=\"line\">top       Lookup the running processes of a container   # 查看容器中运行的进程信息</span><br><span class=\"line\"></span><br><span class=\"line\">unpause   Unpause a paused container                    # 取消暂停容器</span><br><span class=\"line\"></span><br><span class=\"line\">version   Show the docker version information           # 查看 docker 版本号</span><br><span class=\"line\"></span><br><span class=\"line\">wait      Block until a container stops, then print its exit code   # 截取容器停止时的退出状态值</span><br></pre></td></tr></table></figure>\n<h3 id=\"Docker镜像\">Docker镜像</h3>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305191142128.png\" alt></p>\n<p>一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好形成一个可交付的运行环境(包括代码、运行时需要的库、环境变量和配置文件等)，这个打包好的运行环境就是image镜像文件。</p>\n<h4 id=\"UnionFS（联合文件系统）\">UnionFS（联合文件系统）</h4>\n<p>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p>\n<p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p>\n<h4 id=\"Docker镜像加载原理\">Docker镜像加载原理</h4>\n<ul>\n<li>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</li>\n<li>bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是引导文件系统bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</li>\n<li>rootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。</li>\n</ul>\n<blockquote>\n<p>平时我们安装进虚拟机的CentOS都是好几个G，为什么docker这里才200M？</p>\n<ul>\n<li>对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。</li>\n</ul>\n</blockquote>\n<h4 id=\"为什么-Docker-镜像要采用这种分层结构呢\">为什么 Docker 镜像要采用这种分层结构呢</h4>\n<p>镜像分层最大的一个好处就是共享资源，方便复制迁移，就是为了复用。</p>\n<blockquote>\n<p>Docker镜像层是只读的，容器层是可写的。当容器启动时，一个新的可写层被加载到镜像的顶部。 这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p>\n<p>所有对容器的改动 - 无论添加、删除、还是修改文件都只会发生在容器层中。只有容器层是可写的，容器层下面的所有镜像层都是只读的。</p>\n</blockquote>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011232707.png\" alt=\"img\" style=\"zoom:33%;\">\n<h4 id=\"Docker镜像commit操作案例\">Docker镜像commit操作案例</h4>\n<p>docker commit 提交容器副本使之成为一个新的镜像</p>\n<p><code>docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器ID 要创建的目标镜像名:[标签名]</code></p>\n<p><strong>安装完成后，commit我们自己的新镜像</strong></p>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011436841.png\" alt></p>\n<p><strong>启动我们的新镜像并和原来的对比</strong></p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011436021.png\" alt=\"img\" style=\"zoom:35%;\">\n<ol>\n<li>\n<ol>\n<li>官网是默认下载的Ubuntu没有vim命令</li>\n</ol>\n</li>\n<li>我们自己commit构建的镜像，新增加了vim功能，可以成功使用。</li>\n</ol>\n<h4 id=\"总结-2\">总结</h4>\n<p>Docker中的镜像分层，支持通过扩展现有镜像，创建新的镜像。类似Java继承于一个Base基础类，自己再按需扩展。</p>\n<p>新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011436090.png\" alt=\"img\" style=\"zoom:35%;\">\n<h3 id=\"本地镜像发布到阿里云\">本地镜像发布到阿里云</h3>\n<h4 id=\"镜像的生成方法\">镜像的生成方法</h4>\n<p>基于当前容器创建一个新的镜像，新功能增强 <code>docker commit [OPTIONS] 容器ID [REPOSITORY[:TAG]]</code></p>\n<blockquote>\n<ul>\n<li>\n<p>OPTIONS说明：</p>\n</li>\n<li>\n<p>-a :提交的镜像作者；</p>\n</li>\n<li>\n<p>-m :提交时的说明文字；</p>\n</li>\n</ul>\n</blockquote>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011441522.png\" alt=\"image-20230401144133486\" style=\"zoom:33%;\">\n<h4 id=\"将本地镜像推送到阿里云\">将本地镜像推送到阿里云</h4>\n<p>阿里云开发者平台  <a href=\"https://promotion.aliyun.com/ntms/act/kubernetes.html\">https://promotion.aliyun.com/ntms/act/kubernetes.html</a></p>\n<h4 id=\"将镜像推送到阿里云\">将镜像推送到阿里云</h4>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011446183.png\" style=\"zoom:33%;\">\n<h4 id=\"将阿里云上的镜像下载到本地\">将阿里云上的镜像下载到本地</h4>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011442873.png\" alt=\"image-20230401144252838\" style=\"zoom:33%;\">\n<h3 id=\"本地镜像发布到私有库\">本地镜像发布到私有库</h3>\n<blockquote>\n<p>官方Docker Hub地址：<a href=\"https://hub.docker.com/\">https://hub.docker.com/</a></p>\n<p>Dockerhub、阿里云这样的公共镜像仓库可能不太方便，涉及机密的公司不可能提供镜像给公网，所以需要创建一个本地私人仓库供给团队使用，基于公司内部项目构建镜像。</p>\n<p>Docker Registry是官方提供的工具，可以用于构建私有镜像仓库</p>\n</blockquote>\n<h4 id=\"将本地镜像推送到私有库\">将本地镜像推送到私有库</h4>\n<h5 id=\"下载镜像Docker-Registry\">下载镜像Docker Registry</h5>\n<p><code>docker pull registry </code></p>\n<h5 id=\"运行私有库Registry，相当于本地有个私有Docker-hub\">运行私有库Registry，相当于本地有个私有Docker hub</h5>\n<p><code>docker run -d -p 5000:5000  -v /zzyyuse/myregistry/:/tmp/registry --privileged=true registry</code></p>\n<h5 id=\"commit我们自己的新镜像\">commit我们自己的新镜像</h5>\n<p><code>docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器ID 要创建的目标镜像名:[标签名]</code></p>\n<p>命令：在<strong>容器外</strong>执行</p>\n<p><code>docker commit -m=&quot;ifconfig cmd add&quot; -a=&quot;zzyy&quot; a69d7c825c4f zzyyubuntu:1.2</code></p>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011445282.png\" alt></p>\n<h4 id=\"curl验证私服库上有什么镜像\">curl验证私服库上有什么镜像</h4>\n<p><code>curl -XGET http://172.16.108.129:5000/v2/_catalog</code></p>\n<h5 id=\"将新镜像zzyyubuntu-1-2修改符合私服规范的Tag\">将新镜像zzyyubuntu:1.2修改符合私服规范的Tag</h5>\n<p>按照公式： <code>docker tag   镜像:Tag   Host:Port/Repository:Tag</code></p>\n<p>如：<code>docker tag  zzyyubuntu:1.2  192.168.111.162:5000/zzyyubuntu:1.2</code></p>\n<h5 id=\"修改配置文件使之支持http\">修改配置文件使之支持http</h5>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011448141.png\" alt=\"image-20230401144849106\" style=\"zoom:33%;\">\n<blockquote>\n<p>docker默认不允许http方式推送镜像，通过配置选项来取消这个限制。====&gt; 修改完后如果不生效，建议重启docker。</p>\n</blockquote>\n<h5 id=\"push推送到私服库\">push推送到私服库</h5>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011449802.png\" alt=\"image-20230401144939769\" style=\"zoom:33%;\">\n<h5 id=\"curl验证私服库上有什么镜像-2\">curl验证私服库上有什么镜像</h5>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011449795.png\" alt=\"image-20230401144955759\" style=\"zoom:33%;\">\n<h5 id=\"pull到本地并运行\">pull到本地并运行</h5>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011450484.png\" alt=\"image-20230401145032447\" style=\"zoom:33%;\">\n<h3 id=\"Docker容器数据卷\">Docker容器数据卷</h3>\n<h4 id=\"容器卷记得加入\">容器卷记得加入</h4>\n<p><code>--privileged=true</code></p>\n<blockquote>\n<p>Docker挂载主机目录访问如果出现cannot open directory .: Permission denied</p>\n</blockquote>\n<p><strong>解决办法：在挂载目录后多加一个–privileged=true参数即可</strong></p>\n<p>如果是CentOS7安全模块会比之前系统版本加强，不安全的会先禁止，所以目录挂载的情况被默认为不安全的行为，在SELinux里面挂载目录被禁止掉了，如果要开启，我们一般使用<code>--privileged=true</code>命令，扩大容器的权限解决挂载目录没有权限的问题，也即使用该参数，container内的root拥有真正的root权限，否则，container内的root只是外部的一个普通用户权限。</p>\n<h4 id=\"是什么\">是什么</h4>\n<p>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性：卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。</p>\n<p><strong>一句话：有点类似我们Redis里面的rdb和aof文件。</strong></p>\n<p>将docker容器内的数据保存进宿主机的磁盘中，运行一个带有容器卷存储功能的容器实例。</p>\n<p><code>docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录   镜像名</code></p>\n<h4 id=\"作用\">作用</h4>\n<p>为了能保存数据在docker中我们使用卷</p>\n<blockquote>\n<p>特点：</p>\n<ol>\n<li><strong>数据卷可在容器之间共享或重用数据</strong></li>\n<li><strong>卷中的更改可以直接实时生效，爽</strong></li>\n<li><strong>数据卷中的更改不会包含在镜像的更新中</strong></li>\n<li><strong>数据卷的生命周期一直持续到没有容器使用它为止</strong></li>\n</ol>\n</blockquote>\n<h4 id=\"数据卷案例\">数据卷案例</h4>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011507312.png\" alt></p>\n<h5 id=\"1-宿主vs容器之间映射添加容器卷\">1 宿主vs容器之间映射添加容器卷</h5>\n<p><code>直接命令添加</code></p>\n<p><code>docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录 镜像名</code></p>\n<p>公式：<code>docker run -it -v /宿主机目录:/容器内目录 ubuntu /bin/bash</code></p>\n<p><code>docker run -it --name myu3 --privileged=true -v /tmp/myHostData:/tmp/myDockerData ubuntu /bin/bash</code></p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011457756.png\" style=\"zoom:25%;\">\n<p><strong>查看数据卷是否挂载成功</strong>   <code>docker inspect 容器ID</code></p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011458135.png\" alt=\"image-20230401145802112\" style=\"zoom:25%;\">\n<p><strong>容器和宿主机之间数据共享</strong></p>\n<blockquote>\n<ol>\n<li>docker修改，主机同步获得 。</li>\n<li>主机修改，docker同步获得。</li>\n<li>docker容器stop，主机修改，docker容器重启数据同步</li>\n</ol>\n</blockquote>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011455958.png\" alt=\"img\" style=\"zoom:25%;\">\n<h5 id=\"2-读写规则映射添加说明\">2 读写规则映射添加说明</h5>\n<p>读写(默认)  <code>docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录:rw 镜像名</code></p>\n<p>默认同上案例，默认就是rw</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011459152.png\" alt=\"image-20230401145933130\" style=\"zoom:33%;\">\n<p>只读        容器实例内部被限制，只能读取不能写</p>\n<blockquote>\n<p>/容器目录:ro 镜像名               就能完成功能，此时容器自己只能读取不能写</p>\n<p>此时如果宿主机写入内容，可以同步给容器内，容器可以读取到。</p>\n<p>​\t\t<code>docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录:ro 镜像名</code></p>\n</blockquote>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011500515.png\" alt=\"image-20230401150027489\" style=\"zoom:33%;\">\n<h5 id=\"3-卷的继承和共享\">3 卷的继承和共享</h5>\n<p>容器1完成和宿主机的映射 <code>docker run -it  --privileged=true -v /mydocker/u:/tmp --name u1 ubuntu</code></p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011501748.png\" alt=\"image-20230401150135721\" style=\"zoom:25%;\">\n<p>容器2继承容器1的卷规则 <code>docker run -it  --privileged=true --volumes-from 父类  --name u2 ubuntu</code></p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011455985.png\" alt=\"img\" style=\"zoom:25%;\">\n<p>数据卷的作用：</p>\n<ul>\n<li>将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全</li>\n</ul>\n<p>数据卷操作：</p>\n<ul>\n<li>docker volume create：创建数据卷</li>\n<li>docker volume ls：查看所有数据卷</li>\n<li>docker volume inspect：查看数据卷详细信息，包括关联的宿主机目录位置</li>\n<li>docker volume rm：删除指定数据卷</li>\n<li>docker volume prune：删除所有未使用的数据卷</li>\n</ul>\n<p>挂载数据卷</p>\n<ul>\n<li>我们在创建容器时，可以通过<code> -v</code> 参数来挂载一个数据卷到某个容器内目录，命令格式如下：</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run \\</span><br><span class=\"line\">  --name mn \\</span><br><span class=\"line\">  -v html:/root/html \\</span><br><span class=\"line\">  -p 8080:80</span><br><span class=\"line\">  nginx \\</span><br></pre></td></tr></table></figure>\n<p>这里的<code>-v</code>就是挂载数据卷的命令：</p>\n<ul>\n<li><code>-v html:/root/htm</code> ：把<code>html</code>数据卷挂载到容器内的<code>/root/html</code>这个目录中</li>\n</ul>\n<h3 id=\"Docker常规安装\">Docker常规安装</h3>\n<h4 id=\"总体步骤\">总体步骤</h4>\n<blockquote>\n<ol>\n<li>搜索镜像</li>\n<li>拉取镜像</li>\n<li>查看镜像</li>\n<li>启动镜像 - 服务端口映射</li>\n<li>停止容器</li>\n<li>移除容器</li>\n</ol>\n</blockquote>\n<h2 id=\"Docker-进阶\">Docker 进阶</h2>\n<p>实验有时间可做  参考： <strong>尚硅谷文档 + <a href=\"https://www.yuque.com/tmfl/cloud/ixlgsl#94eae42b\">https://www.yuque.com/tmfl/cloud/ixlgsl#94eae42b</a></strong></p>\n<h3 id=\"MySQL主从复制\">MySQL主从复制</h3>\n<p><a href=\"https://blog.csdn.net/Guzarish/article/details/123244487\">https://blog.csdn.net/Guzarish/article/details/123244487</a></p>\n<h4 id=\"主从复制原理\">主从复制原理</h4>\n<p><a href=\"https://blog.csdn.net/Guzarish/article/details/123244487\">https://blog.csdn.net/Guzarish/article/details/123244487</a></p>\n<h4 id=\"主从搭建步骤\">主从搭建步骤</h4>\n<img src=\"/post/../Library/Application%20Support/typora-user-images/image-20230401151032867.png\" alt=\"image-20230401151032867\" style=\"zoom:33%;\">\n<p>1、新建主服务器容器实例3307</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -p 3307:3306 --name mysql-master \\</span><br><span class=\"line\">-v /mydata/mysql-master/log:/var/log/mysql \\</span><br><span class=\"line\">-v /mydata/mysql-master/data:/var/lib/mysql \\</span><br><span class=\"line\">-v /mydata/mysql-master/conf:/etc/mysql \\</span><br><span class=\"line\">-e MYSQL_ROOT_PASSWORD=root  \\</span><br><span class=\"line\">-d mysql:5.7</span><br></pre></td></tr></table></figure>\n<p>2、进入/mydata/mysql-master/conf目录下新建my.cnf   <code>vim my.cnf</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\"><span class=\"comment\">## 设置server_id，同一局域网中需要唯一</span></span><br><span class=\"line\">server_id=101 </span><br><span class=\"line\"><span class=\"comment\">## 指定不需要同步的数据库名称</span></span><br><span class=\"line\">binlog-ignore-db=mysql  </span><br><span class=\"line\"><span class=\"comment\">## 开启二进制日志功能</span></span><br><span class=\"line\">log-bin=mall-mysql-bin  </span><br><span class=\"line\"><span class=\"comment\">## 设置二进制日志使用内存大小（事务）</span></span><br><span class=\"line\">binlog_cache_size=1M  </span><br><span class=\"line\"><span class=\"comment\">## 设置使用的二进制日志格式（mixed,statement,row）</span></span><br><span class=\"line\">binlog_format=mixed  </span><br><span class=\"line\"><span class=\"comment\">## 二进制日志过期清理时间。默认值为0，表示不自动清理。</span></span><br><span class=\"line\">expire_logs_days=7  </span><br><span class=\"line\"><span class=\"comment\">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span></span><br><span class=\"line\"><span class=\"comment\">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span></span><br><span class=\"line\">slave_skip_errors=1062</span><br></pre></td></tr></table></figure>\n<p>3、修改完配置后重启master实例</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker restart mysql-master</span><br></pre></td></tr></table></figure>\n<p>4、进入mysql-master容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">exec</span> -it mysql-master /bin/bash</span><br><span class=\"line\">mysql -uroot -proot</span><br></pre></td></tr></table></figure>\n<p>5、master容器实例内创建数据同步用户</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE USER <span class=\"string\">&#x27;slave&#x27;</span>@<span class=\"string\">&#x27;%&#x27;</span> IDENTIFIED BY <span class=\"string\">&#x27;123456&#x27;</span>;</span><br><span class=\"line\">GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO <span class=\"string\">&#x27;slave&#x27;</span>@<span class=\"string\">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p>6、新建从服务器容器实例3308</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -p 3308:3306 --name mysql-slave \\</span><br><span class=\"line\">-v /mydata/mysql-slave/log:/var/log/mysql \\</span><br><span class=\"line\">-v /mydata/mysql-slave/data:/var/lib/mysql \\</span><br><span class=\"line\">-v /mydata/mysql-slave/conf:/etc/mysql \\</span><br><span class=\"line\">-e MYSQL_ROOT_PASSWORD=root  \\</span><br><span class=\"line\">-d mysql:5.7</span><br></pre></td></tr></table></figure>\n<p>7、进入/mydata/mysql-slave/conf目录下新建my.cnf   <code>vim my.cnf</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\"><span class=\"comment\">## 设置server_id，同一局域网中需要唯一</span></span><br><span class=\"line\">server_id=102</span><br><span class=\"line\"><span class=\"comment\">## 指定不需要同步的数据库名称</span></span><br><span class=\"line\">binlog-ignore-db=mysql  </span><br><span class=\"line\"><span class=\"comment\">## 开启二进制日志功能，以备Slave作为其它数据库实例的Master时使用</span></span><br><span class=\"line\">log-bin=mall-mysql-slave1-bin  </span><br><span class=\"line\"><span class=\"comment\">## 设置二进制日志使用内存大小（事务）</span></span><br><span class=\"line\">binlog_cache_size=1M  </span><br><span class=\"line\"><span class=\"comment\">## 设置使用的二进制日志格式（mixed,statement,row）</span></span><br><span class=\"line\">binlog_format=mixed  </span><br><span class=\"line\"><span class=\"comment\">## 二进制日志过期清理时间。默认值为0，表示不自动清理。</span></span><br><span class=\"line\">expire_logs_days=7  </span><br><span class=\"line\"><span class=\"comment\">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span></span><br><span class=\"line\"><span class=\"comment\">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span></span><br><span class=\"line\">slave_skip_errors=1062  </span><br><span class=\"line\"><span class=\"comment\">## relay_log配置中继日志</span></span><br><span class=\"line\">relay_log=mall-mysql-relay-bin  </span><br><span class=\"line\"><span class=\"comment\">## log_slave_updates表示slave将复制事件写进自己的二进制日志</span></span><br><span class=\"line\">log_slave_updates=1  </span><br><span class=\"line\"><span class=\"comment\">## slave设置为只读（具有super权限的用户除外）</span></span><br><span class=\"line\">read_only=1</span><br></pre></td></tr></table></figure>\n<p>8、修改完配置后重启slave实例</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker restart mysql-slave</span><br></pre></td></tr></table></figure>\n<p>9、在主数据库中查看主从同步状态</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show master status;</span><br></pre></td></tr></table></figure>\n<p>10、进入mysql-slave容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">exec</span> -it mysql-slave /bin/bash</span><br><span class=\"line\">mysql -uroot -proot</span><br></pre></td></tr></table></figure>\n<p>11、在从数据库中配置主从复制</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">change master to master_host=<span class=\"string\">&#x27;宿主机ip&#x27;</span>, master_user=<span class=\"string\">&#x27;slave&#x27;</span>, master_password=<span class=\"string\">&#x27;123456&#x27;</span>, </span><br><span class=\"line\">master_port=3307, master_log_file=<span class=\"string\">&#x27;mall-mysql-bin.000001&#x27;</span>, master_log_pos=617, master_connect_retry=30;</span><br></pre></td></tr></table></figure>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011510292.png\" alt=\"img\" style=\"zoom:25%;\">\n<blockquote>\n<p>主从复制命令参数说明</p>\n<ul>\n<li>\n<p>master_host：主数据库的IP地址；</p>\n</li>\n<li>\n<p>master_port：主数据库的运行端口；</p>\n</li>\n<li>\n<p>master_user：在主数据库创建的用于同步数据的用户账号；</p>\n</li>\n<li>\n<p>master_password：在主数据库创建的用于同步数据的用户密码；</p>\n</li>\n<li>\n<p>master_log_file：指定从数据库要复制数据的日志文件，通过查看主数据的状态，获取File参数；</p>\n</li>\n<li>\n<p>master_log_pos：指定从数据库从哪个位置开始复制数据，通过查看主数据的状态，获取Position参数；</p>\n</li>\n<li>\n<p>master_connect_retry：连接失败重试的时间间隔，单位为秒。</p>\n</li>\n</ul>\n</blockquote>\n<p>12、在从数据库中查看主从同步状态</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show slave status \\G;</span><br></pre></td></tr></table></figure>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011510845.png\" alt=\"img\" style=\"zoom:25%;\">\n<p>13、在从数据库中开启主从同步</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start slave;</span><br></pre></td></tr></table></figure>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011515863.png\" alt=\"image-20230401151540796\" style=\"zoom:33%;\">\n<p>14、查看从数据库状态发现已经同步</p>\n<img src=\"/post/../Library/Application%20Support/typora-user-images/image-20230401151557453.png\" alt=\"image-20230401151557453\" style=\"zoom: 25%;\">\n<p>15、主从复制测试</p>\n<ol>\n<li>\n<ul>\n<li>主机新建库-使用库-新建表-插入数据，ok</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>从机使用库-查看记录，ok</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"redis集群\">redis集群</h3>\n<ul>\n<li>\n<p>cluster(集群)模式-docker版</p>\n</li>\n<li>\n<p>哈希槽分区进行亿级数据存储</p>\n</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011517830.png\" alt=\"image-20230401151750776\" style=\"zoom:33%;\">\n<h4 id=\"题目\">题目</h4>\n<p><strong>Q</strong>\t\t1~2亿条数据需要缓存，请问如何设计这个存储案例？</p>\n<p><strong>A</strong>\t\t单机单台100%不可能，肯定是分布式存储，用redis如何落地？</p>\n<p>上述问题阿里P6~P7工程案例和场景设计类必考题目， 一般业界有==3种解决方案==</p>\n<h4 id=\"3种解决方案\">3种解决方案</h4>\n<h5 id=\"1、哈希取余分区\">1、哈希取余分区</h5>\n<img src=\"https://cdn.nlark.com/yuque/0/2022/png/27791237/1658996785793-2ca8867b-2254-45ee-8bc7-8f566d737db2.png\" alt=\"img\" style=\"zoom: 50%;\">\n<p>2亿条记录就是2亿个k,v，我们必须要分布式多机，假设有3台机器构成一个集群，用户每次读写操作都是根据公式：</p>\n<p>hash(key) % N个机器台数，计算出哈希值，用来决定数据映射到哪一个节点上。</p>\n<p><strong>优点：</strong></p>\n<p>简单粗暴，直接有效，只需要预估好数据规划好节点，例如3台、8台、10台，就能保证一段时间的数据支撑。使用Hash算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求（并维护这些请求的信息），起到负载均衡+分而治之的作用。</p>\n<p><strong>缺点：</strong></p>\n<p>原来规划好的节点，进行扩容或者缩容就比较麻烦了额，不管扩缩，每次数据变动导致节点有变动，映射关系需要重新进行计算，在服务器个数固定不变时没有问题，如果需要弹性扩容或故障停机的情况下，原来的取模公式就会发生变化：Hash(key)/3会变成Hash(key)/?。此时地址经过取余运算的结果将发生很大变化，根据公式获取的服务器也会变得不可控。</p>\n<p>某个redis机器宕机了，由于台数数量变化，会导致hash取余全部数据重新洗牌。</p>\n<h5 id=\"2、一致性哈希算法分区\">2、一致性哈希算法分区</h5>\n<p>一致性Hash算法背景</p>\n<p>一致性哈希算法在1997年由麻省理工学院中提出的，设计目标是为了解决分布式缓存数据变动和映射问题，某个机器宕机了，分母数量改变了，自然取余数不行了。</p>\n<p>目的</p>\n<p>​\t\t当服务器个数发生变动时， 尽量减少影响客户端到服务器的映射关系</p>\n<h6 id=\"3大步骤\">3大步骤</h6>\n<p><strong>算法构建一致性哈希环</strong></p>\n<p>一致性哈希环</p>\n<blockquote>\n<p>​\t一致性哈希算法必然有个hash函数并按照算法产生hash值，这个算法的所有可能哈希值会构成一个全量集，这个集合可以成为一个hash空间[0,2^32-1]，这个是一个线性空间，但是在算法中，我们通过适当的逻辑控制将它首尾相连(0 = 2^32),这样让它逻辑上形成了一个环形空间。</p>\n<p>​\t它也是按照使用取模的方法，前面笔记介绍的节点取模法是对节点（服务器）的数量进行取模。而一致性Hash算法是对2^32取模，简单来说，一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形），整个哈希环如下图：整个空间按顺时针方向组织，圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、……直到2^32-1，也就是说0点左侧的第一个点代表2^32-1， 0和2^32-1在零点中方向重合，我们把这个由2^32个点组成的圆环称为Hash环。</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011527556.png\" alt=\"image-20230401152700520\" style=\"zoom:15%;\">\n</blockquote>\n<p><strong>服务器IP节点映射</strong></p>\n<blockquote>\n<p>节点映射</p>\n<p>将集群中各个IP节点映射到环上的某一个位置。</p>\n<p>将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置。假如4个节点NodeA、B、C、D，经过IP地址的哈希函数计算(hash(ip))，使用IP地址哈希后在环空间的位置如下：</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011527380.png\" alt=\"image-20230401152746347\" style=\"zoom:15%;\">\n</blockquote>\n<p><strong>key落到服务器的落键规则</strong></p>\n<blockquote>\n<p>当我们需要存储一个kv键值对时，首先计算key的hash值，hash(key)，将这个key使用相同的函数Hash计算出哈希值并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器，并将该键值对存储在该节点上。</p>\n<p>如我们有Object A、Object B、Object C、Object D四个数据对象，经过哈希计算后，在环空间上的位置如下：根据一致性Hash算法，数据A会被定为到Node A上，B被定为到Node B上，C被定为到Node C上，D被定为到Node D上。</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011518673.png\" alt=\"img\" style=\"zoom:25%;\">\n</blockquote>\n<h6 id=\"优点\"><strong>优点</strong></h6>\n<ul>\n<li>一致性哈希算法的容错性</li>\n</ul>\n<blockquote>\n<p>容错性</p>\n<p>假设Node C宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。一般的，在一致性Hash算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响。简单说，就是C挂了，受到影响的只是B、C之间的数据，并且这些数据会转移到D进行存储。</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011529810.png\" alt=\"image-20230401152919770\" style=\"zoom:15%;\">\n</blockquote>\n<ul>\n<li>一致性哈希算法的扩展性</li>\n</ul>\n<blockquote>\n<p>数据量增加了，需要增加一台节点NodeX，X的位置在A和B之间，那收到影响的也就是A到X之间的数据，重新把A到X的数据录入到X上即可，不会导致hash取余全部数据重新洗牌。</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011530014.png\" alt=\"img\" style=\"zoom:25%;\">\n</blockquote>\n<h6 id=\"缺点\"><strong>缺点</strong></h6>\n<p>一致性哈希算法的数据倾斜问题</p>\n<blockquote>\n<p>Hash环的数据倾斜问题</p>\n<p>一致性Hash算法在服务节点太少时，容易因为节点分布不均匀而造成数据倾斜（被缓存的对象大部分集中缓存在某一台服务器上）问题，</p>\n<p>例如系统中只有两台服务器：</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011531041.png\" alt=\"img\" style=\"zoom:25%;\">\n</blockquote>\n<h6 id=\"小总结\"><strong>小总结</strong></h6>\n<blockquote>\n<p>为了在节点数目发生改变时尽可能少的迁移数据,将所有的存储节点排列在收尾相接的Hash环上，每个key在计算Hash后会顺时针找到临近的存储节点存放。而当有节点加入或退出时仅影响该节点在Hash环上顺时针相邻的后续节点。</p>\n<ul>\n<li>优点</li>\n</ul>\n<p>加入和删除节点只影响哈希环中顺时针方向的相邻的节点，对其他节点无影响。</p>\n<ul>\n<li>缺点</li>\n</ul>\n<p>数据的分布和节点的位置有关，因为这些节点不是均匀的分布在哈希环上的，所以数据在进行存储时达不到均匀分布的效果。</p>\n</blockquote>\n<h5 id=\"3-哈希槽分区\">3 哈希槽分区</h5>\n<h6 id=\"是什么-2\">是什么</h6>\n<blockquote>\n<h6 id=\"为什么出现-img-src-https-gitee-com-Ryang1118-typora-raw-master-images-202304011533650-png-alt-image-20230401153252082-style-zoom-25\">为什么出现                   <img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011533650.png\" alt=\"image-20230401153252082\" style=\"zoom:25%;\"></h6>\n<p>​\t哈希槽实质就是一个数组，数组[0,2^14 -1]形成hash slot空间。</p>\n<h6 id=\"能干什么\">能干什么</h6>\n<p>解决均匀分配的问题，在数据和节点之间又加入了一层，把这层称为哈希槽（slot），用于管理数据和节点之间的关系，现在就相当于节点上放的是槽，槽里放的是数据。</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011518273.png\" alt=\"img\" style=\"zoom:35%;\">\n<p>槽解决的是粒度问题，相当于把粒度变大了，这样便于数据移动。</p>\n<p>哈希解决的是映射问题，使用key的哈希值来计算所在的槽，便于数据分配。</p>\n<h6 id=\"多少个hash槽\">多少个hash槽</h6>\n<p>一个集群只能有16384个槽，编号0-16383（0-2^14-1）。这些槽会分配给集群中的所有主节点，分配策略没有要求。可以指定哪些编号的槽分配给哪个主节点。集群会记录节点和槽的对应关系。解决了节点和槽的关系后，接下来就需要对key求哈希值，然后对16384取余，余数是几key就落入对应的槽里。slot = CRC16(key) % 16384。以槽为单位移动数据，因为槽的数目是固定的，处理起来比较容易，这样数据移动问题就解决了。</p>\n</blockquote>\n<h6 id=\"哈希槽计算\">哈希槽计算</h6>\n<blockquote>\n<p>Redis 集群中内置了 16384 个哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点。当需要在 Redis 集群中放置一个 key-value时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，也就是映射到某个节点上。如下代码，key之A 、B在Node2， key之C落在Node3上</p>\n</blockquote>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011537859.png\" alt=\"image-20230401153713827\" style=\"zoom:25%;\">\n<h4 id=\"案例演示\">案例演示</h4>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011518732.png\" alt=\"image-20230401151818690\" style=\"zoom: 25%;\">\n<h5 id=\"3主3从redis集群配置\">3主3从redis集群配置</h5>\n<p>1、关闭防火墙+启动docker后台服务   <code>systemctl start docker</code></p>\n<p>2、新建6个docker容器redis实例</p>\n<p>​\t\t\t\t\t命令分步解释</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011542993.png\" style=\"zoom:25%;\">\n<p>3、进入容器redis-node-1并为6台机器构建集群关系</p>\n<p>​\t3.1、进入容器           docker exec -it redis-node-1 /bin/bash</p>\n<blockquote>\n<p>//注意，进入docker容器后才能执行一下命令，且注意自己的真实IP地址</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\"><span class=\"comment\"># 启动第1台节点</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\"><span class=\"comment\"># --net host 使用宿主机的IP和端口，默认</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\"><span class=\"comment\"># --cluster-enabled yes 开启redis集群</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\"><span class=\"comment\"># --appendonly yes 开启redis持久化</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\"><span class=\"comment\"># --port 6381 配置redis端口号</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\">docker run -d --name redis-node-1 --net host --privileged=<span class=\"literal\">true</span> -v /app/redis-cluster/share/redis-node-1:/data redis:6.0.8 --cluster-enabled <span class=\"built_in\">yes</span> --appendonly <span class=\"built_in\">yes</span> --port 6381</span></span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\"><span class=\"comment\"># 启动第2台节点</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\">docker run -d --name redis-node-2 --net host --privileged=<span class=\"literal\">true</span> -v /app/redis-cluster/share/redis-node-2:/data redis:6.0.8 --cluster-enabled <span class=\"built_in\">yes</span> --appendonly <span class=\"built_in\">yes</span> --port 6382</span></span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\"><span class=\"comment\"># 启动第3台节点</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\">docker run -d --name redis-node-3 --net host --privileged=<span class=\"literal\">true</span> -v /app/redis-cluster/share/redis-node-3:/data redis:6.0.8 --cluster-enabled <span class=\"built_in\">yes</span> --appendonly <span class=\"built_in\">yes</span> --port 6383</span></span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\"><span class=\"comment\"># 启动第4台节点</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\">docker run -d --name redis-node-4 --net host --privileged=<span class=\"literal\">true</span> -v /app/redis-cluster/share/redis-node-4:/data redis:6.0.8 --cluster-enabled <span class=\"built_in\">yes</span> --appendonly <span class=\"built_in\">yes</span> --port 6384</span></span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\"><span class=\"comment\"># 启动第5台节点</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\">docker run -d --name redis-node-5 --net host --privileged=<span class=\"literal\">true</span> -v /app/redis-cluster/share/redis-node-5:/data redis:6.0.8 --cluster-enabled <span class=\"built_in\">yes</span> --appendonly <span class=\"built_in\">yes</span> --port 6385</span></span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\"><span class=\"comment\"># 启动第6台节点</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\">docker run -d --name redis-node-6 --net host --privileged=<span class=\"literal\">true</span> -v /app/redis-cluster/share/redis-node-6:/data redis:6.0.8 --cluster-enabled <span class=\"built_in\">yes</span> --appendonly <span class=\"built_in\">yes</span> --port 6386</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​\t3.2、构建主从关系</p>\n<blockquote>\n<p>进入节点1（或其中任意一个节点）:   <code>docker exec -it redis-node-1 /bin/bash</code></p>\n<p>构建主从关系：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\"><span class=\"comment\"># 宿主机IP:端口</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\">redis-cli --cluster create 192.168.xxx.xxx:6381 192.168.xxx.xxx:6382 192.168.xxx.xxx:6383 192.168.xxx.xxx:6384 192.168.xxx.xxx:6385 192.168.xxx.xxx:6386 --cluster-replicas 1</span></span><br></pre></td></tr></table></figure>\n<p>redis尝试自动进行主从节点分配</p>\n<p>因为我们的docker容器IP相同，所以会出现警告，可以直接忽略该警告</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\">[WARNING] Some slaves are <span class=\"keyword\">in</span> the same host as their master</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>–cluster-replicas 1 表示为每个master创建一个slave节点</p>\n</blockquote>\n<p>输入<code>Yes</code>确认后，redis会向其他节点发送信息加入集群，并分配哈希槽：</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011544608.png\" style=\"zoom:25%;\">\n</blockquote>\n<p>​\t3.3、一切OK的话，3主3从搞定</p>\n<p>4、链接进入6381作为切入点，查看集群状态</p>\n<p>​\t\t\t链接进入6381作为切入点，查看节点状态</p>\n<blockquote>\n<p>​\t  进入容器节点1（或集群中其他节点）： <code>docker exec -it redis-node-1 /bin/bash</code></p>\n<p>​     使用<code>redis-cli</code>连接到<code>6381</code>节点：  <code>redis-cli -p 6381</code></p>\n<p>​     使用<code>redis</code>的相关命令查看集群状态：<code>cluster info      \t</code></p>\n<p>​     查看集群节点信息 <code>cluster nodes</code></p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011546265.png\" alt=\"image-20230401154647238\" style=\"zoom:25%;\">\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011545819.png\" alt=\"image-20230401154545791\" style=\"zoom:25%;\">\n</blockquote>\n<h5 id=\"主从容错切换迁移案例\">主从容错切换迁移案例</h5>\n<h6 id=\"数据读写存储\">数据读写存储</h6>\n<p>1、启动6机构成的集群并通过exec进入   <code>docker exec -it redis-node-1 /bin/bash</code></p>\n<p>2、  使用<code>redis-cli</code>连接，不加<code>-c</code>参数时    对6381新增两个key      可能会成功，也可能会失败</p>\n<p>3、防止路由失效加参数-c并新增两个key</p>\n<blockquote>\n<p>当使用 <code>redis-cli</code>连接redis集群时，需要添加 <code>-c</code>参数，否则可能会出现读写出错。</p>\n</blockquote>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011547061.png\" alt=\"image-20230401154741033\" style=\"zoom:25%;\">\n<p>4、查看集群信息            <code>redis-cli --cluster check 192.168.111.147:6381</code></p>\n<h6 id=\"容错切换迁移\">容错切换迁移</h6>\n<p>1、主6381和从机切换，先停止主机6381</p>\n<p>​\t\t\t6381主机停了，对应的真实从机上位</p>\n<p>​\t\t\t6381作为1号主机分配的从机以实际情况为准，具体是几号机器就是几号</p>\n<p>2、再次查看集群信息</p>\n<blockquote>\n<p>6381宕机了，6385上位成为了新的master。</p>\n<p>备注：6381为主下面挂从6385。</p>\n</blockquote>\n<p>3、先还原之前的3主3从</p>\n<p>​\t\t先启6381\t\t   <code>docker start redis-node-1</code></p>\n<p>​\t\t再停6385          <code>docker stop redis-node-5</code></p>\n<p>​\t\t再启6385\t\t\t<code>docker start redis-node-5</code></p>\n<p>​\t\t主从机器分配情况以实际情况为准</p>\n<p>4、查看集群状态         <code>redis-cli --cluster check 自己IP:6381</code></p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011551760.png\" style=\"zoom:25%;\">\n<h5 id=\"主从扩容案例\">主从扩容案例</h5>\n<p>1、新建6387、6388两个节点+新建后启动+查看是否8节点</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d --name redis-node-7 --net host --privileged=<span class=\"literal\">true</span> -v /data/redis/share/redis-node-7:/data redis:6.0.8 --cluster-enabled <span class=\"built_in\">yes</span> --appendonly <span class=\"built_in\">yes</span> --port 6387</span><br><span class=\"line\"></span><br><span class=\"line\">docker run -d --name redis-node-8 --net host --privileged=<span class=\"literal\">true</span> -v /data/redis/share/redis-node-8:/data redis:6.0.8 --cluster-enabled <span class=\"built_in\">yes</span> --appendonly <span class=\"built_in\">yes</span> --port 6388</span><br><span class=\"line\"></span><br><span class=\"line\">docker ps</span><br></pre></td></tr></table></figure>\n<p>2、进入6387容器实例内部   <code>docker exec -it redis-node-7  /bin/bash</code></p>\n<p>3、将新增的6387节点(空槽号)作为master节点加入原集群</p>\n<blockquote>\n<p>将新增的6387作为master节点加入集群<code>redis-cli --cluster add-node 自己实际IP地址:6387 自己实际IP地址:6381</code></p>\n</blockquote>\n<p>4、检查集群情况第1次<code>redis-cli --cluster check 真实ip地址:6381</code></p>\n<blockquote>\n<p>可以发现，6371节点已经作为master加入了集群，但是该节点没有被分配槽位。</p>\n</blockquote>\n<p>5、重新分派槽号      <code>redis-cli --cluster reshard 192.168.xxx.xxx:6381</code></p>\n<p>6、检查集群情况第2次   <code>redis-cli --cluster check 192.168.xxx.xxx:6381</code></p>\n<blockquote>\n<p>槽号分派说明:</p>\n<p>为什么6387是3个新的区间，以前的还是连续？</p>\n<p>重新分配成本太高，所以前3家各自匀出来一部分，从6381/6382/6383三个旧节点分别匀出1364个坑位给新节点6387</p>\n</blockquote>\n<p>7、为主节点6387分配从节点6388</p>\n<blockquote>\n<p>命令：<code>redis-cli --cluster add-node ip:新slave端口 ip:新master端口 --cluster-slave --cluster-master-id 新主机节点ID</code></p>\n<p><code>redis-cli --cluster add-node 192.168.111.147:6388 192.168.111.147:6387 --cluster-slave --cluster-master-id </code></p>\n<p>e4781f644d4a4e4d4b4d107157b9ba8144631451-------这个是6387的编号，按照自己实际情况</p>\n</blockquote>\n<p>9、检查集群情况第3次</p>\n<blockquote>\n<p><code>redis-cli --cluster check 192.168.xxx.xxx:6381</code></p>\n</blockquote>\n<h5 id=\"主从缩容案例\">主从缩容案例</h5>\n<p>1、目的：假如业务高峰期过去，需要将4主4从重新缩容到3主3从。即从集群中移除node8和node7.</p>\n<blockquote>\n<p>进入容器节点1</p>\n<p><code>docker exec -it redis-node-1 /bin/bash</code></p>\n</blockquote>\n<p>2、检查集群情况1获得6388的节点ID   <code>redis-cli --cluster check 192.168.111.147:6382</code></p>\n<p>3、将6388删除 从集群中将4号从节点6388删除    <code>redis-cli --cluster del-node 192.168.xxx.xxx:6388 6388节点编号</code></p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011613757.png\" alt=\"image-20230401161321720\" style=\"zoom:25%;\">\n<p>4、将6387的槽号清空，重新分配，本例将清出来的槽号都给6381</p>\n<blockquote>\n<p>对集群重新分配哈希槽</p>\n<p><code>redis-cli --cluster reshard 192.168.xxx.xxx:6381</code></p>\n<p>redis经过槽位检查后，会提示需要分配的槽位数量：</p>\n<p>How many slots do you want to move (from 1 to 16384)?</p>\n<p>如果我们想直接把node7的4096个哈希槽全部分给某个节点，可以直接输入4096。<br>\n输入<code>4096</code>后，会让输入要接收这些哈希槽的节点ID。假如我们想把这4096个槽都分给Node1，直接输入node1节点的编号即可。<br>\n然后会提示，询问要从哪些节点中拨出一部分槽位凑足4096个分给Node1。这里我们输入node7的节点编号，回车后输入<code>done</code>。</p>\n<p>node7上面没有了哈希槽，此时便可以将node7从集群中移除。（如果node7上面有哈希槽，直接从集群中移除会报错）</p>\n</blockquote>\n<p>5、检查集群情况第二次     <code>redis-cli --cluster check 192.168.111.147:6381</code></p>\n<p>6、将6387删除         <code>redis-cli --cluster del-node 192.168.xxx.xxx:6387 node7节点ID</code></p>\n<p>7、检查集群情况第三次    <code>redis-cli --cluster check 192.168.111.147:6381</code></p>\n<h3 id=\"DockerFile解析\">DockerFile解析</h3>\n<h4 id=\"是什么-3\">是什么</h4>\n<blockquote>\n<p>Dockerfile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。</p>\n<p><strong>官网</strong></p>\n<p><a href=\"https://docs.docker.com/engine/reference/builder/\">https://docs.docker.com/engine/reference/builder/</a></p>\n<p><strong>构建三步骤</strong></p>\n<ol>\n<li>编写Dockerfile文件</li>\n<li>docker build 命令构建镜像</li>\n<li>docker run 镜像 运行容器实例</li>\n</ol>\n</blockquote>\n<h4 id=\"DockerFile构建过程解析\">DockerFile构建过程解析</h4>\n<h5 id=\"Dockerfile内容基础知识\">Dockerfile内容基础知识</h5>\n<blockquote>\n<ul>\n<li>每条保留字指令都必须为大写字母且后面要跟随至少一个参数</li>\n<li>指令按照从上到下，顺序执行</li>\n<li>#表示注释</li>\n<li>每条指令都会创建一个新的镜像层并对镜像进行提交</li>\n</ul>\n</blockquote>\n<h5 id=\"Docker执行Dockerfile的大致流程\">Docker执行Dockerfile的大致流程</h5>\n<ol>\n<li>docker从基础镜像运行一个容器</li>\n<li>执行一条指令并对容器作出修改</li>\n<li>执行类似<code>docker commit</code>的操作提交一个新的镜像层</li>\n<li>docker再基于刚提交的镜像运行一个新容器</li>\n<li>执行dockerfile中的下一条指令直到所有指令都执行完成</li>\n</ol>\n<h4 id=\"小总结-2\">小总结</h4>\n<p>从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表软件的三个不同阶段，</p>\n<ul>\n<li>Dockerfile是软件的原材料</li>\n<li>Docker镜像是软件的交付品</li>\n<li>Docker容器则可以认为是软件镜像的运行态，也即依照镜像运行的容器实例</li>\n</ul>\n<p>Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合力充当Docker体系的基石。</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011619814.png\" alt=\"image-20230401161915775\" style=\"zoom:25%;\">\n<ul>\n<li>\n<p>Dockerfile，需要定义一个Dockerfile，Dockerfile定义了进程需要的一切东西。Dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制)等等;</p>\n</li>\n<li>\n<p>Docker镜像，在用Dockerfile定义一个文件之后，docker build时会产生一个Docker镜像，当运行 Docker镜像时会真正开始提供服务;</p>\n</li>\n<li>\n<p>Docker容器，容器是直接提供服务的。</p>\n</li>\n</ul>\n<h4 id=\"DockerFile常用保留字指令\">DockerFile常用保留字指令</h4>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305191141389.png\" alt></p>\n<p><strong>参考tomcat8的dockerfile入门</strong>      <a href=\"https://github.com/docker-library/tomcat\">https://github.com/docker-library/tomcat</a></p>\n<p><strong>FROM</strong>    基础镜像，当前新镜像是基于哪个镜像的，指定一个已经存在的镜像作为模板，第一条必须是from</p>\n<p><strong>MAINTAINER</strong>    镜像维护者的姓名和邮箱地址</p>\n<p><strong>RUN</strong>    容器构建时需要运行的命令  RUN是在 docker build时运行</p>\n<p>​\t\t两种格式</p>\n<p>​\t\t\t\tshell格式</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">等同于在终端操作的shell命令</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">格式：RUN &lt;命令行命令&gt;</span></span><br><span class=\"line\">RUN yum -y install vim</span><br></pre></td></tr></table></figure>\n<p>​\t\t\t\texec格式</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">格式：RUN [<span class=\"string\">&quot;可执行文件&quot;</span> , <span class=\"string\">&quot;参数1&quot;</span>, <span class=\"string\">&quot;参数2&quot;</span>]</span></span><br><span class=\"line\">RUN [&quot;./test.php&quot;, &quot;dev&quot;, &quot;offline&quot;]  # 等价于 RUN ./test.php dev offline</span><br></pre></td></tr></table></figure>\n<p><strong>EXPOSE</strong>              当前容器对外暴露出的端口</p>\n<p><strong>WORKDIR</strong>           指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点</p>\n<p><strong>USER</strong>                  指定该镜像以什么样的用户去执行，如果都不指定，默认是root</p>\n<p><strong>ENV</strong>                    用来在构建镜像过程中设置环境变量</p>\n<blockquote>\n<p>这个环境变量可以在后续的任何RUN指令中使用，这就如同在命令前面指定了环境变量前缀一样；也可以在其它指令中直接使用这些环境变量。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">格式 ENV 环境变量名 环境变量值</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">或者 ENV 环境变量名=值</span></span><br><span class=\"line\">ENV MY_PATH /usr/mytest</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">使用环境变量</span></span><br><span class=\"line\">WORKDIR $MY_PATH</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>ADD</strong>                   将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包</p>\n<p><strong>COPY</strong>                 类似ADD，拷贝文件和目录到镜像中。</p>\n<blockquote>\n<p>将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">COPY src dest</span><br><span class=\"line\">COPY [&quot;src&quot;, &quot;dest&quot;]</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">&lt;src源路径&gt;：源文件或者源目录</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">&lt;dest目标路径&gt;：容器内的指定路径，该路径不用事先建好。如果不存在会自动创建</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>VOLUME</strong>              容器数据卷，用于数据保存和持久化工作</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">VOLUME 挂载点</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">挂载点可以是一个路径，也可以是数组（数组中的每一项必须用双引号）</span></span><br><span class=\"line\">VOLUME /var/lib/mysql</span><br></pre></td></tr></table></figure>\n<p><strong>CMD</strong></p>\n<p>指定容器启动后的要干的事情</p>\n<p>​\t\t有两种格式：</p>\n<p>​\t\t\t\tshell格式</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">CMD &lt;命令&gt;</span></span><br><span class=\"line\">CMD echo &quot;hello world&quot;</span><br></pre></td></tr></table></figure>\n<p>​\t\t\t\t exec格式</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">CMD [<span class=\"string\">&quot;可执行文件&quot;</span>, <span class=\"string\">&quot;参数1&quot;</span>, <span class=\"string\">&quot;参数2&quot;</span> ...]</span></span><br><span class=\"line\">CMD [&quot;catalina.sh&quot;, &quot;run&quot;]</span><br></pre></td></tr></table></figure>\n<p>​\t\t\t\t参数列表</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">CMD [<span class=\"string\">&quot;参数1&quot;</span>, <span class=\"string\">&quot;参数2&quot;</span> ....]，与ENTRYPOINT指令配合使用</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>注意：</strong></p>\n<p>Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换。</p>\n<p>例如，对于tomcat镜像，执行以下命令会有不同的效果：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">因为tomcat的Dockerfile中指定了 CMD [<span class=\"string\">&quot;catalina.sh&quot;</span>, <span class=\"string\">&quot;run&quot;</span>]</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">所以直接docker run 时，容器启动后会自动执行 catalina.sh run</span></span><br><span class=\"line\">docker run -it -p 8080:8080 tomcat</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">指定容器启动后执行 /bin/bash</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">此时指定的/bin/bash会覆盖掉Dockerfile中指定的 CMD [<span class=\"string\">&quot;catalina.sh&quot;</span>, <span class=\"string\">&quot;run&quot;</span>]</span></span><br><span class=\"line\">docker run -it -p 8080:8080 tomcat /bin/bash</span><br></pre></td></tr></table></figure>\n<p>它和前面RUN命令的区别</p>\n<ul>\n<li>CMD是在docker run 时运行。</li>\n<li>RUN是在 docker build 时运行。</li>\n</ul>\n</blockquote>\n<p><strong>ENTRYPOINT</strong>        用来指定一个容器启动时要运行的命令</p>\n<blockquote>\n<p>类似于 CMD 指令，但是ENTRYPOINT不会被docker run后面的命令覆盖， 而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。</p>\n</blockquote>\n<p>命令格式：                 <img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011627515.png\" alt=\"image-20230401162753424\" style=\"zoom:25%;\"></p>\n<blockquote>\n<p>ENTRYPOINT可以和CMD一起用，一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参。</p>\n<p>当指定了ENTRYPOINT后，CMD的含义就发生了变化，不再是直接运行其命令而是将CMD的内容作为参数传递给ENTRYPOINT指令，他两个组合会变成 <img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011628072.png\" alt=\"image-20230401162805012\" style=\"zoom:25%;\"></p>\n<p>优点：在执行docker run的时候可以指定 ENTRYPOINT 运行所需的参数。</p>\n<p>注意：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。</p>\n</blockquote>\n<p><strong>总结</strong></p>\n<blockquote>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011632532.png\" alt=\"image-20230401163213500\" style=\"zoom:25%;\">\n</blockquote>\n<h4 id=\"案例演示-2\">案例演示</h4>\n<h5 id=\"自定义镜像mycentosjava8\">自定义镜像mycentosjava8</h5>\n<p><strong>要求</strong></p>\n<p>1、Centos7镜像具备vim+ifconfig+jdk8</p>\n<p>2、JDK的下载镜像地址：</p>\n<p>​\t\t官网：<a href=\"https://www.oracle.com/java/technologies/downloads/#java8\">https://www.oracle.com/java/technologies/downloads/#java8</a></p>\n<p>​\t\t<a href=\"https://mirrors.yangxingzhen.com/jdk/\">https://mirrors.yangxingzhen.com/jdk/</a></p>\n<p><strong>编写</strong></p>\n<p>准备编写Dockerfile文件</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> centos</span><br><span class=\"line\"><span class=\"keyword\">MAINTAINER</span> zzyy&lt;zzyybs@<span class=\"number\">126</span>.com&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> MYPATH /usr/local</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> <span class=\"variable\">$MYPATH</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#安装vim编辑器</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> yum -y install vim</span></span><br><span class=\"line\"><span class=\"comment\">#安装ifconfig命令查看网络IP</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> yum -y install net-tools</span></span><br><span class=\"line\"><span class=\"comment\">#安装java8及lib库</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> yum -y install glibc.i686</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">mkdir</span> /usr/local/java</span></span><br><span class=\"line\"><span class=\"comment\">#ADD 是相对路径jar,把jdk-8u171-linux-x64.tar.gz添加到容器中,安装包必须要和Dockerfile文件在同一位置</span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"language-bash\"> jdk-8u171-linux-x64.tar.gz /usr/local/java/</span></span><br><span class=\"line\"><span class=\"comment\">#配置java环境变量</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> JAVA_HOME /usr/local/java/jdk1.<span class=\"number\">8.0</span>_171</span><br><span class=\"line\"><span class=\"keyword\">ENV</span> JRE_HOME $JAVA_HOME/jre</span><br><span class=\"line\"><span class=\"keyword\">ENV</span> CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH</span><br><span class=\"line\"><span class=\"keyword\">ENV</span> PATH $JAVA_HOME/bin:$PATH</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">80</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> <span class=\"built_in\">echo</span> <span class=\"variable\">$MYPATH</span></span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> <span class=\"built_in\">echo</span> <span class=\"string\">&quot;success--------------ok&quot;</span></span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> /bin/bash</span></span><br></pre></td></tr></table></figure>\n<p><strong>构建</strong></p>\n<p>docker build -t 新镜像名字:TAG .    <code>docker build -t centosjava8:1.5 .</code></p>\n<blockquote>\n<p>注意，上面TAG后面有个空格，有个点</p>\n</blockquote>\n<p><strong>运行</strong></p>\n<p>docker run -it 新镜像名字:TAG       <code>docker run -it centosjava8:1.5 /bin/bash</code></p>\n<h5 id=\"虚悬镜像\">虚悬镜像</h5>\n<p><strong>是什么</strong></p>\n<p>仓库名、标签都是&lt;none&gt;的镜像，俗称dangling image</p>\n<p>Dockerfile写一个</p>\n<p><code>vim Dockerfile</code></p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> ubuntu</span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> <span class=\"built_in\">echo</span> <span class=\"string\">&#x27;action is success&#x27;</span></span></span><br></pre></td></tr></table></figure>\n<p><code>docker build .</code></p>\n<p><strong>查看</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker image ls -f dangling=true</span><br></pre></td></tr></table></figure>\n<p><strong>删除</strong></p>\n<p>虚悬镜像已经失去存在价值，可以删除</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker image prune</span><br></pre></td></tr></table></figure>\n<h5 id=\"自定义镜像myubuntu\">自定义镜像myubuntu</h5>\n<p><strong>编写</strong></p>\n<p>准备编写DockerFile文件</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> ubuntu</span><br><span class=\"line\"><span class=\"keyword\">MAINTAINER</span> zzyy&lt;zzyybs@<span class=\"number\">126</span>.com&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">ENV</span> MYPATH /usr/local</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> <span class=\"variable\">$MYPATH</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get update</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get install net-tools</span></span><br><span class=\"line\"><span class=\"comment\">#RUN apt-get install -y iproute2</span></span><br><span class=\"line\"><span class=\"comment\">#RUN apt-get install -y inetutils-ping</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">80</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> <span class=\"built_in\">echo</span> <span class=\"variable\">$MYPATH</span></span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> <span class=\"built_in\">echo</span> <span class=\"string\">&quot;install inconfig cmd into ubuntu success--------------ok&quot;</span></span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> /bin/bash</span></span><br></pre></td></tr></table></figure>\n<p><strong>构建</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -t 新镜像名字:TAG .</span><br></pre></td></tr></table></figure>\n<p><strong>运行</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it 新镜像名字:TAG</span><br></pre></td></tr></table></figure>\n<h5 id=\"小总结-3\">小总结</h5>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011518976.png\" alt=\"img\" style=\"zoom: 33%;\">\n<h3 id=\"Docker微服务实战\">Docker微服务实战</h3>\n<h4 id=\"通过IDEA新建一个普通微服务模块\">通过IDEA新建一个普通微服务模块</h4>\n<p><strong>建Module</strong></p>\n<p>docker_boot</p>\n<p><strong>改POM</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">parent</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.5.6<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">relativePath</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">parent</span>&gt;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.atguigu.docker<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>docker_boot<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>0.0.1-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">project.build.sourceEncoding</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">maven.compiler.source</span>&gt;</span>1.8<span class=\"tag\">&lt;/<span class=\"name\">maven.compiler.source</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">maven.compiler.target</span>&gt;</span>1.8<span class=\"tag\">&lt;/<span class=\"name\">maven.compiler.target</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">junit.version</span>&gt;</span>4.12<span class=\"tag\">&lt;/<span class=\"name\">junit.version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">log4j.version</span>&gt;</span>1.2.17<span class=\"tag\">&lt;/<span class=\"name\">log4j.version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">lombok.version</span>&gt;</span>1.16.18<span class=\"tag\">&lt;/<span class=\"name\">lombok.version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">mysql.version</span>&gt;</span>5.1.47<span class=\"tag\">&lt;/<span class=\"name\">mysql.version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">druid.version</span>&gt;</span>1.1.16<span class=\"tag\">&lt;/<span class=\"name\">druid.version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">mapper.version</span>&gt;</span>4.1.5<span class=\"tag\">&lt;/<span class=\"name\">mapper.version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">mybatis.spring.boot.version</span>&gt;</span>1.3.0<span class=\"tag\">&lt;/<span class=\"name\">mybatis.spring.boot.version</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--SpringBoot通用依赖模块--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--test--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.maven.plugins<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven-resources-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.1.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>写YML</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server.port=6001</span><br></pre></td></tr></table></figure>\n<p><strong>主启动</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.atguigu.docker;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.SpringApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DockerBootApplication</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        SpringApplication.run(DockerBootApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>业务类</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.atguigu.docker.controller;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.UUID;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@auther</span> zzyy</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@create</span> 2021-10-25 17:43</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OrderController</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String port;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/order/docker&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">helloDocker</span><span class=\"params\">()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello docker&quot;</span>+<span class=\"string\">&quot;\\t&quot;</span>+port+<span class=\"string\">&quot;\\t&quot;</span>+ UUID.randomUUID().toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(value =&quot;/order/index&quot;,method = RequestMethod.GET)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">index</span><span class=\"params\">()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;服务端口号: &quot;</span>+<span class=\"string\">&quot;\\t&quot;</span>+port+<span class=\"string\">&quot;\\t&quot;</span>+UUID.randomUUID().toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"通过dockerfile发布微服务部署到docker容器\">通过dockerfile发布微服务部署到docker容器</h4>\n<p><strong>IDEA工具里面搞定微服务jar包</strong>        <code> docker_boot-0.0.1-SNAPSHOT.jar</code></p>\n<p><strong>编写Dockerfile</strong></p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 基础镜像使用java</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> java:<span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"comment\"># 作者</span></span><br><span class=\"line\"><span class=\"keyword\">MAINTAINER</span> zzyy</span><br><span class=\"line\"><span class=\"comment\"># VOLUME 指定临时文件目录为/tmp，在主机/var/lib/docker目录下创建了一个临时文件并链接到容器的/tmp</span></span><br><span class=\"line\"><span class=\"keyword\">VOLUME</span><span class=\"language-bash\"> /tmp</span></span><br><span class=\"line\"><span class=\"comment\"># 将jar包添加到容器中并更名为zzyy_docker.jar</span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"language-bash\"> docker_boot-0.0.1-SNAPSHOT.jar zzyy_docker.jar</span></span><br><span class=\"line\"><span class=\"comment\"># 运行jar包</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> bash -c <span class=\"string\">&#x27;touch /zzyy_docker.jar&#x27;</span></span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> [<span class=\"string\">&quot;java&quot;</span>,<span class=\"string\">&quot;-jar&quot;</span>,<span class=\"string\">&quot;/zzyy_docker.jar&quot;</span>]</span></span><br><span class=\"line\"><span class=\"comment\">#暴露6001端口作为微服务</span></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">6001</span></span><br></pre></td></tr></table></figure>\n<p>将微服务jar包和Dockerfile文件上传到同一个目录下/mydocker</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011639755.png\" alt=\"image-20230401163957654\" style=\"zoom:25%;\">\n<p><strong>构建镜像</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -t zzyy_docker:1.6 .</span><br></pre></td></tr></table></figure>\n<p><strong>运行容器</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d -p 6001:6001 zzyy_docker:1.6</span><br></pre></td></tr></table></figure>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011641705.png\" style=\"zoom:25%;\">\n<p><strong>访问测试</strong></p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011518725.png\" alt=\"img\" style=\"zoom: 50%;\">\n<h3 id=\"Docker网络\">Docker网络</h3>\n<h4 id=\"是什么-4\">是什么</h4>\n<p><strong>docker不启动，默认网络情况</strong></p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011645105.png\" alt=\"image-20230401164537059\" style=\"zoom:25%;\">\n<p><strong>docker启动后，网络情况</strong></p>\n<ul>\n<li>\n<p>docker0</p>\n<blockquote>\n<p>Docker 服务默认会创建一个<code>docker0</code>网桥（其上有一个<code>docker0</code>内部接口），该桥接网络的名称为 <code>docker0</code>，它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。</p>\n<p>Docker默认指定了<code>docker0</code>接口的IP地址和子网掩码，让主机和容器之间可以通过网桥互相通信。</p>\n<p>查看<code>bridge</code>网络的详细信息，并通过<code>grep</code>获取名称：   可以看到其名称为<code>docker0</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\">docker network inspect bridge | grep name</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011646602.png\" alt=\"image-20230401164623547\" style=\"zoom:25%;\">\n<p><strong>查看docker网络模式命令，默认创建3大网络模式。</strong></p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011646774.png\" alt=\"image-20230401164656723\" style=\"zoom:25%;\">\n<h4 id=\"常用基本命令\">常用基本命令</h4>\n<p><strong>All命令</strong></p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011649184.png\" alt=\"image-20230401164909146\" style=\"zoom:25%;\">\n<p><strong>查看网络</strong>              <code>docker network ls</code></p>\n<p><strong>查看网络源数据</strong>     <code>docker network inspect XXX网络名字</code></p>\n<p><strong>删除网络</strong>               <code>docker network rm XXX网络名字</code></p>\n<p><strong>案例</strong></p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011649967.png\" style=\"zoom:25%;\">\n<h4 id=\"Docker网络的作用\">Docker网络的作用</h4>\n<ul>\n<li>\n<p>容器间的互联和通信以及端口映射</p>\n</li>\n<li>\n<p>容器IP变动时候可以通过服务名直接网络通信而不受到影响</p>\n</li>\n</ul>\n<h4 id=\"网络模式\">网络模式</h4>\n<p><strong>总体介绍</strong></p>\n<table>\n<thead>\n<tr>\n<th>网络模式</th>\n<th>简介</th>\n<th>使用方式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>bridge</td>\n<td>为每一个容器分配、设置IP等，并将容器连接到一个<code>docker0</code>虚拟网桥，默认为该模式</td>\n<td><code>--network bridge</code></td>\n</tr>\n<tr>\n<td>host</td>\n<td>容器将不会虚拟出自己的网卡、配置自己的IP等，而是使用宿主机的IP和端口</td>\n<td><code>--network host</code></td>\n</tr>\n<tr>\n<td>none</td>\n<td>容器有独立的 Network namespace，但并没有对齐进行任何网络设置，如分配 <code>veth pari</code> 和 网桥连接、IP等</td>\n<td><code>--network none</code></td>\n</tr>\n<tr>\n<td>container</td>\n<td>新创建的容器不会创建自己的网卡和配置自己的IP，而是和一个指定的容器共享IP、端口范围等</td>\n<td><code>--network container:NAME或者容器ID</code></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<ul>\n<li>\n<p>bridge模式：使用–network bridge指定，默认使用docker0</p>\n</li>\n<li>\n<p>host模式：使用–network host指定</p>\n</li>\n<li>\n<p>none模式：使用–network none指定</p>\n</li>\n<li>\n<p>container模式：使用–network container:NAME或者容器ID指定</p>\n</li>\n</ul>\n</blockquote>\n<p>查看某个容器的网络模式：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">通过inspect获取容器信息，最后20行即为容器的网络模式信息</span></span><br><span class=\"line\">docker inspect 容器ID | tail -n 20</span><br></pre></td></tr></table></figure>\n<p><strong>容器实例内默认网络IP生产规则</strong></p>\n<p>​\t<strong>1、先启动两个ubuntu容器实例</strong></p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011651269.png\" alt=\"image-20230401165138224\" style=\"zoom:25%;\">\n<p>​\t<strong>2、docker inspect 容器ID or 容器名字</strong></p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011651136.png\" alt=\"image-20230401165149093\" style=\"zoom:25%;\">\n<p>​\t<strong>3、关闭u2实例，新建u3，查看ip变化</strong></p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011652890.png\" alt=\"image-20230401165201841\" style=\"zoom:25%;\">\n<p><strong>结论</strong></p>\n<blockquote>\n<p>docker容器内部的ip是有可能会发生改变的</p>\n</blockquote>\n<h5 id=\"bridge模式\">bridge模式</h5>\n<h6 id=\"介绍\">介绍</h6>\n<blockquote>\n<p>1、Docker使用Linux桥接，在宿主机虚拟一个<code>Docker</code>容器网桥（<code>docker0</code>），Docker启动一个容器时会根据<code>Docker</code>网桥的网段分配给容器一个IP地址，称为<code>Container-IP</code>，同时Docker网桥是每个容器的默认网关。因为在同一个宿主机内的容器接入同一个网桥，这样容器之间就能够通过容器的<code>Container-IP</code>直接通信。</p>\n<p>2、<code>docker run</code>的时候，没有指定<code>--network</code>的话，默认使用的网桥模式就是<code>bridge</code>，使用的就是<code>docker0</code>。在宿主机<code>ifconfig</code>就苦役看到<code>docker0</code>和自己<code>create</code>的<code>network</code>。</p>\n<p>3、网桥<code>docker0</code>创建一对对等虚拟设备接口，一个叫<code>veth</code>，另一个叫<code>eth0</code>，成对匹配：</p>\n<p>3.1、整个宿主机的网桥模式都是<code>docker0</code>，类似一个交换机有一堆接口，每个接口叫 <code>veth</code>，在本地主机和容器内分别创建一个虚拟接口，并让他们彼此联通（这样一对接口叫做 <code>veth pair</code>）。</p>\n<p>3.2、每个容器实例内部也有一块网卡，容器内的网卡接口叫做<code>eth0</code>。</p>\n<p>3.3、<code>docker0</code>上面的每个<code>veth</code>匹配某个容器实例内部的<code>eth0</code>，两两配对，一一匹配。</p>\n<p>通过上述，将宿主机上的所有容器都连接到这个内部网络上，两个容器在同一个网络下,会从这个网关下各自拿到分配的ip，此时两个容器的网络是互通的。</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011656881.png\" alt=\"image-20230401165619779\" style=\"zoom:25%;\">\n</blockquote>\n<p>查看 bridge 网络的详细信息，并通过 grep 获取名称项</p>\n<p><code>docker network inspect bridge | grep name</code></p>\n<h5 id=\"host模式\">host模式</h5>\n<h6 id=\"介绍-2\">介绍</h6>\n<blockquote>\n<p>直接使用宿主机的 IP 地址与外界进行通信，不再需要额外进行 NAT 转换。</p>\n<p>容器将不会获得一个独立的 Network Namespace，而是和宿主机共用一个 Network space。</p>\n<p>容器将不会虚拟出自己的网卡，而是直接使用宿主机的 IP 和端口。</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011657895.png\" alt=\"image-20230401165717854\" style=\"zoom:25%;\">\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\">docker run -d -p 8081:8080 --name tomcat81 billygoo/tomcat8-jdk8</span></span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\">docker run -d -p 8082:8080 --name tomcat82 billygoo/tomcat8-jdk8</span></span><br></pre></td></tr></table></figure>\n<p>如果在 docker run 命令中同时使用了 --network host 和 -p端口映射，例如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\">docker run -p 8082:8080 --network host tomcat</span></span><br></pre></td></tr></table></figure>\n<p>那么会出现一个警告：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;WARNING: Published ports are discarded when using host network mode</span><br></pre></td></tr></table></figure>\n<p>因为此时已经使用了<code>host</code>模式，本身就是直接使用的宿主机的IP和端口，此时的<code>-p</code>端口映射就没有了意义，也不会生效，端口号还是会以主机端口号为主。</p>\n<p>正确做法是：不再进行<code>-p</code>端口映射，或者改用<code>bridge</code>模式</p>\n</blockquote>\n<h5 id=\"none模式\">none模式</h5>\n<h6 id=\"介绍-3\">介绍</h6>\n<blockquote>\n<p>禁用网络功能;</p>\n<p>在<code>none</code>模式下，并不为docker容器进行任何网络配置。进入容器内，使用 <code>ip addr</code>查看网卡信息，只能看到 <code>lo</code>（本地回环网络<code>127.0.0.1</code>网卡）。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d -p 8084:8080 --network none --name tomcat84 billygoo/tomcat8-jdk8</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h5 id=\"container模式\">container模式</h5>\n<h6 id=\"介绍-4\">介绍</h6>\n<blockquote>\n<p>新建的容器和已经存在的一个容器共享网络IP配置，而不是和宿主机共享。</p>\n<p>新创建的容器不会创建自己的网卡、IP，而是和一个指定的容器共享IP、端口范围。两个容器除了网络共享，其他的如文件系统、进程列表依然是隔离的。</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011658625.webp\" alt=\"img\" style=\"zoom:25%;\">\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011705812.png\" style=\"zoom:25%;\">\n</blockquote>\n<h4 id=\"自定义网络\">自定义网络</h4>\n<blockquote>\n<p>容器间的互联和通信以及端口映射。</p>\n<p>容器 IP 变动时候可以通过服务名直接网络通信而不受影响。（类似Eureka，通过服务名直接互相通信，而不是写死IP地址）。</p>\n<p>docker中还有一个 <code>--link</code> 进行容器网络互联，但是已经被标记为过时的，可能会在将来的版本中移除这个功能。推荐使用自定义网络替换link</p>\n</blockquote>\n<h5 id=\"自定义桥接网络（自定义网络默认使用的是桥接网络-bridge）\">自定义桥接网络（自定义网络默认使用的是桥接网络 <code>bridge</code>）</h5>\n<blockquote>\n<p><strong>新建自定义网络</strong>  <code>docker network create tomcat_network</code></p>\n<p><strong>查看网络列表</strong>   <code>docker network ls</code></p>\n<p><strong>创建容器时</strong>，<strong>指定加入我们自定义的网络中</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\">docker run -d -p 8081:8080 --network tomcat_network --name tomcat1 tomcat:8.5-jdk8-corretto</span></span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\">docker run -d -p 8082:8080 --network tomcat_network --name tomcat2 tomcat:8.5-jdk8-corretto</span></span><br></pre></td></tr></table></figure>\n<p>此时进入<code>tomcat1</code>中，使用<code>ping</code>命令测试连接<code>tomcat2</code>容器名，发现可以正常连通</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\"><span class=\"comment\"># 安装ifconfig命令</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\">yum install -y net-tools</span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\"><span class=\"comment\"># 安装ip addr命令</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\">yum install -y iproute</span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\"><span class=\"comment\"># 安装ping命令</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\">yum install -y iputils</span></span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\"><span class=\"comment\"># 直接ping容器名，不需要ping IP地址</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\">ping tomcat2</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>==自定义网络本身就维护好了主机名和ip的对应关系（ip和域名都能通）==</p>\n</blockquote>\n</blockquote>\n<h5 id=\"link连接\">link连接</h5>\n<p><strong>演示</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">启动一台mysql容器</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">--name 为容器指定一个别名</span></span><br><span class=\"line\">docker run --name mysql-matomo -p 3308:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql:8.0.28</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">启动另一个容器，通过--<span class=\"built_in\">link</span>连接到mysql容器</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">--<span class=\"built_in\">link</span> 容器名称:本容器连接对方时的别名</span></span><br><span class=\"line\">docker run -d -p 8888:80 --link mysql-matomo:db --name matomo matomo:4.9.0</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">此时，在matomo容器中，便可以通过 db 这个hostname连接到mysql-matomo容器，而无须再通过ip</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">连接地址：db:3306</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"Docker平台架构图解\">Docker平台架构图解</h4>\n<h5 id=\"整体说明\"><strong>整体说明</strong></h5>\n<p>从其架构和运行流程来看，Docker 是一个 C/S 模式的架构，后端是一个松耦合架构，众多模块各司其职。</p>\n<blockquote>\n<h6 id=\"Docker-运行的基本流程为：\">Docker 运行的基本流程为：</h6>\n<p>1 用户是使用 Docker Client 与 Docker Daemon 建立通信，并发送请求给后者。</p>\n<p>2 Docker Daemon 作为 Docker 架构中的主体部分，首先提供 Docker Server 的功能使其可以接受 Docker Client 的请求。</p>\n<p>3 Docker Engine 执行 Docker 内部的一系列工作，每一项工作都是以一个 Job 的形式的存在。</p>\n<p>4 Job 的运行过程中，当需要容器镜像时，则从 Docker Registry 中下载镜像，并通过镜像管理驱动 Graph driver将下载镜像以Graph的形式存储。</p>\n<p>5 当需要为 Docker 创建网络环境时，通过网络管理驱动 Network driver 创建并配置 Docker 容器网络环境。</p>\n<p>6 当需要限制 Docker 容器运行资源或执行用户指令等操作时，则通过 Execdriver 来完成。</p>\n<p>7 Libcontainer是一项独立的容器管理包，Network driver以及Exec driver都是通过Libcontainer来实现具体对容器进行的操作。</p>\n</blockquote>\n<h5 id=\"整体架构\"><strong>整体架构</strong></h5>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011713071.png\" alt=\"image-20230401171342022\" style=\"zoom:25%;\">\n<h3 id=\"Docker-compose容器编排\">Docker-compose容器编排</h3>\n<h4 id=\"介绍-5\">介绍</h4>\n<blockquote>\n<p>Docker-Compose是Docker官方的开源项目， 负责实现对Docker容器集群的快速编排。</p>\n<p><code>Docker-Compose</code>可以管理多个Docker容器组成一个应用。需要定义一个yaml格式的配置文件 <code>docker-compose.yml</code>，配置好多个容器之间的调用关系，然后只需要一个命令就能同时启动/关闭这些容器。</p>\n<p>Docker建议我们每个容器中只运行一个服务，因为Docker容器本身占用资源极少，所以最好是将每个服务单独的分割开来。但是如果我们需要同时部署多个服务，每个服务单独构建镜像构建容器就会比较麻烦。所以 Docker 官方推出了 <code>docker-compose</code> 多服务部署的工具。</p>\n<p>Compose允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件来定义一组相关联的应用容器为一个项目（<code>project</code>）。可以很容易的用一个配置文件定义一个多容器的应用，然后使用一条指令安装这个应用的所有依赖，完成构建。</p>\n</blockquote>\n<p>官网   <a href=\"https://docs.docker.com/compose/compose-file/compose-file-v3/\">https://docs.docker.com/compose/compose-file/compose-file-v3/</a></p>\n<p>官网下载   <a href=\"https://docs.docker.com/compose/install/\">https://docs.docker.com/compose/install/</a></p>\n<p>安装步骤</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">例如从github下载 2.5.0版本的docker-compose</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">下载下来的文件放到 /usr/local/bin目录下，命名为 docker-compose</span></span><br><span class=\"line\">curl -L https://github.com/docker/compose/releases/download/v2.5.0/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">添加权限</span></span><br><span class=\"line\">chmod +x /usr/local/bin/docker-compose</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">验证</span></span><br><span class=\"line\">docker-compose version</span><br></pre></td></tr></table></figure>\n<h4 id=\"Compose核心概念\">Compose核心概念</h4>\n<p>一文件     <code>docker-compose.yml</code></p>\n<p>两要素</p>\n<ul>\n<li>\n<p>服务（service）         一个个应用容器实例，比如订单微服务、库存微服务、mysql容器、nginx容器或者redis容器</p>\n</li>\n<li>\n<p>工程（project）         由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。</p>\n</li>\n</ul>\n<h4 id=\"Compose使用的三个步骤\">Compose使用的三个步骤</h4>\n<ul>\n<li>编写Dockerfile定义各个微服务应用并构建出对应的镜像文件</li>\n<li>使用 docker-compose.yml 定义一个完整业务单元，安排好整体应用中的各个容器服务。</li>\n<li>最后，执行docker-compose up命令 来启动并运行整个应用程序，完成一键部署上线</li>\n</ul>\n<h4 id=\"Compose常用命令\">Compose常用命令</h4>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker-compose -h                           # 查看帮助</span><br><span class=\"line\"></span><br><span class=\"line\">docker-compose up                           # 启动所有docker-compose服务</span><br><span class=\"line\"></span><br><span class=\"line\">docker-compose up -d                        # 启动所有docker-compose服务并后台运行</span><br><span class=\"line\"></span><br><span class=\"line\">docker-compose down                         # 停止并删除容器、网络、卷、镜像。</span><br><span class=\"line\"></span><br><span class=\"line\">docker-compose exec  yml里面的服务id                 # 进入容器实例内部  docker-compose exec docker-compose.yml文件中写的服务id /bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">docker-compose ps                      # 展示当前docker-compose编排过的运行的所有容器</span><br><span class=\"line\"></span><br><span class=\"line\">docker-compose top                     # 展示当前docker-compose编排过的容器进程</span><br><span class=\"line\"></span><br><span class=\"line\">docker-compose logs  yml里面的服务id     # 查看容器输出日志</span><br><span class=\"line\"></span><br><span class=\"line\">docker-compose config     # 检查配置</span><br><span class=\"line\"></span><br><span class=\"line\">docker-compose config -q  # 检查配置，有问题才有输出</span><br><span class=\"line\"></span><br><span class=\"line\">docker-compose restart   # 重启服务</span><br><span class=\"line\"></span><br><span class=\"line\">docker-compose start     # 启动服务</span><br><span class=\"line\"></span><br><span class=\"line\">docker-compose stop      # 停止服务</span><br></pre></td></tr></table></figure>\n<h4 id=\"Compose编排微服务\">Compose编排微服务</h4>\n<h5 id=\"改造升级微服务工程docker-boot\">改造升级微服务工程docker_boot</h5>\n<p><strong>前置</strong></p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011720937.png\" style=\"zoom:25%;\">\n<p><strong>编写Dockerfile</strong></p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 基础镜像使用java</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> java:<span class=\"number\">8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 作者</span></span><br><span class=\"line\"><span class=\"keyword\">MAINTAINER</span> zzyy</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># VOLUME 指定临时文件目录为/tmp，在主机/var/lib/docker目录下创建了一个临时文件并链接到容器的/tmp</span></span><br><span class=\"line\"><span class=\"keyword\">VOLUME</span><span class=\"language-bash\"> /tmp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将jar包添加到容器中并更名为zzyy_docker.jar</span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"language-bash\"> docker_boot-0.0.1-SNAPSHOT.jar zzyy_docker.jar</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 运行jar包</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> bash -c <span class=\"string\">&#x27;touch /zzyy_docker.jar&#x27;</span></span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> [<span class=\"string\">&quot;java&quot;</span>,<span class=\"string\">&quot;-jar&quot;</span>,<span class=\"string\">&quot;/zzyy_docker.jar&quot;</span>]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#暴露6001端口作为微服务</span></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">6001</span></span><br></pre></td></tr></table></figure>\n<p>构建镜像          <code>docker build -t zzyy_docker:1.6 .</code></p>\n<h5 id=\"不用Compose\">不用Compose</h5>\n<h6 id=\"步骤\">步骤</h6>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011723525.png\" alt=\"image-20230401172326483\" style=\"zoom:33%;\">\n<h6 id=\"虽然成功但是有问题\">虽然成功但是有问题?</h6>\n<blockquote>\n<ul>\n<li>\n<p>先后顺序要求固定，先mysql+redis才能微服务访问成功</p>\n</li>\n<li>\n<p>多个run命令…</p>\n</li>\n<li>\n<p>容器间的启停或宕机，有可能导致IP地址对应的容器实例变化，映射出错， 要么生产IP写死(可以但是不推荐)，要么通过服务调用</p>\n</li>\n</ul>\n</blockquote>\n<h5 id=\"使用Compose\">使用Compose</h5>\n<blockquote>\n<p>服务编排，一套带走，安排</p>\n</blockquote>\n<p>编写docker-compose.yml文件</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># docker-compose文件版本号</span></span><br><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&quot;3&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置各个容器服务</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">microService:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">springboot_docker:1.0</span></span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">ms01</span>  <span class=\"comment\"># 容器名称，如果不指定，会生成一个服务名加上前缀的容器名</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;6001:6001&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">/app/microService:/data</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">springboot_network</span></span><br><span class=\"line\">    <span class=\"attr\">depends_on:</span>  <span class=\"comment\"># 配置该容器服务所依赖的容器服务</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">redis</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">mysql</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">redis:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">redis:6.0.8</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;6379:6379&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">/app/redis/redis.conf:/etc/redis/redis.conf</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">/app/redis/data:data</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">springboot_network</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> <span class=\"string\">redis-server</span> <span class=\"string\">/etc/redis/redis.conf</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">mysql:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:5.7</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"attr\">MYSQL_ROOT_PASSWORD:</span> <span class=\"string\">&#x27;123456&#x27;</span></span><br><span class=\"line\">      <span class=\"attr\">MYSQL_ALLOW_EMPTY_PASSWORD:</span> <span class=\"string\">&#x27;no&#x27;</span></span><br><span class=\"line\">      <span class=\"attr\">MYSQL_DATABASE:</span> <span class=\"string\">&#x27;db_springboot&#x27;</span></span><br><span class=\"line\">      <span class=\"attr\">MYSQL_USER:</span> <span class=\"string\">&#x27;springboot&#x27;</span></span><br><span class=\"line\">      <span class=\"attr\">MYSQL_PASSWORD:</span> <span class=\"string\">&#x27;springboot&#x27;</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;3306:3306&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">/app/mysql/db:/var/lib/mysql</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">/app/mysql/conf/my.cnf:/etc/my.cnf</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">/app/mysql/init:/docker-entrypoint-initdb.d</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">springboot_network</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> <span class=\"string\">--default-authentication-plugin=mysql_native_password</span> <span class=\"comment\"># 解决外部无法访问</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"comment\"># 创建 springboot_network 网桥网络</span></span><br><span class=\"line\">  <span class=\"attr\">springboot_network:</span></span><br></pre></td></tr></table></figure>\n<p>编写完成<code>docker-compose.yml</code>后，进行语法检查：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">进行语法检查</span></span><br><span class=\"line\">docker-compose config -q</span><br></pre></td></tr></table></figure>\n<p><strong>第二次修改微服务工程</strong>docker_boot</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011724445.png\" alt=\"image-20230401172449400\" style=\"zoom:25%;\">\n<p><strong>执行</strong> <code>docker-compose up</code> 或者 执行 <code>docker-compose up -d</code></p>\n<p><strong>进入mysql容器实例并新建库db2021+新建表t_user</strong></p>\n<p><strong>测试通过</strong></p>\n<p>关停    <code> docker-compose stop</code></p>\n<h3 id=\"Docker轻量级可视化工具Portainer\">Docker轻量级可视化工具Portainer</h3>\n<h4 id=\"是什么-5\">是什么</h4>\n<blockquote>\n<p>Portainer 是一款轻量级的应用，它提供了图形化界面，用于方便地管理Docker环境，包括单机环境和集群环境。</p>\n</blockquote>\n<h4 id=\"安装\">安装</h4>\n<p><strong>官网</strong></p>\n<p><a href=\"https://www.portainer.io/\">https://www.portainer.io/</a></p>\n<p><a href=\"https://docs.portainer.io/v/ce-2.9/start/install/server/docker/linux\">https://docs.portainer.io/v/ce-2.9/start/install/server/docker/linux</a></p>\n<p><strong>步骤</strong></p>\n<p><strong>docker命令安装</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 旧版镜像地址为portainer/portainer，从2022年1月标记为过期</span></span><br><span class=\"line\"><span class=\"comment\"># 新版镜像地址为portainer/portainer-ce</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># --restart=always 如果Docker引擎重启了，那么这个容器实例也会在Docker引擎重启后重启，类似开机自启</span></span><br><span class=\"line\">docker run -d -p 8000:8000 -p 9000:9000 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:2.13.0-alpine</span><br></pre></td></tr></table></figure>\n<p><strong>第一次登录需创建admin，访问地址：<a href=\"http://xxx.xxx.xxx.xxx:9000\">xxx.xxx.xxx.xxx:9000</a></strong></p>\n<p>首次进来时，需要创建 admin 的用户名（默认admin）、密码（必须满足校验规则，例如portainer.io123）。</p>\n<p>选择 local管理本地docker，即可看到本地Docker的详细信息，包括其中的镜像（images）、容器（containers）、网络（networks）、容器卷（volumes）、compose编排（stacks）等等。</p>\n<h3 id=\"Docker容器监控之-CAdvisor-InfluxDB-Granfana\">Docker容器监控之 CAdvisor+InfluxDB+Granfana</h3>\n<h4 id=\"CIG\">CIG</h4>\n<p>通过<code>docker stats</code> 命令可以很方便的查看当前宿主机上所有容器的CPU、内存、网络流量等数据，可以满足一些小型应用。</p>\n<p>但是 <code>docker stats</code> 统计结果只能是当前宿主机的全部容器，数据资料是实时的，没有地方存储、没有健康指标过线预警等功能。</p>\n<p>CAdvisor（监控收集） + InfluxDB（存储数据） + Granfana（展示图表），合称 <code>CIG</code>。</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202304011729933.png\" alt=\"img\" style=\"zoom:25%;\">\n<h5 id=\"CAdvisor\">CAdvisor</h5>\n<p>CAdvisor是一个容器资源监控工具，包括容器的内存、CPU、网络IO、磁盘IO等监控，同时提供了一个Web页面用于查看容器的实时运行状态。</p>\n<p>CAdvisor默认存储2分钟的数据，而且只是针对单物理机。不过CAdvisor提供了很多数据集成接口，支持 InfluxDB、Redis、Kafka、Elasticsearch等集成，可以加上对应配置将监控数据发往这些数据库存储起来。</p>\n<p>CAdvisor主要功能：</p>\n<ul>\n<li>\n<p>展示Host和容器两个层次的监控数据</p>\n</li>\n<li>\n<p>展示历史变化数据</p>\n</li>\n</ul>\n<h5 id=\"InfluxDB\">InfluxDB</h5>\n<p>InfluxDB是用Go语言编写的一个开源分布式时序、事件和指标数据库，无需外部依赖。</p>\n<p>CAdvisor默认只在本机保存2分钟的数据，为了持久化存储数据和统一收集展示监控数据，需要将数据存储到InfluxDB中。InfluxDB是一个时序数据库，专门用于存储时序相关数据，很适合存储 CAdvisor 的数据。而且 CAdvisor本身已经提供了InfluxDB的集成方法，在启动容器时指定配置即可。</p>\n<p>InfluxDB主要功能：</p>\n<ul>\n<li>\n<p>基于时间序列，支持与时间有关的相关函数（如最大、最小、求和等）</p>\n</li>\n<li>\n<p>可度量性，可以实时对大量数据进行计算</p>\n</li>\n<li>\n<p>基于事件，支持任意的事件数据</p>\n</li>\n</ul>\n<h5 id=\"Granfana\">Granfana</h5>\n<p>Grafana是一个开源的数据监控分析可视化平台，支持多种数据源配置（支持的数据源包括InfluxDB、MySQL、Elasticsearch、OpenTSDB、Graphite等）和丰富的插件及模板功能，支持图表权限控制和报警。</p>\n<p>Granfana主要功能：</p>\n<ul>\n<li>\n<p>灵活丰富的图形化选项</p>\n</li>\n<li>\n<p>可以混合多种风格</p>\n</li>\n<li>\n<p>支持白天和夜间模式</p>\n</li>\n<li>\n<p>多个数据源</p>\n</li>\n</ul>\n<h4 id=\"compose容器编排\">compose容器编排</h4>\n<p><strong>docker-compose.yml</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.1&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"attr\">grafana_data:</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">influxdb:</span></span><br><span class=\"line\">\t<span class=\"comment\"># tutum/influxdb 相比influxdb多了web可视化视图。但是该镜像已被标记为已过时</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">tutum/influxdb:0.9</span></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">always</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">PRE_CREATE_DB=cadvisor</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;8083:8083&quot;</span>         <span class=\"comment\"># 数据库web可视化页面端口</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;8086:8086&quot;</span>         <span class=\"comment\"># 数据库端口</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./data/influxdb:/data</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">cadvisor:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">google/cadvisor:v0.32.0</span></span><br><span class=\"line\">    <span class=\"attr\">links:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">influxdb:influxsrv</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">-storage_driver=influxdb</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">-storage_driver_db=cadvisor</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">-storage_driver_host=influxsrv:8086</span></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">always</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;8080:8080&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">/:/rootfs:ro</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">/var/run:/var/run:rw</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">/sys:/sys:ro</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">/var/lib/docker/:/var/lib/docker:ro</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">grafana:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">grafana/grafana:8.5.2</span></span><br><span class=\"line\">    <span class=\"attr\">user:</span> <span class=\"string\">&#x27;104&#x27;</span></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">always</span></span><br><span class=\"line\">    <span class=\"attr\">links:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">influxdb:influxsrv</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;3000:3000&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">grafana_data:/var/lib/grafana</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">HTTP_USER=admin</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">HTTP_PASS=admin</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">INFLUXDB_HOST=influxsrv</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">INFLUXDB_PORT=8086</span></span><br></pre></td></tr></table></figure>\n<p><strong>检查语法</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker-compose config -q </span><br></pre></td></tr></table></figure>\n<p><strong>创建并启动容器</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker-compose up -d</span><br></pre></td></tr></table></figure>\n<p>查看三个服务容器是否启动</p>\n<p>测试</p>\n<ul>\n<li>\n<p>浏览cAdvisor收集服务，<a href=\"http://ip:8080/\">http://ip:8080/</a>      第一次访问慢，请稍等   cadvisor也有基础的图形展现功能，这里主要用它来作数据采集</p>\n</li>\n<li>\n<p>浏览influxdb存储服务，<a href=\"http://ip:8083/\">http://ip:8083/</a></p>\n</li>\n<li>\n<p>浏览grafana展现服务，<a href=\"http://ip:3000\">http://ip:3000</a>          ip+3000端口的方式访问,默认帐户密码（admin/admin）</p>\n</li>\n</ul>\n<h4 id=\"Grafana配置\">Grafana配置</h4>\n<h5 id=\"添加数据源\">添加数据源</h5>\n<p>在<code>Configuration</code>（小齿轮）选项卡中，选择<code>Data Sources</code>，添加一个InfluxDB数据源：</p>\n<ul>\n<li>\n<p>name：自定义一个数据源名称，例如<code>InfluxDB</code></p>\n</li>\n<li>\n<p>Query Language：查询语言，默认<code>InfluxQL</code>即可</p>\n</li>\n<li>\n<p>URL：根据compose中的容器服务名连接，<code>http://influxdb:8086</code></p>\n</li>\n<li>\n<p>database：我们在InfluxDB中创建的数据库实例，<code>cadvisor</code></p>\n</li>\n<li>\n<p>User：InfluxDB的默认用户，<code>root</code></p>\n</li>\n<li>\n<p>Password：<code>root</code></p>\n</li>\n</ul>\n<p>保存并测试，可以连通即可</p>\n<h5 id=\"添加工作台\">添加工作台</h5>\n<ul>\n<li>\n<p>在<code>Create</code>（加号）选项卡中，选择创建 <code>Dash Board</code>工作台。右上角配置中可以配置创建出来的工作台的标题、文件夹等信息。</p>\n</li>\n<li>\n<p>在创建出来的工作台中，选择<code>Add panel</code>中的<code>Add a new panel</code>添加一个新的面板。</p>\n</li>\n</ul>\n<ol>\n<li>\n<ol>\n<li>在右上角<code>Time series</code>（时序图）位置可以切换展示的图表样式（柱状图、仪表盘、表格、饼图等等）</li>\n</ol>\n</li>\n<li>右侧边栏为该图表配置相关信息：标题、描述</li>\n<li>图表下方可以配置该图表展示的数据的查询语句，例如：</li>\n</ol>\n<ul>\n<li>\n<ul>\n<li>\n<ul>\n<li>FROM：<code>cpu_usage_total</code>（Grafana会自动获取InfluxDB数据库中的元数据，可以直接选择对应表名）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ul>\n<li>WHERE：添加一个条件，<code>container_name=cig-cadvisor-1</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ul>\n<li>ALIAS：配置一个别名，<code>CPU使用情况汇总</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","_path":"post/f5f9fa9b.html","_link":"http://rycan.top/post/f5f9fa9b.html","_id":"clndbzy5j0001150phslzaluv"}}