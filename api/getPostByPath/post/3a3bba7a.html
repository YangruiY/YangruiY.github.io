{"type":"getPostByPath","data":{"title":"夯实基础（持续更新）","date":"2023-11-03T13:37:36.000Z","description":"夯实基础系列","categories":[{"name":"基础","_id":"cloioo9eh006ani0p9qch2ocn"}],"tags":[{"name":"基础","_id":"cloioo9es0099ni0p21ztgw7o"}],"content":"<meta name=\"referrer\" content=\"no-referrer\">\n# Java\n<blockquote>\n<p>结合<code>韩顺平</code>的Java 零基础笔记</p>\n</blockquote>\n<h2 id=\"1、基础概念\">1、基础概念</h2>\n<ul>\n<li>\n<p>程序： 计算机执行某些操作或者解决某个问题的一系列有序指令的集合</p>\n<ul>\n<li>\n<p>进程：程序的一次执行过程，正在运行的程序，是一个动态的过程，有自己的生命周期</p>\n</li>\n<li>\n<p>线程：进程的实体，一个进程有多个实体</p>\n</li>\n</ul>\n</li>\n<li>\n<p>java 跨平台的保障：JVM、是一种解释性语言（编译之后的字节码文件是不能被机器直接执行的）、不同于C/C++的编译型语言（编译之后的代码可以直接被机器执行）、OOP(面向对象)</p>\n</li>\n<li>\n<p>JDK = JRE + java 的开发工具（java 、javac 、javadoc 、 javap…）</p>\n</li>\n<li>\n<p>JRE = JVM + java核心类库</p>\n</li>\n</ul>\n<h2 id=\"2、语言概念\">2、语言概念</h2>\n<ul>\n<li>转义字符 <code>\\t   \\n   \\\\   \\&quot;    \\'    \\r(一个回车)</code></li>\n</ul>\n<h4 id=\"基础\">基础</h4>\n<ul>\n<li>\n<p>基本数据类型：</p>\n<ul>\n<li>数值型：\n<ul>\n<li>整型（存放整数）： byte「1字节   -128~127」 short「2字节  -2<sup>15</sup>~2<sup>15</sup>-1」   int(默认) 「4字节   -2<sup>31</sup>~2<sup>31</sup>-1」    long（L/l）「8字节    -2<sup>63</sup>~2<sup>63</sup>-1」<code>PS: (1字节=8位)</code></li>\n<li>浮点型（存放小数）：float(F/f) 「4字节： -3.403E38~3.403E38 」  double(默认) 「8字节：-1.798E308~1.798E308」 <code> PS:  浮点数=符号位+指数位+尾数位</code>      可以使用   科学计数法（5.12e2 (*10<sup>2</sup>)   5.12E-2 (*10-<sup>2</sup>)）     或者   十进制数（5.12    512.0f      .512）     的形式表示</li>\n</ul>\n</li>\n<li>字符型：(存放单个字符)char</li>\n<li>boolean   「1字节  true/false  」</li>\n</ul>\n</li>\n<li>\n<p>引用数据类型</p>\n<ul>\n<li>类</li>\n<li>数组</li>\n<li>接口</li>\n</ul>\n</li>\n<li>\n<p>自动类型转换「小  ———&gt;  大」<code>char -&gt; int -&gt; long -&gt; float  -&gt; double</code>   || <code>byte -&gt; short -&gt;  int  -&gt; long -&gt;  float -&gt; double</code>    (byte  short  char  之间不能进行转化，但是三者之间可以进行计算，计算的时候会先转为  int 类型）</p>\n</li>\n<li>\n<p>强制类型转换「大  ———&gt;  小」 要使用<code>() </code> ，但是可能会造成精度降低或者溢出  （byte   char   short   在进行运算的时候要当做 int 进行处理）</p>\n</li>\n<li>\n<p>逻辑运算</p>\n<ul>\n<li>a&amp;b : <code>&amp;</code> 叫逻辑与: 规则:当 a 和 b 同时为 true ,则结果为 true, 否则为 false</li>\n<li>a&amp;&amp;b : <code>&amp;&amp;</code> 叫短路与:规则:当 a 和 b 同时为 true ,则结果为 true,否则为 false；如果第一个条件为 false ,后面的条件不再判断;高效</li>\n<li>a|b : <code>|</code> 叫逻辑或，规则:当 a 和 b ，有一个为 true ,则结果为 true,否则为 false</li>\n<li>a||b : <code>|| </code>叫短路或，规则:当 a 和 b ，有一个为 true ,则结果为 true,否则为 false；如果第一个条件为 true，则第二个条件不会判断，效率高</li>\n<li>!a : 叫<code>取反</code>，或者非运算。当 a 为 true, 则结果为 false, 当 a 为 false 是，结果为 true</li>\n<li>a^b: 叫<code>逻辑异或</code>，当 a 和 b 不同时，则结果为 true, 否则为 false</li>\n</ul>\n</li>\n<li>\n<p>进制:</p>\n<p>对于整数，有四种表示方式:</p>\n<ul>\n<li>二进制:0,1 ，满2进1.以0b或0B开头。</li>\n<li>十进制:0-9 ，满 10 进 1。</li>\n<li>八进制:0-7 ，满 8 进 1. 以数字 0 开头表示。</li>\n<li>十六进制:0-9 及 A(10)-F(15)，满 16 进 1. 以 <strong>0x</strong> 或 <strong>0X</strong> 开头表示。此处的 A-F 不区分大小写。</li>\n</ul>\n</li>\n<li>\n<p>进制之间的转换：</p>\n<ul>\n<li>\n<p>2  -&gt; 10</p>\n<p>规则：从最低位（右边）开始，将每个位上的数提取出来，乘以2的（位数-1）次方，然后求和。</p>\n<p>案例：请将0b1011转成十进制的数      0b1011=1*2<sup>(1-1)</sup>+1*2<sup>(2-1)</sup>+0*2<sup>(3-1)</sup>+1* 2<sup>(4-1)</sup>=1+2+0+8=11</p>\n</li>\n<li>\n<p>2 -&gt; 8</p>\n<p>规则:从低位开始,将二进制数每三位一组，转成对应的八进制数即可。</p>\n<p>案例:请将  ob11(3)010(2)101(5) =&gt; 0325</p>\n</li>\n<li>\n<p>2-&gt; 16</p>\n<p>规则:从低位开始，将二进制数每四位一组，转成对应的十六进制数即可。</p>\n<p>案例:请将 ob1101(D)0101(5) = 0xD5</p>\n</li>\n<li>\n<p>10 -&gt; 2</p>\n<p>规则:将该数不断除以 2，直到商为 0 为止，然后将每步得到的余数倒过来，就是对应的二进制。</p>\n<p>案例:请将 34   = 0B00100010</p>\n</li>\n<li>\n<p>10 -&gt; 8</p>\n<p>规则:将该数不断除以 8，直到商为 0 为止，然后将每步得到的余数倒过来，就是对应的八进制。</p>\n<p>案例:请将 131  =&gt; 0203</p>\n</li>\n<li>\n<p>10 -&gt; 16</p>\n<p>规则:将该数不断除以 16，直到商为 0 为止，然后将每步得到的余数倒过来，就是对应的十六进制。</p>\n<p>案例:请将 237  =&gt; 0xED</p>\n</li>\n<li>\n<p>8 -&gt; 2</p>\n<p>规则:将八进制数每 1 位，转成对应的一个 3 位的二进制数即可。</p>\n<p>案例:  02(010)3(011)7(111) = 0b10011111</p>\n</li>\n<li>\n<p>8 -&gt; 10</p>\n<p>规则：从最低位（右边）开始，将每个位上的数提取出来，乘以8的（位数-1）次方然后求和。</p>\n<p>案例：请将0234转成十进制的数    0234=4*8<sup>0</sup>+3*8<sup>1</sup>+2*8<sup>2</sup>=4+24+128=156</p>\n</li>\n<li>\n<p>16 - &gt; 2</p>\n<p>规则:将十六进制数每 1 位，转成对应的 4 位的一个二进制数即可。</p>\n<p>案例: 0x2(0010)3(0011)B(1011) = 0b001000111011</p>\n</li>\n<li>\n<p>16 -&gt; 10</p>\n<p>规则:从最低位(右边)开始，将每个位上的数提取出来，乘以 16 的(位数-1)次方，然后求和。</p>\n<p>案例:请将 0x23A 转成十进制的数     0x23A = 10 * 16<sup>0</sup> + 3 * 16 <sup>1</sup> + 2 * 16<sup>2</sup> = 10 + 48 + 512 = 570</p>\n</li>\n</ul>\n</li>\n<li>\n<p>原码补码反码</p>\n<p>对于有符号的而言：</p>\n<ol>\n<li>二进制的最高位是符号位：0表示正数，1表示负数</li>\n<li>正数的<code>原码，反码，补码</code>都一样（三码合一）</li>\n<li>负数的<code>反码</code>=它的<code>原码</code>符号位不变，其它位<code>取反</code>(0-&gt;1,1-&gt;0)</li>\n<li>负数的<code>补码</code>=它的<code>反码</code>+1，负数的<code>反码</code>=负数的<code>补码</code>-1</li>\n<li>0的<code>反码，补码</code>都是0</li>\n<li>java中的数都是有符号的</li>\n<li>在计算机运算的时候，都是以<code>补码</code>的方式来运算的.</li>\n<li>当我们看运算结果的时候，要看他的<code>原码</code>（重点）</li>\n</ol>\n</li>\n<li>\n<p>位运算</p>\n<p>分别是按位与&amp;、按位或按位异或A,按位取反~，它们的运算规则是：</p>\n<ol>\n<li>按位与<code>&amp;</code>     两位全为1，结果为1，否则为0</li>\n<li>按位或 <code>|</code>         两位有一个为1，结果为1，否则为0</li>\n<li>按位异或<code>^</code>     两位一个为0，一个为1，结果为1，否则为0</li>\n<li>按位取反<code>~</code>：    0-&gt;1,1-&gt;0</li>\n<li>算术右移 <code>&gt;&gt;</code>:低位溢出,符号位不变,并用符号位补溢出的高位</li>\n<li>算术左移 <code>&lt;&lt;</code>: 符号位不变,低位补 0</li>\n<li><code>&gt;&gt;&gt;</code> 逻辑右移也叫无符号右移: 运算规则是: 低位溢出，高位补 0</li>\n<li>特别说明:没有 &lt;&lt;&lt; 符号</li>\n</ol>\n</li>\n<li>\n<p>循环   之  for  「(1)循环变量初始化；(2)循环条件；(3)循环操作」{  (4)循环变量迭代 }   执行顺序：（1）-&gt; （2） -&gt; （4） -&gt; （3）</p>\n</li>\n<li>\n<p>重载 VS   重写</p>\n<ul>\n<li>==重载：== 作用在一个类上；多个方法的   <code>形参列表中的（顺序，个数， 类型）</code>   任何一个一样就可以  「多个方法重载时要是存在  可变参数列表的方法时， 匹配的话就会优先匹配 具体参数个数的方法」，(PS: 对返回类型和访问修饰符没有要求)</li>\n<li>==重写：==作用于父子类；子类的某个方法和父类的某个方法<code>方法名称、参数列表</code>完全一样，子类<code>返回值类型和抛出的异常</code>是父类<code>返回值类型和抛出的异常</code>的子类 或者 一样，子类方法不能缩小父类方法的访问权限</li>\n</ul>\n</li>\n<li>\n<p>作用域：</p>\n<ul>\n<li>全局变量： 就是属性，作用域是整个类。可以不赋值，直接使用，有默认值</li>\n<li>局部变量：通常指的就是：在方法中定义的变量；即属性之外的其他变量，作用在所在代码块中；必须赋值之后才能使用，没有默认值</li>\n<li>使用原则：属性和局部变量可以重名「非同一作用域」，但是访问遵循就近原则，同一个作用域中不能重名</li>\n<li>属性的生命周期和对象相同，而局部变量的生命周期和代码块相同</li>\n</ul>\n</li>\n<li>\n<p>this VS super</p>\n<ul>\n<li>this :\n<ul>\n<li>可以访问本类的属性、方法、构造器</li>\n<li>可以区分当前类的属性 和 局部变量</li>\n<li>访问成员方法的语法为  this.方法名(参数列表)</li>\n<li>访问构造器的语法：this(参数列表)  只能在构造器中使用，必须放在第一个行</li>\n<li>必须要类定义的方法中使用，不能在类定义的外部使用</li>\n</ul>\n</li>\n<li>super：\n<ul>\n<li>代表父类的引用，用于访问父类的属性、方法、构造器</li>\n<li>但是不能访问父类的私有属性、私有方法</li>\n<li>访问构造器的语法：super(参数列表)  只能在构造器中使用，必须放在第一个行</li>\n<li>只有在子类和父类  属性 方法  重名的时候访问时才必须要加上super 关键字</li>\n<li>不限于直接父类，间接父类要是和子类的方法名一样，想要访问间接父类也可以用super ，但是多个子类的方法都是一样的，那么访问就会按照就近原则</li>\n</ul>\n</li>\n<li>对比\n<ul>\n<li>访问属性：this : 访问本类中的属性，如果本类没有此属性则从父类中继续查找           super : 从父类开始查找属性</li>\n<li>调用方法：this : 访问本类中的方法，如果本类没有此方法则从父类中继续查找.          super : 从父类开始查找方法</li>\n<li>调用构造器：this :调用本类构造器，必须放在构造器的首行                                           super : 调用父类构造器，必须放在子类构造器的首行</li>\n<li>特殊：this ：表示当前对象                                                                                                  super : 子类中访问父类对象</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>访问修饰符</p>\n<p>可以修饰  类中的属性、方法、类（只有public  默认（不写）才能修饰 类）</p>\n<ul>\n<li>public ：同类  、同包、子类、不同包</li>\n<li>protect：同类  、同包、子类</li>\n<li>default(默认)：同类  、同包</li>\n<li>private：同类</li>\n</ul>\n</li>\n<li>\n<p>三大特性</p>\n<ul>\n<li>\n<p>封装：</p>\n<ul>\n<li>隐藏实现细节，通过暴露接口给外部调用，保证数据的安全性</li>\n<li>1、将属性私有化    2、提供公有（public）的访问方法（set / get）</li>\n</ul>\n</li>\n<li>\n<p>继承</p>\n<ul>\n<li>可以解决代码复用问题，非私有的属性和方法可以被子类直接访问，但是私有的属性和方法不能在子类中直接访问，要通过父类提供的公共方法去访问</li>\n<li>子类必须调用父类的构造器才能完成父类的初始化（一般不用写，默认调用的是父类的默认的无参构造器「即： 默认会在所有的子类的构造器的第一行会默认写上super()」</li>\n<li>但是要是父类没有无参构造器，此时必须在子类的构造器中用super(…….)去指定使用的是父类的那一个构造器才能完成父类的初始化工作,</li>\n<li>值得注意的是：要是父类已经有一个构造器（非默认的构造器），就不会有默认的无参构造器了，要是想要实现无参构造器，那么就要手动实现</li>\n<li>也可以使用super 去调用指定的父类的构造器</li>\n<li>this 和 super 在一个类的构造器中只能选一个，并放在第一行</li>\n<li>所有的类的父类是Object ,父类构造器的调用不限于直接父类，可以一直追溯到顶级（Object）父类中</li>\n</ul>\n</li>\n<li>\n<p>多态</p>\n<ul>\n<li>说的就是<code>对象或者方法</code>具有多种形态,所谓的<code>方法的多态</code>就是  重载和重写，而<code>对象的多态</code>：对象的编译类型（=左边，在定义对象的时候就确定了，不能改变，父类）和运行类型（=右边，运行时是变化的，子类）可以不一样</li>\n<li>继承是前提</li>\n<li>向上转型：父类的引用指向子类的对象，  <code>父类类型    引用名 =  new 子类类型()</code>；只能调用父子类公有的，不能调用子类特有的属性方法，最终的运行效果以子类的为准</li>\n<li>向下转型：  <code>子类类型  引用名 =  (子类类型)   父类的引用</code>； 只能强转父类的引用，不能强转父类的对象，要求父类的引用必须指向的是当前目标类型的对象，向下转型之后，可以调用子类类型的所有成员;在使用向下转型的时候，必须在声明父类引用的时候就声明为和要向下转型的子类类型一致才可以：<code>Father fa = new Girl();        Girl son = (Girl) fa;</code>  否则会有 类型转换异常的错误</li>\n<li><code>instanceOf</code> 比较操作符，用于判断对象的运行类型是否为XX类型或XX类型的子类型</li>\n<li>动态绑定：当调用<code>对象方法</code>的时候，该方法会和该对象的<code>内存地址/运行类型</code>绑定；当调用<code>对象属性</code>时，没有动态绑定机制，哪里声明，那里使用</li>\n<li>使用应用：\n<ul>\n<li>多态数组：数组的定义类型为父类类型，里面保存的实际元素类型为子类类型</li>\n<li>多态参数：方法的形参类型是父类类型，实参类型允许为子类类型</li>\n<li>上面的两个都要借助<code>  instanceof</code> 判断是不是摸个累的子类，并要 向下转型 才能实现对应的方法</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>Object类</p>\n<ul>\n<li>\n<p>equals()    Object中 只判断对象引用是不是一样的（判断地址是不是一样的），Object 的子类会重写，判断两个内容是不是一样的</p>\n<ul>\n<li>它是自反的：对于任何非空引用值x，x.equals(x)应该返回true。</li>\n<li>它是对称的：对于任何非空引用值x和y，当且仅当y.equals(x)返回true时，x.equals(y)应该返回true。</li>\n<li>它是传递的：对于任何非空引用值x、y和z，如果x.equals(y)返回true且y.equals(z)返回true，则x.equals(z)应该返回true。</li>\n<li>它是一致的：对于任何非空引用值x和y，只要在equals比较中使用的信息没有被修改，多次调用x.equals(y)应始终一致地返回true或一致地返回false。 对于任何非空引用值x，x.equals(null)应返回false。</li>\n<li>Object类的equals方法实现了对对象的最具区分性的等价关系；也就是说，对于任何非空引用值x和y，当且仅当x和y引用同一个对象（x == y的值为true）时，该方法返回true。</li>\n<li>==    比较运算符，基本数据类型比较的是数值，引用类型比较的是地址（是不是一个对象）</li>\n</ul>\n</li>\n<li>\n<p>hashcode() 返回的是对象的hash码，可以提升哈希表的性能</p>\n<ul>\n<li>(前提：只要在equals比较中使用的信息没有被修改)  对同一个对象多次调用hashCode方法时，hashCode方法必须始终返回相同的整数</li>\n<li>根据equals() 比较两个对象是不是相等的；相等的话，那么两个对象调用hashcode()所生成的整数值也是相等的，不相等的话，那么所生成的哈希码可以不一样</li>\n<li>Object中的hashcode()—哈希值；主要根据地址号来的,但是不能完全将哈希值等价于地址；Object 的<code>子类</code>重写的hashcode()则是可以根据<code>内容</code>得到哈希码</li>\n</ul>\n<blockquote>\n<p>通常需要在<code>重写equals</code>方法的同时重写<code>hashCode</code>方法，以满足hashCode方法的一般约定，即<code>相等的对象必须具有相等的哈希码</code>。</p>\n</blockquote>\n</li>\n<li>\n<p>toString()     默认返回:全类名+@+哈希值的十六进制,子类往往重写 toString 方法，用于返回对象的属性信息，打印对象或拼接对象时，都会自动调用该对象的toString形式</p>\n</li>\n<li>\n<p>finalize 方法</p>\n<ul>\n<li>当对象被回收时，系统自动调用该对象的finalize方法</li>\n<li>什么时候被回收:当某个对象没有任何引用时，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来 销毁该对象，在销毁该对象前，会先调用 finalize 方法</li>\n<li>垃圾回收机制的调用，是由系统来决定(即有自己的GC算法),也可以通过System.gc()主动触发垃圾回收机制</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>一些规范：</p>\n<ol>\n<li>包名:多单词组成时所有字母都小写</li>\n<li>类名、接口名:多单词组成时，所有单词的首字母大写「大驼峰」</li>\n<li>变量名、方法名:多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写「小驼峰」</li>\n<li>常量名:所有字母都大写。多单词时每个单词用下划线连接</li>\n</ol>\n</blockquote>\n<h4 id=\"高级\">高级</h4>\n<ul>\n<li>\n<p>静态变量（类变量）   <code>static</code>修饰的变量</p>\n<ul>\n<li>静态变量是属于类的，不是属于对象的，只有一个副本。又称之为类变量，是一个类的所有实例共享的;类加载的时候就生成了</li>\n<li>访问：对象名.类变量名   /     类名.类变量名</li>\n<li>什么时候需要用类变量：当我们需要让某个类的所有对象都共享一个变量时，就可以考虑使用类变量（静态变量)：</li>\n<li>类变量与实例变量（普通属性）区别 ：类变量是该类的所有对象共享的，而实例变量是每个对象独享的。</li>\n<li>加上static称为类变量或静态变量，否则称为实例变量/普通变量/非静态变量</li>\n<li>类变量是在类加载时就初始化了，也就是说，即使你没有创建对象，只要类加载了，就可以使用类变量了</li>\n<li>类变量的生命周期是随类的加载开始，随着类消亡而销毁。</li>\n<li>类方法和类变量不能有和对象相关的关键字，即 :   this   &amp;   super</li>\n<li>静态（类）方法：   静态方法不能访问非静态变量，只能访问静态成员，非静态方法在访问修饰符允许的情况下都可以访问</li>\n</ul>\n</li>\n<li>\n<p>代码块：只有方法体，加载的时候或者创建对象的时候隐式的调用的，修饰符要写的话只能写 static</p>\n<ul>\n<li>静态代码块在类加载的时候执行，只执行一次，普通代码块是每创建一个非静态对象，就调用执行一次</li>\n<li>创建对象实例、创建子类对象实例，父类也会加载、使用类的静态成员（静态属性或者静态方法）时都会加载类</li>\n<li>创建一个对象时，在一个类调用顺序是：\n<ul>\n<li>①调用<code>静态代码块和静态属性初始化</code>（注意：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用)</li>\n<li>②调用<code>普通代码块和普通属性的初始化</code>（注意：普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义顺序调用)</li>\n<li>③调用<code>构造器</code>（里面可能也有<code>super</code>  和调用<code>普通代码块</code> ）</li>\n</ul>\n</li>\n<li>创建一个子类对象时，在一个类调用顺序是：\n<ul>\n<li>①父类的静态代码块和静态属性（优先级一样，按定义顺序执行）</li>\n<li>②子类的静态代码块和静态属性（优先级一样，按定义顺序执行）</li>\n<li>③父类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）</li>\n<li>④父类的构造方法</li>\n<li>⑤子类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）</li>\n<li>⑥子类的构造方法</li>\n</ul>\n</li>\n<li>静态代码块只能直接调用静态成员（静态属性和静态方法），普通代码块可以调用任意成员</li>\n</ul>\n</li>\n<li>\n<p>final :可以修饰所有不期望变化或者继承或者重写   的  类  、属性 、方法 、局部变量</p>\n<ul>\n<li><code>静态</code>不可变常量  使用 static final 进行修饰  ； 初始化的位置只能是： 定义时  或者  静态代码块；不能在构造器中赋值</li>\n<li>final  的<code>非静态</code>变量的初始化位置： 定义时  或者  代码块 、 构造器中</li>\n<li>final 修饰类不能被继承但是可以实例化</li>\n<li>包装类 + String  都是   final 的</li>\n</ul>\n</li>\n<li>\n<p>抽象类：  abstract 类；抽象类会被继承，有其子类来实现抽象方法；抽象类不能被实例化，可以没有 abstract 方法，一旦包含了abstract 方法 就一定要将这个类声明为  abstract 类；  abstract 只能修饰 类和方法</p>\n<ul>\n<li>如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法除非它自己也声明为abstract类。</li>\n</ul>\n</li>\n<li>\n<p>接口：    interface；将一些设计出来但是没有实现的方法进行封装到一起，当某个类要使用的时候就实现这些方法</p>\n<ul>\n<li>\n<p>是更加抽象的抽象类，抽象类中的方法可以有方法体，接口里的所有方法都没有方法体『Jdk7.0』。特别说明：『Jdk8.0』后接口类可以有静态方法，默认方法，也就是说接口中可以有方法的具体实现</p>\n</li>\n<li>\n<p>接口不能被实例化;接口中所有的方法是public方法，接口中抽象方法，可以不用abstract修饰;一个普通类实现接口就必须将该接口的所有方法都实现。但是抽象类实现接口，可以不用实现接口的方法。</p>\n</li>\n<li>\n<p>接口中的属性，只能是final的，而且默认的是public static final修饰符。</p>\n</li>\n<li>\n<p>接口中属性的访问形式：接口名.属性名</p>\n</li>\n<li>\n<p>接口不能继承其它的类，但是可以继承多个接口</p>\n</li>\n<li>\n<p>接口的修饰符只能是public和默认，这点和类的修饰符是一样的。</p>\n</li>\n<li>\n<p>接口也是与多态性的；多态参数，多态数组（数组存的是实现类的对象），也存在多态传递的现象</p>\n</li>\n</ul>\n</li>\n<li>\n<p>内部类（4个）</p>\n<ul>\n<li>\n<p>定义在类的局部位置（==方法/代码块==）</p>\n<ul>\n<li>局部内部类： 定义在类的局部位置 :\n<ul>\n<li>可以直接访问外部类的所有成员，包含私有的</li>\n<li>不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量是不能使用修饰符的。但是可以使用final修饰，因为局部变量也可以使用 final</li>\n<li>作用域：仅仅在定义它的方法或代码块中。</li>\n<li>局部内部类—访问------------&gt;外部类的成员               访问方式：直接访问</li>\n<li>外部类---------访问------------&gt;局部内部类的成员        访问方式：创建对象，再访问（注意：必须在作用域内）</li>\n<li>外部其他类–不能访问—&gt;局部内部类                     （因为局部内部类地位是一个局部变量）</li>\n<li>如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> ry.lambda;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OuterAndInner</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Inner02 inner02 = new Inner02();// 报错  外部其他类--不能访问---&gt;局部内部类</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Outer0</span> <span class=\"variable\">outer0</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Outer0</span>();</span><br><span class=\"line\">        outer0.m2();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span>  <span class=\"title class_\">Outer0</span>&#123; <span class=\"comment\">//外部类</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span>  <span class=\"type\">int</span> <span class=\"variable\">n1</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span>  <span class=\"type\">int</span> <span class=\"variable\">n2</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">m1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Outer0 m1()&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">m2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">class</span> <span class=\"title class_\">Inner02</span> &#123;<span class=\"comment\">//局部内部类</span></span><br><span class=\"line\">           <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">n1</span> <span class=\"operator\">=</span> <span class=\"number\">800</span>;</span><br><span class=\"line\">           <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">f1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">               System.out.println(n2);<span class=\"comment\">//局部内部类---访问---&gt;外部类的成员   访问方式：直接访问</span></span><br><span class=\"line\">               System.out.println(<span class=\"string\">&quot;n1=&quot;</span> + n1 + <span class=\"string\">&quot; 外部类的 n1=&quot;</span> + Outer0.<span class=\"built_in\">this</span>.n1);<span class=\"comment\">//重名时,如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问</span></span><br><span class=\"line\">               System.out.println(<span class=\"string\">&quot;Outer02.this hashcode=&quot;</span> + Outer0.<span class=\"built_in\">this</span>);</span><br><span class=\"line\">               m1();<span class=\"comment\">//局部内部类---访问-------&gt;外部类的成员       访问方式：直接访问</span></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"type\">Inner02</span> <span class=\"variable\">inner02</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Inner02</span>();</span><br><span class=\"line\">       inner02.f1(); <span class=\"comment\">//外部类--访问--&gt;局部内部类的成员    访问方式：创建对象，再访问（注意：必须在作用域内）</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>匿名内部类\n<ul>\n<li>匿名内部类的语法比较奇特，请大家注意，因为匿名内部类既是一个类的定义；同时它本身也是一个对象，因此从语法上看，它既有定义类的特征，也可以创建对象，因此可以调用匿名内部类方法。</li>\n<li>可以直接访问外部类的所有成员，包含私有的;不能添加访问修饰符，因为它的地位就是一个局部变量。</li>\n<li>作用域：仅仅在定义它的方法或代码块中。</li>\n<li>匿名内部类—访问------------------&gt;外部类成员                     [访问方式： 直接访问]</li>\n<li>外部其他类–不能访问-------------&gt;匿名内部类                 （因为匿名内部类地位是一个局部变量）</li>\n<li>如果外部类和匿名内部类的成员重名时，匿名内部类访问的话，默认遵循就近原则如果想访问外部类的成员，则可以使用(外部类名.this.成员)去访问</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OuterAndInner</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Outer1</span> <span class=\"variable\">outer1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Outer1</span>();</span><br><span class=\"line\">        outer1.m1();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span>  <span class=\"title class_\">Outer1</span> &#123; <span class=\"comment\">//外部类</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">n1</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">n2</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">m1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Outer0 m1()&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(n2); <span class=\"comment\">//匿名内部类---访问------------&gt;外部类成员     [访问方式： 直接访问]</span></span><br><span class=\"line\">        <span class=\"type\">IA</span> <span class=\"variable\">tiger</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IA</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">happy</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;哈哈哈哈哈&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;tiger 的运行类型=&quot;</span> + tiger.getClass());</span><br><span class=\"line\">        tiger.happy();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">IB</span> <span class=\"variable\">ib</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IB</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">void</span> <span class=\"title function_\">haha</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;嘿嘿嘿&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        ib.haha();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">IC</span> <span class=\"variable\">ic</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IC</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">void</span>  <span class=\"title function_\">watch</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;watch 123&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        ic.watch();</span><br><span class=\"line\">        <span class=\"type\">CI</span> <span class=\"variable\">ci</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CI</span>()&#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">void</span>  <span class=\"title function_\">watch</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;watch 321&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        ci.watch();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">IA</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">happy</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span>  <span class=\"title class_\">IB</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">haha</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span>  <span class=\"title class_\">IC</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span>  <span class=\"title function_\">watch</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;watch TV&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CI</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">IC</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span>  <span class=\"title function_\">watch</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;watch Phone&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>定义在成员位置（==属于类的，在类中==）</p>\n<ul>\n<li>成员内部类（非 static ）\n<ul>\n<li>成员内部类是定义在外部类的成员位置，并且没有static修饰。可以直接访问外部类的所有成员，包含私有的</li>\n<li>可以添加任意访问修饰符(public、.protected、默认、private),因为它的地位就是一个成员。</li>\n<li>作用域 : 和外部类的其他成员一样，整个类</li>\n<li>成员内部类–访问--------&gt;外部类成员               （比如：属性)[访问方式：直接访问]</li>\n<li>外部类--------访问--------&gt;成员内部类                 访问方式：创建对象，再访问</li>\n<li>外部其他类–访问--------&gt;成员内部类                 访问方式：创建外部类的对象,    对象.new 内部类  或者 对象.get对象实例，再访问</li>\n<li>如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.ths成员）去访问</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OuterAndInner</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Inner02 inner02 = new Inner02();// 报错  外部其他类--不能访问---&gt;局部内部类</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Outer2</span> <span class=\"variable\">outer2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Outer2</span>();</span><br><span class=\"line\">        outer2.f2();    <span class=\"comment\">//外部类--------访问--------&gt;成员内部类                 访问方式：创建对象，再访问</span></span><br><span class=\"line\">        outer2.<span class=\"keyword\">new</span> <span class=\"title class_\">Inner2</span>().say();           <span class=\"comment\">//外部其他类--访问--------&gt;成员内部类</span></span><br><span class=\"line\">        outer2.getInner08Instance().say();  <span class=\"comment\">//外部其他类--访问--------&gt;成员内部类</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span>  <span class=\"title class_\">Outer2</span>&#123; <span class=\"comment\">//外部类</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span>  <span class=\"type\">int</span> <span class=\"variable\">n1</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span>  <span class=\"type\">int</span> <span class=\"variable\">n2</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">m1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Outer0 m1()&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Inner2</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span>  <span class=\"type\">int</span> <span class=\"variable\">n1</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">        <span class=\"keyword\">void</span> <span class=\"title function_\">say</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">            System.out.println(n2);<span class=\"comment\">//成员内部类--访问--------&gt;外部类成员          （比如：属性)[访问方式：直接访问]</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;n1 = &quot;</span> + n1 + <span class=\"string\">&quot; 外部类的 n1=&quot;</span> + Outer2.<span class=\"built_in\">this</span>.n1);</span><br><span class=\"line\">            m1();<span class=\"comment\">//成员内部类--访问--------&gt;外部类成员          （比如：属性)[访问方式：直接访问]</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Inner2 <span class=\"title function_\">getInner08Instance</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Inner2</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     <span class=\"keyword\">void</span> <span class=\"title function_\">f2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">         <span class=\"type\">Inner2</span> <span class=\"variable\">inner2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Inner2</span>();</span><br><span class=\"line\">         inner2.say();</span><br><span class=\"line\">         System.out.println(inner2.n1);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>静态内部类（ static ）\n<ul>\n<li>静态内部类是定义在外部类的成员位置，并且有static修饰</li>\n<li>可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员</li>\n<li>可以添加任意访问修饰符(public、.protected、默认、private),因为它的地位就是一个成员。</li>\n<li>作用域：同其他的成员，为整个类体</li>\n<li>静态内部类–访问–&gt;外部类                                （只能访问静态的外部属性或者方法）[访问方式：直接访问所有静态成员]</li>\n<li>外部类---------访问---------&gt;静态内部类                 访问方式：创建对象，再访问</li>\n<li>外部其他类----访问---------&gt;静态内部类               访问方式：创建外部类的对象,    对象.new 内部类  或者 对象.get对象实例，再访问</li>\n<li>如果外部类和静态内部类的成员重名时，静态内部类访问的时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.成员）去访问</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OuterAndInner</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Inner02 inner02 = new Inner02();// 报错  外部其他类--不能访问---&gt;局部内部类</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Outer3</span> <span class=\"variable\">outer3</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Outer3</span>();</span><br><span class=\"line\">        outer3.m1();</span><br><span class=\"line\">        <span class=\"comment\">//外部其他类----访问---------&gt;静态内部类               访问方式：创建外部类的对象,    对象.new 内部类  或者 对象.get对象实例，再访问 </span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Outer3</span>.Inner3().say();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Outer3</span>().getInner3().say();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">class</span>  <span class=\"title class_\">Outer3</span>&#123; <span class=\"comment\">//外部类</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span>  <span class=\"variable\">n1</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span>  <span class=\"type\">int</span> <span class=\"variable\">n2</span> <span class=\"operator\">=</span> <span class=\"number\">400</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">m1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Outer0 m1()&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Inner3</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">n1</span> <span class=\"operator\">=</span> <span class=\"number\">400</span>;</span><br><span class=\"line\">        <span class=\"keyword\">void</span> <span class=\"title function_\">say</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;n1 = &quot;</span> + n1 + <span class=\"string\">&quot; 外部类的 n1=&quot;</span> + Outer3.n1);<span class=\"comment\">//静态内部类--访问--&gt;外部类    （只能访问静态的外部属性或者方法）[访问方式：直接访问所有静态成员]</span></span><br><span class=\"line\">            m1();<span class=\"comment\">//静态内部类--访问--&gt;外部类      （只能访问静态的外部属性或者方法）[访问方式：直接访问所有静态成员]</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">      <span class=\"keyword\">public</span> Inner3 <span class=\"title function_\">getInner3</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">          System.out.println(<span class=\"string\">&quot;not static&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Inner3</span>();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">f2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Inner3</span> <span class=\"variable\">inner3</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Inner3</span>();</span><br><span class=\"line\">        inner3.say(); <span class=\"comment\">//外部类---------访问---------&gt;静态内部类         访问方式：创建对象，再访问</span></span><br><span class=\"line\">        System.out.println(Inner3.n1); <span class=\"comment\">//外部类---------访问---------&gt;静态内部类         访问方式：创建对象，再访问</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>枚举类</p>\n<ul>\n<li>当我们使用enum 关键字开发一个枚举类时，默认会继承Enum类, 而且是一个final 类</li>\n<li>传统的 public static final Season2 SPRING = new Season2(“春天”, “温暖”); 简化成 SPRING(“春天”, “温暖”)；这里必须知道，它调用的是哪个构造器.</li>\n<li>如果使用无参构造器创建枚举对象，则实参列表和小括号都可以省略</li>\n<li>当有多个枚举对象时，使用,间隔，最后有一个分号结尾</li>\n<li>枚举对象必须放在枚举类的行首</li>\n</ul>\n</li>\n<li>\n<p>注解</p>\n<p>三个基本的 Annotation:</p>\n<ul>\n<li>@Override: 限定某个方法，是重写父类方法, 该注解只能用于方法     可以修饰方法</li>\n<li>@Deprecated: 用于表示某个程序元素(类, 方法等)已过时         可以修饰方法，类，字段, 包, 参数 等等</li>\n<li>@SuppressWarnings: 抑制编译器警告</li>\n</ul>\n<p>元注解：JDK 的元 Annotation 用于修饰其他 Annotation</p>\n<ul>\n<li>Retention //指定注解的作用范围，三种 SOURCE,CLASS,RUNTIME</li>\n<li>Target // 指定注解可以在哪些地方使用</li>\n<li>Documented //指定该注解是否会在 javadoc 体现</li>\n<li>Inherited //子类会继承父类注解</li>\n</ul>\n</li>\n<li>\n<p>异常</p>\n<ul>\n<li>\n<p>Java语言中，将程序<code>执行中发生的不正常情况称为“异常”</code>。（开发过程中的语法错误和逻辑错误不是异常)</p>\n</li>\n<li>\n<p>执行过程中所发生的异常事件可分为两大类</p>\n<ul>\n<li>\n<p>Error(错误：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError[栈溢出]和OOM(out of memory),Error是严重错误，程序会崩溃。</p>\n</li>\n<li>\n<p>Exceptio:其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。</p>\n<p>Exception分为两大类：</p>\n<ul>\n<li>运行时异常[程序运行时，发生的异常] :</li>\n<li>运行时异常，编译器检查不出来。一般是指编程时的逻辑错误，是程序员应该避免其出现的异常。java.lang.RuntimeException类及它的子类都是运行时异常;对于运行时异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响</li>\n<li>编译时异常编程时，编译器检查出的异常]。编译时异常，是编译器要求必须处置的异常。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>处理的方式</p>\n<ul>\n<li>try-catch-finally      程序员在代码中捕获发生的异常，自行处理\n<ul>\n<li>如果异常发生了，则异常发生后面的代码不会执行，直接进入到 catch 块</li>\n<li>如果异常没有发生，则顺序执行 try 的代码块，不会进入到 catch</li>\n<li>如果希望不管是否发生异常，都执行某段代码(比如关闭连接，释放资源等)则使用如下代码- finally</li>\n<li>可以有多个ctch语句，捕获不同的异常（进行不同的业务处理），要求父类异常在后，子类异常在前，比如(Exception在后，NullPointerException在前)，如果发生异常，只会匹配一个catch,案例演示</li>\n<li>可以进行 try-finally 配合使用, 这种用法相当于没有捕获异常， 因此程序会直接崩掉/退出。</li>\n</ul>\n</li>\n<li>throws      将发生的异常抛出，交给调用者（方法）来处理，最顶级的处理者就是VM\n<ul>\n<li>对于编译异常，程序中必须处理，比如 try-catch 或者 throws</li>\n<li>对于运行时异常，程序中如果没有处理，默认就是 throws 的方式处理</li>\n<li>子类重写父类的方法时，对抛出异常的规定:子类重写的方法，所抛出的异常类型要么和父类抛出的异常一致，要么为父类抛出的异常类型的子类型</li>\n<li>在 throws 过程中，如果有方法 try-catch , 就相当于处理异常，就可以不必 throws</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>​                              意义                                                            位置                                                                   后面跟的东西<br>\nthrows            异常处理的一种方式                                   方法声明处                                                               异常类型<br>\nthrow              手动生成异常对象的关键字                       方法体中                                                                    异常对象</p>\n</li>\n</ul>\n</li>\n<li>\n<p>String</p>\n<p>两种创建 String 对象的区别</p>\n<ul>\n<li>\n<p>方式一：直接赋值String s=“abc”;         先从常量池查看是否有&quot;abc”&quot;数据空间，如果有，直接指向；如果没有则重新创建，然后指向。S最终指向的是常量池的空间地址</p>\n</li>\n<li>\n<p>方式二：调用构造器String s2=new String(“abc”);  先在堆中创建空间，里面维护了value属性，指向常量池的] abc 空间，如果常量池没有&quot;abc&quot;,重新创建，如果有，直接通过value指向。最终指向的是堆中的空间地址。</p>\n</li>\n<li>\n<p>当调用<code>intern</code>方法时，如果字符串常量池已经包含一个等于此String对象的字符串（用equals(  )方法确定)，则返回池中的字符串。否则，将此String对象添<br>\n加到池中，并返回此String对象的引用</p>\n</li>\n<li>\n<p>String b = new String(“abc”) ;       b.intern()方法最终返回的是常量池的地址（对象）</p>\n</li>\n<li>\n<p>String c1=&quot;ab”+“cd”;常量相加，在池中, == 比值         String c1=a+b;变量相加，是在堆中。== 比地址</p>\n</li>\n</ul>\n</li>\n<li>\n<p>泛型</p>\n<ul>\n<li>编译时，检查添加元素的类型，解决了使用基本数据类型的安全性</li>\n<li>注意： 因为静态是和类相关的，在类加载时，对象还没有创建，所以，如果静态方法和静态属性使用了泛型，JVM 就无法完成初始化</li>\n<li>泛型不具备继承性</li>\n<li><code>&lt;?&gt;:支持任意泛型类型 </code></li>\n<li><code>&lt;?extends A&gt;:支持A类以及A类的子类，规定了泛型的上限</code></li>\n<li><code> &lt;?super A&gt;:支持A类以及A类的父类，不限于直接父类，规定了泛型的下限</code></li>\n</ul>\n</li>\n<li>\n<p>反射</p>\n<ul>\n<li>\n<p>Class也是类，因此也继承Object类</p>\n</li>\n<li>\n<p>Class类对象不是new出来的，而是系统创建的</p>\n</li>\n<li>\n<p>对于某个类的Class类对象，在内存中只有一份，因为类只加载一次</p>\n</li>\n<li>\n<p>每个类的实例都知道自己是由哪个Class实例所生成</p>\n</li>\n<li>\n<p>通过Class对象可以完整地得到一个类的完整结构，通过一系列API</p>\n</li>\n<li>\n<p>Class对象是存放在堆区的，不是方法区。类的<a href=\"https://www.zhihu.com/search?q=%E5%85%83%E6%95%B0%E6%8D%AE&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A250966824%7D\">元数据</a>（元数据并不是类的Class对象！Class对象是加载的最终产品，类的<a href=\"https://www.zhihu.com/search?q=%E6%96%B9%E6%B3%95%E4%BB%A3%E7%A0%81&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A250966824%7D\">方法代码</a>，变量名，方法名，访问权限，<a href=\"https://www.zhihu.com/search?q=%E8%BF%94%E5%9B%9E%E5%80%BC&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A250966824%7D\">返回值</a>等等都是在方法区的）才是存在<a href=\"https://www.zhihu.com/search?q=%E6%96%B9%E6%B3%95%E5%8C%BA&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A250966824%7D\">方法区</a>的</p>\n</li>\n<li>\n<p>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class&lt;?&gt; cls = Class.forName(<span class=\"string\">&quot;ry.lambda.Cat&quot;</span>);</span><br><span class=\"line\">System.out.println(cls); <span class=\"comment\">//ry.lambda.Cat</span></span><br><span class=\"line\">cls.getClass()  <span class=\"comment\">//java.lang.Class</span></span><br><span class=\"line\">cls.getPackage().getName()  <span class=\"comment\">//得到包名</span></span><br><span class=\"line\">System.out.println(cls.getName()); <span class=\"comment\">//得到全类名</span></span><br><span class=\"line\"><span class=\"type\">Car</span> <span class=\"variable\">car</span> <span class=\"operator\">=</span> (Car) cls.newInstance(); System.out.println(car);<span class=\"comment\">//通过 cls 创建对象实例car.toString()</span></span><br><span class=\"line\"><span class=\"type\">Field</span> <span class=\"variable\">brand</span> <span class=\"operator\">=</span> cls.getField(<span class=\"string\">&quot;brand&quot;</span>); System.out.println(brand.get(car));<span class=\"comment\">//通过反射获取属性 brand   宝马</span></span><br><span class=\"line\">brand.set(car, <span class=\"string\">&quot;奔驰&quot;</span>); System.out.println(brand.get(car));<span class=\"comment\">// 通过反射给属性赋值    奔驰</span></span><br><span class=\"line\"><span class=\"comment\">//得到所有的属性(字段) </span></span><br><span class=\"line\">Field[] fields = cls.getFields();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (Field f : fields) &#123;</span><br><span class=\"line\">  System.out.println(f.getName());<span class=\"comment\">//名称 </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>获取所有的Class 对象的方法</p>\n<ul>\n<li>已知<code>一个类的全类名</code>，且该类在类路径下，可通过Class类的静态方法  forName()获取，可能抛出ClassNotFoundException\n<ul>\n<li>实例：Class cls1=Class.forName(“java.lang.Cat”)</li>\n<li>应用场景：多用于配置文件，读取类全路径，加载类</li>\n</ul>\n</li>\n<li>若<code>已知具体的类</code>，通过类的clss获取，该方式最为安全可靠，程序性能最高\n<ul>\n<li>实例：Class cls2=Cat.class;</li>\n<li>应用场景：多用于参数传递，比如通过反射得到对应构造器对象</li>\n</ul>\n</li>\n<li>已知<code>某个类的实例</code>，调用该实例的getClass(0方法获取Class对象，\n<ul>\n<li>实例：Class clazz=对象.getClass0;/运行类型</li>\n<li>应用场景：通过创建好的对象，获取Class对象.</li>\n</ul>\n</li>\n<li><code>其他方式</code>\n<ul>\n<li>ClassLoader cl =.getClass().getClassLoader();</li>\n<li>Class clazz4=cl.loadClass(“类的全类名”)：</li>\n</ul>\n</li>\n<li><code>基本数据</code>(int,char,boolean,float,double,byte,long,short))按如下方式得到Class类对象\n<ul>\n<li>Class cls=基本数据类型.class</li>\n</ul>\n</li>\n<li>基本数据类型对应的<code>包装类</code>，可以通过.TYPE得到Class类对象\n<ul>\n<li>Class cls=包装类.TYPE</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>哪些类型有 Class 对象</p>\n<ul>\n<li>外部类，成员内部类，静态内部类，局部内部类，匿名内部类</li>\n<li>interface:接口</li>\n<li>数组</li>\n<li>enum:枚举</li>\n<li>annotation:注解</li>\n<li>基本数据类型</li>\n<li>void</li>\n</ul>\n</li>\n<li>\n<p>类加载:    反射机制是 java 实现动态语言的关键，也就是通过<code>反射</code>实现<code>类动态加载</code>。</p>\n<ul>\n<li>静态加载：<code>编译</code>时加载相关的类，如果没有则报错，依赖性太强</li>\n<li>动态加载：<code>运行</code>时加载需要的类，如果运行时不用该类，即使不存在该类，则不报错，降低了依赖性</li>\n</ul>\n</li>\n<li>\n<p>类加载时机</p>\n<ul>\n<li>\n<p>当创建对象时(new)                             //静态加载</p>\n</li>\n<li>\n<p>当子类被加载时，父类也加载           //静态加载</p>\n</li>\n<li>\n<p>调用类中的静态成员时                      //静态加载</p>\n</li>\n<li>\n<p>通过反射                                             //动态加载   Class.forName(“com.test.Cat”);</p>\n</li>\n<li>\n<p>反射的作用：</p>\n<ul>\n<li>\n<p>通过调用api  可以获取<code>类的结构信息</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Class类</span></span><br><span class=\"line\"><span class=\"number\">1.</span>getName获取全类名</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span>getSimpleName:获取简单类名</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span>getFields:获取所有<span class=\"keyword\">public</span>修饰的属性，包含本类以及父类的</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">4.</span>getDeclaredFields:获取本类中所有属性</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">5.</span>getMethods::获取所有oublic修饰的方法，包含本类以及父类的</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">6.</span>getDeclaredMethods:获取本类中所有方法</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">7.</span>getConstructors:获取本类所有publicf修饰的构造器</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">8.</span>getDeclaredConstructors:获取本类中所有构造器</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">9.</span>getPackage:以Package形式返回包信息</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">10.</span>getSuperClass::以Classi形式返回父类信息</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">11.</span>getInterfaces:以Class[]形式返回接口信息</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">12.</span>getAnnotations:以Annotation]]形式返回注解信息</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//Field类</span></span><br><span class=\"line\"><span class=\"number\">1.</span>getModifiers:以<span class=\"type\">int</span>形式返回修饰符  [说明：默认修饰符是<span class=\"number\">0</span>，<span class=\"keyword\">public</span>是<span class=\"number\">1</span>，<span class=\"keyword\">private</span>是<span class=\"number\">2</span>，<span class=\"keyword\">protected</span>是<span class=\"number\">4</span>， <span class=\"keyword\">static</span>是<span class=\"number\">8</span>，<span class=\"keyword\">final</span>是<span class=\"number\">16</span>]，<span class=\"keyword\">public</span>(<span class=\"number\">1</span>)+<span class=\"keyword\">static</span>(<span class=\"number\">8</span>)=<span class=\"number\">9</span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span>getType:以Classj形式返回类型</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span>getName返回属性名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Method类</span></span><br><span class=\"line\"><span class=\"number\">1.</span>getModifiers:以<span class=\"type\">int</span>形式返回修饰符[说明：默认修饰符是<span class=\"number\">0</span>，<span class=\"keyword\">public</span>是<span class=\"number\">1</span>，<span class=\"keyword\">private</span>是<span class=\"number\">2</span>，<span class=\"keyword\">protected</span>是<span class=\"number\">4</span>，<span class=\"keyword\">static</span>是<span class=\"number\">8</span>，<span class=\"keyword\">final</span>是<span class=\"number\">16</span>]</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span>getReturnType:以Class形式获取返回类型</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span>getName:返回方法名</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">4.</span>getParameterTypes:以Class[]返回参数类型数组</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Constructor类</span></span><br><span class=\"line\"><span class=\"number\">1.</span>getModifiers:以<span class=\"type\">int</span>形式返回修饰符</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span>getName:返回构造器名（全类名）</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span>getParameterTypes:以Class[]返回参数类型数组</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p>创建对象</p>\n<ul>\n<li>方式一：调用类中的public修饰的无参构造器</li>\n<li>方式二：调用类中的指定构造器</li>\n<li>方式三: Class类相关方法\n<ul>\n<li>newlnstance:调用类中的无参构造器，获取对应类的对象</li>\n<li>getConstructor(Class…clazz):根据参数列表，获取对应的oublic构造器对象</li>\n<li>getDecalaredConstructor(Class…clazz):根据参数列表，获取对应的所有构造器对象</li>\n</ul>\n</li>\n<li>方式四.Constructor类相关方法\n<ul>\n<li>setAccessible:暴破</li>\n<li>newlnstance(Object…obj):调用构造器</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Mian</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            Class&lt;?&gt; aClass = Class.forName(<span class=\"string\">&quot;ry.lambda.Cat&quot;</span>);</span><br><span class=\"line\">            <span class=\"comment\">//通过 public 的无参构造器创建实例</span></span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">o</span> <span class=\"operator\">=</span> aClass.newInstance();</span><br><span class=\"line\">            System.out.println(o); <span class=\"comment\">//ry.lambda.Cat@1540e19d</span></span><br><span class=\"line\">            <span class=\"comment\">//通过 public 的有参构造器创建实例</span></span><br><span class=\"line\">            Constructor&lt;?&gt; constructor = aClass.getConstructor(<span class=\"type\">int</span>.class);</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">o1</span> <span class=\"operator\">=</span> constructor.newInstance(<span class=\"number\">123</span>);</span><br><span class=\"line\">            System.out.println(o1);<span class=\"comment\">//ry.lambda.Cat@677327b6</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//通过非 public 的有参构造器创建实例</span></span><br><span class=\"line\">            Constructor&lt;?&gt; declaredConstructor = aClass.getDeclaredConstructor(String.class, <span class=\"type\">int</span>.class);</span><br><span class=\"line\">            declaredConstructor.setAccessible(<span class=\"literal\">true</span>);</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">o2</span> <span class=\"operator\">=</span> declaredConstructor.newInstance(<span class=\"string\">&quot;red&quot;</span>, <span class=\"number\">123</span>);</span><br><span class=\"line\">            System.out.println(o2);<span class=\"comment\">//ry.lambda.Cat@14ae5a5</span></span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"> \t\t<span class=\"keyword\">public</span> <span class=\"title function_\">Cat</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Cat</span><span class=\"params\">(<span class=\"type\">int</span> age)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Cat</span><span class=\"params\">(String color,<span class=\"type\">int</span> age)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.color = color;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>访问类中的成员</p>\n<p>属性</p>\n<ul>\n<li>根据属性名获取Field对象     Field f=clazz对象.getDeclaredField(属性名)；</li>\n<li>暴破：f.setAccessible(true);/f是Field</li>\n<li>访问   f.set(o,值);//o表示对象    System.out.println(f.get(o));//o表示对象</li>\n<li>注意：如果是静态属性，则set和get中的参数o,可以写成null</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class&lt;?&gt; aClass = Class.forName(<span class=\"string\">&quot;ry.lambda.Cat&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//通过 public 的无参构造器创建实例</span></span><br><span class=\"line\"><span class=\"type\">Object</span> <span class=\"variable\">o</span> <span class=\"operator\">=</span> aClass.newInstance();</span><br><span class=\"line\">System.out.println(o); <span class=\"comment\">//ry.lambda.Cat@1540e19d</span></span><br><span class=\"line\"><span class=\"type\">Field</span> <span class=\"variable\">age</span> <span class=\"operator\">=</span> aClass.getField(<span class=\"string\">&quot;age&quot;</span>); <span class=\"comment\">//  age  为  public  </span></span><br><span class=\"line\">age.set(o,<span class=\"number\">12</span>);</span><br><span class=\"line\">System.out.println(age.get(o));<span class=\"comment\">//12</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 私有方法  需要暴破</span></span><br><span class=\"line\">Class&lt;?&gt; aClass = Class.forName(<span class=\"string\">&quot;ry.lambda.Cat&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//通过 public 的无参构造器创建实例</span></span><br><span class=\"line\"><span class=\"type\">Object</span> <span class=\"variable\">o</span> <span class=\"operator\">=</span> aClass.newInstance();</span><br><span class=\"line\">System.out.println(o); <span class=\"comment\">//ry.lambda.Cat@1540e19d</span></span><br><span class=\"line\"><span class=\"type\">Field</span> <span class=\"variable\">color</span> <span class=\"operator\">=</span> aClass.getDeclaredField(<span class=\"string\">&quot;color&quot;</span>); <span class=\"comment\">// private String color;</span></span><br><span class=\"line\">color.setAccessible(<span class=\"literal\">true</span>);</span><br><span class=\"line\">color.set(o,<span class=\"string\">&quot;red&quot;</span>);</span><br><span class=\"line\">System.out.println(color.get(o)); <span class=\"comment\">//red</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>方法</p>\n<ul>\n<li>根据方法名和参数列表获取Method方法对象：Method m=clazz.getDeclaredMethod(方法名，XX.class)😕/得到本类的所有方法</li>\n<li>获取对象：Object o=clazz.newlnstance();</li>\n<li>暴破：m.setAccessible(true):</li>\n<li>访问：Object returnValue=m.invoke(o,实参列表)：//o就是对象</li>\n<li>注意：如果是静态方法，则invoke的参数o,可以写成null</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class&lt;?&gt; aClass = Class.forName(<span class=\"string\">&quot;ry.lambda.Cat&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//通过 public 的无参构造器创建实例</span></span><br><span class=\"line\"><span class=\"type\">Object</span> <span class=\"variable\">o</span> <span class=\"operator\">=</span> aClass.newInstance();</span><br><span class=\"line\"><span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> aClass.getMethod(<span class=\"string\">&quot;hi&quot;</span>, String.class);</span><br><span class=\"line\">method.invoke(o,<span class=\"string\">&quot;hi&quot;</span>);<span class=\"comment\">//hi</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Method</span> <span class=\"variable\">method1</span> <span class=\"operator\">=</span> aClass.getDeclaredMethod(<span class=\"string\">&quot;hello&quot;</span>, String.class);</span><br><span class=\"line\">method1.setAccessible(<span class=\"literal\">true</span>);</span><br><span class=\"line\">method1.invoke(o,<span class=\"string\">&quot;world&quot;</span>);<span class=\"comment\">//world</span></span><br><span class=\"line\">method1.invoke(o,<span class=\"string\">&quot;hello&quot;</span>);<span class=\"comment\">//hello</span></span><br><span class=\"line\">method1.invoke(o,<span class=\"string\">&quot;hei&quot;</span>);<span class=\"comment\">//hei</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span>  <span class=\"title function_\">hi</span><span class=\"params\">(String i)</span>&#123;</span><br><span class=\"line\">     System.out.println(i);;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">hello</span><span class=\"params\">(String name)</span>&#123;</span><br><span class=\"line\">     System.out.println(name);</span><br><span class=\"line\">     <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p>多线程</p>\n<ul>\n<li>\n<p>start0() 是本地方法，是 JVM 调用, 底层是 c/c++实现 ；真正实现多线程的效果， 是 start0(), 而不是 run；start() 方法调用start0()方法后，该线程并不一定会立马执行，只是将线程变成了可运行状态。具体什么时候执行，取决于CPU,由CPU统一调度。</p>\n</li>\n<li>\n<p>start(); 启动线程-&gt; 最终会执行 cat 的 run 方法；run 方法就是一个普通的方法, 没有真正的启动一个线程，就会把 run 方法执行完毕，才向下执行</p>\n</li>\n<li>\n<p>线程终止的方法：  当线程完成任务后，会自动退出。还可以通过使用变量来控制run  方法退出的方式停止线程，即通知方式</p>\n</li>\n<li>\n<p>线程的生命周期</p>\n<p>线程状态。线程可以处于以下状态之一：</p>\n<ul>\n<li>NEW      尚未启动的线程处于此状态。<code>start()</code></li>\n<li>RUNNABLE      在Java虚拟机中执行的线程处于此状态。<code>从New 中过来后被线程调度器执行 、 TIMED WAITING 中方法的时间结束 、 WAITING中执行notify() notifyall() unpark()  、 BLOCKED中获取锁</code></li>\n<li>BLOCKED         被阻塞等待监视器锁定的线程处于此状态。<code>进入同步代码块中</code></li>\n<li>WAITING          正在等待另一个线程执行特定动作的线程处于此状态。 <code>wait()   join()   park()</code></li>\n<li>TIMED WAITING      正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。 <code>sleep(time)   wait(time)   join(time)   parkUtil()  parkNanos()</code></li>\n<li>TERMINATED            已退出的线程处于此状态。</li>\n</ul>\n</li>\n<li>\n<p>何时释放锁：</p>\n<ul>\n<li>当前线程的同步方法、同步代码块执行结束</li>\n<li>当前线程在同步代码块、同步方法中遇到break、return。,</li>\n<li>当前线程在同步代码块、同步方法中出现了未处理的Error或Exception,导致异常结束</li>\n<li>当前线程在同步代码块、同步方法中执行了线程对象的wt0方法，当前线程暂停，并释放锁。</li>\n</ul>\n</li>\n<li>\n<p>何时 不 释放锁：</p>\n<ul>\n<li>线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行，不会释放锁</li>\n<li>线程执行同步代码块时，其他线程调用了该线程的suspend0方法将该线程挂起该线程不会释放锁。   提示：应尽量避免使用suspend()和resume()来控制线程，这些方法不再推荐使用</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>IO流</p>\n<ul>\n<li>\n<p>流：数据在数据源（文件）和程序（内存）之间经历的路径</p>\n<ul>\n<li>输入流：数据从数据源（文件）到程序（内存）的路径</li>\n<li>输出流：数据从程序（内存）到数据源（文件）的路径</li>\n</ul>\n</li>\n<li>\n<p>分类：</p>\n<ul>\n<li>按操作数据单位不同分为：字节流(8bit)二进制文件「InputStream、OutputStream」，字符流(按字符)文本文件「Reader、Writer」</li>\n<li>按数据流的流向不同分为：输入流，输出流</li>\n<li>按流的角色的不同分为：节点流，处理流/包装流</li>\n</ul>\n</li>\n<li>\n<p>字符流： 节点流和处理流</p>\n<ul>\n<li>节点流可以从一个特定的数据源读写数据，如FileReader、FileWriter</li>\n<li>处理流（也叫包装流）是“连接”在已存在的流（节点流或处理流）之上，为程序提供更为强大的读写功能，也更加灵活，如BufferedReader、BufferedWriter</li>\n<li>区别：节点流是底层流/低级流，直接跟数据原相接。\n<ul>\n<li>处理流（包装流）包装节点流，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出</li>\n<li>处理流（也叫包装流）对节点流进行包装，使用了修饰器设计模式，不会直接与数据源相连</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>对象流： ObjectInputStream 和 ObjectOutputStream</p>\n<p>提供了对基本类型或对象类型的序列化和反序列化的方法</p>\n<ul>\n<li>ObjectOutputStream   序列化就是在保存数据时，保存数据的值和数据类型</li>\n<li>ObjectInputStream      反序列化就是在恢复数据时，恢复数据的值和数据类型</li>\n<li>需要让某个对象支持序列化机制，则必须让其类是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一：\n<ul>\n<li>Serializable             //这是一个标记接口，没有方法</li>\n<li>Externalizable       //该接口有方法需要实现，因此我们一般实现上面的Serializable接口</li>\n</ul>\n</li>\n<li>读写顺序要一致</li>\n<li>要求序列化或反序列化对象，需要实现Serializable</li>\n<li>序列化的类中建议添加SerialVersionU川D,为了提高版本的兼容性</li>\n<li>序列化对象时，默认将里面所有属性都进行序列化，但除了static?或transient修饰的成员</li>\n<li>序列化对象时，要求里面属性的类型也需要实现序列化接口</li>\n<li>序列化具备可继承性，也就是如果某类已经实现了序列化，则它的所有子类也已经默认实现了序列化</li>\n</ul>\n</li>\n<li>\n<p>标准输入输出流</p>\n<ul>\n<li>​                                                       类型                                                                    默认设备<br>\n<a href=\"http://System.in\">System.in</a>    标准输入             InputStream                                                                 键盘<br>\nSystem.out标准输出              PrintStream                                                                  显示器</li>\n</ul>\n</li>\n<li>\n<p>转换流-InputStreamReader 和 OutputStreamWriter</p>\n<ul>\n<li>InputStreamReader:Reader的子类，可以将InputStream(字节流)包装成（转换）Reader(字符流)</li>\n<li>OutputStreamWriter:Writer的子类，实现将OutputStream(字节流)包装成Writer(字符流)</li>\n<li>当处理纯文本数据时，如果使用字符流效率更高，并且可以有效解决中文问题，所以建议将字节流转换成字符流</li>\n<li>可以在使用时指定编码格式（比如utf-8,gbk,gb2312,IS08859-1等）</li>\n</ul>\n</li>\n<li>\n<p>打印流-PrintStream 和 PrintWriter</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3、集合\">3、集合</h2>\n<h4 id=\"Collection\">Collection</h4>\n<ul>\n<li>\n<p>List的遍历元素的方式</p>\n<ul>\n<li>\n<p>方式 1-使用 Iterator(迭代器) ： 在调用iterator.next()方法之前必须要调用iterator.hasNext() 进行检测。若不调用，且下一条记录无效，直接调用it.next0会抛出NoSuchElementException.异常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Iterator</span> <span class=\"variable\">iterator</span> <span class=\"operator\">=</span> col.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> iterator.next(); </span><br><span class=\"line\">  System.out.println(<span class=\"string\">&quot;obj=&quot;</span> + obj);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//如果希望再次遍历，需要重置我们的迭代器</span></span><br><span class=\"line\">iterator = col.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> iterator.next(); </span><br><span class=\"line\">  System.out.println(<span class=\"string\">&quot;obj=&quot;</span> + obj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>方式 2-增强for 循环</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (Object dog : list) &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;dog=&quot;</span> + dog); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>方式 3-普通for</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class=\"line\">  System.out.println(<span class=\"string\">&quot;对象=&quot;</span> + list.get(i)); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p>​                                                底层结构                         线程安全（同步）效率                                    扩容倍数<br>\nArrayList                                可变数组                            不安全，效率高                        如果有参构造1.5倍;如果是无参1.第一次10    2.从第二次按1.5扩容<br>\nVector                                    可变数组，Object[]          安全，效率不高                        如果是无参，默认10 ,满后，就按2倍扩容如果指定大小，每次直接按2倍扩容</p>\n</li>\n<li>\n<p>Set 遍历元素的方式</p>\n<ul>\n<li>\n<p>方式 1-使用 Iterator(迭代器)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Iterator</span> <span class=\"variable\">iterator</span> <span class=\"operator\">=</span> set.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> iterator.next(); </span><br><span class=\"line\">  System.out.println(<span class=\"string\">&quot;obj=&quot;</span> + obj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p>方式 2: 增强 for</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (Object o : set) &#123; </span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;o=&quot;</span> + o);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"Map\">Map</h4>\n<ul>\n<li>\n<p>Map 接口遍历方法</p>\n<ul>\n<li>\n<p>先取出 所有的 Key , 通过 Key 取出对应的 Value</p>\n<ul>\n<li>\n<p>(1) 增强 for</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (Object key : keyset) &#123;</span><br><span class=\"line\">  System.out.println(key + <span class=\"string\">&quot;-&quot;</span> + map.get(key)); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>(2) 迭代器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Iterator</span> <span class=\"variable\">iterator</span> <span class=\"operator\">=</span> keyset.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">  <span class=\"type\">Object</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> iterator.next();</span><br><span class=\"line\">  System.out.println(key + <span class=\"string\">&quot;-&quot;</span> + map.get(key)); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p>把所有的 values 取出</p>\n<ul>\n<li>\n<p>(1) 增强 for</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Collection</span> <span class=\"variable\">values</span> <span class=\"operator\">=</span> map.values(); <span class=\"comment\">//这里可以使用所有的 Collections 使用的遍历方法 </span></span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;---取出所有的 value 增强 for----&quot;</span>); </span><br><span class=\"line\"><span class=\"keyword\">for</span> (Object value : values) &#123;</span><br><span class=\"line\">  System.out.println(value); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p>(2) 迭代器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Collection</span> <span class=\"variable\">values</span> <span class=\"operator\">=</span> map.values(); <span class=\"comment\">//这里可以使用所有的 Collections 使用的遍历方法 </span></span><br><span class=\"line\"><span class=\"type\">Iterator</span> <span class=\"variable\">iterator2</span> <span class=\"operator\">=</span> values.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator2.hasNext()) &#123;</span><br><span class=\"line\">  <span class=\"type\">Object</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> iterator2.next();</span><br><span class=\"line\">  System.out.println(value); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p>通过 EntrySet 来获取 k-v</p>\n<ul>\n<li>\n<p>增强 for</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Set</span> <span class=\"variable\">entrySet</span> <span class=\"operator\">=</span> map.entrySet();<span class=\"comment\">// EntrySet&lt;Map.Entry&lt;K,V&gt;&gt; </span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (Object entry : entrySet) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//将 entry 转成 Map.Entry</span></span><br><span class=\"line\">  Map.<span class=\"type\">Entry</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> (Map.Entry) entry;</span><br><span class=\"line\">  System.out.println(m.getKey() + <span class=\"string\">&quot;-&quot;</span> + m.getValue());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>迭代器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Set</span> <span class=\"variable\">entrySet</span> <span class=\"operator\">=</span> map.entrySet();<span class=\"comment\">// EntrySet&lt;Map.Entry&lt;K,V&gt;&gt; </span></span><br><span class=\"line\"><span class=\"type\">Iterator</span> <span class=\"variable\">iterator3</span> <span class=\"operator\">=</span> entrySet.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator3.hasNext()) &#123;</span><br><span class=\"line\">  <span class=\"type\">Object</span> <span class=\"variable\">entry</span> <span class=\"operator\">=</span> iterator3.next();</span><br><span class=\"line\">  Map.<span class=\"type\">Entry</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> (Map.Entry) entry;</span><br><span class=\"line\">  System.out.println(m.getKey() + <span class=\"string\">&quot;-&quot;</span> + m.getValue());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p>hashMap 源码分析</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//执行 put() , 该方法会执行 hash(key) 得到 key 对应的 hash 值 算法 h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> V <span class=\"title function_\">put</span><span class=\"params\">(K key, V value)</span> &#123;<span class=\"comment\">//key = &quot;java&quot; value = PRESENT 共享 </span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"literal\">false</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//执行 putVal</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> V <span class=\"title function_\">putVal</span><span class=\"params\">(<span class=\"type\">int</span> hash, K key, V value, <span class=\"type\">boolean</span> onlyIfAbsent,<span class=\"type\">boolean</span> evict)</span> &#123;</span><br><span class=\"line\">\tNode&lt;K,V&gt;[] tab; </span><br><span class=\"line\">  Node&lt;K,V&gt; p; </span><br><span class=\"line\">  <span class=\"type\">int</span> n, i; </span><br><span class=\"line\">  <span class=\"comment\">//定义了辅助变量 </span></span><br><span class=\"line\">  <span class=\"comment\">//table 就是 HashMap 的一个数组，类型是 Node[] </span></span><br><span class=\"line\">  <span class=\"comment\">//if 语句表示如果当前 table 是 null, 或者 大小=0 //就是第一次扩容，到 16 个空间.</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((tab = table) == <span class=\"literal\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\tn = (tab = resize()).length;</span><br><span class=\"line\"><span class=\"comment\">//(1)根据 key，得到 hash 去计算该 key 应该存放到 table 表的哪个索引位置 并把这个位置的对象，赋给 p</span></span><br><span class=\"line\"><span class=\"comment\">//(2)判断 p 是否为 null</span></span><br><span class=\"line\"><span class=\"comment\">//(2.1) 如果 p 为 null, 表示还没有存放元素, 就创建一个 Node (key=&quot;java&quot;,value=PRESENT) </span></span><br><span class=\"line\"><span class=\"comment\">//(2.2) 就放在该位置 tab[i] = newNode(hash, key, value, null)</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"literal\">null</span>)</span><br><span class=\"line\">\t\ttab[i] = newNode(hash, key, value, <span class=\"literal\">null</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tNode&lt;K,V&gt; e; K k; </span><br><span class=\"line\"><span class=\"comment\">//如果当前索引位置对应的链表的第一个元素和准备添加的 key 的 hash 值一样 并且满足 下面两个条件之一:</span></span><br><span class=\"line\"><span class=\"comment\">//(1) 准备加入的 key 和 p 指向的 Node 结点的 key 是同一个对象</span></span><br><span class=\"line\"><span class=\"comment\">//(2) p 指向的 Node 结点的 key 的 equals() 和准备加入的 key 比较后相同 就不能加入</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">      e = p;</span><br><span class=\"line\"><span class=\"comment\">//再判断 p 是不是一颗红黑树, //如果是一颗红黑树，就调用 putTreeVal , 来进行添加 </span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">\t\t\te = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"built_in\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">//如果 table 对应索引位置，已经是一个链表, 就使用 for 循环比较</span></span><br><span class=\"line\"><span class=\"comment\">//(1) 依次和该链表的每一个元素比较后，都不相同, 则加入到该链表的最后注意在把元素添加到链表后，立即判断 该链表是否已经达到 8 个结点, 就调用 treeifyBin() 对当前这个链表进行树化(转成红黑树)注意，在转成红黑树时，要进行判断, 判断条件if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY(64))  resize();</span></span><br><span class=\"line\"><span class=\"comment\">// 如果上面条件成立，先 table 扩容.  只有上面条件不成立时，才进行转成红黑树</span></span><br><span class=\"line\"><span class=\"comment\">//(2) 依次和该链表的每一个元素比较过程中，如果有相同情况,就直接 break</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">binCount</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; ; ++binCount) &#123; </span><br><span class=\"line\">    \t\t<span class=\"keyword\">if</span> ((e = p.next) == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          p.next = newNode(hash, key, value, <span class=\"literal\">null</span>);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD(<span class=\"number\">8</span>) - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">            treeifyBin(tab, hash); </span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;((k = e.key) == key || (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">          <span class=\"keyword\">break</span>; </span><br><span class=\"line\">        p = e;</span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e != <span class=\"literal\">null</span>) &#123; <span class=\"comment\">// existing mapping for key V oldValue = e.value;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"literal\">null</span>)</span><br><span class=\"line\">        e.value = value; afterNodeAccess(e); <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ++modCount;</span><br><span class=\"line\">  <span class=\"comment\">//size 就是我们每加入一个结点 Node(k,v,h,next), size++ if (++size &gt; threshold)</span></span><br><span class=\"line\">  resize();<span class=\"comment\">//扩容 </span></span><br><span class=\"line\">  afterNodeInsertion(evict); </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//关于树化(转成红黑树)</span></span><br><span class=\"line\"><span class=\"comment\">//如果 table 为 null ,或者大小还没有到 64，暂时不树化，而是进行扩容. //否则才会真正的树化 -&gt; 剪枝</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">treeifyBin</span><span class=\"params\">(Node&lt;K,V&gt;[] tab, <span class=\"type\">int</span> hash)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (tab == <span class=\"literal\">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class=\"line\">    resize();</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<h1>数据库</h1>\n<h4 id=\"语法\">语法</h4>\n<ul>\n<li>\n<p>插入： <code>INSERT INTO   表名  『(id, goods_name, price) 可选』  VALUES(对应的表中的字段的值);</code></p>\n<ul>\n<li>字符和日期型数据应包含在单引号中</li>\n<li>如果是给表中的所有字段添加数据，可以不写前面的字段名称</li>\n<li>insert into tab_name (列名…) values (),(),() 形式添加多条记录</li>\n<li>列可以插入空值[前提是该字段允许为空]，insert into table value(null)</li>\n<li>默认值的使用，当不给某个字段值时，如果有默认值就会添加默认值，否则报错</li>\n</ul>\n</li>\n<li>\n<p>更新：<code>update  表名  set(列 = 值，列 = 值，列 = 值,...)  「where (限定) 」 </code></p>\n<ul>\n<li>WHERE子句指定应更新哪些行。如没有VHERE子句，则更新所有的行（记录）</li>\n</ul>\n</li>\n<li>\n<p>删除：<code>delete from  表名  「where  限定」</code></p>\n<ul>\n<li>如果不使用where子句，将删除表中所有数据。</li>\n<li>Delete语句不能删除某一列的值（可使用update设为null或者&quot;）</li>\n<li>使用deletei语句仅删除记录，不删除表本身。如要删除表，使用drop  table语句。<code>drop table表名</code></li>\n</ul>\n</li>\n<li>\n<p>查找：<code>select 「distinct」 *|(列|表达式  (as  别名)，列|表达式   (as  别名)，...|聚合函数)  from  表名  「where ...  group by (某个 列) ...  having ... order by （列 desc|asc,列 desc|asc,列 desc|asc,...） limit start,rows;」</code></p>\n<ul>\n<li>\n<p>where ：过滤条件的</p>\n<ul>\n<li>可以使用运算符\n<ul>\n<li>「比较运算符： &gt; 、 &lt;  、&lt;=  、&gt;= 、 &lt;&gt; 、!=  、 between…and… 、 in(set)  、like‘…’ 、not like ‘…’  、is null、is not null」</li>\n<li>「逻辑运算符  and、or、 not 」</li>\n<li>%: 表示 0 到多个任意字符</li>\n<li>_: 表示单个任意字符</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>order by：指定排序的列，列可以是表中的列名  或者  是指定的列名，ASC (默认，升序) 、DESC 降序，order by 应该放置在 select 语句 的结尾</p>\n<ul>\n<li>分页查询\n<ul>\n<li>基本语法：select…limit  start,rows     表示从<code>start+1</code>行开始取，取出<code>rows</code>行，start从0开始计算</li>\n<li>公式：推导一个公式<code>SELECT *  FROM emp  ORDER BY empno limit 「每页显示记录数*（第几页- 1）」开始的位置,「每页显示记录数」偏移量</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>集合函数</p>\n<ul>\n<li>count()  :    count(*) 返回满足条件的记录的行数;  count(列): 统计满足条件的某列有多少个，但是会排除 为 null 的情况</li>\n<li>sum(一个或者多个列名+)： 求和</li>\n<li>avg(一个或者多个列名+)： 求平均值</li>\n<li>max (一个或者多个列名+)： 最大值</li>\n<li>min (一个或者多个列名+)： 最小值</li>\n</ul>\n</li>\n<li>\n<p>group by : 对查询的结果分组</p>\n</li>\n<li>\n<p>having : 限制分组显示结果</p>\n</li>\n<li>\n<p>可以在select 的语句  或者 where  语句中  使用 函数：字符串相关函数、数学相关函数、时间相关函数、加密（MD5）和系统相关函数</p>\n</li>\n<li>\n<p>select 中进行  ： 流程控制函数</p>\n<ul>\n<li>\n<p>IF(expr1,expr2,expr3)               如果expr1为True,则返回expr2 否则返回expr3</p>\n</li>\n<li>\n<p>IFNULL(expr1,expr2)                如果expr1不为空NULL,则返回expr1,否则返回 expr2</p>\n</li>\n<li>\n<p>SELECT      CASE WHEN expr1      THEN expr2           WHEN expr3 THEN expr4         ELSE  expr5      END;[类似多重分支.，]</p>\n<p>​     \t\t\t\t如果expr1为TRUE,     则返回expr2,    如果expr3为true ,返回expr4,        否则返回expr5</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">    <span class=\"keyword\">CASE</span></span><br><span class=\"line\">        <span class=\"keyword\">WHEN</span> deptno <span class=\"keyword\">BETWEEN</span> <span class=\"number\">0</span> <span class=\"keyword\">AND</span> <span class=\"number\">10</span> <span class=\"keyword\">THEN</span> <span class=\"string\">&#x27;0-10&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">WHEN</span> deptno <span class=\"keyword\">BETWEEN</span> <span class=\"number\">11</span> <span class=\"keyword\">AND</span> <span class=\"number\">20</span> <span class=\"keyword\">THEN</span> <span class=\"string\">&#x27;11-20&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">WHEN</span> deptno <span class=\"keyword\">BETWEEN</span> <span class=\"number\">21</span> <span class=\"keyword\">AND</span> <span class=\"number\">30</span> <span class=\"keyword\">THEN</span> <span class=\"string\">&#x27;21-30&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">ELSE</span> <span class=\"string\">&#x27;Other&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">END</span> <span class=\"keyword\">AS</span> dept_range,</span><br><span class=\"line\">    <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">AS</span> dept_count</span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">    emp</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span></span><br><span class=\"line\">    dept_range;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>多表查询</p>\n<ul>\n<li>\n<p>多表<code>查询的条件</code> <code>不能少于</code> <code>表的个数-1</code>, 否则<code>会出现笛卡尔集</code></p>\n</li>\n<li>\n<p>自连接：</p>\n<ul>\n<li>\n<p>列名不明确，可以指定列的别名 列名 as 列的别名  <code>SELECT worker.ename AS '职员名' , boss.ename AS '上级名'</code></p>\n</li>\n<li>\n<p>需要给表 赋予 别名   <code> from  emp worker, emp boss</code></p>\n</li>\n</ul>\n</li>\n<li>\n<p>子查询（嵌套查询）</p>\n<ul>\n<li>\n<p>在 where子句中使用子查询</p>\n<ul>\n<li>\n<p>单行子查询是指只返回一行数据的子查询语句</p>\n</li>\n<li>\n<p>多行子查询 ： 指返回多行数据的子查询 或者查询的结果集中不止一条返回的结果，使用关键字 in</p>\n</li>\n<li>\n<p>在多行子查询中使用 all (所有，一定程度上 等价于   max())、any(其中一个 ，一定程度上 等价于   min() )</p>\n</li>\n<li>\n<p>多列子查询:   (字段 1， 字段 2 …) = (select 字段 1，字段 2 from ….)</p>\n</li>\n</ul>\n</li>\n<li>\n<p>在 from 子句中使用子查询</p>\n<ul>\n<li>将一个子查询当作一个临时表</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>合并查询</p>\n<ul>\n<li>union       就是将两个查询结果合并，会去重</li>\n<li>unionall   就是将两个查询结果合并，不会去重 ；高效</li>\n</ul>\n</li>\n<li>\n<p>表外连接</p>\n<ul>\n<li>左外连接： left    join  表1 on 表2   ：  左边的表(exam) 和右表没有匹配的记录，也会把左表的记录显示出来</li>\n<li>右外连接：right  join  表1 on  表2   ：  右边的表(exam) 和左表没有匹配的记录，也会把右表的记录显示出来</li>\n</ul>\n</li>\n<li>\n<p>约束</p>\n<ul>\n<li>primary key  主键  ，唯一标识表行的数据，定义主键约束之后该列不能重复，不能为 null,一个表最多只有一个主键，但是可以是复合主键\n<ul>\n<li>设计方式：\n<ul>\n<li>1、直接在字段名后指定:字段名 primakry key     <code>id INT PRIMARY KEY, -- 表示 id 列是主键\t</code></li>\n<li>2、在表定义最后写 primary key(列名)                 <code>PRIMARY KEY (id, name) -- 这里就是复合主键</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>not null(非空)  多个</li>\n<li>unique(唯一)   多个\n<ul>\n<li>如果没有指定 not null , 则 unique 字段可以有多个 null；如果一个列(字段)， 是 unique not null 使用效果类似 primary key</li>\n<li>一张表可以有多个 unique 字段</li>\n</ul>\n</li>\n<li>foreign key(外键)\n<ul>\n<li>用于定义主表和从表之间的关系：外键约束要定义在从表上，主表则必须具有主键约束或是unique约束，当定义外键约束后，要求外键列数据必须在主表的主键列存在或是为null</li>\n<li><code>FOREIGN KEY    (本表字段名)   REFERENCES   主表名（主键名或unique:字段名）</code></li>\n<li>表的类型是innodb,这样的表才支持外键</li>\n<li>外键字段的类型要和主键字段的类型一致（长度可以不同）</li>\n<li>外键字段的值，必须在主键字段中出现过，或者为null [前提是外键字段允许为null]</li>\n<li>一旦建立主外键的关系，数据就不能随意删除了</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>自增长</p>\n<ul>\n<li>一般来说自增长是和primary key配合使用的；自增长也可以单独使用[但是需要配合一个unique]；自增长修饰的字段为整数型的（虽然小数也可以但是非常非常少这样使用)</li>\n<li>自增长默认从1开始，你也可以通过如下命令修改 <code> alter table 表名 auto_increment = 新的开始值</code>；</li>\n<li>如果你添加数据时，给自增长字段（列）指定的有值，则以指定的值为准，如果指定了自增长，一般来说，就按照自增长的规则来添加数据。</li>\n</ul>\n</li>\n<li>\n<p>索引</p>\n<ul>\n<li>创建索引：\n<ul>\n<li><code>create [UNIQUE]index 索引名 on   表名 (列，列， [(/ength)]   [ASC DESC],.....);</code></li>\n<li><code>alter table 表名 ADD INDEX [索引名](列,列,...)</code></li>\n</ul>\n</li>\n<li>查询索引：\n<ul>\n<li><code>SHOW INDEXES/index FROM 表名;</code></li>\n<li><code>show keys from 表名;</code></li>\n<li><code>desc 表名;</code></li>\n</ul>\n</li>\n<li>删除索引：\n<ul>\n<li><code>DROP INDEX 索引名 ON 表名,</code></li>\n<li><code>alter table 表名 drop index 索引名;</code></li>\n</ul>\n</li>\n<li>删除主键索引：<code>alter table 表名  drop 主键:</code></li>\n<li>索引的类型：\n<ul>\n<li>主键索引，主键自动的为主索引（类型Primary key)</li>\n<li>唯一索引(UNIQUE)</li>\n<li>普通索引(INDEX)</li>\n<li>全文索引(FULLTEXT)[适用于MyISAM]   一般开发，不使用mysq自带的全文索引，而是使用：全文搜索Solr 、ElasticSearch (ES)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>事务</p>\n<ul>\n<li>\n<p>操作</p>\n<ul>\n<li>\n<p>start transaction----------------------开始一个事务</p>\n</li>\n<li>\n<p>savepoint  保存点名------------------设置保存点</p>\n</li>\n<li>\n<p>rollback to  保存点名-----------------回退事务</p>\n</li>\n<li>\n<p>rollback-----------------------------------回退全部事务</p>\n</li>\n<li>\n<p>commit-----------------------------------提交事务，所有的操作生效，不能回退</p>\n</li>\n</ul>\n</li>\n<li>\n<p>细节：</p>\n<ul>\n<li>\n<p>如果不开始事务，默认情况下，dml 操作是自动提交的，不能回滚</p>\n</li>\n<li>\n<p>如果开始一个事务，你没有创建保存点.你可以执行rollback,默认就是回退到事务开始的状态；</p>\n</li>\n<li>\n<p>也可以在这个事务中（还没有提交时），创建多个保存点；比如：savepoint   aaa;执行dml,  savepoint bbb;</p>\n</li>\n<li>\n<p>可以在事务没有提交前，选择回退到哪个保存点.</p>\n</li>\n<li>\n<p>InnoDB 存储引擎支持事务 , MyISAM 不支持</p>\n</li>\n<li>\n<p>开始一个事务start transaction,  set autocommit=off;</p>\n</li>\n</ul>\n</li>\n<li>\n<p>产生的问题</p>\n<ul>\n<li>脏读：读到其他事务没有提交的数据</li>\n<li>不可重复读： 读到   其他事务 修改 /-  的数据，导致每次返回的结果集不一样</li>\n<li>幻读： 读到 其他事务  + 的数据，导致每次返回的结果集不一样</li>\n</ul>\n</li>\n<li>\n<p>隔离级别：  mysql默认的事务隔离级别是repeatable read,一般情况下，没有特殊要求，没有必要修改（因为该级别可以满足绝大部分项目需求）</p>\n<ul>\n<li>读未提交  (Read uncommitted)</li>\n<li>读已提交(Read committed)</li>\n<li>可重复读(Repeatable read)</li>\n<li>可串行化(Serializable)</li>\n</ul>\n</li>\n<li>\n<p>隔离级别的操作</p>\n<ul>\n<li>查看当前<code>会话</code>隔离级别        select @@tx isolation;</li>\n<li>查看<code>系统</code>当前隔离级别        select @@global.tx isolation;</li>\n<li><code>设置</code>当前会话隔离级别        set session transaction isolation level repeatable read;</li>\n<li><code>设置</code>系统当前隔离级别        set global transaction isolation level repeatable read;</li>\n</ul>\n</li>\n<li>\n<p>ACID</p>\n<ul>\n<li>原子性(Atomicity)           原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</li>\n<li>一致性(Consistency)      事务必须使数据库从一个一致性状态变换到另外一个一致性状态</li>\n<li>隔离性(Isolation)            事务的隔离性是多个用户并发访问数据库时，不会被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。</li>\n<li>持久性(Durability)          持久性是指一个事务一亘被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>视图</p>\n<ul>\n<li>\n<p>基本使用</p>\n<ul>\n<li><code>create view  视图名  as selecti语句      ------创建新的视图</code></li>\n<li><code>alter view   视图名  as selecti  语句    ------更新成新的视图</code></li>\n<li><code>SHOW CREATE VIEW 视图名                 ------查看视图</code></li>\n<li><code>drop view 视图名1，视图名2...            ------删除视图</code></li>\n</ul>\n</li>\n<li>\n<p>创建视图后，到数据库去看，对应视图只有一个视图结构文件(形式: 视图名.frm)</p>\n</li>\n<li>\n<p>视图的数据变化会影响到基表，基表的数据变化也会影响到视图[insert update delete ]</p>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> my_tab02 <span class=\"keyword\">LIKE</span> emp; <span class=\"comment\">-- 这个语句 把 emp 表的结构(列)，复制到 my_tab02</span></span><br><span class=\"line\"></span><br><span class=\"line\">表名.<span class=\"operator\">*</span>      表示将该表所有列都显示出来, 可以简化 <span class=\"keyword\">sql</span> 语句</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> my_tmp <span class=\"keyword\">select</span> <span class=\"keyword\">distinct</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> my_tab02;  <span class=\"comment\">-- 把 my_tmp 的记录 通过 distinct 关键字 处理后 把记录复制到 my_tmp </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> my_tab02 <span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> my_tmp;           <span class=\"comment\">-- 把 my_tmp 表的 所有 记录复制到 my_tab02 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> my_tab01  <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> my_tab01;        <span class=\"comment\">-- 自我复制（蠕虫复制）</span></span><br></pre></td></tr></table></figure>\n","_path":"post/3a3bba7a.html","_link":"http://rycan.top/post/3a3bba7a.html","_id":"cloioo9ef005yni0p5ipidny2"}}