{"type":"getPostByPath","data":{"title":"lambda表达式","date":"2023-09-27T03:24:56.379Z","description":"lambda","categories":[{"name":"lambda","_id":"cloioo9ec005cni0p5c5ig929"}],"tags":[{"name":"lambda","_id":"cloioo9eq008lni0p8ayw8tvf"}],"content":"<meta name=\"referrer\" content=\"no-referrer\">\n<h1>函数式编程（lambda表达式）</h1>\n<h1>前言</h1>\n<p>java是面向对象语言，但是有时候为了更加方面的实现某些功能，引入了<a href=\"https://so.csdn.net/so/search?q=%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B&amp;spm=1001.2101.3001.7020\">函数式编程</a>，具体可见本文2.2中的例子。 本文首先介绍了函数式编程中必不可少的函数式接口，之后介绍了<a href=\"https://so.csdn.net/so/search?q=lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F&amp;spm=1001.2101.3001.7020\">lambda表达式</a>的基本格式、优点，以及常见的4个函数式接口。</p>\n<h1>函数式接口</h1>\n<ul>\n<li>有且仅有一个抽象方法的接口</li>\n</ul>\n<p>格式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">修饰符 interface 接口名称 &#123;</span><br><span class=\"line\">    public abstract 返回值类型 方法名称(可选参数信息);</span><br><span class=\"line\">    // 其他非抽象方法内容</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>举例</p>\n<p>注解：@FunctionalInterface</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@FunctionalInterface</span><br><span class=\"line\">public interface MyFunctionalInterface &#123;</span><br><span class=\"line\">    void myMethod();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1>函数式编程</h1>\n<p>函数式编程中的函数指的不是程序中的函数（方法），而是数学中的函数即映射关系，如：y=sin(x)，描述数据（函数）之间的映射，同时需要保证相同的输入始终能得到相同的输出。</p>\n<p>函数式编程不会保留计算中间的结果，因此也可以说是无状态的。函数式编程可以将一个函数的执行结果再交由另一个函数去处理。</p>\n<p>Java8通过Lambda表达式与方法引用等，实现函数式编程，可将其可定义为一种简洁、可传递的匿名函数。</p>\n<h2 id=\"Lambda表达式标准格式\">Lambda表达式标准格式</h2>\n<p>两种格式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(parameters) -&gt; expression</span><br><span class=\"line\"></span><br><span class=\"line\">(parameters) -&gt;&#123; statements; &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>parameters：类似方法中的形参列表，这里的参数是函数式接口里的参数，多个参数逗号隔开</p>\n</li>\n<li>\n<p>-&gt;：可以理解为被用于</p>\n</li>\n<li>\n<p>方法体:</p>\n</li>\n<li>\n<p>List item</p>\n</li>\n<li>\n<ul>\n<li>表达式，如果只有一句的话当前表达式即为返回值，不需要写return</li>\n</ul>\n</li>\n<li>\n<p>代码：用{}括起来，如有返回值需要return</p>\n</li>\n</ul>\n<p>举例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 返回给定字符串的长度（隐含return语句） </span><br><span class=\"line\">(String str) -&gt; str.length()</span><br><span class=\"line\"></span><br><span class=\"line\">// 始终返回233的无参方法（隐含return语句） </span><br><span class=\"line\">() -&gt; 233</span><br><span class=\"line\"></span><br><span class=\"line\">// 返回当前用户是否年龄大于20岁，返回一个boolean值（隐含return语句） </span><br><span class=\"line\">(User user) -&gt; user.getAge() &gt; 20</span><br><span class=\"line\"></span><br><span class=\"line\">// 包含多行表达式，需用花括号括起来，并使用return关键字返回</span><br><span class=\"line\">(int x, int y) -&gt; &#123; </span><br><span class=\"line\">    int z = x * y; </span><br><span class=\"line\">    return x + z; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Lambda表达式举例\">Lambda表达式举例</h2>\n<p>我们此处以通过Runnable接口实现类的创建线程为例，由于Runnable接口只有一个run（）方法，所以这里从之前的直观写法到lambda表达式进行代码演示。</p>\n<ol>\n<li>通过创建一个Runnable接口实现类来实现</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestThread &#123;</span><br><span class=\"line\">    @Test</span><br><span class=\"line\">    public void testThread1()&#123;</span><br><span class=\"line\">        Thread thread = new Thread(new MyRunnable(), &quot;thread1&quot;);</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class=\"line\">            System.out.println(&quot;主线程&quot; + i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class MyRunnable implements Runnable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread() + &quot;正在执行：&quot; + i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>通过匿名内部类</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void testThread2()&#123;</span><br><span class=\"line\">    Thread thread = new Thread(new Runnable() &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + &quot;正在执行：&quot; + i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, &quot;thread1&quot;);</span><br><span class=\"line\">    thread.start();</span><br><span class=\"line\">    for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class=\"line\">        System.out.println(&quot;主线程&quot; + i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>通过lambda表达式</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void testThread3()&#123;</span><br><span class=\"line\">    Thread thread = new Thread(() -&gt; &#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread() + &quot;正在执行：&quot; + i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, &quot;thread1&quot;);</span><br><span class=\"line\">    thread.start();</span><br><span class=\"line\">    for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class=\"line\">        System.out.println(&quot;主线程&quot; + i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"函数式编程的好处\">函数式编程的好处</h2>\n<ol>\n<li>减少业务逻辑和代码的分歧。他允许我们在更高层次更自然的描述业务逻辑。让代码直接描述“你想做什么”，而不是“你想怎样去做”。</li>\n<li>延迟执行：以lambda表达式为例，通过下面的例子可以看出lambda表达式是现将代码逻辑传送进去，符合逻辑才执行，此时传进去的flag为2，不符合逻辑，则lambda中的逻辑均不执行</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestThread &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Test</span><br><span class=\"line\">    public void testDelay()&#123;</span><br><span class=\"line\">        printLog(2, () -&gt; &#123;</span><br><span class=\"line\">            System.out.println(&quot;lambda执行&quot;);</span><br><span class=\"line\">            return &quot;a&quot; + &quot;b&quot; + &quot;c&quot;;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void printLog(int flag, MessageBuilder message)&#123;</span><br><span class=\"line\">        if(flag == 1)&#123;</span><br><span class=\"line\">            System.out.println(message.buildMessage());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">interface MessageBuilder &#123;</span><br><span class=\"line\">    String buildMessage();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"常用函数式接口\">常用函数式接口</h2>\n<ul>\n<li>对于各个常用接口，这里仅介绍他们的抽象方法，对于Consumer等还有一些默认方法。</li>\n<li>这四个接口，会通过后面的文章具体解析编程时的应用。</li>\n</ul>\n<h3 id=\"Supplier\">Supplier</h3>\n<p>对外提供一个符合泛型类型的对象数据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@FunctionalInterface</span><br><span class=\"line\">public interface Supplier&lt;T&gt; &#123;</span><br><span class=\"line\">    T get();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>举例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.function.Supplier;</span><br><span class=\"line\"></span><br><span class=\"line\">public class DemoSupplier &#123;</span><br><span class=\"line\">    private static String getString(Supplier&lt;String&gt; function) &#123;</span><br><span class=\"line\">        return function.get();</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    </span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        String msgA = &quot;Hello&quot;;</span><br><span class=\"line\">        String msgB = &quot;World&quot;;</span><br><span class=\"line\">        System.out.println(getString(() ‐&gt; msgA + msgB));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Consumer\">Consumer</h3>\n<p>正好与Supplier接口相反，它不是生产一个数据，而是消费一个数据，其数据类型由泛型决定</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@FunctionalInterface</span><br><span class=\"line\">public interface Consumer&lt;T&gt; &#123;</span><br><span class=\"line\">    void accept(T t);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">import java.util.function.Consumer;</span><br><span class=\"line\">public class Demo09Consumer &#123;</span><br><span class=\"line\">    private static void consumeString(Consumer&lt;String&gt; function) &#123;</span><br><span class=\"line\">        function.accept(&quot;Hello&quot;);</span><br><span class=\"line\">    &#125; public static void main(String[] args) &#123;</span><br><span class=\"line\">        consumeString(s ‐&gt; System.out.println(s));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Predicate\">Predicate</h3>\n<p>对某种类型的数据进行判断，从而得到一个boolean值结果。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@FunctionalInterface</span><br><span class=\"line\">public interface Predicate&lt;T&gt; &#123;</span><br><span class=\"line\">    boolean test(T t);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">import java.util.function.Predicate;</span><br><span class=\"line\">public class Demo15PredicateTest &#123;</span><br><span class=\"line\">    private static void method(Predicate&lt;String&gt; predicate) &#123;</span><br><span class=\"line\">        boolean veryLong = predicate.test(&quot;HelloWorld&quot;);</span><br><span class=\"line\">        System.out.println(&quot;字符串很长吗：&quot; + veryLong);</span><br><span class=\"line\">    &#125; public static void main(String[] args) &#123;</span><br><span class=\"line\">        method(s ‐&gt; s.length() &gt; 5);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Function\">Function</h3>\n<p>用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@FunctionalInterface</span><br><span class=\"line\">public interface Function&lt;T, R&gt; &#123;</span><br><span class=\"line\">    R apply(T t);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">import java.util.function.Function;</span><br><span class=\"line\">public class Demo11FunctionApply &#123;</span><br><span class=\"line\">    private static void method(Function&lt;String, Integer&gt; function) &#123;</span><br><span class=\"line\">        int num = function.apply(&quot;10&quot;);</span><br><span class=\"line\">        System.out.println(num + 20);</span><br><span class=\"line\">    &#125; public static void main(String[] args) &#123;</span><br><span class=\"line\">        method(s ‐&gt; Integer.parseInt(s));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1>Stream流的数据操作（串行）</h1>\n<h1>总体介绍</h1>\n<h2 id=\"Stream流的概念\">Stream流的概念</h2>\n<p>Stream API 提供了一种高效且易于使用的处理数据的方式。Stream是Java8中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API 对集合数据进行操作， 就类似于使用 SQL 执行的数据库查询。</p>\n<p>java中的流都是用于传输数据的数据渠道，但是不同的流具体功能不同，就像java中的IO流类似，stream流也是用于承载数据传输，但是stream流是为了处理数据。</p>\n<p>既然stream流的核心目的是处理数据，那么对于无需前后数据就可处理的过程可利用多线程操作，本文主要讲stream的串行操作，并行操作放在<a href=\"https://www.yuque.com/mingzhaohexi/hcbh16/bmg3fl8w1xlefd0m%E4%B8%AD%E3%80%82\">https://www.yuque.com/mingzhaohexi/hcbh16/bmg3fl8w1xlefd0m中。</a></p>\n<h2 id=\"Stream流的三部分\">Stream流的三部分</h2>\n<ul>\n<li>创建 Stream：一个数据源（如： 集合、 数组）， 获取一个流</li>\n<li>中间操作：一个中间操作链， 对数据源的数据进行处理</li>\n<li>终止操作(终端操作)：一个终止操作， 执行中间操作链， 并产生结果</li>\n</ul>\n<h2 id=\"Stream流的注意事项\">Stream流的注意事项</h2>\n<ul>\n<li>Stream 自己不会存储元素。</li>\n<li>Stream 不会改变源对象。 相反， 他们会返回一个持有结果的新Stream。</li>\n<li>Stream 操作是延迟执行的。 这意味着他们会等到需要结果的时候才执行。</li>\n</ul>\n<h1>创建方式</h1>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void test() &#123;</span><br><span class=\"line\">    // 1.通过Collection集合的方法获取</span><br><span class=\"line\">    List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">    Stream&lt;String&gt; stream = list.stream();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 2.数组：通过Arrays的静态方法stream()</span><br><span class=\"line\">    String[] strArr = new String[2];</span><br><span class=\"line\">    Stream&lt;String&gt; stream1 = Arrays.stream(strArr);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 3.通过Stream的静态方法of()</span><br><span class=\"line\">    Stream&lt;String&gt; a = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 4.创建无限流</span><br><span class=\"line\">    // 4.1 迭代</span><br><span class=\"line\">    Stream&lt;Integer&gt; stream2 = Stream.iterate(0, (x) -&gt; x + 1);</span><br><span class=\"line\">    stream2.limit(5).forEach(System.out::print);</span><br><span class=\"line\">    System.out.println();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 4.2 生成</span><br><span class=\"line\">    Stream.generate(Math::random)</span><br><span class=\"line\">            .limit(5)</span><br><span class=\"line\">            .forEach(System.out::println);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>前3种应该比较好理解，个人认为最常见的还是第一种，对于无限流，创建时写入创建元素的方法，那么流的长度就是无穷大，为了功能需求，一般通过中间操作limit()来实现限制流的长度：</p>\n<ul>\n<li>迭代：Stream.iterate() 第一个参数为第一个元素大小，第二个参数为后一个元素在前一个元素已知条件下的生成规则</li>\n<li>生成：生成方法</li>\n</ul>\n<h1>中间操作</h1>\n<table>\n<thead>\n<tr>\n<th><strong>位置</strong></th>\n<th><strong>类型</strong></th>\n<th><strong>函数</strong></th>\n<th><strong>作用</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>中间操作</td>\n<td>无状态</td>\n<td>filter()</td>\n<td>过滤</td>\n</tr>\n<tr>\n<td>中间操作</td>\n<td>无状态</td>\n<td>peek()</td>\n<td>流中的执行操作，debug，不改变元素内容</td>\n</tr>\n<tr>\n<td>中间操作</td>\n<td>无状态</td>\n<td>map()</td>\n<td>元素-&gt;元素 映射</td>\n</tr>\n<tr>\n<td>中间操作</td>\n<td>无状态</td>\n<td>FlatMap()</td>\n<td>元素-&gt;流 映射，并将流中的元素合并到原数据流中</td>\n</tr>\n<tr>\n<td>中间操作</td>\n<td>无状态</td>\n<td>mapToInt()</td>\n<td>元素-&gt;IntStream 映射</td>\n</tr>\n<tr>\n<td>中间操作</td>\n<td>无状态</td>\n<td>mapToDouble()</td>\n<td>元素-&gt;DoubleStream 映射</td>\n</tr>\n<tr>\n<td>中间操作</td>\n<td>无状态</td>\n<td>mapToLong()</td>\n<td>元素-&gt;LongStream 映射</td>\n</tr>\n<tr>\n<td>中间操作</td>\n<td>无状态</td>\n<td>flatMapToInt()</td>\n<td>元素-&gt;IntStream 映射，和原数据流合并</td>\n</tr>\n<tr>\n<td>中间操作</td>\n<td>无状态</td>\n<td>flatMapToDouble()</td>\n<td>元素-&gt;DoubleStream 映射，和原数据流合并</td>\n</tr>\n<tr>\n<td>中间操作</td>\n<td>无状态</td>\n<td>flatMapToLong()</td>\n<td>元素-&gt;LongStream 映射，和原数据流合并</td>\n</tr>\n<tr>\n<td>中间操作</td>\n<td>有状态</td>\n<td>limit(n)</td>\n<td>切片：保留前n个元素</td>\n</tr>\n<tr>\n<td>中间操作</td>\n<td>有状态</td>\n<td>skip(n)</td>\n<td>切片：丢弃前n个元素</td>\n</tr>\n<tr>\n<td>中间操作</td>\n<td>有状态</td>\n<td>distinct()</td>\n<td>筛选：去重，hashCode()&amp;equals()</td>\n</tr>\n<tr>\n<td>中间操作</td>\n<td>有状态</td>\n<td>sorted()</td>\n<td>排序</td>\n</tr>\n<tr>\n<td>中间操作</td>\n<td>有状态</td>\n<td>sorted(comp)</td>\n<td>按比较器comp排序</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>无状态： 指元素的处理不受之前元素的影响，各个元素的处理可多线程操作；</li>\n<li>有状态： 指该操作只有拿到所有元素之后才能继续下去。</li>\n</ul>\n<p>下面的程序主要用下面这个流进行举例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;String&gt; stream1 = Stream.iterate(&quot;a&quot;, (x) -&gt; &#123;</span><br><span class=\"line\">    char[] chars = x.toCharArray();</span><br><span class=\"line\">    return x + (char) (chars[chars.length - 1] + 1);</span><br><span class=\"line\">&#125;).limit(6);</span><br><span class=\"line\"></span><br><span class=\"line\">stream1.forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a</span><br><span class=\"line\">ab</span><br><span class=\"line\">abc</span><br><span class=\"line\">abcd</span><br><span class=\"line\">abcde</span><br><span class=\"line\">abcdef</span><br></pre></td></tr></table></figure>\n<h2 id=\"无状态操作\">无状态操作</h2>\n<h3 id=\"过滤\">过滤</h3>\n<p>filter(Predicate p) 接收 Lambda ， 从流中保留符合条件的元素。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stream1.filter(x -&gt; x.length() &gt; 3).forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n<p>结果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">abcd</span><br><span class=\"line\">abcde</span><br><span class=\"line\">abcdef</span><br></pre></td></tr></table></figure>\n<h3 id=\"执行\">执行</h3>\n<p>执行操作主要用于debug中使用，和forEach作用类似，对每个元素遍历操作且不改变元素内容，但forEach是结束流只能在最后用一次，所以中间的操作使用peek()</p>\n<p>peek(Consumer&lt;? super T&gt; action) 用于流中间不改变元素内容的操作</p>\n<p>为更好的举例，这里使用int类型的流举例，可以看出流中执行的顺序：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; list = Arrays.asList(4, 7, 9, 11, 12);</span><br><span class=\"line\">list.stream()</span><br><span class=\"line\">        .peek(x -&gt; System.out.println(&quot;stream: &quot; + x))</span><br><span class=\"line\">        .map(x -&gt; x + 2)</span><br><span class=\"line\">        .peek(x -&gt; System.out.println(&quot;map: &quot; + x))</span><br><span class=\"line\">        .filter(x -&gt; x % 2 != 0)</span><br><span class=\"line\">        .peek(x -&gt; System.out.println(&quot;filter: &quot; + x))</span><br><span class=\"line\">        .limit(2)</span><br><span class=\"line\">        .peek(x -&gt; System.out.println(&quot;limit: &quot; + x))</span><br><span class=\"line\">        .collect(Collectors.toList());</span><br><span class=\"line\">stream: 4</span><br><span class=\"line\">map: 6</span><br><span class=\"line\">stream: 7</span><br><span class=\"line\">map: 9</span><br><span class=\"line\">filter: 9</span><br><span class=\"line\">limit: 9</span><br><span class=\"line\">stream: 9</span><br><span class=\"line\">map: 11</span><br><span class=\"line\">filter: 11</span><br><span class=\"line\">limit: 11</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n<h3 id=\"映射\">映射</h3>\n<ul>\n<li>map(Function f) 接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</li>\n<li>flatMap(Function f) 接收一个函数作为参数， 将流中的每个值都换成另一个流， 然后把所有流连接成一个流</li>\n<li>mapToDouble(ToDoubleFunction f) 接收一个函数作为参数， 该函数会被应用到每个元素上， 产生一个新的 DoubleStream。</li>\n<li>mapToInt(ToIntFunction f) 接收一个函数作为参数， 该函数会被应用到每个元素上， 产生一个新的 IntStream。</li>\n<li>mapToLong(ToLongFunction f) 接收一个函数作为参数， 该函数会被应用到每个元素上， 产生一个新的 LongStream。</li>\n</ul>\n<p>map：用于数据处理，这里相当于大数据map-reduce中map处理，返回类型可以与输入类型不同，在结束操作中有reduce方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stream1.map(x -&gt; x+&quot;111&quot;).forEach(System.out::println);</span><br><span class=\"line\">a111</span><br><span class=\"line\">ab111</span><br><span class=\"line\">abc111</span><br><span class=\"line\">abcd111</span><br><span class=\"line\">abcde111</span><br><span class=\"line\">abcdef111</span><br></pre></td></tr></table></figure>\n<p>flatMap：在flatMap中，返回的数据类型是一个stream流类型，这个方法将流中的每个元素打平到原来的大流中，类似于集合的addAll()方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stream1.flatMap(x -&gt; &#123;</span><br><span class=\"line\">    char[] chars = x.toCharArray();</span><br><span class=\"line\">    Character[] newChars = new Character[chars.length];</span><br><span class=\"line\">    for (int i = 0; i &lt; chars.length; i++) &#123;</span><br><span class=\"line\">        newChars[i] = chars[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Stream&lt;Character&gt; stream2 = Arrays.stream(newChars);</span><br><span class=\"line\">    return stream2;</span><br><span class=\"line\">&#125;).forEach(System.out::print);</span><br><span class=\"line\">aababcabcdabcdeabcdef</span><br></pre></td></tr></table></figure>\n<h2 id=\"有状态操作\">有状态操作</h2>\n<p>有状态操作需要将所用元素执行完前面的操作后，再一起执行</p>\n<h3 id=\"切片\">切片</h3>\n<ul>\n<li>limit(long maxSize) 截断流， 使其元素不超过给定数量。</li>\n<li>skip(long n) 跳过元素， 返回一个扔掉了前 n 个元素的流。 若流中元素不足 n 个， 则返回一个空流。 与 limit(n) 互补</li>\n</ul>\n<h3 id=\"筛选去重\">筛选去重</h3>\n<ul>\n<li>distinct() 筛选， 通过流所生成元素的 hashCode() 和 equals() 去除重复元素</li>\n</ul>\n<h3 id=\"排序\">排序</h3>\n<ul>\n<li>sorted() 产生一个新流， 其中按自然顺序排序</li>\n<li>sorted(Comparator comp) 产生一个新流， 其中按比较器顺序排序</li>\n</ul>\n<h1>终止操作</h1>\n<table>\n<thead>\n<tr>\n<th><strong>位置</strong></th>\n<th><strong>类型</strong></th>\n<th><strong>函数</strong></th>\n<th><strong>作用</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>结束操作</td>\n<td>短路操作</td>\n<td>findFirst()</td>\n<td>返回第一个元素</td>\n</tr>\n<tr>\n<td>结束操作</td>\n<td>短路操作</td>\n<td>findAny()</td>\n<td>返回任意一个元素</td>\n</tr>\n<tr>\n<td>结束操作</td>\n<td>短路操作</td>\n<td>allMatch()</td>\n<td>是否匹配所有元素</td>\n</tr>\n<tr>\n<td>结束操作</td>\n<td>短路操作</td>\n<td>anyMatch()</td>\n<td>是否至少匹配一个元素</td>\n</tr>\n<tr>\n<td>结束操作</td>\n<td>短路操作</td>\n<td>noneMatch()</td>\n<td>是否没有匹配所有元素</td>\n</tr>\n<tr>\n<td>结束操作</td>\n<td>短路操作</td>\n<td>noneMatch()</td>\n<td>是否没有匹配所有元素</td>\n</tr>\n<tr>\n<td>结束操作</td>\n<td>非短路操作</td>\n<td>reduce()</td>\n<td>规约合并到一个元素</td>\n</tr>\n<tr>\n<td>结束操作</td>\n<td>非短路操作</td>\n<td>collect()</td>\n<td>收集到其他形式</td>\n</tr>\n<tr>\n<td>结束操作</td>\n<td>非短路操作</td>\n<td>forEach()</td>\n<td>内部迭代</td>\n</tr>\n<tr>\n<td>结束操作</td>\n<td>非短路操作</td>\n<td>toArray()</td>\n<td>转化为数组</td>\n</tr>\n<tr>\n<td>结束操作</td>\n<td>非短路操作</td>\n<td>max()</td>\n<td>统计：最大值</td>\n</tr>\n<tr>\n<td>结束操作</td>\n<td>非短路操作</td>\n<td>min()</td>\n<td>统计：最小值</td>\n</tr>\n<tr>\n<td>结束操作</td>\n<td>非短路操作</td>\n<td>count()</td>\n<td>统计：元素数量</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>非短路操作： 指必须处理所有元素才能得到最终结果；</li>\n<li>短路操作： 指遇到某些符合条件的元素就可以得到最终结果，如 A || B，只要A为true，则无需判断B的结果。</li>\n</ul>\n<p>程序示例：对于结束操作，涉及到大量属性特征的处理，所以创建了一个book类，如下所示，类型包含：学习&amp;小说</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Book&#123;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    private int page;</span><br><span class=\"line\">    private Type type;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Book() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Book(String name, int page, Type type) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        this.page = page;</span><br><span class=\"line\">        this.type = type;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String toString() &#123;</span><br><span class=\"line\">        return &quot;Book&#123;&quot; +</span><br><span class=\"line\">            &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +</span><br><span class=\"line\">            &quot;, page=&quot; + page +</span><br><span class=\"line\">            &quot;, type=&quot; + type +</span><br><span class=\"line\">            &#x27;&#125;&#x27;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean equals(Object o) &#123;</span><br><span class=\"line\">        if (this == o) return true;</span><br><span class=\"line\">        if (o == null || getClass() != o.getClass()) return false;</span><br><span class=\"line\">        Book book = (Book) o;</span><br><span class=\"line\">        return page == book.page &amp;&amp; Objects.equals(name, book.name) &amp;&amp; type == book.type;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public int hashCode() &#123;</span><br><span class=\"line\">        return Objects.hash(name, page, type);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getName() &#123;</span><br><span class=\"line\">        return name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setName(String name) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int getPage() &#123;</span><br><span class=\"line\">        return page;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setPage(int page) &#123;</span><br><span class=\"line\">        this.page = page;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Type getType() &#123;</span><br><span class=\"line\">        return type;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setType(Type type) &#123;</span><br><span class=\"line\">        this.type = type;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">enum Type &#123;</span><br><span class=\"line\">    STUDY,</span><br><span class=\"line\">    NOVEL</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用的流如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void test10()&#123;</span><br><span class=\"line\">    List&lt;Book&gt; books = new ArrayList&lt;&gt;();</span><br><span class=\"line\">    books.add(new Book(&quot;Spring&quot;, 200, Type.STUDY));</span><br><span class=\"line\">    books.add(new Book(&quot;Python&quot;, 180, Type.STUDY));</span><br><span class=\"line\">    books.add(new Book(&quot;C++&quot;, 230, Type.STUDY));</span><br><span class=\"line\">    books.add(new Book(&quot;NOVEL1&quot;, 230, Type.NOVEL));</span><br><span class=\"line\">    books.add(new Book(&quot;NOVEL2&quot;, 280, Type.NOVEL));</span><br><span class=\"line\">    books.add(new Book(&quot;NOVEL3&quot;, 180, Type.NOVEL));</span><br><span class=\"line\"></span><br><span class=\"line\">    books.stream().forEach(System.out::println);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Book&#123;name=&#x27;Spring&#x27;, page=200, type=STUDY&#125;</span><br><span class=\"line\">Book&#123;name=&#x27;Python&#x27;, page=180, type=STUDY&#125;</span><br><span class=\"line\">Book&#123;name=&#x27;C++&#x27;, page=230, type=STUDY&#125;</span><br><span class=\"line\">Book&#123;name=&#x27;NOVEL1&#x27;, page=230, type=NOVEL&#125;</span><br><span class=\"line\">Book&#123;name=&#x27;NOVEL2&#x27;, page=280, type=NOVEL&#125;</span><br><span class=\"line\">Book&#123;name=&#x27;NOVEL3&#x27;, page=180, type=NOVEL&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"短路操作\">短路操作</h2>\n<p>短路操作再遇到某些符合条件的元素时可提前结束，得到结果，无需遍历所有元素</p>\n<h3 id=\"查找\">查找</h3>\n<ul>\n<li>findFirst() 返回第一个元素</li>\n<li>findAny() 返回当前流中的任意元素</li>\n</ul>\n<h3 id=\"匹配\">匹配</h3>\n<ul>\n<li>allMatch(Predicate p) 检查是否匹配所有元素</li>\n<li>anyMatch(Predicate p) 检查是否至少匹配一个元素</li>\n<li>noneMatch(Predicate p) 检查是否没有匹配所有元素</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 1.查找</span><br><span class=\"line\">Optional&lt;Book&gt; first = books.stream().findFirst();</span><br><span class=\"line\">System.out.println(first.get());</span><br><span class=\"line\"></span><br><span class=\"line\">Optional&lt;Book&gt; any = books.stream().findAny();</span><br><span class=\"line\">System.out.println(any.get());</span><br><span class=\"line\"></span><br><span class=\"line\">// 2.匹配</span><br><span class=\"line\">boolean b = books.stream().allMatch(x -&gt; x.getPage() &gt; 200);</span><br><span class=\"line\">System.out.println(b);</span><br><span class=\"line\"></span><br><span class=\"line\">boolean b1 = books.stream().anyMatch(x -&gt; x.getType().equals(Type.STUDY));</span><br><span class=\"line\">System.out.println(b1);</span><br><span class=\"line\"></span><br><span class=\"line\">boolean b2 = books.stream().noneMatch(x -&gt; x.getPage() &gt; 200);</span><br><span class=\"line\">boolean b3 = books.stream().noneMatch(x -&gt; x.getPage() &lt; 100);</span><br><span class=\"line\">System.out.println(b2 + &quot;  &quot; + b3);</span><br><span class=\"line\">Book&#123;name=&#x27;Spring&#x27;, page=200, type=STUDY&#125;</span><br><span class=\"line\">Book&#123;name=&#x27;Spring&#x27;, page=200, type=STUDY&#125;</span><br><span class=\"line\">false</span><br><span class=\"line\">true</span><br><span class=\"line\">false  true</span><br></pre></td></tr></table></figure>\n<h2 id=\"非短路操作\">非短路操作</h2>\n<h3 id=\"规约\">规约</h3>\n<p>规约reduce，相当于大数据map-reduce模型中的reduce，将之前map之后各个元素结果结合到一起</p>\n<ul>\n<li>reduce(T iden, BinaryOperator b) 可以将流中元素反复结合起来， 得到一个值。返回 T。iden为初始元素，b为二元运算，结合各个元素，由于有初始元素iden，所以即使流为空，也可以返回iden</li>\n<li>reduce(BinaryOperator b) 可以将流中元素反复结合起来， 得到一个值。返回 Optional</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer allPage = books.stream().map(Book::getPage).reduce(100, (a, b) -&gt; a + b);</span><br><span class=\"line\">System.out.println(allPage);</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;Book&gt; books2 = new ArrayList&lt;&gt;();</span><br><span class=\"line\">Integer allPage1 = books2.stream().map(Book::getPage).reduce(200, (a, b) -&gt; a + b);</span><br><span class=\"line\">System.out.println(allPage1);</span><br><span class=\"line\"></span><br><span class=\"line\">Optional&lt;Integer&gt; allPage2 = books.stream().map(Book::getPage).reduce((a, b) -&gt; a + b);</span><br><span class=\"line\">System.out.println(allPage2.get());</span><br><span class=\"line\">1400</span><br><span class=\"line\">200</span><br><span class=\"line\">1300</span><br></pre></td></tr></table></figure>\n<h3 id=\"收集\">收集</h3>\n<ul>\n<li>collect(Collector c)将流转换为其他形式。接收一个Collector接口的实现，用于给Stream中元素做汇总的方法</li>\n<li>Collectors实用类提供了很多静态方法， 可以方便地创建常见Collector接口的收集器实例</li>\n</ul>\n<p>Collectors的常用静态方法：</p>\n<ol>\n<li>\n<p>收集为Collection集合</p>\n</li>\n<li>\n<ol>\n<li>toList(),将流收集到List，返回类型为List</li>\n</ol>\n</li>\n<li>\n<p>toSet()，把流中元素收集到Set，返回类型为Set</p>\n</li>\n<li>\n<p>toCollection(Supplier sup),把流中元素收集到创建的集合，可用于任何其他的集合类型</p>\n</li>\n<li>\n<p>收集到统计特征</p>\n</li>\n<li>\n<ol>\n<li>counting()：计算流中元素的个数，返回Long</li>\n</ol>\n</li>\n<li>\n<p>summingInt(Function fun)：对流中元素的整数属性求和，返回Integer</p>\n</li>\n<li>\n<p>averagingInt(Function fun)：计算流中元素Integer属性的平均值，返回Double</p>\n</li>\n<li>\n<p>summarizingInt(Function fun)：收集流中Integer属性的统计值。如： 平均值，返回IntSummaryStatistics</p>\n</li>\n<li>\n<p>连接符：joining(),连接流中每个字符串,返回String</p>\n</li>\n<li>\n<p>比较器统计</p>\n</li>\n<li>\n<ol>\n<li>maxBy(Comparator com):根据比较器选择最大值，返回Optional</li>\n</ol>\n</li>\n<li>\n<p>minBy(Comparator com)：根据比较器选择最小值，返回Optional</p>\n</li>\n<li>\n<p>规约：reducing()：从一个作为累加器的初始值开始， 利用BinaryOperator与流中元素逐个结合， 从而归约成单个值</p>\n</li>\n<li>\n<p>分组&amp;分区</p>\n</li>\n<li>\n<ol>\n<li>分组groupingBy(Function fun):根据某属性值对流分组， 属性为K， 结果为V，返回Map&lt;K, List&gt;，可以级联实现多级分组</li>\n</ol>\n</li>\n<li>\n<p>分区：partitioningBy(Function fun)，根据true或false进行分区，Map&lt;Boolean, List&gt;</p>\n</li>\n<li>\n<p>collectingAndThen():包裹另一个收集器， 对其结s果转换函数</p>\n</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 1.集合</span><br><span class=\"line\">List&lt;Book&gt; collect = books.stream().limit(3).collect(Collectors.toList());</span><br><span class=\"line\">System.out.println(collect);</span><br><span class=\"line\"></span><br><span class=\"line\">Set&lt;Book&gt; collect1 = books.stream().limit(3).collect(Collectors.toSet());</span><br><span class=\"line\">System.out.println(collect1);</span><br><span class=\"line\"></span><br><span class=\"line\">ArrayList&lt;Book&gt; collect2 = books.stream().limit(3).collect(Collectors.toCollection(ArrayList::new));</span><br><span class=\"line\">System.out.println(collect2);</span><br><span class=\"line\"></span><br><span class=\"line\">// 2.统计</span><br><span class=\"line\">Long collect3 = books.stream().limit(3).collect(Collectors.counting());</span><br><span class=\"line\">System.out.println(collect3);</span><br><span class=\"line\"></span><br><span class=\"line\">IntSummaryStatistics collect4 = books.stream().limit(3).collect(Collectors.summarizingInt(Book::getPage));</span><br><span class=\"line\">System.out.println(collect4.getMax());</span><br><span class=\"line\">System.out.println(collect4.getSum());</span><br><span class=\"line\">System.out.println(collect4.getAverage());</span><br><span class=\"line\"></span><br><span class=\"line\">// 3.连接</span><br><span class=\"line\">String collect5 = books.stream().map(Book::getName).collect(Collectors.joining(&quot;,&quot;, &quot;+++&quot;, &quot;---&quot;));</span><br><span class=\"line\">System.out.println(collect5);</span><br><span class=\"line\"></span><br><span class=\"line\">// 4.分组</span><br><span class=\"line\">Map&lt;Type, List&lt;Book&gt;&gt; collect6 = books.stream().collect(Collectors.groupingBy(Book::getType));</span><br><span class=\"line\">System.out.println(collect6);</span><br><span class=\"line\"></span><br><span class=\"line\">Map&lt;Type, Map&lt;Boolean, List&lt;Book&gt;&gt;&gt; collect7 = books.stream()</span><br><span class=\"line\">        .collect(Collectors.groupingBy(Book::getType, Collectors.groupingBy(x -&gt; x.getPage() &gt; 200)));</span><br><span class=\"line\">System.out.println(collect7);</span><br></pre></td></tr></table></figure>\n<h3 id=\"迭代\">迭代</h3>\n<ul>\n<li>forEach(Consumer c) 内部迭代(使用 Collection 接口需要用户去做迭代， 称为外部迭代。 相反， Stream API 使用内部迭代——它帮你把迭代做了)</li>\n</ul>\n<h3 id=\"数组\">数组</h3>\n<ul>\n<li>toArray()：转为数组</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object[] objects = books.stream().map(Book::getName).toArray();</span><br><span class=\"line\">System.out.println(Arrays.toString(objects));</span><br><span class=\"line\">[Spring, Python, C++, NOVEL1, NOVEL2, NOVEL3]</span><br></pre></td></tr></table></figure>\n<h3 id=\"统计\">统计</h3>\n<ul>\n<li>count() 返回流中元素总数</li>\n<li>max(Comparator c) 返回流中最大值</li>\n<li>min(Comparator c) 返回流中最小值</li>\n</ul>\n<h1>Stream流的数据操作（并行）</h1>\n<h1>引言</h1>\n<ul>\n<li>并行（Parallelism）：强调的是将一个大任务分解为多个小任务后，为减少IO等待时间等，通过轮询执行这些小任务，得到多个中间结果后再汇总为一个最终结果。</li>\n<li>并发（Concurrency）：强调的是在同一时间开始执行多个任务，通常会涉及多线程之间的上下文切换</li>\n</ul>\n<p>但在多CPU和分布式的时代，并发和并行的概念联系越来越紧密。至少在Java的Stream中，我们可以将并发和并行理解为同一个意思：基于多线程技术，对一个大任务分拆为多个小任务，分配到不同的线程中执行，从而提高效率，得到多个中间结果后再汇总为一个最终结果。</p>\n<p>Stream的并行编程，底层是基于 ForkJoinPool 技术来实现的。ForkJoinPool是Java 7引入的用于并行执行的任务框架，核心思想是将一个大任务拆分成多个小任务（即fork），然后再将多个小任务的处理结果汇总到一个结果上（即join）。但是java7中的Fork-Join模式编程过程相对复杂，java8将这种模式应用于stream流就大大简化了开发代码。</p>\n<h1>Fork-Join模式</h1>\n<h2 id=\"Fork-Join-框架\">Fork/Join 框架</h2>\n<p>将一个大任务， 进行拆分(fork)成若干个小任务（拆到不可再拆时），再通过递归的方式，将一个个的小任务运算的结果进行 join 汇总。</p>\n<p><img src=\"https://apijoyspace.jd.com/v1/files/Aew1zlPP5nQt562ikxKg/link\" alt></p>\n<p>采用 “工作窃取” 模式（work-stealing）： 当执行新的任务时它可以将其拆分分成更小的任务执行， 并将小任务加到线程队列中， 然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。减少子任务等待时间，从而提高整体的效率。</p>\n<h2 id=\"Fork-Join-Map-Reduce-区别\">Fork-Join &amp; Map-Reduce 区别</h2>\n<p>Fork-Join 与大数据中的Map-Reduce思想类似，但是也有一定区别：</p>\n<ul>\n<li>\n<p>应用场景不同：</p>\n</li>\n<li>\n<ul>\n<li>F-J似乎设计为在单个Java VM上工作，</li>\n</ul>\n</li>\n<li>\n<p>M-R则明确设计为在大型机器集群上工作</p>\n</li>\n<li>\n<p>划分子任务方式不同：</p>\n</li>\n<li>\n<ul>\n<li>F-J提供将任务分割成多个子任务的设施，以递归的方式;更多层次，在这个阶段“跨叉”通信的可能性</li>\n</ul>\n</li>\n<li>\n<p>M-R只做一个大的分裂，映射分裂在彼此之间不说话，然后一起减少一切。单层，没有分裂之间的通信，直到减少，并可大规模扩展。</p>\n</li>\n</ul>\n<h2 id=\"程序举例\">程序举例</h2>\n<p>这里通过一个累加程序来测试，以1-300亿举例</p>\n<ul>\n<li>RecursiveTask : 有返回值</li>\n<li>RecursiveAction ：无返回值</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ForkJoinCalculate extends RecursiveTask&lt;Long&gt; &#123;</span><br><span class=\"line\">    private static final long serialVersionUID = 12345678925L;</span><br><span class=\"line\">    private long start;</span><br><span class=\"line\">    private long end;</span><br><span class=\"line\">    // 没1w个一组划分子任务累加</span><br><span class=\"line\">    private static final long THRESHOLD = 10000L;</span><br><span class=\"line\"></span><br><span class=\"line\">    public ForkJoinCalculate(long start, long end) &#123;</span><br><span class=\"line\">        this.start = start;</span><br><span class=\"line\">        this.end = end;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected Long compute() &#123;</span><br><span class=\"line\">        long length = end - start;</span><br><span class=\"line\">        if (length &lt;= THRESHOLD) &#123;</span><br><span class=\"line\">            long sum = 0L;</span><br><span class=\"line\">            for (long i = start; i &lt;= end; i++) &#123;</span><br><span class=\"line\">                sum += i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return sum;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            long mid = (start + end) / 2;</span><br><span class=\"line\">            ForkJoinCalculate left = new ForkJoinCalculate(start, mid);</span><br><span class=\"line\">            left.fork(); // 通过fork拆分子任务，并压入线程队列中</span><br><span class=\"line\"></span><br><span class=\"line\">            ForkJoinCalculate right = new ForkJoinCalculate(mid+1, end);</span><br><span class=\"line\">            right.fork();</span><br><span class=\"line\"></span><br><span class=\"line\">            // 利用join方法，递归，返回合并结果</span><br><span class=\"line\">            return left.join() + right.join();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>三种提交任务的区别：</p>\n<ul>\n<li>execute(ForkJoinTask) 异步执行tasks，无返回值</li>\n<li>invoke(ForkJoinTask) 有Join, tasks会被同步到主进程，任务执行完毕后才回到主线程</li>\n<li>submit(ForkJoinTask) 异步执行，且带Task返回值，可通过task.get 实现同步到主线程</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void test15() &#123;</span><br><span class=\"line\">    Instant start = Instant.now();</span><br><span class=\"line\"></span><br><span class=\"line\">    ForkJoinPool pool = new ForkJoinPool();</span><br><span class=\"line\">    ForkJoinTask&lt;Long&gt; task = new ForkJoinCalculate(1, 30000000000L);</span><br><span class=\"line\">    Long invoke = pool.invoke(task);</span><br><span class=\"line\"></span><br><span class=\"line\">    Instant end = Instant.now();</span><br><span class=\"line\">    System.out.println(Duration.between(start,end).toMillis());</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Test</span><br><span class=\"line\">public void test16() &#123;</span><br><span class=\"line\">    Instant start = Instant.now();</span><br><span class=\"line\"></span><br><span class=\"line\">    long num = 30000000000L;</span><br><span class=\"line\">    long sum = 0L;</span><br><span class=\"line\">    for (long i = 1; i &lt;= num; i++) &#123;</span><br><span class=\"line\">        sum += i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Instant end = Instant.now();</span><br><span class=\"line\">    System.out.println(Duration.between(start,end).toMillis());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1>并行流的创建</h1>\n<ol>\n<li>\n<p>通过 Collection.parallelStream 方法可以得到一个并行流</p>\n</li>\n<li>\n<p>串行&amp;并行之间的转换，在中间操作中可随意转换</p>\n</li>\n<li>\n<ol>\n<li>BaseStream.parallel() 串 -&gt; 并</li>\n</ol>\n</li>\n<li>\n<p>BaseStream.sequential() 并 -&gt; 串</p>\n</li>\n</ol>\n<p>BaseStream.isParallel() 可以判断一个 stream 是否是并行流。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Instant start = Instant.now();</span><br><span class=\"line\">OptionalLong reduce = LongStream.rangeClosed(0, 30000000000L).parallel().reduce(Long::sum);</span><br><span class=\"line\">System.out.println(reduce.getAsLong());</span><br><span class=\"line\"></span><br><span class=\"line\">Instant end = Instant.now();</span><br><span class=\"line\">System.out.println(Duration.between(start,end).toMillis());</span><br></pre></td></tr></table></figure>\n<h1>顺序性</h1>\n<ul>\n<li>有序：List 和 Array生成的stream都是ordered stream，而使用 BaseStream.unordered() 方法则可以解除顺序限制，变为 unordered stream。</li>\n<li>无序：HashSet 生成的stream是unordered stream，可以通过排序方法 sort() 强行给stream添加一个 encounter order的约束，变为 ordered stream。</li>\n</ul>\n<p>注意：</p>\n<ul>\n<li>unordered并不会打乱顺序，只是解除限制，不再保证顺序，然后某些操作可以做一些特殊优化</li>\n<li>以最常见的Stream.forEach 为例，在并行执行的时候，即使数据源是List，forEach方法处理元素的顺序也是无序的。要保证处理顺序，需要使用方法 Stream.forEachOrdered。</li>\n</ul>\n<h1>线程安全</h1>\n<h2 id=\"纯函数\">纯函数</h2>\n<p>纯函数（purely function）：函数调用不会改变函数以外的其它状态，换而言之，即函数调用不会改变在该函数之外定义的变量值。</p>\n<p>要保证数据安全，就要求流操作中要全部使用纯函数操作。</p>\n<p>以下在并行时，就不能保证数据安全</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList&lt;String&gt; results = new ArrayList&lt;&gt;();</span><br><span class=\"line\">provinces.parallelStream()</span><br><span class=\"line\">        // 过滤掉以 G 开头的省份</span><br><span class=\"line\">        .filter(s -&gt; !s.startsWith(&quot;G&quot;))</span><br><span class=\"line\">        // 在 lambda表达式中修改了 results 的值，</span><br><span class=\"line\">        // 说明了 &quot;s -&gt; results.add(s)&quot; 并非一个纯函数，</span><br><span class=\"line\">        // 带来了不必要的 &quot;副作用&quot;，</span><br><span class=\"line\">        // 在并行执行时，会导致线程不安全的问题。</span><br><span class=\"line\">        .forEach(s -&gt; results.add(s));</span><br></pre></td></tr></table></figure>\n<p>应该为一下形式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; provinces = Arrays.asList(&quot;Guangdong&quot;, &quot;Jiangsu&quot;, &quot;Guangxi&quot;, &quot;Jiangxi&quot;, &quot;Shandong&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;String&gt; results = provinces.parallelStream()</span><br><span class=\"line\">        // 过滤掉以 G 开头的省份</span><br><span class=\"line\">        .filter(s -&gt; !s.startsWith(&quot;G&quot;))</span><br><span class=\"line\">        // 没有 &quot;副作用&quot;</span><br><span class=\"line\">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>\n<h2 id=\"规约操作（reduce）\">规约操作（reduce）</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>identity:是规约操作的初始值。对任意值 t，要满足 accumulator.apply(identity, t) == t 。否则，会导致错误的结果。</li>\n<li>accumulator: 二元表达式，要求满足结合律（associative），否则在一些顺序不确定的或并行的场景中会导致不正确的结果。这是因为并行的时候可能会有多个元素和初始值进行运算操作。</li>\n</ul>\n<h2 id=\"收集器（collect）\">收集器（collect）</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;R&gt; R collect(Supplier&lt;R&gt; supplier,</span><br><span class=\"line\">              BiConsumer&lt;R, ? super T&gt; accumulator,</span><br><span class=\"line\">              BiConsumer&lt;R, R&gt; combiner);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>R:回值的类型，通常是一个容器类（例如 Collection 或 Map）。</li>\n<li>T 是Stream中的元素类型。</li>\n<li>supplier：是用来创建一个容器实例的函数。</li>\n<li>accumulator：将Stream中的一个元素合并到容器中的函数。</li>\n<li>combiner 是将两个容器归并为一个容器的函数，只在并行执行的时候用到。</li>\n</ul>\n<p>在并行执行的场景下，我们有一些额外的要求：</p>\n<ol>\n<li>combiner函数满足结合律</li>\n<li>要求combiner 和 accumulator 是兼容的（compatible），即对于任意的r和t， combiner.accept(r, accumulator.accept(supplier.get(), t)) == accumulator.accept(r, t)</li>\n</ol>\n<h1>Optional</h1>\n<h1>概念</h1>\n<p>Optional 类(java.util.Optional) 是一个容器类， 代表一个值存在或不存在，原来用 null 表示一个值不存在， 现在 Optional 可以更好的表达这个概念。 并且可以避免空指针异常。</p>\n<p>相信很多人会好奇Optional 是怎么避免空指针异常的吧，这在“举例”中会详细分析，大体解决思路就是在空指针异常前，在获取对象的时候就会判断是否为空，没有创建默认选项的话，会提前报错，从而在空指针发生前提示，方便定位空指针发生的位置，从而让开发者不必再debug去找问题。</p>\n<h1>常用方法</h1>\n<ol>\n<li>Optional.of(T t) : 创建一个 Optional 实例</li>\n<li>Optional.empty() : 创建一个空的 Optional 实例</li>\n<li>Optional.ofNullable(T t):若 t 不为 null,创建 Optional 实例,否则创建空实例</li>\n<li>isPresent() : 判断是否包含值</li>\n<li>orElse(T t) : 如果调用对象包含值， 返回该值， 否则返回t</li>\n<li>orElseGet(Supplier s) :如果调用对象包含值， 返回该值， 否则返回 s 获取的值</li>\n<li>map(Function f): 如果有值对其处理， 并返回处理后的Optional， 否则返回Optional.empty()</li>\n<li>flatMap(Function mapper):与 map 类似， 要求返回值必须是Optional</li>\n</ol>\n<h1>举例</h1>\n<p>创建一个Book对象：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Book &#123;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    private int page;</span><br><span class=\"line\">    private Type type;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Book() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Book(String name, int page, Type type) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        this.page = page;</span><br><span class=\"line\">        this.type = type;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String toString() &#123;</span><br><span class=\"line\">        return &quot;Book&#123;&quot; +</span><br><span class=\"line\">                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +</span><br><span class=\"line\">                &quot;, page=&quot; + page +</span><br><span class=\"line\">                &quot;, type=&quot; + type +</span><br><span class=\"line\">                &#x27;&#125;&#x27;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean equals(Object o) &#123;</span><br><span class=\"line\">        if (this == o) return true;</span><br><span class=\"line\">        if (o == null || getClass() != o.getClass()) return false;</span><br><span class=\"line\">        Book book = (Book) o;</span><br><span class=\"line\">        return page == book.page &amp;&amp; Objects.equals(name, book.name) &amp;&amp; type == book.type;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public int hashCode() &#123;</span><br><span class=\"line\">        return Objects.hash(name, page, type);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getName() &#123;</span><br><span class=\"line\">        return name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setName(String name) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int getPage() &#123;</span><br><span class=\"line\">        return page;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setPage(int page) &#123;</span><br><span class=\"line\">        this.page = page;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Type getType() &#123;</span><br><span class=\"line\">        return type;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setType(Type type) &#123;</span><br><span class=\"line\">        this.type = type;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"获取时异常\">获取时异常</h2>\n<p>由于在获取Book对象是，是null的，所以直接报错，方便开发者定位到空值的位置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        Optional&lt;Book&gt; empty = Optional.empty();</span><br><span class=\"line\">        empty.get();</span><br><span class=\"line\">java.util.NoSuchElementException: No value present</span><br><span class=\"line\">    at java.util.Optional.get(Optional.java:135)</span><br><span class=\"line\">    at com.atguigu.spring5.test.TestOptional.test1(TestOptional.java:11)</span><br></pre></td></tr></table></figure>\n<h2 id=\"一般使用默认值填充\">一般使用默认值填充</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        Optional&lt;Book&gt; empty = Optional.empty();</span><br><span class=\"line\">        Book book = empty.orElseGet(() -&gt; new Book(&quot;java&quot;,100,Type.STUDY));</span><br><span class=\"line\">        System.out.println(book);</span><br><span class=\"line\">Book&#123;name=&#x27;java&#x27;, page=100, type=STUDY&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"三种创建方式\">三种创建方式</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Optional&lt;Book&gt; option1 = Optional.empty();</span><br><span class=\"line\">Optional&lt;Book&gt; option2 = Optional.of(new Book());</span><br><span class=\"line\">Optional&lt;Object&gt; option3 = Optional.ofNullable(null);</span><br><span class=\"line\">Optional&lt;Book&gt; book = Optional.ofNullable(new Book());</span><br></pre></td></tr></table></figure>\n<h2 id=\"map方法\">map方法</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        Optional&lt;Book&gt; option1 = Optional.empty();</span><br><span class=\"line\">        Optional&lt;Book&gt; option2 = Optional.of(new Book(&quot;java&quot;,100,Type.STUDY));</span><br><span class=\"line\"></span><br><span class=\"line\">        Optional&lt;String&gt; s1 = option1.map(Book::getName);</span><br><span class=\"line\">        Optional&lt;String&gt; s2 = option2.map(Book::getName);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(s1);</span><br><span class=\"line\">        System.out.println(s2.get());</span><br><span class=\"line\">Optional.empty</span><br><span class=\"line\">java</span><br></pre></td></tr></table></figure>\n<h1>方法引用</h1>\n<p>方法引用有如下三种格式</p>\n<ul>\n<li>对象::实例方法</li>\n<li>类::静态方法</li>\n<li>类::实例方法</li>\n</ul>\n<h2 id=\"对象-实例方法\">对象::实例方法</h2>\n<ul>\n<li>作用：调用某个对象的某个具体实例方法</li>\n<li>注意：实现抽象方法的参数列表， 必须与方法引用方法的参数列表保持一致！</li>\n<li>格式：使用操作符 “::” 将方法名和对象名字分隔开来。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void test2() &#123;</span><br><span class=\"line\">    Consumer&lt;String&gt; con1 = (x) -&gt; System.out.println(x);</span><br><span class=\"line\">    con1.accept(&quot;con1&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    Consumer&lt;String&gt; con2 = System.out::println;</span><br><span class=\"line\">    con2.accept(&quot;con2&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"类-静态方法\">类::静态方法</h2>\n<p>这里与对象::实例方法基本一致，用于引用类的静态方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void test3() &#123;</span><br><span class=\"line\">    Comparator&lt;Integer&gt; com1 = (o1, o2) -&gt; Integer.compare(o1, o2);</span><br><span class=\"line\">    Comparator&lt;Integer&gt; com2 = Integer::compare;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"类-实例方法\">类::实例方法</h2>\n<p>对于这个格式，我之前刚看见的时候觉得有点奇怪，其实这个格式中的参数列表与前两个方法不一样，这种格式用于引用第一个对象的方法，将后面的对象作为方法的参数列表。</p>\n<p>具体如下所示，&quot;::“前面是第一个对象的类，”::&quot;后面为对象的实例方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void test4() &#123;</span><br><span class=\"line\">    BiPredicate&lt;String, String&gt; bp1 = (o1, o2) -&gt; o1.equals(o2);</span><br><span class=\"line\">    BiPredicate&lt;String, String&gt; bp2 = String::equals;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1>构造器引用</h1>\n<ul>\n<li>格式： ClassName::new</li>\n<li>注意：可以把有参构造器引用赋值给定义的方法， 与构造器参数列表要与接口中抽象方法的参数列表一致！</li>\n</ul>\n<p>这个例子中，分别使用了无参构造和有参构造，有参构造在调用接口实例化方法时传参。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void test5() &#123;</span><br><span class=\"line\">    Supplier&lt;String&gt; sup1 = () -&gt; new String(&quot;aaa&quot;);</span><br><span class=\"line\">    Supplier&lt;String&gt; sup2 = String::new;</span><br><span class=\"line\">    Function&lt;byte[], String&gt; fun = String::new;</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(sup1.get());</span><br><span class=\"line\">    System.out.println(sup2.get());</span><br><span class=\"line\">    byte[] byteArr = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;;</span><br><span class=\"line\">    System.out.println(fun.apply(byteArr));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aaa</span><br><span class=\"line\"></span><br><span class=\"line\">abc</span><br></pre></td></tr></table></figure>\n<h1>数组引用</h1>\n<p>数组引用与构造器引用基本一致</p>\n<ul>\n<li>格式： type[] :: new</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void test6()&#123;</span><br><span class=\"line\">    Function&lt;Integer, String[]&gt; fun1 = (x) -&gt; new String[x];</span><br><span class=\"line\">    Function&lt;Integer, String[]&gt; fun2 = String[]::new;</span><br><span class=\"line\"></span><br><span class=\"line\">    String[] apply1 = fun1.apply(10);</span><br><span class=\"line\">    String[] apply2 = fun2.apply(100);</span><br><span class=\"line\">    System.out.println(apply1.length);</span><br><span class=\"line\">    System.out.println(apply2.length);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10</span><br><span class=\"line\">100</span><br></pre></td></tr></table></figure>\n","_path":"post/330a6169.html","_link":"http://rycan.top/post/330a6169.html","_id":"cloioo9ea004yni0p28ef8sde"}}