{"type":"getPostByPath","data":{"title":"redis 源码","date":"2023-07-03T08:52:37.000Z","description":"redis的底层数据结构与源码(未读)","categories":[{"name":"redis","_id":"clkuj1jyf001o370pcflydjud"}],"tags":[{"name":"redis","_id":"clkuj1jyi002p370p6mqbdzcz"}],"content":"<meta name=\"referrer\" content=\"no-referrer\">\n<h2 id=\"redis数据结构\">redis数据结构</h2>\n<h3 id=\"redis6-数据结构\">redis6 数据结构</h3>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202307031648466.png\" alt=\"image-20230526172020470\" style=\"zoom:33%;\">\n<h3 id=\"redis7-数据结构\">redis7    数据结构</h3>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202307031648946.png\" alt=\"image-20230526171836200\" style=\"zoom:33%;\">\n<h3 id=\"时间复杂度\">时间复杂度</h3>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202307031648219.png\" alt=\"image-20230526172050397\" style=\"zoom:25%;\">\n<h2 id=\"底层数据结构种类\">底层数据结构种类</h2>\n<h3 id=\"动态字符串\">动态字符串</h3>\n<ul>\n<li>获取字符串长度的时间复杂度为O(1)</li>\n<li>支持动态扩容</li>\n<li>减少内存分配次数</li>\n<li>二进制安全</li>\n</ul>\n<h3 id=\"intset\">intset</h3>\n<ul>\n<li>Redis会确保Intset中的元素唯一、有序</li>\n<li>具备类型升级机制，可以节省内存空间</li>\n<li>底层采用二分查找方式来查询</li>\n</ul>\n<h3 id=\"Dict\">Dict</h3>\n<p>键与值的映射关系正是通过Dict来实现的</p>\n<p>Dict由三部分组成，分别是：哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）</p>\n<p>Dict的伸缩：</p>\n<ul>\n<li>当LoadFactor大于5或者LoadFactor大于1并且没有子进程任务时，Dict扩容</li>\n<li>当LoadFactor小于0.1时，Dict收缩</li>\n<li>扩容大小为第一个大于等于used + 1的2^n</li>\n<li>收缩大小为第一个大于等于used 的2^n</li>\n<li>Dict采用渐进式rehash，每次访问Dict时执行一次rehash</li>\n<li>rehash时ht[0]只减不增，新增操作只在ht[1]执行，其它操作在两个哈希表</li>\n</ul>\n<h3 id=\"ZipList\">ZipList</h3>\n<p>一种特殊的“双端链表” ,由一系列特殊编码的连续内存块组成。可以在任意一端进行压入/弹出操作, 并且该操作的时间复杂度为 O(1)。</p>\n<p><strong>ZipList特性：</strong></p>\n<ul>\n<li>压缩列表的可以看做一种连续内存空间的&quot;双向链表&quot;</li>\n<li>列表的节点之间不是通过指针连接，而是记录上一节点和本节点长度来寻址，内存占用较低</li>\n<li>如果列表数据过多，导致链表过长，可能影响查询性能</li>\n<li>增或删较大数据时有可能发生连续更新问题</li>\n</ul>\n<h3 id=\"QuickList\">QuickList</h3>\n<p>问题1：ZipList虽然节省内存，但申请内存必须是连续空间，如果内存占用较多，申请内存效率很低。怎么办？</p>\n<p>​\t答：为了缓解这个问题，我们必须限制ZipList的长度和entry大小。</p>\n<p>问题2：但是我们要存储大量数据，超出了ZipList最佳的上限该怎么办？</p>\n<p>​\t答：我们可以创建多个ZipList来分片存储数据。</p>\n<p>问题3：数据拆分后比较分散，不方便管理和查找，这多个ZipList如何建立联系？</p>\n<p>​\t答：Redis在3.2版本引入了新的数据结构QuickList，它是一个双端链表，只不过链表中的每个节点都是一个ZipList。</p>\n<p>特点</p>\n<ul>\n<li>是一个节点为ZipList的双端链表</li>\n<li>节点采用ZipList，解决了传统链表的内存占用问题</li>\n<li>控制了ZipList大小，解决连续内存空间申请效率问题</li>\n<li>中间节点可以压缩，进一步节省了内存</li>\n</ul>\n<h3 id=\"SkipList\">SkipList</h3>\n<p><code>SkipList</code>（跳表）首先是链表，但与传统链表相比有几点差异：</p>\n<ul>\n<li>元素按照升序排列存储</li>\n<li>节点可能包含多个指针，指针跨度不同。</li>\n</ul>\n<p><code>SkipList</code>的特点：</p>\n<ul>\n<li>跳跃表是一个双向链表，每个节点都包含score和ele值</li>\n<li>节点按照score值排序，score值一样则按照ele字典排序</li>\n<li>每个节点都可以包含多层指针，层数是1到32之间的随机数</li>\n<li>不同层指针到下一个节点的跨度不同，层级越高，跨度越大</li>\n<li>增删改查效率与红黑树基本一致，实现却更简单</li>\n</ul>\n<h3 id=\"RedisObject\">RedisObject</h3>\n<p>Redis中的任意数据类型的键和值都会被封装为一个<code>RedisObject</code>，也叫做Redis对象</p>\n<h2 id=\"源码级别\">源码级别</h2>\n<blockquote>\n<p>WILLDO</p>\n</blockquote>\n","_path":"post/e8b61f90.html","_link":"http://rycan.top/post/e8b61f90.html","_id":"clkuj1jyq0045370pc103h4r2"}}