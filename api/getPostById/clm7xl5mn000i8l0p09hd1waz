{"type":"getPostById","data":{"title":"MySQL调优与优化","date":"2023-07-02T08:43:47.000Z","description":"MySQL调优与优化","categories":[{"name":"MySQL","_id":"clm7xl5mo000s8l0pfmwkefq0"}],"tags":[{"name":"MySQL","_id":"clm7xl5mo000t8l0p5hgx5208"}],"content":"<h2 id=\"性能分析工具的使用思路\">性能分析工具的使用思路</h2>\n<ul>\n<li>先观察服务器状态，进行判断是否<code>存在周期性波动</code>&lt;比如双十一、各种促销活动&gt;\n<ul>\n<li>存在周期性波动,==就加大缓存，更改缓存失效策略==</li>\n</ul>\n</li>\n<li>不存在周期性波动 或者 缓存失效的策略即使更改了依旧无法解决，分析 <code>仍然出现不规则的延迟或者卡顿</code>的现象出现的原因\n<ul>\n<li>==开启慢查询==\n<ul>\n<li>目的是  ： 定位执行慢的<code>sql</code>语句,设置慢的阈值，设置的参数就是<code>long_query_time</code>,一旦<code>SQL</code>执行时间超过了所设定的阈值，那么就认为是慢查询。当收集上来这些慢查询之后，我们就可以通过<code>分析工具</code>对<code>慢查询日志</code>进行分析。</li>\n</ul>\n</li>\n<li>对于<code>执行慢的SQL语句</code>，我们可以使用==EXPLAIN==语句查询执行计划，或者使用==show profile==查看SQL中<code>每一个步骤的时间成本</code>，从而判断是==执行时间长==还是==等待的时间长==\n<ul>\n<li>对于 <code>等待的时间长</code> ，可以==调优服务器的参数== &lt;比如适当增加数据库缓冲池等&gt;</li>\n<li>对于 <code>执行的时间长</code>， ==考虑是不是索引的问题，是不是关联查询的数据表过多的问题，是不是数据库的某一个字段设计的不合理导致的==，并针对性的进行调优</li>\n<li>从上述的两个方向去 查看是否能够解决<code>延迟卡顿</code>的问题</li>\n</ul>\n</li>\n<li>要是 <code>参数调优 </code>和  <code>上述优化思路</code>都无法进行解决的话，考虑的角度就应该应该是==数据库自身的SQL查询性能是否已经达到了瓶颈==\n<ul>\n<li>要是没有的话就进行反复检查，重复上述的步骤</li>\n<li>已经达到瓶颈的话就进行<code>增加服务器的数量</code>，进行<code>读写分离的主从架构 或者 对数据库进行分库分表(垂直分库、水平分表、水平分库)</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>注意：</p>\n<ul>\n<li>对于数据库的延时卡顿的现象我们可以进行分析工具帮助我们定位有问题的语句，常见的<code>三种工具</code>：\n<ul>\n<li>慢查询：主要帮助我们发现<code>执行时间特别长</code>的SQL查询，针对性的优化，从而提高整体的效率，一般默认不开启，需要手动开启此参数；</li>\n<li>分析查询语句<code>Explain</code>： 定位了查询慢的SQL之后，我们就可以使用<code>EXPLAIN</code>或<code>DESCRIBE</code>工具做针对性的分析查询语句，两者的语法和分析结果都是一样的，主要作用是 表和数据的读取，索引的使用、表之间的引用等</li>\n<li>分析优化器的执行计划：<code>trace</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"数据库调优\">数据库调优</h2>\n<h3 id=\"目标\">目标:</h3>\n<ul>\n<li>尽可能节省系统资源 ，以便系统可以<code>提供更大负荷的服务</code>。（吞吐量更大）</li>\n<li>合理的结构设计和参数调整，以<code>提高用户操作响应的速度</code> 。（响应速度更快）</li>\n<li>减少系统的瓶颈，提高<code>MySQL</code>数据库整体的性能。</li>\n</ul>\n<h3 id=\"方向：\">方向：</h3>\n<ul>\n<li>索引失效、没有充分利用到索引——<code>建立索引</code></li>\n<li>关联查询太多JOIN（设计缺陷或不得已的需求）——<code>SQL优化</code></li>\n<li>服务器调优及各个参数设置（缓冲、线程数等）——<code>调整my.cnf</code></li>\n<li>数据过多——<code>分库分表</code></li>\n</ul>\n<h3 id=\"调优的角度\">调优的角度:</h3>\n<h4 id=\"优化sql参数配置和相关的服务器硬件\">优化sql参数配置和相关的服务器硬件</h4>\n<h4 id=\"优化数据库结构\">优化数据库结构</h4>\n<ul>\n<li>\n<p><code>拆分表：冷热数据分离</code></p>\n<ul>\n<li>\n<p>拆分表的思路是: 把1个包含很多字段的表拆分成2个或者多个相对较小的表。<code>冷热数据分离</code>的目的是：</p>\n<p>①<code>减少磁盘IO</code>,保证<code>热数据</code>的内存缓存命中率。</p>\n<p>②<code>更有效的利用缓存</code>，避免读入无用的冷数据。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><code>增加中间表</code></p>\n<ul>\n<li>对于需要经常联合查询的表，可以建立中间表以提高查询效率。</li>\n<li>通过建立中间表，把需要经常联合查询的数据插入中间表中，然后将原来的<code>联合查询</code> <code>改为</code> 对<code>中间表</code>的查询，以此来提高查询效率。</li>\n<li>做法:\n<ul>\n<li>首先，分析经常联合查询表中的字段；</li>\n<li>然后，使用这些字段建立一个中间表，并将原来联合查询的表的数据插入中间表中；</li>\n<li>最后，使用中间表来进行查询。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><code>增加冗余字段</code></p>\n</li>\n<li>\n<p><code>优化数据类型</code>   ： 优先选择符合存储需要的<code>最小的数据类型</code></p>\n</li>\n<li>\n<p><code>优化插入记录的速度</code></p>\n<ul>\n<li>\n<p><code>MyISAM</code>引擎的表的实现方式</p>\n<p><strong>① 禁用索引</strong></p>\n<p><strong>② 禁用唯一性检查</strong></p>\n<p><strong>③ 使用批量插入</strong></p>\n<p><strong>④ 使用LOAD DATA INFILE 批量导入</strong></p>\n</li>\n<li>\n<p><code>InnoDB</code>引擎的表的实现方式</p>\n<p><strong>① 禁用唯一性检查</strong></p>\n<p><strong>② 禁用外键检查</strong></p>\n<p><strong>③ 禁止自动提交</strong></p>\n</li>\n</ul>\n</li>\n<li>\n<p><code>使用非空约束</code></p>\n</li>\n</ul>\n<h4 id=\"大表的优化\">大表的优化</h4>\n<ul>\n<li><code>限定查询的范围 </code>\n<ul>\n<li>禁止不带任何限制数据范围条件的查询语句</li>\n</ul>\n</li>\n<li><code>读/写分离  ： 主库负责写，从库负责读</code>\n<ul>\n<li>\n<p>垂直拆分 :当数据量级达到 <code>千万级</code> 以上时，有时候我们需要把一个数据库切成多份，放到不同的数据库服务器上，减少对单一数据库服务器的访问压力。</p>\n<ul>\n<li>\n<p>如果数据库的数据<code>表过多</code>，可以采用<code>垂直分库</code>的方式，将关联的数据库部署在同一个数据库上。</p>\n</li>\n<li>\n<p>如果数据库中的<code>列过多</code>，可以采用<code>垂直分表</code>的方式，将一张数据表分拆成多张数据表，把经常一起使用的列放在同一张表里。</p>\n</li>\n<li>\n<p><code>垂直拆分的优点</code>： 可以使得列数据变小，在查询时减少读取的<code>Block数，减少I/O次数</code>。此外，垂直分区可以简化表的结构，易于维护。</p>\n</li>\n<li>\n<p><code>垂直拆分的缺点</code>： 主键会出现冗余，需要管理冗余列，并会引起 JOIN 操作。此外，垂直拆分会让事务变得更加复杂。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>水平拆分</p>\n<ul>\n<li>尽量控制单表数据量的大小，建议控制在<code>千万级别</code>以内。</li>\n<li>这里我们主要考虑业务数据的<code>水平分表</code>策略。将大的数据表按照某个属性维度分拆成不同的小表，每张小表保持相同的表结构。比如你可以按照年份来划分，把不同年份的数据放到不同的数据表中。</li>\n<li>水平分表仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以<code>水平拆分最好分库</code>，从而达到分布式的目的。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"查询优化\">查询优化</h4>\n<ul>\n<li>\n<p>逻辑查询优化</p>\n<ul>\n<li>使用更高效的<code>sql</code>语句进行等价代替</li>\n</ul>\n</li>\n<li>\n<p>物理查询优化</p>\n<ul>\n<li>\n<p>使用<code>索引</code>减少执行的代价</p>\n</li>\n<li>\n<p>使用<code>缓存技术</code></p>\n</li>\n<li>\n<p>使用<code>读写分离 和 数据分片&lt;垂直分库和水平分表&gt;</code></p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"索引的优化\">索引的优化</h4>\n<h5 id=\"何时失效\">何时失效</h5>\n<ul>\n<li>全值匹配   <code>select * </code></li>\n<li>联合索引不遵循 <code>最佳左前缀法则</code></li>\n<li><code>字符串不加单引号</code>，造成索引失效。</li>\n<li><code>计算、函数、类型转换</code>(自动或手动)导致索引失效</li>\n<li>范围查询条件<code>【(&lt;) (&lt;=) (&gt;) (&gt;=) 和 between 等】右边的列</code>索引失效</li>\n<li><code>不等于(!= 或者&lt;&gt;)索引</code>失效</li>\n<li><code>is null可以</code>使用索引，<code>is not null无法</code>使用索引</li>\n<li>like以通配符<code>%开头</code>索引失效</li>\n<li><code>OR 前后</code>存在非索引的列，索引失效\n<ul>\n<li>因为OR的含义就是两个只要满足一个即可，因此<code>只有一个条件列进行了索引是没有意义的</code>，只要有条件列没有进行索引，就会进行<code>全表扫描</code>，因此所以的条件列也会失效</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"使用索引进行查询时候优化的角度\">使用索引进行查询时候优化的角度</h5>\n<ul>\n<li>关联查询\n<ul>\n<li>参与</li>\n<li><code>join</code>字段已经创建了索引</li>\n<li>参与<code>join</code>字段的数据类型需要保持绝对的一致</li>\n<li>在使用<code>left join</code> 的时候使用<code>小表为驱动表</code>，<code>大表为被驱动表</code>，从而减少外层循环的次数</li>\n<li>使用<code>INNER JOIN</code> 时，MySQL会自动将 小结果集的表选为驱动表 。选择相信MySQL优化策略。</li>\n<li>能够直接多表关联的尽量直接关联，不用子查询。(减少查询的趟数)</li>\n</ul>\n</li>\n<li>子查询\n<ul>\n<li>可以使用连接（JOIN）查询来替代子查询\n<ul>\n<li>连接查询 <code>不需要建立临时表</code> ，其 <code>速度比子查询</code> 要快 ，如果查询中使用索引的话，性能就会更好。</li>\n</ul>\n</li>\n<li>尽量<code>不要</code>使用<code>NOT IN</code>或者<code>NOT EXISTS</code>，用<code>LEFT JOIN xxx ON xx WHERE xx IS NULL</code>替代</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<details>\n    <summary>展开查看 子查询为什么速度比较慢</summary> \n<pre>\n① 执行子查询时，MYSQL需要为内层查询语句的查询结果 建立一个临时表 ，然后外层查询语句从临时表中查询记录。查询完毕后，再撤销这些临时表 。这样会消耗过多的CPU和IO资源，产生大量的慢查询。\n② 子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都不会存在索引 ，所以查询性能会受到一定的影响。\n③ 对于返回结果集比较大的子查询，其对查询性能的影响也就越大。\n</pre>\n</details>\n</blockquote>\n<ul>\n<li>分页查询\n<ul>\n<li>在<code>索引上</code>完成<code>排序分页操作</code>，最后根据<code>主键</code>关联<code>回原表</code>查询所需要的其他列内容</li>\n<li>适用于主键自增的表，可以把<code>Limit </code>查询转换成某个位置的查询</li>\n</ul>\n</li>\n<li>使用索引\n<ul>\n<li>优先考虑覆盖索引</li>\n<li>在<code>where</code> 字段和<code>Order by</code>字段都要加上索引</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<details>\n    <summary>展开查看： 覆盖索引</summary> \n  <pre> \n1.是什么：一个索引包含了满足查询结果的数据就叫做覆盖索引\n2.优点：\n\t可避免`Innodb表`索引的二次查询，因为在 覆盖索引中，二级索引的键值中可以获取所要的数据，避免了对主键的二次查询，减少了I0操作，所以提升了查询效率。\n\t可以把随机IO 变化为顺序IO ,也可以加快查询效率，由于覆盖索引是按键值的顺序存储的，对于I0密集型的范围查找来说，对比随机从磁盘读取每一行的数据I0要少的多\n3.缺点：\n\t索引字段的维护是有一定的代价的\n    </pre> \n</details> \n</blockquote>\n<blockquote>\n<details>\n    <summary>展开查看： 为什么OrderBy字段也要加上索引</summary> \n   <pre>\n在MySQL中，支持两种排序方式，分别是 `FileSort` 和 `Index` 排序\n① 在 Index 排序中，索引可以保证数据的有序性，不需要再进行排序，`效率更高`\n② 在 FileSort 排序则一般在 `内存中` 进行排序，占用`CPU较多`。如果待排结果较大，会产生临时文件 I/O 到磁盘进行排序的情况，效率较低\n所以就是说：在`Order by` 中使用索引时要尽量避免使用`FileSort`排序；尽量使用 `Index` 完成 `ORDER BY` 排序，。如果 `WHERE` 和` ORDER BY `后面是相同的列就使用`单列索引`； 如果不同就使用`联合索引`。 \n   </pre> \n</details>\n</blockquote>\n<h4 id=\"设计\">设计</h4>\n<h5 id=\"数据库的设计\">数据库的设计</h5>\n<ul>\n<li>遵循三范式原则</li>\n<li>适当的使用反范式</li>\n<li>对于表的字段类型的设计要谨慎考虑</li>\n</ul>\n<blockquote>\n<details>\n    <summary>展开查看： 范式与反范式</summary> \n    <pre>\n范式：\n①第一范式 ： 主要确保数据库中每个字段的值必须具有`原子性`，也就是说数据表中每个字段的值为`不可再次拆分`的最小数据单元。\n②第二范式： 在满足第一范式的基础上，还要**满足数据库里的每一条数据记录，都是可唯一标识的。而且所有非主键字段，都必须完全依赖主键，不能只依赖主键的一部分**。第二范式（2NF）要求实体的属性完全依赖主关键字。\n③第三范式：  在第二范式的基础上，确保数据表中的每一个非主键字段都和主键字段直接相关，也就是说，**要求数据表中的所有非主键字段不能依赖于其他非主键字段**。（即，不能存在非主属性A依赖于非主属性B，非主属性B依赖于主键C的情况，即存在“A->B->C\"的决定关系）通俗地讲，该规则的意思是所有`非主键属性`之间不能由依赖关系，必须`相互独立`。\n④BCNF(巴斯范式)： 若一个关系达到了第三范式，并且它只有一个候选键，或者它的每个候选键都是单属性，则该关系自然达到BC范式。\n⑤第四范式 ： 在满足巴斯 - 科德范式（BCNF）的基础上，消除非平凡且非函数依赖的多值依赖（即把同一表的多对多关系删除）。\n所谓的三范式原则说的就是`①②③`\n反范式:\n- 优点\n  可以通过在数据表中增加`冗余字段`来`提高数据库的读性能`\n- 缺点：\n  存储 空间变大了\n  一个表中字段做了修改，另一个表中冗余的字段也需要做同步修改，否则数据不一致\n  若采用存储过程来支持数据的更新、删除等额外操作，如果更新频繁，会非常消耗系统资源\n  在 数据量小 的情况下，反范式不能体现性能的优势，可能还会让数据库的设计更加复杂\n- 使用场景:\n  当冗余信息有价值或者能 `大幅度提高查询效率` 的时候\n</pre>\n</details>\n</blockquote>\n<h5 id=\"表的设计\">表的设计</h5>\n<ul>\n<li>数据<code>表的个数</code>越少越好</li>\n<li>数据表中的<code>字段个数</code>越少越好</li>\n<li>数据表中<code>联合主键</code>的字段个数越少越好</li>\n<li>使用<code>主键和外键</code>越多越好</li>\n</ul>\n<h2 id=\"实例场景\">实例场景</h2>\n<ul>\n<li>\n<p>TB的订单号的设计策略：<code>订单ID = 时间+ 去重字段+ UserId后6位</code></p>\n</li>\n<li>\n<p><code>自增ID</code>的问题</p>\n<ul>\n<li>可靠性： 存在自增ID回溯的问题</li>\n<li>安全性：对外暴露的接口可以非常容易猜测对应的信息。</li>\n<li>性能差：自增ID的性能较差，需要在数据库服务器端生成。</li>\n<li>交互多：业务还需要额外执行一次类似 <code>last_insert_id() </code>的函数才能知道刚才插入的自增值，这需要多一次的网络交互。在海量并发的系统中，多1条SQL，就多一次性能上的开销。</li>\n<li>局部唯一性：自增ID是局部唯一，只在当前数据库实例中唯一，而<code>不是全局唯一</code>，也不是在任意服务器间都 是唯一的。所以对于分布式系统不适用</li>\n</ul>\n</li>\n<li>\n<p>主键的设计的一种简单的策略</p>\n<ul>\n<li>使用<code>UUID</code>😗*其特点：**全局唯一，占用36字节，数据无序，插入性能差。</li>\n</ul>\n</li>\n</ul>\n","_path":"post/917a6f4c.html","_link":"http://rycan.top/post/917a6f4c.html","_id":"clm7xl5mn000i8l0p09hd1waz"}}