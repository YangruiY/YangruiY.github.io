{"type":"getPostById","data":{"title":"深入理解 redis总和","date":"2023-07-03T12:09:40.000Z","description":"合集","categories":[{"name":"redis","_id":"clm7xl5mw001o8l0phwdf3hxw"}],"tags":[{"name":"redis","_id":"clm7xl5n4003b8l0pfjxpbrn0"}],"content":"<meta name=\"referrer\" content=\"no-referrer\">\n<h2 id=\"基础概念\">基础概念</h2>\n<blockquote>\n<p>关系型VS非关系型</p>\n</blockquote>\n<ul>\n<li>存储方式\n<ul>\n<li>关系型数据库基于磁盘进行存储，会有大量的磁盘IO，对性能有一定影响</li>\n<li>非关系型数据库，他们的操作更多的是依赖于内存来操作，内存的读写速度会非常快，性能自然会好一些</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>扩展性\n<ul>\n<li>关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用，称为垂直扩展。</li>\n<li>非关系型数据库可以将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题。称为水平扩展。</li>\n<li>关系型数据库因为表之间存在关联关系，如果做水平扩展会给数据查询带来很多麻烦</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>redis</p>\n</blockquote>\n<ul>\n<li>是一个基于内存的键值型<code>NoSQL</code>数据库。</li>\n</ul>\n<p><strong>能干什么</strong></p>\n<ul>\n<li>\n<p>缓存</p>\n<blockquote>\n<p>Redis常用于作为高速缓存，将常用的数据存储在内存中，提高访问速度和响应时间，减轻后端数据库的压力。Redis支持多种数据结构，可以根据数据的类型和特点选择合适的数据结构进行缓存。</p>\n</blockquote>\n</li>\n<li>\n<p><code>RDB</code>和<code>AOF</code>持久化</p>\n<blockquote>\n<p>redis<code>支持异步</code>将<code>内存</code>中的数据写到硬盘上，同时不影响继续服务。</p>\n<p>即使设备断电了，数据也不会丢失，重启后重新<code>从硬盘恢复</code>数据。</p>\n</blockquote>\n</li>\n<li>\n<p>高可用架构搭配：单机、主从、哨兵、集群</p>\n<blockquote>\n<p>支持大规模数据存储和高并发访问。</p>\n</blockquote>\n</li>\n<li>\n<p>解决缓存穿透、击穿、雪崩</p>\n<blockquote>\n<ol>\n<li>对查询不存在的数据的请求进行过滤，比如采用<code>Bloom Filter</code>进行<code>缓存预热或者对查询请求</code>进行<code>缓存穿透</code>保护。</li>\n<li>对于热点数据的访问，可以采用<code>分布式锁</code>等方法对缓存进行保护，避免<code>缓存击穿</code>。</li>\n<li>对于<code>缓存雪崩</code>，可以采用<code>缓存预热、缓存过期时间随机化、缓存数据的多级缓存</code>等方法进行缓解。</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>分布式锁</p>\n<blockquote>\n<p>Redis支持原子操作和过期时间等特性，可以用于实现分布式锁。</p>\n<p>可以保证在分布式系统中同一时刻只有一个客户端可以持有锁，从而保证共享资源的互斥访问。</p>\n<p>例如，可以使用Redis的SETNX命令实现基于key的锁，使用Lua脚本实现基于value的锁。</p>\n</blockquote>\n</li>\n<li>\n<p>消息队列</p>\n<blockquote>\n<p>redis提供了多种队列模式：List队列、Pub/Sub队列、Stream队列</p>\n</blockquote>\n</li>\n<li>\n<p>计数器和排行榜</p>\n<blockquote>\n<p>Redis支持原子操作，可以用于实现计数器和排行榜功能。</p>\n<p>例如，可以使用Redis的INCR命令实现计数器功能，使用ZADD命令实现有序集合排行榜功能。</p>\n</blockquote>\n</li>\n</ul>\n<p>除了以上几个方面，Redis还可以用于实现<code>限流、地理位置服务、实时统计</code>等应用场景。</p>\n<p>总之，Redis是一个功能丰富、性能优秀的内存数据库，适合于需要高性能、高可用(集群、主从、哨兵、集群)、高并发的应用场景。</p>\n<p><strong>特征</strong>：</p>\n<ul>\n<li>键值（key-value）型，value支持多种不同数据结构，功能丰富</li>\n<li>单线程，每个命令具备原子性</li>\n<li>低延迟，速度快（基于内存、IO多路复用、良好的编码）。</li>\n<li>支持数据持久化</li>\n<li>支持主从集群、分片集群</li>\n<li>支持多语言客户端</li>\n</ul>\n<p><strong>优势</strong></p>\n<ul>\n<li>性能极高 -Redis能读的速度是110000次/秒，写的速度是81000次/秒</li>\n<li>Redis数据类型丰富，不仅仅支持简单的key-value类型的数据，同时还提供list，zset，set，hash等数据结构的存储</li>\n<li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用</li>\n<li>Redis支持数据的备份，即master-slave模式的数据备份</li>\n</ul>\n<h2 id=\"基本数据类型\">基本数据类型</h2>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305242035738.png\" alt></p>\n<blockquote>\n<p>String</p>\n</blockquote>\n<p>String类型，也就是字符串类型，是Redis中最简单的存储类型。</p>\n<p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p>\n<ul>\n<li>string：普通字符串</li>\n<li>int：整数类型，可以做自增、自减操作</li>\n<li>float：浮点类型，可以做自增、自减操作</li>\n</ul>\n<p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m.</p>\n<blockquote>\n<p>Hash</p>\n</blockquote>\n<p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p>\n<p>K-V模式不变，但v又是一个键值对：Map&lt;key,Map&lt;key,value&gt;&gt;</p>\n<ul>\n<li>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便</li>\n<li>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD</li>\n</ul>\n<blockquote>\n<p>List    <strong>列表</strong></p>\n</blockquote>\n<p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p>\n<p>特征也与LinkedList类似：</p>\n<ul>\n<li>有序</li>\n<li>元素可以重复</li>\n<li>插入和删除快</li>\n<li>查询速度一般</li>\n</ul>\n<p>Redis的List类型是一个单Key多Value的集合，其value值是有序可重复的。</p>\n<p><em>如果键不存在，创建新的链表；</em></p>\n<p><em>如果键已存在，新增内容，可重复；</em></p>\n<p><em>如果值全移除，对应的键也就消失了。</em></p>\n<p>常用来存储一个有序数据，例如：<code>朋友圈点赞列表，评论列表</code>等。</p>\n<blockquote>\n<p>set</p>\n</blockquote>\n<p>Redis的Set结构与Java中的HashSet类似，它内部键值对是无序的、唯一的。它的内部实现相当于一个特殊的字典，字典中所有的value都是一个值NULL，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p>\n<ul>\n<li>无序</li>\n<li>元素不可重复</li>\n<li>查找快</li>\n<li>支持交集、并集、差集等功能</li>\n</ul>\n<p>应用场景：</p>\n<ul>\n<li>微信抽奖小程序。（SRANDMEMBER）</li>\n<li>微信朋友圈共友点赞。（SINTER）</li>\n<li>QQ推荐可能认识的人。（SDIFF）</li>\n</ul>\n<blockquote>\n<p>SortedSet(ZSet)</p>\n</blockquote>\n<p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。</p>\n<p>SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。score的值是一个<em>整型数值或者浮点数值</em>  的数，是可重复的。</p>\n<p>SortedSet具备下列特性：</p>\n<ul>\n<li>可排序</li>\n<li>元素不重复</li>\n<li>查询速度快</li>\n</ul>\n<p>因为SortedSet的可排序特性，经常被用来实现<code>排行榜</code>这样的功能</p>\n<blockquote>\n<p>HyperLogLog  <strong>基数统计</strong></p>\n</blockquote>\n<p>HyperLogLog是一种概率数据结构，用于计数唯一的事物(技术上这是指<code>估计一个集合的基数</code>)。(基数就是一个数据集中去除重复数据后总的个数)</p>\n<p>HyperLogLog的数据类型还是String。在Redis中的HyperLogLog，虽然技术上是不同的数据结构，但被编码为Redis字符串。</p>\n<ul>\n<li>\n<p>在Redis里面每个HyperLogLog键只需要花费12kb内存就可以统计接近2^64个不同元素的基数。</p>\n</li>\n<li>\n<p>HyperLogLog只会根据输入的元素来计算计数，不会存储输入的元素本身，所以HyperLogLog不能像集合那样返回输入的元素。</p>\n</li>\n</ul>\n<p>应用场景:</p>\n<ul>\n<li>网站、文章的uv  (独立访客 要去重考虑)</li>\n<li>网站某关键词的搜索数量</li>\n<li>用户每天搜索的不同词条数目</li>\n</ul>\n<blockquote>\n<p>Bitmap   <strong>位图</strong></p>\n</blockquote>\n<p>用String类型作为底层数据结构实现的一种统计二值状态的数据类型。</p>\n<p>位图本质是数组，该数组由多个二进制位组成，<code>其值只能是1或0</code>，默认0，每个二进制位都对应一个偏移量(我们称之为一个索引)。偏移位从 <code>0</code> 开始</p>\n<p>Bitmap支持的最大位数是2<sup>32</sup>位，它可以极大的节约存储空间，使用512M内存就可以存储多达42.9亿的字节信息。<br>\n(512*1024*1024*8=2<sup>9</sup>*2<sup>10</sup>*2<sup>10</sup>*2<sup>3</sup> = 2<sup>32</sup>)</p>\n<p>一个字节占有8位，若在一个bitmap类型的key中，偏移量(索引)为8的位置存入1，前面7位会默认设置为0，那么该key占用两个字节，因为偏移量为8的那一位属于第二个字节了。</p>\n<blockquote>\n<p>应用使用 ：由于offset值得范围是[0,2<sup>32</sup>-1]，这个数非常大，可以将<u>用户id和偏移量形成映射关系</u>来存储很多二值数据：<br>\n通常先将用户存储到哈希表中，通过field值来标识每一位用户，然后再将field值和偏移量形成映射关系，比如<br>\n<code>HSET user 1 uid1001 2 uid1002</code> ：1代表uid1001，2代表uid1002<br>\n<code>SETBIT sign:Monday 1 1</code>\t偏移量1的位置值为1，偏移量1对应用户uid1001（1表示已签到，0表示未签到）<br>\n<code>SETBIT sign:Monday 2 1</code>\t偏移量2的位置值为1，偏移量2对应用户uid1002<br>\n…<br>\n<code>SETBIT sign:Monday n 1</code><br>\n再通过<code>BITCOUNT sign:Monday</code>就很容易获取Monday<code>签到的用户数量</code>了</p>\n</blockquote>\n<p>应用场景:</p>\n<ul>\n<li><code>打卡、签到</code></li>\n<li>用户是否登陆过Y、N，比如软件的每日签到功能</li>\n<li>电影、广告是否被点击播放过</li>\n</ul>\n<blockquote>\n<p>Geospatial  <strong>地理空间</strong></p>\n</blockquote>\n<p>Redis地理空间索引可以存储坐标并搜索它们。</p>\n<p>此数据结构用于在给定半径或包围框内查找附近点。</p>\n<p>Geopatial的数据类型是Zset，相当于由之前的<code>score</code>变成了<code>longitude</code>和<code>latitude</code>，可以使用Zset的命令对其进行操作。</p>\n<p>应用场景:</p>\n<ul>\n<li>交友软件中附近的人</li>\n<li>外卖软件中附近的美食店铺</li>\n<li>高德地图附近的核酸检查点</li>\n</ul>\n<blockquote>\n<p>Stream  <strong>流</strong>    就是<code>redis</code>版本的<code>MQ</code></p>\n<p>背景:</p>\n<p>Redis5.0 之前</p>\n<ul>\n<li>List实现消息队列，List实现方式其实就是点对点的模式(一进一出)</li>\n<li>Pub/Sub[发布/订阅]</li>\n</ul>\n<p>Redis5.0版本新增了一个更强大的数据结构—Stream</p>\n<ul>\n<li>Stream流就是Redis版的MQ消息中间件+阻塞队列</li>\n</ul>\n</blockquote>\n<p>Redis流是一种数据结构（Stream类型），它的作用类似于只能追加的日志。可以使用流来实时记录和同时聚合事件。</p>\n<p>Redis流用例示例包括:</p>\n<ul>\n<li>\n<p>事件来源(例如，跟踪用户操作、点击等)</p>\n</li>\n<li>\n<p>传感器监测(例如，来自现场设备的读数)</p>\n</li>\n<li>\n<p>通知(例如，在单独的流中存储每个用户通知的记录)</p>\n</li>\n</ul>\n<p>Redis为每个流消息生成一个唯一的ID，可以使用这些id检索它们关联的消息，或者读取和处理流中的所有后续消息。</p>\n<blockquote>\n<p>四种和ID有关的特殊符号：<br>\n<code>-</code>和<code>+</code>：当前流中最小ID和最大ID<br>\n<code>$</code>：表示大于当前流中最大的id，用于新添加的消息<br>\n<code>&gt;</code>：用于XREANGROUP命令，表示迄今没有发送给组中使用者的信息，会更新消费者组的最后ID<br>\n<code>*</code>：用于XADD命令中，表示让系统自动生成ID</p>\n</blockquote>\n<p>Stream流就是Redis版的MQ消息中间件+阻塞队列，它能实现消息队列，它支持消息的持久化、支持自动生成全局唯一ID、支持ack确认消息的模式、支持消费组模式等，让消息队列更加的稳定和可靠。</p>\n<blockquote>\n<p>$\\textcolor{blue}{一个消息链表，将所有加入的消息都串起来，每个消息都有一个唯一的ID和对应的内容}$</p>\n</blockquote>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305250027574.png\" alt></p>\n<ul>\n<li>\n<p>Message Content：消息内容</p>\n</li>\n<li>\n<p>Consumer group：消费组，通过<code>XGROUP CREATE </code>命令创建，同一个消费组可以有多个消费者</p>\n</li>\n<li>\n<p>Last_delivered_id：游标，每个消费组会有个游标<code> last_delivered_id</code>，任意一消费者读取了消息都会使游标 <code>last_delivered_id</code> 往前移动。</p>\n</li>\n<li>\n<p>Consumer：消费者，消费组中的消费者</p>\n</li>\n<li>\n<p>Pending_ids：消费者会有一个状态变量，用于记录被当前消费已读取但未ack的消息Id，如果客户端没有ack，这个变量里面的消息ID会越来越多，一旦某个消息被ack它就开始减少。这个pending_ids变量在Redis官方被称之为 PEL(Pending Entries List)，记录了当前已经被客户端读取的消息，但是还没有 ack (Acknowledge character：确认字符），它用来确保客户端至少消费了消息一次，而不会在网络传输的中途丢失了没处理</p>\n</li>\n</ul>\n<blockquote>\n<p><em>Bitfield    位域(了解)</em></p>\n</blockquote>\n<p>将一个redis字符串看作是<strong>一个由二进制位组成的数组</strong>并能对变长位宽和任意没有字节对齐的指定整型<code>位域进行寻址和修改</code></p>\n<p>主要作用：</p>\n<ul>\n<li><code>位域修改</code></li>\n<li><code>溢出控制</code></li>\n</ul>\n<blockquote>\n<p>BITFIELD命令的作用在于它能够将很多小的整数储存到一个长度较大的位图中，又或者将一个非常庞大的键分割为多个较小的键来进行储存，从而非常高效地使用内存，使得Rdis能够得到更多不同的应用一特别是在实时分析领域：BTFIELD能够以指定的方式对计算溢出进行控制的能力，使得它可以被应用于这一领域。</p>\n</blockquote>\n<p>Bitfield结构的底层也是String类型。</p>\n<p>Redis位字段允许设置、递增和获取任意位长度的整数值。例如可以对从无符号1位整数到有符号63位整数的任何数字进行操作。</p>\n<p>这些值使用二进制编码的Redis字符串存储。位字段支持原子读、写和递增操作，这使它们成为管理计数器和类似数值的好选择。</p>\n<blockquote>\n<p>例如:  hello 等价于<code> 0110100001100101011011000110110001101111</code>，每八位对应一个字母，也对应一个十进制值。可以修改每一位的数字从而改变对应的数值从而改变对应的字母。</p>\n</blockquote>\n<hr>\n<h2 id=\"持久化\">持久化</h2>\n<blockquote>\n<p>将数据写入持久存储，如固态硬盘(SSD)</p>\n</blockquote>\n<blockquote>\n<p>1、RDB</p>\n</blockquote>\n<p>$\\textcolor{red} {定义}$</p>\n<p>RDB  以指定的时间间隔执行数据集的时间点快照,就是把某一时刻的数据和状态以文件的形式写到磁盘上，也就是快照</p>\n<p>在默认情况下， Redis 将数据库快照保存在名字为 dump.rdb的二进制文件中。可以对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动保存一次数据集。也可以通过调用 SAVE或者 BGSAVE ， 手动让 Redis 进行数据集保存操作。</p>\n<p>在指定的时间间隔内将内存中的数据集快照写入磁盘，它恢复时再将硬盘快照文件直接读回到内存里。</p>\n<p>Redis的数据都在内存中，保存备份时它执行的是全量快照，即：把内存中的所有数据都记录到磁盘中。</p>\n<p>$\\textcolor{red}{优劣}$</p>\n<p>优:</p>\n<ul>\n<li>RDB是Redis 数据的一个非常紧凑的单文件时间点表示。RDB文件非常适合备份。例如，您可能希望在最近的24小时内每小时归档一次RDB文件，并在30天内每天保存一个RDB快照。这样就可以在发生灾难时轻松恢复不同版本的数据集。</li>\n<li>RDB非常适合灾难恢复，它是一个可以传输到远程数据中心或Amazon S3(可能已加密）的压缩文件。</li>\n<li>RDB最大限度地提高了Redis 的性能，因为Redis 父进程为了持久化而需要做的唯一工作就是派生一个将完成所有其余工作的子进程。父进程永远不会执行磁盘I/О或类似操作。</li>\n<li>与AOF 相比，RDB允许使用大数据集更快地重启。</li>\n<li>在副本上，RDB支持重启和故障转移后的部分重新同步。</li>\n<li>对数据完整性和一致性要求不高</li>\n</ul>\n<p>劣:</p>\n<ul>\n<li>在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失从当前至最近一次快照期间的数据，<strong>快照之间的数据会丢失</strong></li>\n<li>内存数据的全量同步，如果数据量太大会导致IO严重影响服务器性能</li>\n<li>RDB依赖于主进程的fork，在更大的数据集中，这可能会导致服务请求的瞬间延迟。fork的时候内存中的数据被克隆了一份，大致2倍的膨胀性，需要考虑</li>\n</ul>\n<p>$\\textcolor{red}{备份}$</p>\n<blockquote>\n<p>触发备份：</p>\n<h5 id=\"自动触发\">自动触发</h5>\n<ul>\n<li>按照redis.conf里配置的 save &lt;seconds&gt; &lt;changes&gt;</li>\n</ul>\n<p><strong>备份：</strong></p>\n<p>在 Redis 中，保存快照并不是在规定的时间到达后才进行，而是在修改数据时和时间间隔条件的<code>双重限制</code>下才进行的。</p>\n<p>如果限制只按时间间隔来进行保存快照，则会出现两个问题：</p>\n<ul>\n<li>\n<p>如果时间间隔太大，那么 Redis 持久化的数据可能会丢失，并且故障恢复时的数据可能会受到影响。</p>\n</li>\n<li>\n<p>如果时间间隔太小，那么数据的保存成本就会过高，并可能导致 Redis 运行效率下降。</p>\n</li>\n</ul>\n<p>因此，Redis 引入了按时间和数据修改次数双重限制的快照保存机制，以在灵活性和效率之间取得平衡。如果在 5 秒内修改的次数超过 2 次，则说明数据的变化较快，在此情况下保存快照并不会带来明显的性能问题。因此，Redis 将其纳入保存快照的范围，以保证数据的安全和一致性</p>\n<p><strong>恢复：</strong></p>\n<p>将备份文件(dump.rdb)移动到 Redis 安装目录并启动服务即可</p>\n<p>物理恢复，一定要将服务产生的RDB文件备份一份，然后分机隔离，避免生产上物理损坏后备份文件也挂了。</p>\n<h5 id=\"被动触发：\">被动触发：</h5>\n<p>使用save或者bgsave命令  $\\textcolor{red}{redis提供了两个命令来生成RDB文件，分别是save和bgsave}$</p>\n<p><strong>save</strong>：在主程序中执行会<strong>阻塞</strong>当前redis服务器，直到持久化工作完成执行save命令期间，Redis不能处理其他命令，<strong>线上禁止使用</strong></p>\n<p><strong>bgsave(默认)</strong>：redis会在后台异步进行快照操作，这就允许主进程同时可以修改数据。<strong>不阻塞</strong>快照同时还可以相应客户端请求，该触发方式会fork一个子进程由子进程复制持久化过程</p>\n</blockquote>\n<p>$\\textcolor{red}{.rdb文件}$</p>\n<p>哪些情况会触发RDB快照</p>\n<ol>\n<li>配置文件中默认的快照配置</li>\n<li>手动<code>save/bgsave</code>命令</li>\n<li>执行<code>flushdb/fulshall</code>命令也会产生dump.rdb文件，但是也会将命令记录到dump.rdb文件中，恢复后依旧是空，无意义</li>\n<li>执行<code>shutdown且没有</code>设置开启AOF持久化</li>\n<li>主从复制时，<code>主节点自动触发</code></li>\n</ol>\n<p>禁用快照</p>\n<ol>\n<li>动态所有停止RDB保存规则的方法：<code>redis-cli config set value &quot;&quot;</code></li>\n<li>手动修改配置文件  <code>save &quot;&quot;</code></li>\n</ol>\n<blockquote>\n<p>2、AOF</p>\n</blockquote>\n<p>$\\textcolor{red}{定义}$</p>\n<p>$\\textcolor{red}{以日志的形式来记录每个写操作}$，将Redis执行过的所有写指令记录下来(读操作不记录)，只许追加文件但是不可以改写文件，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p>\n<p>默认情况下，redis是没有开启AOF的。开启AOF功能需要设置配置：appendonly yes</p>\n<p>$\\textcolor{red}{流程}$</p>\n<ol>\n<li>\n<p>Client作为命令的来源，会有多个源头以及源源不断的请求命令。</p>\n</li>\n<li>\n<p>在这些命令到达Redis Server 以后并不是直接写入AOF文件，会将这些命令先放入AOF缓存中进行保存。这里的AOF缓冲区实际上是内存中的一片区域，存在的目的是当这些命令达到一定量以后再写入磁盘，避免频繁的磁盘IO操作。</p>\n</li>\n<li>\n<p>AOF缓冲会根据AOF缓冲区<strong>同步文件的三种写回策略</strong>将命令写入磁盘上的AOF文件。</p>\n</li>\n<li>\n<p>随着写入AOF内容的增加为避免文件膨胀，会根据规则进行命令的合并(<strong>又称AOF重写</strong>)，从而起到AOF文件压缩的目的。</p>\n</li>\n<li>\n<p>当Redis Server服务器重启的时候会对AOF文件载入数据。</p>\n</li>\n</ol>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305251051356.png\" alt=\"image-20230525105157332\" style=\"zoom:33%;\">\n<p>$\\textcolor{red}{写回策略}$</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">配置项</th>\n<th style=\"text-align:center\">写回时机</th>\n<th style=\"text-align:center\">优点</th>\n<th style=\"text-align:center\">缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Always</td>\n<td style=\"text-align:center\">同步写回</td>\n<td style=\"text-align:center\">可靠性高，数据基本不丢失</td>\n<td style=\"text-align:center\">每个写命令都要同步记录，性能影响较大</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Everysec</td>\n<td style=\"text-align:center\">每秒写回</td>\n<td style=\"text-align:center\">性能适中</td>\n<td style=\"text-align:center\">宕机时丢失一秒内的数据</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">No</td>\n<td style=\"text-align:center\">操作系统控制的写回</td>\n<td style=\"text-align:center\">性能好</td>\n<td style=\"text-align:center\">宕机时丢失数据较多</td>\n</tr>\n</tbody>\n</table>\n<p>$\\textcolor{red}{变化}$</p>\n<ul>\n<li>\n<p>redis7之前 aof 文件有且只有一个</p>\n</li>\n<li>\n<p>redis7之后 aof文件变为了multi part</p>\n<ul>\n<li><strong>BASE: 表示基础AOF</strong>，它一般由子进程通过重写产生，该文件最多只有一个。</li>\n</ul>\n</li>\n<li>\n<p><strong>INCR:表示增量AOF</strong>，它一般会在AOFRW开始执行时被创建，该文件可能存在多个。</p>\n</li>\n<li>\n<p><strong>HISTORY</strong>:表示历史AOF，它由BASE和INCR AOF变化而来，每次AOFRW成功完成时，本次AOFRW之前对应的BASE和INCR AOF都将变为HISTORY，HISTORY类型的AOF会被Redis自动删除。</p>\n</li>\n</ul>\n<p>为了管理这些AOF文件，我们引入了一个manifest (清单)文件来跟踪、管理这些AOF。</p>\n<p>$\\textcolor{red}{优劣}$</p>\n<p>优</p>\n<ul>\n<li>使用AOF Redis 更加持久。</li>\n<li>AOF 日志是一个仅附加日志，因此不会出现寻道问题，也不会在断电时出现损坏问题。</li>\n<li>当AOF 变得太大时，Redis 能够在后台自动重写AOF。重写是完全安全的，因为当 Redis继续附加到旧文件时，会使用创建当前数据集所需的最少操作集生成一个全新的文件，一旦第二个文件准备就绪，Redis 就会切换两者并开始附加到新的那一个。</li>\n<li>AOF以易于理解和解析的格式依次包含所有操作的日志。可以轻松导出AOF文件。</li>\n</ul>\n<p>劣</p>\n<ul>\n<li>相同数据集的数据而言AOF文件要远大于RDB文件，恢复速度慢于RDB</li>\n<li>AOF运行效率要慢于RDB，每秒同步策略效率较好，不同步效率和RDB相同</li>\n</ul>\n<p>$\\textcolor{red}{重写机制}$</p>\n<ul>\n<li>当AOF文件的大小超过所设定的峰值时，Redis就会<strong>自动</strong>启动AOF文件的内容压缩。只保留可以恢复数据的最小指令集。</li>\n</ul>\n<p>何时触发：</p>\n<ul>\n<li>自动触发\n<ul>\n<li>满足配置文件中的选项后，Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时</li>\n</ul>\n</li>\n<li><strong>手动触发</strong>\n<ul>\n<li>客户端向服务器发送bgrewriteaof命令</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>AOF文件重写并不是对原文件进行重新整理，而是直接读取服务器现有的键值对，然后用一条命令去代替之前记录这个键值对的多条命令，生成一个新的文件后去替换原来的AOF文件</p>\n</blockquote>\n<p>原理：</p>\n<ol>\n<li>在重写开始前，redis会创建一个“重写子进程”，这个子进程会读取现有的AOF文件，并将其包含的指令进行分析压缩并写入到一个临时文件中。</li>\n<li>与此同时，主进程会将新接收到的写指令一边累积到内存缓冲区中，一边继续写入到原有的AOF文件中（这样做是保证原有的AOF文件的可用性，避免在重写过程中出现意外。）</li>\n<li>当“重写子进程”完成重写工作后，它会给父进程发一个信号，父进程收到信号后就会将内存中缓存的写指令追加到新AOF文件中</li>\n<li>当追加结束后，redis就会用新AOF文件来代替旧AOF文件，之后再有新的写指令，就都会追加到新的AOF文件中</li>\n<li>重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似</li>\n</ol>\n<blockquote>\n<p>3、混合持久化</p>\n</blockquote>\n<p><strong>$\\textcolor{red}{数据恢复顺序和加载流程}$</strong></p>\n<p>在<code>同时</code>开启<code>rdb</code>和<code>aof</code>持久化时，重启时<code>只会</code>加载<code>aof</code>文件，<code>不会</code>加载<code>rdb</code>文件</p>\n<p>$\\textcolor{blue}{定义区别}$</p>\n<ul>\n<li>RDB持久化方式能够在指定的时间间隔对你的数据进行快照存储。</li>\n<li>AOF持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以redis协议追加保存每次写的操作到文件末尾。</li>\n</ul>\n<p><span style=\"color:red\">同时开启两种持久化方式</span></p>\n<ul>\n<li>当redis重启的时候会<code>优先载入AOF文件</code>来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</li>\n<li>RDB的数据不是实时的，同时使用两者时服务器重启也只会找AOF文件。 redis  的 作者也不建议只使用AOF方式备份，因为RDB更适合用于备份数据库（AOF在不断的变化不好备份），留着RDB是为了 作为一个以防万一的手段。</li>\n</ul>\n<blockquote>\n<p>推荐使用<code>两者混合使用</code></p>\n<ul>\n<li>RDB镜像做全量持久化，AOF做增量持久化</li>\n</ul>\n<p>建议先使用RDB进行快照存储，</p>\n<p>然后使用AOF持久化记录所有的写操作，</p>\n<p>当重写策略满足或手动触发重写的时候，将最新的数据存储为新的RDB记录。</p>\n<p>这样的话，重启服务的时候会从RDB和AOF两部分恢复数据，既保证了数据完整性，又提高了恢复数据的性能。</p>\n<p>简单来说:混合持久化方式产生的文件一部分是RDB格式，一部分是AOF格式。----&gt;AOF包括了RDB头部+AOF混写</p>\n</blockquote>\n<blockquote>\n<p>4、纯缓存模式</p>\n</blockquote>\n<p><code>同时关闭</code>RDB+AOF，只用缓存</p>\n<ol>\n<li>\n<p>save “”  – 禁用RDB</p>\n<p>禁用RDB持久化模式下，我们仍然可以使用命令save、bgsave生成RDB文件</p>\n</li>\n<li>\n<p>appendonly no  – 禁用AOF</p>\n<p>禁用AOF持久化模式下，我们仍然可以使用命令bgrewriteaof生成AOF文件</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"事务\">事务</h2>\n<p>可以一次执行多个命令，本质是一组命令的集合，一个事务中的所有命令都会序列化，$\\textcolor{red}{按顺序地串行化执行而不会被其他命令插入，不许加塞}$</p>\n<p>$\\textcolor{red}{特点}$</p>\n<table>\n<thead>\n<tr>\n<th>单独的隔离操作</th>\n<th>Redis的事务仅仅是保证事务里的操作会被连续独占的执行，redis命令执行是单线程架构，在执行完事务内所有指令前是不可能再去同时执行其他客户端的请求的</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>没有隔离级别的概念</td>\n<td>因为事务提交前任何指令都不会被实际执行，也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这种问题了</td>\n</tr>\n<tr>\n<td>不保证原子性</td>\n<td>Redis的事务不保证原子性，也就是不保证所有指令同时成功或同时失败，只有决定是否开始执行全部指令的能力，没有执行到一半进行回滚的能力</td>\n</tr>\n<tr>\n<td>排它性</td>\n<td>Redis会保证一个事务内的命令依次执行，而不会被其它命令插入</td>\n</tr>\n</tbody>\n</table>\n<p>$\\textcolor{red}{流程}$</p>\n<p>（1）开启：以<code>MULTI</code>命令开启一个事务</p>\n<p>（2）入队：将多个命令加入到事务队列中，接到这些命令并不会立即执行。</p>\n<p>（3）执行：由<code>EXEC</code>命令执行事务队列中的命令。</p>\n<hr>\n<h2 id=\"管道\">管道</h2>\n<p>Redis 管道（Pipeline）是一种在客户端和 Redis 服务器之间建立的双向通道，它可以让客户端在一次请求中发送多个命令并一次性接收多个命令的响应结果。通过使用 Redis 管道，客户端可以减少网络通信的次数，从而提高 Redis 的吞吐量和性能。</p>\n<blockquote>\n<p>在传统的 Redis 操作中，每个命令都需要通过网络发送到 Redis 服务器，然后等待 Redis 服务器返回响应结果后再进行下一个命令的操作，这样就会产生大量的网络通信开销。而使用 Redis 管道，客户端可以将多个命令一次性发送到 Redis 服务器，然后一次性接收所有命令的响应结果，从而减少网络通信的次数和开销。</p>\n</blockquote>\n<p>$\\textcolor{red}{总结}$</p>\n<ul>\n<li>Pipeline与原生批量命令(<code>mset</code>)对比：\n<ul>\n<li>原生批量命令（例如mset、mget）具有原子性，pipeline是非原子性。</li>\n<li>原生批量命令一次只能执行一种命令，pipeline支持批量执行不同命令。</li>\n<li>原生批命令是redis服务端实现，而pipeline需要redis服务端和客户端共同完成。</li>\n</ul>\n</li>\n<li>Pipeline与事务对比：\n<ul>\n<li>事务具有原子性，管道不具有原子性。</li>\n<li>管道一次性将命令发送给服务器，事务是一条一条的发，事务只有在接收到EXEC命令后才会执行。</li>\n<li>执行事务时会阻塞其他命令的执行，而执行管道中的命令不会。</li>\n</ul>\n</li>\n<li>使用Pipeline注意事项：\n<ul>\n<li>pipeline缓冲的指令只是会依次执行，不保证原子性，如果执行中指令发生异常，还会继续执行后续的指令。</li>\n<li>使用pipeline传输的命令也不能太多，如果数据量大客户端的阻塞时间可能会过久，同时服务端此时也被迫回复一个队列答复，占用很多内存。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"集群下的批处理\">集群下的批处理</h2>\n<p>如果Redis是一个集群，那批处理命令的多个key必须落在一个插槽中，否则就会导致执行失败。</p>\n<p><span style=\"color:red\">方式</span></p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305272026267.png\" alt=\"image-20230527202618094\" style=\"zoom:33%;\">\n<p>第一种方案：串行执行，所以这种方式没有什么意义，当然，执行起来就很简单了，缺点就是耗时过久。</p>\n<p>第二种方案：串行slot，简单来说，就是执行前，客户端先计算一下对应的key的slot，一样slot的key就放到一个组里边，不同的，就放到不同的组里边，然后对每个组执行pipeline的批处理，他就能串行执行各个组的命令，这种做法比第一种方法耗时要少，但是缺点呢，相对来说复杂一点，所以这种方案还需要优化一下</p>\n<p><font color=\"red\">第三种方案：并行slot</font>，相较于第二种方案，在分组完成后串行执行，第三种方案，就变成了并行执行各个命令，所以他的耗时就非常短，但是实现呢，也更加复杂。</p>\n<p>第四种：hash_tag，redis计算key的slot的时候，其实是根据key的有效部分来计算的，通过这种方式就能一次处理所有的key，这种方式耗时最短，实现也简单，但是如果通过操作key的有效部分，那么就会导致所有的key都落在一个节点上，产生数据倾斜的问题，所以我们推荐使用第三种方式。</p>\n<h2 id=\"发布和订阅\">发布和订阅</h2>\n<ul>\n<li>\n<p>Redis 发布和订阅（Publish/Subscribe，简称 Pub/Sub）是一种消息传递模式，用于在 Redis 中实现消息的发布和订阅。</p>\n</li>\n<li>\n<p>在 Redis 中，发布者（Publisher）可以将消息发送到一个或多个频道（Channel），订阅者（Subscriber）可以订阅一个或多个频道，以接收发布者发送的消息。当发布者在某个频道上发布一条消息时，所有订阅该频道的订阅者都会收到这条消息。</p>\n</li>\n</ul>\n<p><code>Redis Pub/Sub</code> 是基于消息传递的异步通信模型，可以用于构建实时系统、聊天室、实时广播等应用场景。</p>\n<p>$\\textcolor{red}{总结}$</p>\n<ul>\n<li>发布的消息在Redis系统不能持久化，因此必须先执行订阅，再等待消息发布，如果先发布了消息且该消息没有订阅者接收，那么该消息被直接丢弃。</li>\n<li>消息只管发送，对于发布者而言消息是即发即失的，也没有ACK机制，无法保证消息是否消费成功。</li>\n<li>Redis5.0新增了Stream数据结构，不但支持多播，还支持数据持久化，比Pub/Sub更加强大。</li>\n</ul>\n<hr>\n<h2 id=\"复制\">复制</h2>\n<blockquote>\n<p>Redis 复制可以提高系统的可用性、可靠性和扩展性，使得在发生故障时可以快速地恢复数据。</p>\n</blockquote>\n<p>slave可以执行写命令吗？</p>\n<ul>\n<li>slave不可以执行写命令。master负责写命令，也可以执行读命令，slave负责读命令。即使slave是另一台slave的master，也不能执行写命令。</li>\n</ul>\n<p>slave是从头开始复制还是从切入点开始复制?</p>\n<ul>\n<li>\n<p>都可以</p>\n</li>\n<li>\n<p>当从节点<code>第一次连接主节点</code>时，如果主节点还<code>没有持久化数据</code>，从节点将<code>从头开始复制</code>。即主节点会将自己的全部数据发送给从节点，从节点将接收并保存全部数据。</p>\n</li>\n<li>\n<p>当从节点与主节点<code>已经建立了连接</code>，并且已经有了初始数据同步，如果从节点断开与主节点的连接后重新连接，从节点可以选择从上次同步的位置（复制偏移量）继续同步数据，这样可以避免从头开始复制所带来的性能影响和数据冗余。（master会检查backlog里面的offset，master和slave都会保存一个复制的offset和一个masterId）</p>\n</li>\n</ul>\n<blockquote>\n<p>需要注意的是，如果从节点断开与主节点的连接时间过长，主节点可能已经自动执行了 BGSAVE 命令，生成了新的 RDB 文件，此时从节点需要从头开始复制。此外，如果从节点的内存不足，也可能需要从头开始复制，以避免内存溢出。</p>\n</blockquote>\n<p>主节点SHUTDOWN后，从节点会上位吗？</p>\n<ul>\n<li>主节点关闭后，从节点不会变成主节点，它们会等待主节点重新启动，但是从节点的数据可以正常读取。-主节点重启后，主从关系依旧存在。</li>\n</ul>\n<p>$\\textcolor{red}{复制的过程}$</p>\n<p>（1）从节点向主节点发送 <code>SYNC</code> 命令,从节点<code>第一次</code>与主节点进行连接的时候会进行一次全量复制（完全同步），slave自身原有数据会被master数据覆盖清除</p>\n<p>（2）主节点接收到<code> SYNC 命令</code>后，开始在<code>后台保存快照</code>，生成 RDB 文件，收集并缓存此过程中记录所有执行的写命令。</p>\n<p>（3）主节点在执行完<code>rdb持久化</code>后，将生成的 RDB 文件和所有的缓存命令发送给从节点，完成一次完全同步。</p>\n<p>（4）从节点接收到主节点发送的 RDB 文件和写命令，会将其进行存盘，并加载到内存中，完成复制初始化，来保持与主节点的数据一致。</p>\n<p>（5）从节点持续监听主节点发来的新命令，并将其执行，以保持与主节点的数据同步。</p>\n<p>（6）为了保持主节点和从节点之间的通信，master会发出PING包的周期默认是10秒（：<code>repl-ping-replica-period 10</code>在661行）</p>\n<p>（6）当主节点发生故障时，从节点会尝试与其他主节点建立连接，并选举出一个新的主节点（手动  slave of|自动 哨兵），从而成为新的从节点，[注意：默认情况下，不会在slave节点中自动选一个master]</p>\n<p>（7）从机下线重新连接的时候，master会进行检查backlog里面的offset,master只会把已经缓存的<code>offset后面</code>的数据复制给slave</p>\n<blockquote>\n<p>Redis 复制是异步的，因此从节点可能存在数据不一致的情况。</p>\n<p>为了避免数据不一致，可以设置 Redis 的复制偏移量（replication offset），当从节点与主节点连接断开后，从节点可以通过该偏移量快速地同步数据。</p>\n</blockquote>\n<p>$\\textcolor{red}{缺点}$ (引出<code>哨兵和集群</code>)</p>\n<p>（1）<em>数据同步延迟</em>：由于 Redis 复制是异步的，从节点的数据可能会与主节点存在一定的延迟，因此从节点可能无法实时获取到最新的数据。</p>\n<p>（2）<em>单点故障</em>：当主节点发生故障时，需要手动进行故障转移或者使用集群来保证系统的可用性。</p>\n<p>（3）<em>网络通信问题</em>：当网络出现故障或者通信延迟过高时，复制的效率会受到影响，从节点可能无法及时接收到主节点发送的数据。</p>\n<p>（4）<em>内存消耗问题</em>：当从节点处理不过来主节点发送过来的写命令时，从节点会自动触发执行全量复制，这会导致从节点内存消耗变大</p>\n<p>（5）<em>数据安全问题</em>：当主节点的数据被误删或者篡改时，从节点也会受到影响，因此需要采取一定的措施来保证数据的安全性</p>\n<hr>\n<h2 id=\"哨兵Sentinel\">哨兵Sentinel</h2>\n<p>是 Redis 的高可用性解决方案之一，它可以用于监控和管理 Redis 主从复制集群，并在主节点发生故障时<code>自动</code>将从节点升级为新的主节点，从而保证系统的<code>高可用性</code>和可靠性。</p>\n<p>$\\textcolor{red}{作用:}$</p>\n<ol>\n<li>\n<p><strong>主从监控</strong>：监控主从redis库运行是否正常</p>\n</li>\n<li>\n<p><strong>消息通知</strong>：哨兵可以将故障转移的结果发送给客户端</p>\n</li>\n<li>\n<p><strong>故障转移</strong>：如果master异常，则会进行主从切换，将其中一个slave作为新master</p>\n</li>\n<li>\n<p><strong>配置中心</strong>：客户端通过连接哨兵来获得当前Redis服务的主节点地址</p>\n</li>\n</ol>\n<p>$\\textcolor{red}{哨兵的流程原理}$</p>\n<ol>\n<li>当哨兵检测到主节点不可用时，会将主节点标记为下线状态(sdown)，并向其他哨兵发送通知，通知其他哨兵主节点已经下线，其他哨兵也标记主节点下线后(odown)，确定主节点不可用</li>\n</ol>\n<blockquote>\n<p>下线方式：</p>\n<ul>\n<li>\n<p>主观下线(sdown)：指的是单个Sentinel实例对服务器做出的下线判断，即单个sentinel认为某个服务下线（有可能是接收不到订阅，之间的网络不通等等原因）。就是说如果服务器在给定的毫秒数之内没有回应PING命令或者返回一个错误消息， 那么这个Sentinel会主观的(单方面的)认为这个master不可以用了。</p>\n</li>\n<li>\n<p>客观下线(odown)：客观下线需要多个哨兵达成一致意见才能认为主节点真正不可用。quorum(票数)这个参数是进行客观下线的一个依据。</p>\n</li>\n</ul>\n</blockquote>\n<ol start=\"2\">\n<li>哨兵在检测到主节点不可用后，会进入选举状态，此时开始选举哨兵的领导者。</li>\n</ol>\n<blockquote>\n<p>选举算法：</p>\n<ul>\n<li>监视该主节点的所有哨兵都有可能被选为领导者，选举使用的算法是Raft算法；Raft算法的基本思路是先到先得</li>\n</ul>\n</blockquote>\n<ol start=\"3\">\n<li>哨兵leader开始推动故障切换流程并选举出一个新的master</li>\n</ol>\n<blockquote>\n<p>选举规则：</p>\n<ul>\n<li>优先级 (slave-priority  、 replica-priority)  （数值越小优先级越高）</li>\n<li>复制偏移量（大的优先）</li>\n<li>run id（小的优先，每个redis实例启动后都会随机生成一个40位的run id）</li>\n</ul>\n</blockquote>\n<ol start=\"4\">\n<li>选举出新的master后由Sentinel leader完成failover工作(故障切换)</li>\n</ol>\n<blockquote>\n<p>具体流程：</p>\n<ul>\n<li>执行slaveof no one命令让选出来的从节点成为新的主节点，并通过slaveof命令让其他节点（包括原来的master）成为新主节点的从节点。</li>\n<li>Sentinel leader会向被重新配置的实例发送一个 CONFIG REWRITE 命令， 从而确保这些配置会持久化在硬盘里(写入配置文件)。</li>\n<li>值得注意的是： 原来的master重连也将变成从节点</li>\n</ul>\n</blockquote>\n<p>$\\textcolor{red}{故障恢复的流程}$</p>\n<ul>\n<li>\n<p>从下线的主服务的所有从服务里面挑选个从服务，将其转成主服务（选举的原则就是上面👆🏻的）</p>\n</li>\n<li>\n<p>从服务挑选出新的主服务之后，<code>sentinel</code> 向原主服务的从服务发送自己是新主机的命令，其他的将变为该服务的从服务</p>\n</li>\n<li>\n<p>下线的主机再次上线时，<code>sentinel</code>会向其发送<code>slaveof</code>命令：让其成为新主的从节点</p>\n</li>\n</ul>\n<p>==注意==</p>\n<ul>\n<li>\n<p>哨兵节点的数量应为多个，哨兵本身应该集群，保证高可用，哨兵节点的数量应该是奇数</p>\n</li>\n<li>\n<p>哨兵集群+主从复制，并<code>不能保证数据零丢失</code>（引出集群cluster，集群可以解决这一问题），此时数据丢失的原因就是：master宕机后，哨兵需要在一定时间内选出新的master并执行failover操作，这段时间内从节点无法写入数据，造成数据丢失。</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"集群\">集群</h2>\n<p>$\\textcolor{red}{定义}$</p>\n<p>Redis集群是一个提供在多个Redis节点间共享数据的程序集，Redis集群可以支持多个master</p>\n<p>$\\textcolor{red}{作用}$</p>\n<ul>\n<li>Redis集群支持<code>多个master</code>，每个master又可以挂载<code>多个slave</code>\n<ol>\n<li>读写分离</li>\n<li>支持数据的高可用</li>\n<li>支持海量数据的读写存储操作</li>\n</ol>\n</li>\n<li>由于Cluster自带<code>Sentinel</code>的故障转移机制，内置了高可用的支持，<code>无需再去使用哨兵功能</code></li>\n<li>客户端与Redis的节点连接，不再需要连接集群中所有的节点，<code>只需要任意连接集群中的一个可用节点即可</code></li>\n<li>槽位<code>slot</code>负责分配到各个物理服务节点，由对应的集群来负责维护节点、插槽和数据之间的关系</li>\n</ul>\n<p>$\\textcolor{red}{槽位slot}$</p>\n<p>Redis集群没有使用一致性hash 而是引入了哈希槽的概念。</p>\n<p>Redis集群有16384个哈希槽每个key通过<code>CRC16校验</code>后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽</p>\n<p>$\\textcolor{red}{分片}$</p>\n<ul>\n<li>\n<p>是什么： 使用Redis集群时我们会将存储的数据分散到多台redis机器上，这称为分片。就是集群中的每个Redis实例都被认为是整个数据的一个分片。</p>\n</li>\n<li>\n<p>如何找到给定key的分片：为了找到给定key的分片，我们对key进行<code>CRC16(key)</code>算法处理并通过对总分片数量取模。然后，使用确定性<code>哈希函数</code>，这意味着<code>给定的key</code>将多次始终映射到同一个分片，我们可以推断将来读取特定key的位置。</p>\n</li>\n</ul>\n<p>$\\textcolor{red}{分片和槽位的优势}$</p>\n<ul>\n<li>方便扩缩容和数据分派查找</li>\n<li>容易添加或者删除节点，将一个结点的哈希槽移动到另一个节点并不会停止服务，所以无论<code>添加删除或者改变</code>某个节点的哈希槽的数量都不会造成集群不可用的状态。</li>\n</ul>\n<p>$\\textcolor{red}{槽位映射方案}$</p>\n<ul>\n<li>\n<p>哈希取余分区$\\textcolor{red}{&lt;和服务器数量有关&gt;}$</p>\n<ul>\n<li>优点:\n<ul>\n<li>简单有效，只需要预估好数据规划的节点就可以了</li>\n<li>使用Hash算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求 (并维护这些请求的信息)， 起到负载均衡+分而治之的作用。</li>\n</ul>\n</li>\n<li>缺点:\n<ul>\n<li>扩容或者缩容就比较麻烦；一旦某个redis机器宕机了，由于台数数量变化，会导致hash取余全部数据重新洗牌。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>一致性哈希算法分区</p>\n<ul>\n<li>\n<p>作用</p>\n<ul>\n<li>可以解决分布式缓存数据变动和映射问题，当服务器个数发生变动时，尽量减少影响客户端到服务器的映射关系</li>\n</ul>\n</li>\n<li>\n<p>步骤</p>\n<ul>\n<li>由一致性Hash算法构建一致性哈希环</li>\n</ul>\n<blockquote>\n<p>上面的节点取模法是对<code>节点（服务器）</code>的数量进行取模。</p>\n<p>而一致性Hash算法是对2<sup>32</sup>取模，简单来说，一致性Hash算法将整个<code>哈希值空间组织成一个虚拟的圆环</code></p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305251705966.png\" alt=\"image-20230525170513937\" style=\"zoom:25%;\">\n</blockquote>\n<ul>\n<li>服务器IP节点映射: 将集群中各个IP节点映射到环上的某一个位置</li>\n</ul>\n<blockquote>\n<p>将各个服务器使用Hash进行运算，可以选择服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305251706848.png\" alt=\"image-20230525170644816\" style=\"zoom:25%;\">\n</blockquote>\n<ul>\n<li>key落到服务器的落键规则</li>\n</ul>\n<blockquote>\n<p>当我们需要存储一个kv键值对时，首先计算key的hash值，hash(key)，将这个key使用相同的函数Hash计算出哈希值并确定此数据在环上的位置，<strong>从此位置沿环顺时针“行走”</strong>，第一台遇到的服务器就是其应该定位到的服务器，并将该键值对存储在该节点上。</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305251709034.png\" alt=\"image-20230525170901005\" style=\"zoom:25%;\">\n</blockquote>\n</li>\n<li>\n<p>优点</p>\n<ul>\n<li>一致性哈希算法的容错性</li>\n</ul>\n<blockquote>\n<p>一般的，在一致性Hash算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器〈即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305251709670.png\" alt=\"image-20230525170927600\" style=\"zoom:20%;\">\n</blockquote>\n<ul>\n<li>一致性哈希算法的扩展性</li>\n</ul>\n<blockquote>\n<p>数据量增加了，需要增加一台节点NodeX，X的位置在A和B之间，那收到影响的也就是A到X之间的数据，重新把A到X的数据录入到X上即可，不会导致hash取余全部数据重新洗牌。</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305251709030.png\" alt=\"image-20230525170937921\" style=\"zoom:25%;\">\n</blockquote>\n</li>\n<li>\n<p>缺点</p>\n<ul>\n<li>一致性哈希算法的数据倾斜问题</li>\n</ul>\n<blockquote>\n<p>一致性Hash算法在服务<strong>节点太少时</strong>，容易因为节点分布不均匀而造成<strong>数据倾斜</strong>（被缓存的对象大部分集中缓存在某一台服务器上)问题</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305251710888.png\" alt=\"image-20230525171000852\" style=\"zoom:25%;\">\n</blockquote>\n</li>\n</ul>\n</li>\n<li>\n<p>哈希槽分区</p>\n<ul>\n<li>\n<p>作用</p>\n<ul>\n<li>\n<p>解决均匀分配的问题，在数据和节点之间又加入了一层，把这层称为哈希槽(slot)，用于管理数据和节点之间的关系，现在就相当于节点上放的是槽，槽里面放的是数据。</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305251711708.png\" alt=\"image-20230525171159628\" style=\"zoom:25%;\">\n</li>\n<li></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ul>\n<li>\n<p>为什么Redis集群的最大槽数是16384个</p>\n<blockquote>\n<p>Redis集群并没有使用一致性hash而是引入了哈希槽的概念,作用是：每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽</p>\n</blockquote>\n<ul>\n<li>(1)如果槽位为65536，发送心跳信息的消息头达8k（65536÷8÷1024=8kb），发送的心跳包过于庞大</li>\n<li>(2)redis的集群主节点数量基本不可能超过1000个</li>\n<li>(3)槽位越小，节点少的情况下，压缩比高，容易传输</li>\n</ul>\n</li>\n</ul>\n<p>==注意==</p>\n<blockquote>\n<p>Redis集群不保证强一致性： 在特定的条件下，Redis集群可能会丢掉一些被系统收到的写入请求命令</p>\n</blockquote>\n<hr>\n<h2 id=\"整合\">整合</h2>\n<blockquote>\n<p><code>Jedis</code>   Jedis本身是<code>线程不安全</code>的，并且<code>频繁的创建和销毁连接</code>会有性能损耗，推荐使用Jedis<code>连接池</code>代替Jedis的<code>直连</code>方式。</p>\n</blockquote>\n<blockquote>\n<p><code>SpringDataRedis</code>    提供了RedisTemplate工具类，其中封装了各种对Redis的操作</p>\n</blockquote>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305242101617.png\" alt=\"image-20230524210152588\" style=\"zoom:33%;\">\n<blockquote>\n<p>解决序列化：</p>\n</blockquote>\n<p>方式一：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisConfig</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RedisTemplate&lt;String, Object&gt; <span class=\"title function_\">redisTemplate</span><span class=\"params\">(RedisConnectionFactory connectionFactory)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建RedisTemplate对象</span></span><br><span class=\"line\">        RedisTemplate&lt;String, Object&gt; template = <span class=\"keyword\">new</span> <span class=\"title class_\">RedisTemplate</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// 设置连接工厂</span></span><br><span class=\"line\">        template.setConnectionFactory(connectionFactory);</span><br><span class=\"line\">        <span class=\"comment\">// 创建JSON序列化工具</span></span><br><span class=\"line\">        <span class=\"type\">GenericJackson2JsonRedisSerializer</span> <span class=\"variable\">jsonRedisSerializer</span> <span class=\"operator\">=</span> </span><br><span class=\"line\">            \t\t\t\t\t\t\t<span class=\"keyword\">new</span> <span class=\"title class_\">GenericJackson2JsonRedisSerializer</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 设置Key的序列化</span></span><br><span class=\"line\">        template.setKeySerializer(RedisSerializer.string());</span><br><span class=\"line\">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class=\"line\">        <span class=\"comment\">// 设置Value的序列化</span></span><br><span class=\"line\">        template.setValueSerializer(jsonRedisSerializer);</span><br><span class=\"line\">        template.setHashValueSerializer(jsonRedisSerializer);</span><br><span class=\"line\">        <span class=\"comment\">// 返回</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> template;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>==方式二：==</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowrited</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> StringRedisTemplete stringRedisTemplete</span><br><span class=\"line\"><span class=\"comment\">// JSON序列化工具</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">ObjectMapper</span> <span class=\"variable\">mapper</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectMapper</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">testSaveUser</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> JsonProcessingException &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建对象</span></span><br><span class=\"line\">    <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>(<span class=\"string\">&quot;虎哥&quot;</span>, <span class=\"number\">21</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 手动序列化</span></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">json</span> <span class=\"operator\">=</span> mapper.writeValueAsString(user);</span><br><span class=\"line\">    <span class=\"comment\">// 写入数据</span></span><br><span class=\"line\">    stringRedisTemplate.opsForValue().set(<span class=\"string\">&quot;user:200&quot;</span>, json);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取数据</span></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">jsonUser</span> <span class=\"operator\">=</span> stringRedisTemplate.opsForValue().get(<span class=\"string\">&quot;user:200&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 手动反序列化</span></span><br><span class=\"line\">    <span class=\"type\">User</span> <span class=\"variable\">user1</span> <span class=\"operator\">=</span> mapper.readValue(jsonUser, User.class);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;user1 = &quot;</span> + user1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>解决转圈圈</p>\n</blockquote>\n<ul>\n<li>\n<p>原因：SpringBoot客户端没有动态感知RedisCluster的最新集群信息</p>\n</li>\n<li>\n<p>现象：Redis Cluster集群部署采用了3主3从拓扑结构，数据读写访问master节点，slave节点负责备份。当master宕机主从切换成功，redis可以正常运行，但是java程序出现异常</p>\n</li>\n<li>\n<p>解决：</p>\n<ul>\n<li>\n<p>排除lettuce采用Jedis（不推荐）</p>\n</li>\n<li>\n<p>重写连接工厂实例（极度不推荐）</p>\n</li>\n<li>\n<p><code>刷新节点集群拓扑动态感应</code></p>\n<ul>\n<li>调用 RedisClusterClient.reloadPartitions</li>\n<li>后台基于时间间隔的周期刷新</li>\n<li>后台基于持续的 <strong>断开</strong> 和 <strong>移动</strong>、<strong>重定向</strong> 的自适应更新</li>\n</ul>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#支持集群拓扑动态感应刷新，自适应拓扑刷新是否使用所有可用的更新，默认false关闭</span></span><br><span class=\"line\"><span class=\"string\">spring.redis.lettuce.cluster.refresh.adaptive=true</span></span><br><span class=\"line\"><span class=\"comment\">#定时刷新</span></span><br><span class=\"line\"><span class=\"string\">spring.redis.lettuce.cluster.refresh.period=2000</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"redis单线程-VS-多线程\">redis单线程 VS 多线程</h2>\n<blockquote>\n<p>Redis是单线程究竟何意</p>\n</blockquote>\n<p>Redis是单线程主要是指Redis的网络IO和键值对读写是由一个线程来完成的，Redis在处理客户端的请求时包括获取(socket 读)、解析、执行、内容返回(socket 写) 等都由一个顺序串行的主线程处理，这就是所谓的“单线程”</p>\n<p>优点</p>\n<ul>\n<li>使用单线程模型使 Redis 的开发和维护更简单，因为单线程模型方便开发和调试;</li>\n<li>即使使用单线程模型也并发的处理多客户端的请求，主要使用的是<code>IO多路复用和非阻塞IO</code>；</li>\n<li>对于Redis系统来说，主要的<code>性能瓶颈</code>是内存或者网络带宽而并非 CPU。</li>\n</ul>\n<p>问题：</p>\n<ul>\n<li>大key删除会陷入等待   [因为是单线程原子命令操作，这就会导致 Redis 服务卡顿]</li>\n<li>随着网络硬件的性能提升，Redis的性能瓶颈有时会出现在网络IO的处理上,单个主线程处理网络请求的速度跟不上底层网络硬件的速度</li>\n</ul>\n<blockquote>\n<p>Redis的多IO线程只是用来处理网络请求的，<strong>对于读写操作命令Redis仍然使用单线程来处理</strong></p>\n</blockquote>\n<p>原因：</p>\n<ul>\n<li>Redis处理请求时，网络处理经常是瓶颈，通过多个IO线程并行处理网络操作，可以提升实例的整体处理性能。</li>\n<li>而继续使用单线程执行命令，就不用为了保证Lua脚本、事务的原子性，额外开发多线程$\\textcolor{red}{互斥加锁机制了(不管加锁操作处理)}$，这样一来，Redis线程模型实现就简单了</li>\n</ul>\n<p>主线程和IO线程协作完成请求处理的过程</p>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305252049332.png\" alt></p>\n<blockquote>\n<p>redis 为什么快</p>\n</blockquote>\n<p><span style=\"color:red\">IO多路复用  + epoll  + 存于内存之中+ 单线程命令</span></p>\n<ul>\n<li>IO多路复用是什么\n<ul>\n<li>一种同步的IO模型，实现<font color=\"red\">一个线程</font>监视<font color=\"green\"><code>多个</code>文件句柄(文件描述符),一旦某个文件句柄就绪</font>就能够通知到对应应用程序进行相应的读写操作，<font color=\"red\">没有文件句柄就绪时</font>就会阻塞应用程序从而释放CPU资源</li>\n<li>多路：多个客户端连接(连接就是套接字描述符，即 socket 或者 channel)</li>\n<li>复用：复用一个或几个线程</li>\n<li>IO多路复用：就是一个或一组线程处理多个TCP连接，使用单进程就能够实现同时处理多个客户端的连接，<font color=\"red\">无需创建或者维护过多的进程/线程</font></li>\n<li>实现IO多路复用的模型有3种: 可以分<code>select-&gt;poll-&gt;epoll</code>三个阶段来描述。</li>\n</ul>\n</li>\n</ul>\n<p>IO多路复用原理: 有请求就响应，没请求不打扰</p>\n<p>采用多路/O复用技术可以让单个线程高效的处理多个连接请求一个服务端进程可以同时处理多个套接字描述符。</p>\n<blockquote>\n<p><code>epoll</code>是什么</p>\n</blockquote>\n<blockquote>\n<p>浅记：你站在讲台上等，谁解答完谁举手。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案然后继续回到讲台上等] 此时E、A又举手，然后去处理E和A。。。这种就是IO复用模型。 Linux下的select、poll和epoll就是干这个的。</p>\n</blockquote>\n<p>工作原理：</p>\n<ul>\n<li>\n<p>将用户socket对应的文件描述符(FileDescriptor)注册进epoll，然后epoll帮你监听哪些socket上有消息到达，这样就避免了大量的无用操作。</p>\n</li>\n<li>\n<p>此时的socket应该采用<font color=\"red\">非阻塞模式</font>。这样，整个过程只在调用select、poll、epoll这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的reactor反应模式。</p>\n</li>\n</ul>\n<blockquote>\n<p>多线程下操作Redis不会有线程安全问题</p>\n</blockquote>\n<ul>\n<li>\n<p>对于<code>网络数据读写、请求协议解析</code> 是通过多个IO线程的来处理</p>\n<p>而命令的执行依旧是由主线程串行执行的</p>\n<p>因此在多线程下操作Redis不会出现线程安全的问题</p>\n</li>\n</ul>\n<h2 id=\"BigKey\">BigKey</h2>\n<ul>\n<li>\n<p><font color=\"blue\">keys * 这个指令有致命的弊端，在实际环境中最好不要使用</font></p>\n</li>\n<li>\n<p>用<code>Scan</code></p>\n<ul>\n<li>\n<p>SCAN命令是一个基于<code>游标</code>的迭代器，每次被调用之后，都会向用户<code>返回一个新的游标</code>，<font color=\"red\">用户在下次迭代时需要使用这个新游标作为SCAN命令的游标参数</font>，以此来延续之前的迭代过程。</p>\n</li>\n<li>\n<p>命令   <code>SCAN cursor [MATCH pattern] [COUNT count]</code></p>\n<ul>\n<li>cursor - 游标。</li>\n<li>pattern - 匹配的模式。</li>\n<li>count - 指定从数据集里返回多少元素，默认值为 10 。</li>\n</ul>\n</li>\n<li>\n<p>SCAN的遍历顺序<br>\n<font color=\"red\">非常特别，它不是从第一维数组的第零位一直遍历到末尾，而是采用了高位进位加法来遍历。之所以使用这样特殊的方式进行遍历，是考虑到字典的扩容和缩容时避免槽位的遍历重复和遗漏。</font></p>\n</li>\n<li>\n<p>返回值<br>\nSCAN返回一个包含<font color=\"blue\">两个元素的数组</font>，</p>\n<p>第一个元素是用于进行下一次迭代的新游标，<br>\n第二个元素则是一个数组，这个数组中包含了所有被迭代的元素。<font color=\"red\">如果新游标返回零表示迭代已结束。</font></p>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>多大算BigKey</p>\n</blockquote>\n<ul>\n<li>\n<p>通常我们说的BigKey，不是在值的Key很大，而是指的Key对应的value很大</p>\n</li>\n<li>\n<p>list、hash、set和zset，value的实际上个数超过5000就是bigkey</p>\n</li>\n<li>\n<p>string是value，理论上最大是512MB，但是  实际上 ≥10KB就是bigkey</p>\n</li>\n<li>\n<p>非字符串的bigkey,不要使用del删除，使用<code>hscan、sscan、zscan</code>方式渐进式删除，同时要注意防止bigkeyi过期时间自动删除问题</p>\n</li>\n</ul>\n<blockquote>\n<p>危害</p>\n</blockquote>\n<ul>\n<li>内存不均，集群迁移困难</li>\n<li>超时删除，大key删除作梗  ：对元素较多的hash、list、zset等做运算会耗时较旧，使主线程被阻塞</li>\n<li>网络流量阻塞 ：对BigKey执行读请求时，少量的QPS就可能导致带宽使用率被占满，导致Redis实例，乃至所在物理机变慢</li>\n<li>数据倾斜 ：   BigKey所在的Redis实例内存使用率远超其他实例，无法使数据分片的内存资源达到均衡</li>\n</ul>\n<blockquote>\n<p>发现</p>\n</blockquote>\n<ul>\n<li><font color=\"red\">–bigkeys参数 + （查询大于10kb的所有key）memory usage  [给出一个 <code>key</code> 和它的值在 内存 中所占用的字节数。] </font></li>\n</ul>\n<blockquote>\n<p>如何删除</p>\n</blockquote>\n<ul>\n<li>\n<p>String   一般用del，如果<code>过于庞大</code>使用<code>unlink key </code>删除</p>\n</li>\n<li>\n<p>hash    使用<code>hscan</code>每次获取少量<code>field-value</code>，再使用<code>hdel</code>删除每个<code>field</code></p>\n</li>\n<li>\n<p>list       使用<code>ltrim</code>渐进式逐步删除   [让列表只保留指定区间内的元素，不在指定区间之内的元素都将被除。]</p>\n</li>\n<li>\n<p>set      使用<code>sscan</code>每次获取部分元素，在使用<code>srem</code>命令删除每个元素</p>\n</li>\n<li>\n<p>zset     使用<code>zscan</code>每次获取部分元素，在使用<code>zremrangebyrank</code>命令删除每个元素</p>\n</li>\n</ul>\n<blockquote>\n<p>生产调优   — ”惰性释放“</p>\n</blockquote>\n<p>redis有两种删除的方式</p>\n<ul>\n<li>\n<p><code> del</code>    阻塞型删除</p>\n<blockquote>\n<p>这意味着服务器停止处理新命令，以便以同步方式回收与对象关联的所有内存。如果删除的键与一个小对象相关联，则执行DEL命令所需的时间非常短  ，Redis中的O(1)或O(Iog_N)命令。但是，如果键与包含数百万个元素的聚合值相关联，则服务器可能会阻塞很长时间（甚至几秒钟）才能完成操作。</p>\n</blockquote>\n</li>\n<li>\n<p><code>unlink </code> 非阻塞型删除</p>\n<blockquote>\n<p>基于上述原因，Redis还提供了非阻塞删除原语，例如<code>UNLINK</code>(非阻塞DEL)以及<code>FLUSHALL</code>和<code>FLUSHDB</code>命令的<code>ASYNC</code>选项，以便在后台回收内存。这些命令在恒定时间内执行。另一个线程将尽可能快地逐步释放后台中的对象。<code>FLUSHALL</code>和<code>FLUSHDB</code>的<code>DEL</code>、<code>UNLINK</code>和<code>ASYNC</code>选项是用户控<br>\n制的。</p>\n</blockquote>\n</li>\n</ul>\n<p>优化配置</p>\n<blockquote>\n<p><code>lazyfree-lazy-server-del        yes</code></p>\n<p><code>replica-lazy-flush              yes</code></p>\n<p><code>lazyfree-lazy-user-del          yes</code></p>\n</blockquote>\n<h2 id=\"缓存双写一致性\">缓存双写一致性</h2>\n<ul>\n<li>\n<p>如果redis中<font color=\"red\">有数据</font>    需要和数据库中的值相同</p>\n</li>\n<li>\n<p>如果redis中<font color=\"red\">无数据</font>     数据库中的值要是最新值，且准备回写redis</p>\n</li>\n</ul>\n<p>缓存按照操作来分，细分2种</p>\n<ul>\n<li>\n<p>只读缓存</p>\n</li>\n<li>\n<p>读写缓存</p>\n<ul>\n<li>\n<p>同步直写策略<code>[就是只要查到数据库就立刻回写到缓存，保持同步,及时生效]</code></p>\n<ul>\n<li>\n<p>写数据库之后也同步写redis缓存，缓存和数据库中的数据一致；</p>\n</li>\n<li>\n<p>对于读写缓存来说，要想保证缓存和数据库中的数据一致，就要采用<code>同步直写策略</code></p>\n</li>\n</ul>\n</li>\n<li>\n<p>异步缓写策略<code>[业务上有一定的延时允许]</code></p>\n<ul>\n<li>\n<p>正常业务中，MySQL数据变了，但是可以在业务上容许出现一定时间后才作用于redis，比如仓库、物流系统</p>\n</li>\n<li>\n<p>异常情况出现了， 不得不将失败的动作重新修补，有可能需要借助kafka或者RabbitMQ等消息中间件，实现重试重写</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><font color=\"red\">采用双检加锁策略</font></p>\n<blockquote>\n<p>没有加锁的隐患：</p>\n<ul>\n<li>对于mysql的请求会大量增加<code>（mysql会被打爆）</code></li>\n<li>对于redis 的回写操作可能会 数据覆盖（不是原子操作，多线程就会并发，引发问题）</li>\n</ul>\n</blockquote>\n<p>多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个<code>互斥锁</code>来锁住它。</p>\n<p>其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。</p>\n<p>后面的线程进来发现已经有缓存了，就直接走缓存。</p>\n<blockquote>\n<p>防止打爆<code>mysql</code></p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305252254716.png\" alt=\"image-20230525225420679\" style=\"zoom: 25%;\">\n</blockquote>\n<blockquote>\n<p>更新策略</p>\n</blockquote>\n<ul>\n<li>\n<p>目的 ： 我们要达到最终一致性</p>\n</li>\n<li>\n<p>弱一致性：</p>\n<ul>\n<li>使用redis的内存淘汰机制</li>\n<li>过期剔除： <font color=\"blue\">给缓存设置过期时间，定期清理缓存并回写，是保证最终一致性的解决方案。</font></li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>我们可以对存入缓存的数据设置过期时间，所有的<font color=\"gree\">写操作以数据库为准</font>，对缓存操作只是尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存，达到一致性，<font color=\"gree\">切记，要以mysql的数据库写入库为准</font>。</p>\n</blockquote>\n<ul>\n<li>\n<p>强一致性：</p>\n<ul>\n<li>\n<p>可以停机：停机升级，服务降级</p>\n</li>\n<li>\n<p>不可以停机：</p>\n<ul>\n<li>\n<p>四种策略</p>\n<ul>\n<li>\n<p>先更新数据库，在更新缓存</p>\n</li>\n<li>\n<p>先更新缓存，再更新数据库</p>\n</li>\n<li>\n<p>先删除缓存，在更新数据库</p>\n</li>\n<li>\n<p>先更新数据库，在删除缓存</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><span style=\"color:red\">先更新数据库，再更新缓存</span></p>\n</blockquote>\n<ul>\n<li>\n<p>异常问题1</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> 先更新mysql的某商品的库存，当前商品的库存是<span class=\"number\">100</span>，更新为<span class=\"number\">99</span>个。</span><br><span class=\"line\"><span class=\"number\">2</span> 先更新mysql修改为<span class=\"number\">99</span>成功，然后更新redis。</span><br><span class=\"line\"><span class=\"number\">3</span> 此时假设异常出现，更新redis失败了，这导致mysql里面的库存是<span class=\"number\">99</span>而redis里面的还是<span class=\"number\">100</span>。</span><br><span class=\"line\"><span class=\"number\">4</span> 上述情况发生之后，会让数据库里面和缓存redis里面数据不一致，读到redis脏数据</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>异常问题2</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">多线程环境下，A、B两个线程有快有慢，有前有后有并行</span><br><span class=\"line\"><span class=\"number\">1</span> A update mysql <span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"number\">3</span> B update mysql <span class=\"number\">80</span></span><br><span class=\"line\"><span class=\"number\">4</span> B update redis <span class=\"number\">80</span></span><br><span class=\"line\"><span class=\"number\">2</span> A update redis <span class=\"number\">100</span></span><br><span class=\"line\">=============================</span><br><span class=\"line\">最终结果，mysql和lredis数据不一致，  mysql  <span class=\"number\">80</span>,redis   <span class=\"number\">100</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p><span style=\"color:red\">先更新缓存，再更新数据库</span></p>\n <figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[异常逻辑]多线程环境下，A. B两个线程有快有慢有并行</span><br><span class=\"line\"> A update redis 100</span><br><span class=\"line\"> B update redis 80</span><br><span class=\"line\"> B update mysql 80</span><br><span class=\"line\"> A update mysql 100</span><br><span class=\"line\"> mysql 100,redis 80</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p><span style=\"color:red\"> 先删除缓存，再更新数据库 </span></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 A线程先成功删除了redis里面的数据，然后去更新mysql,此时mysql正在更新中，还没有结束。(比如网络延时)</span><br><span class=\"line\"> B突然出现要来读取缓存数据。</span><br><span class=\"line\"></span><br><span class=\"line\">2 此时redis里面的数据是空的，B线程来读取，先去读redis里数据(已经被A线程delete掉了)，</span><br><span class=\"line\"></span><br><span class=\"line\">此处出来2个问题:</span><br><span class=\"line\">\t2.1 B从mysql获得了旧值   B线程发现redis里没有(缓存缺失)马上去mysql里面读取，从数据库里面读取来的是旧值。</span><br><span class=\"line\">\t2.2 B会把获得的旧值写回redis  获得旧值数据后返回前台并回写进redis(刚被A线程删除的旧数据有极大可能早被写回了)。</span><br><span class=\"line\"></span><br><span class=\"line\">3 A线程更新完mysql,发现redis里面的缓存是脏数据，</span><br><span class=\"line\">两个并发操作，一个是更新操作，另一个是查询操作，A删除缓存后，B查询操作没有命中缓存，B先把老数据读出来后放到缓存中，然后A更新操作更新了数据库。于是，在缓存中的数据还是老的数据，导致缓存中的数据是脏的，而且还一直这样脏下去了。</span><br><span class=\"line\"></span><br><span class=\"line\">4总结流程:</span><br><span class=\"line\">(1)请求A进行写操作，删除redis缓存后，工作正在进行中，更新mysql..... A还没有彻底更新完mysql,还没commit</span><br><span class=\"line\">(2)请求B开工查询，查询redis发现缓存不存在(被A从redis中删除了)</span><br><span class=\"line\">(3)请求B继续，去数据库查询得到了mysql中的旧值(A还没有更新完)</span><br><span class=\"line\">(4)请求B将旧值写回redis缓存</span><br><span class=\"line\">(5)请求A将新值写入mysql数据库</span><br><span class=\"line\"></span><br><span class=\"line\">上述情况就会导致不一致的情形出现。</span><br></pre></td></tr></table></figure>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305252316603.png\" alt=\"image-20230525231633568\" style=\"zoom:33%;\">\n<ul>\n<li>问题：如果数据库更新失败或超时或返回不及时，导致B线程请求访问缓存时发现redis里面没数据，缓存缺失，B再去读取mysql时，从数据库中读取到旧值，还写回redis， 导致A白干了</li>\n</ul>\n</blockquote>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305262244890.png\" alt=\"image-20230526224429842\" style=\"zoom:35%;\">\n<blockquote>\n<p>延时双删</p>\n</blockquote>\n<p>$\\textcolor{blue}{\\large 先删除缓存，在更新数据库    的解决方案}$：</p>\n<p><font color=\"red\">采用<code>延时双删</code>[ 在第一次删除缓存值后，延迟一段时间再次进行删除]  策略 </font></p>\n<p>主要思想就是： 让一个线程删除前先进行休眠，并且其sleep的时间  需要大于另一个正在进行  <code>读取数据+ 写入缓存</code>的线程 的耗时之和</p>\n<p><font color=\"red\">追问</font></p>\n<ul>\n<li>\n<p><strong>这个删除该休眠多久呢</strong>？</p>\n<ul>\n<li>线程A sleep的时间，就需要大于线程B读取数据再写入缓存的时间。</li>\n</ul>\n</li>\n<li>\n<p><strong>这个时间怎么确定呢</strong>?<br>\n<font color=\"blue\">第一种方法：</font>在业务程序运行的时候，统计下线程读数据和写缓存的操作时间，<code>自行评估</code>自己的项目的读数据业务逻辑的耗时，以此为基础来进行估算。然后写数据的<code>休眠时间</code>则在<code>读数据业务逻辑的耗时基础上</code>加<code>百毫秒</code>即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。<br>\n<font color=\"blue\">第二种方法：</font><font color=\"blue\">新启动一个后台监控程序，比如后面要讲解的WatchDog监控程序，会加时</font></p>\n</li>\n<li>\n<p><strong>这种同步淘汰策略，吞吐量降低怎么办？</strong></p>\n<ul>\n<li>将第二次删除作为异步的，再启动一个线程进行异步删除，就可以不让写请求进行sleep 之后再返回，即可加大吞吐量</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305252331399.png\" alt=\"image-20230525233149371\" style=\"zoom:50%;\">\n</blockquote>\n<p>​</p>\n<blockquote>\n<p><span style=\"color:red\"> 先更新数据库，再删除缓存 </span></p>\n<table>\n<thead>\n<tr>\n<th>时间</th>\n<th>线程A</th>\n<th>线程B</th>\n<th>出现的问题</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>t1</td>\n<td>更新数据库中的值…</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>t2</td>\n<td></td>\n<td>缓存立刻命中，此时B读取的是缓存旧值</td>\n<td>A还没来得及删除缓存的值，导致B缓存命中读到旧值</td>\n</tr>\n<tr>\n<td>t3</td>\n<td>更新缓存的数据，over</td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>问题：先更新数据库，在删除缓存，假如缓存删除失败或者来不及删除，导致请求再次访问redis时缓存命中，<font color=\"red\">读取到的是缓存的旧值。</font></p>\n<p>解决：</p>\n<ul>\n<li>使用MQ</li>\n<li>订阅MySQL的 binlog程序，使用中间件<code>canal</code></li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305252337738.png\" alt=\"image-20230525233703703\" style=\"zoom:35%;\">\n<p>使用消息队列的基本思想</p>\n<ul>\n<li>可以把要删除的缓存值或者是要更新的数据库值<code>暂存</code>到<code>消息队列</code>中（例如使用Kafka/RabbitMQ等)。</li>\n<li>当程序没有能够成功地删除缓存值或者是更新数据库值时，可以从消息队列中重新读取这些值，然后再次进行删除或更新。</li>\n<li>如果<code>能够成功地删除或更新</code>，我们就要把这些值<code>从消息队列中去除</code>，以免重复操作，此时，我们也可以保证数据库和缓存的数据一致了，否则还需要再次进行重试</li>\n<li>如果<code>重试超过的一定次数后还是没有成功</code>，我们就需要向业务层发送报错信息了，通知运维人员。</li>\n</ul>\n<p>此种模式下严格意义上的 <code>强一致性</code>：</p>\n<ul>\n<li>如果业务层要求必须读取一致性的数据，那么我们就需要在更新数据库时，先在Redis缓存客户端暂停并发读请求，等数据库更新完、缓存值删除后，再读取数据，从而保证数据一致性</li>\n</ul>\n</blockquote>\n<p><font color=\"blue\" size=\"4\">只能达到最终一致性!!!</font></p>\n<p>$\\textcolor{red}{总结}$</p>\n<table>\n<thead>\n<tr>\n<th>策略</th>\n<th>高并发多线程条件下</th>\n<th>问题</th>\n<th>现象</th>\n<th>解决方案</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>先删除redis缓存，再更新mysql</td>\n<td>无</td>\n<td>缓存删除成功但数据库更新失败</td>\n<td>Java程序从数据库中读到旧值</td>\n<td>再次更新数据库，重试</td>\n</tr>\n<tr>\n<td>先删除redis缓存，再更新mysql</td>\n<td>有</td>\n<td>缓存删除成功但数据库更新中…有并发请求</td>\n<td>并发请求从数据库读到旧值并回写到redis，导致后续都是从redis读取到旧值</td>\n<td>延迟双删</td>\n</tr>\n<tr>\n<td>先更新mysql，再删除redis缓存</td>\n<td>无</td>\n<td>数据库更新成功，但缓存删除失败</td>\n<td>Java程序从redis中读到旧值</td>\n<td>再次删除缓存，重试</td>\n</tr>\n<tr>\n<td>先更新mysql，再删除redis缓存</td>\n<td>有</td>\n<td>数据库更新成功但缓存删除中…有并发读请求</td>\n<td>并发请求从缓存读到旧值</td>\n<td>等待redis删除完成，这段时间数据不一致，短暂存在。</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>主动更新的三种模式：</p>\n<ul>\n<li>\n<p>Cache Aside Pattern 旁路缓存模式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案</p>\n</li>\n<li>\n<p>Read/Write Through Pattern 读写穿透模式: 由系统本身完成，数据库与缓存的问题交由系统本身去处理</p>\n</li>\n<li>\n<p>Write Behind Caching Pattern 异步缓存写入模式：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致</p>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>如何保证缓存与数据库的操作的同时成功或失败</p>\n<ul>\n<li>单体系统，将缓存与数据库操作放在一个<code>事务</code></li>\n<li>分布式系统，利用<code>TCC等分布式事务</code>方案</li>\n</ul>\n</blockquote>\n<hr>\n<h2 id=\"Bitmap-Hyperloglog-GEO\">Bitmap  Hyperloglog  GEO</h2>\n<blockquote>\n<p>常见的四种统计</p>\n</blockquote>\n<ul>\n<li>\n<p>聚合统计       统计多个集合元素的聚合结果  <font color=\"red\">交差并等集合统计</font></p>\n</li>\n<li>\n<p>排序统计       在面对需要展示最新列表、排行榜等场景时，如果数据更新频繁或者需要分页显示，建议使用ZSet</p>\n</li>\n<li>\n<p>二值统计       集合元素的取值就只有0和1两种。在钉钉上签到打卡的场景中，我们只用记录有签到(1)或没有签单(0)</p>\n</li>\n<li>\n<p>基数统计       指统计一个集合中<font color=\"red\">不重复的元素个数</font>，就是对集合去重复后剩余元素的计算</p>\n</li>\n</ul>\n<blockquote>\n<p>Hyperloglog</p>\n</blockquote>\n<ul>\n<li>\n<p>什么是UV           Unique Visitor，独立访客，一般理解为客户端IP      <font color=\"red\">需要去重考虑</font></p>\n</li>\n<li>\n<p>什么是PV            Page View，页面浏览量        不用去重</p>\n</li>\n<li>\n<p>什么是DAU        Daily Active User，日活跃量用户，<font color=\"red\">登录或者使用了某个产品的用户数（去重复登录的用户）</font>    常用于反映网站、互联网应用或者网络游戏的运营情况</p>\n</li>\n<li>\n<p>什么是MAU        Monthly Active User，月活跃用户量</p>\n</li>\n</ul>\n<p>引入：</p>\n<ul>\n<li>去重方式\n<ul>\n<li>HashSet</li>\n<li>bitmap： 所占内存巨大；bitmaps还是不适用大数据量下(亿级)的基数计数场景，<font color=\"red\">但是bitmaps方法是精确计算的。</font></li>\n</ul>\n</li>\n</ul>\n<p>解决：</p>\n<ul>\n<li>概率算法\n<ul>\n<li><font color=\"red\">通过牺牲准确率来换取空间</font>，对于不要求<font color=\"blue\">绝对准确率</font>的场景下可以使用，因为<font color=\"red\">概率算法不直接存储数据本身</font>，通过一定的概率统计方法预估基数值，同时保证误差在一定范围内，由于又不储存数据故此可以大大节约内存.</li>\n</ul>\n</li>\n</ul>\n<p>原理</p>\n<ul>\n<li>\n<p>只是进行不重复的基数统计，不是集合也不保存数据，只记录数量而不是具体内容</p>\n</li>\n<li>\n<p>有误差，但是很低 0.81% （<code>1.04/sqrt(16384)</code>）；HyperLogLog提供不精确的去重计数方案</p>\n</li>\n</ul>\n<blockquote>\n<p>亿级UV的Redis设计方案</p>\n</blockquote>\n<p>不可行的方案：</p>\n<ul>\n<li>MySQL   高并发下，3000万的数据就需要分库分表了</li>\n<li>redis的hash结构存储   太占内存了</li>\n</ul>\n<p>可行的方案：</p>\n<ul>\n<li>HyperLogLog   在Redis里面，每个HyperLogLog键只需要花费12KB内存，就可以计算接近2<sup>64</sup>个不同元素的基数</li>\n</ul>\n<blockquote>\n<p>为什么是只需要花费12Kb?</p>\n<p>Redist使用了2<sup>14</sup>=16384个桶，按照上面的标准差，误差为0.81%，精度相当高。Redis使用一个log型哈希值的前14个比特用来确定桶编号，剩下的50个比特用来做基数估计。而2<sup>6</sup>=64，所以只需要用6个比特表示下标值，在一般情况下，一个HLL数据结构(每个桶占6位)占用内存的大小为16384*6/8=12kB,Redis将这种情况称为密集(dense)存储。</p>\n</blockquote>\n<h2 id=\"布隆过滤器\">布隆过滤器</h2>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305262258692.png\" alt=\"image-20230526225827642\" style=\"zoom:43%;\">\n<blockquote>\n<p>面试问题：</p>\n<ul>\n<li>现有50亿个电话号码，给你10万个电话号码，如何要<code>快速准确</code>的判断这些电话号码是否已经存在？</li>\n<li><code>判断是否存在</code>，布隆过滤器了解过吗？</li>\n<li>安全连接网址，全球数10亿的网址判断</li>\n<li>黑名单校验，识别垃圾邮件</li>\n<li>白名单校验，识别出合法用户进行后续处理</li>\n</ul>\n</blockquote>\n<h3 id=\"textcolor-red-是什么\">$\\textcolor{red}{是什么}$</h3>\n<ul>\n<li>由<code>一个初值都为零的bit数组</code>和<code>多个哈希函数构成</code>，用来快速判断集合中是否存在某个元素</li>\n</ul>\n<h3 id=\"textcolor-red-目的\">$\\textcolor{red}{目的}$</h3>\n<ul>\n<li>减少内存占用；不保存数据信息，只是在内存中做一个是否存在的标记flag</li>\n</ul>\n<h3 id=\"textcolor-red-特点\">$\\textcolor{red}{特点}$</h3>\n<ul>\n<li>可以高效地插入和查询，占用空间少，返回的结果是不确定性</li>\n<li>一个元素的判断结果：判断结果为<code>存在</code>时，元素<code>不一定存在</code>，但是判断结果为<code>不存在</code>时，则<code>一定不存在</code></li>\n<li>布隆过滤器可以添加元素，但是<font color=\"red\">不能删除元素，</font>由于涉及<code>hashcode</code>判断依据，删除元素会导致误判率增加。</li>\n</ul>\n<h3 id=\"textcolor-red-原理\">$\\textcolor{red}{原理}$</h3>\n<ul>\n<li>实质就是<font color=\"red\">一个大型位数组和几个不同的无偏hash函数</font>(无偏表示分布均匀)。由一个初值都为零的bit数组和多个哈希函数构成，用来快速判断某个数据是否存在。但是跟 HyperLogLog 一样，它也一样有那么一点不精确，也存在一定的误判概率</li>\n</ul>\n<h3 id=\"textcolor-red-数据结构\">$\\textcolor{red}{数据结构}$</h3>\n<ul>\n<li><font color=\"blue\">添加key时</font><br>\n使用<code>多个</code>hash函数对<code>key</code>进行<code>hash</code>运算得到一个整数索引值，对<code>位数组</code>长度进行<code>取模</code>运算得到一个位置，每个<code>hash函数</code>都会得到一个不同的位置，将这<code>几个位置</code>都置<code>1</code>就完成了<code>add</code>操作。</li>\n<li><font color=\"blue\">查询key时</font><br>\n只要有其中一位是零就表示这个key不存在，但如果都是1，则不一定存在对应的值</li>\n<li>hash冲突导致数据不精准\n<ul>\n<li>直接原因就在于 <code>哈希函数</code>会导致<code>哈希冲突</code></li>\n<li>当有变量被加入集合时，通过<code>N个映射函数</code>将这个变量映射成位图中的<code>N个点</code>,把它们都要置为 1，当查询某个变量的时候我们只要看看这些点是不是都是 <code>1</code>，就可以大概率知道集合中有没有它了；如果这些点，<font color=\"red\">有任何一个为零则被查询变量一定不在;</font>如果都是 1，则被查询变量很<font color=\"red\">可能存在</font>，<br>\n<font color=\"red\">为什么说是可能存在，而不是一定存在呢?那是因为<code>映射函数本身就是散列函数</code>，<code>散列函数是会有碰撞的</code>。</font></li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>正是基于布隆过滤器的<code>快速检测特性</code>，我们可以在把数据写入数据库时，使用布隆过滤器做个标记。</p>\n<p>当缓布缺失后，应用查询数据库时，可以通过查询布隆过滤器快速判断数据是否存在。</p>\n<p>如果不存在，就不用再去据库中查询了。</p>\n<p>这样一来，即使发生缓存穿透了，大量请求只会查询Redis和布隆过滤器，而不会积压到数据库，也就不会影响数据库的正常运行。</p>\n<p>布隆过滤器可以使用Redis实现，本身就能承担较大的并发访问压力</p>\n</blockquote>\n<h3 id=\"textcolor-red-如何使用\">$\\textcolor{red}{如何使用}$</h3>\n<ul>\n<li>初始化bitmap       所有的值均设置为0</li>\n<li>添加数据                为了尽量地址不冲突，<font color=\"red\">会使用多个 hash 函数对 key 进行运算</font>，算得一个下标索引值，然后对位数组长度进行<font color=\"red\">取模运算</font>得到一个位置，每个 hash 函数都会算得一个不同的位置。再把位数组的这几个位置都置为 1 就完成了 add 操作。</li>\n<li>判断是否存在         先把这个 key 通过相同的<font color=\"red\">多个 hash 函数进行运算</font>，查看对应的位置是否都为 1，<font color=\"red\">只要有一个位为零，那么说明布隆过滤器中这个 key 不存在；</font><font color=\"red\">如果这几个位置全都是 1，那么说明极有可能存在；</font></li>\n</ul>\n<h3 id=\"textcolor-red-即使误判也不要删除\">$\\textcolor{red}{即使误判也不要删除}$</h3>\n<ul>\n<li>误判的根源在于相同的 bit 位被多次映射且置 1</li>\n<li>布隆过滤器的每一个 bit 并不是独占的，很有可能多个元素共享了某一位。如果我们直接删除这一位的话，会影响其他的元素</li>\n<li>删掉元素会导致误判率增加。</li>\n</ul>\n<h3 id=\"textcolor-red-建议\">$\\textcolor{red}{建议}$</h3>\n<ul>\n<li>使用时最好不要让实际元素数量远大于初始化数量，一次给够避免扩容</li>\n<li>当实际元素数量超过初始化数量时，应该对布隆过滤器进行重建，重新分配一个size 更大的过滤器，再将所有的历史元素批量add进行</li>\n</ul>\n<h3 id=\"textcolor-red-使用场景\">$\\textcolor{red}{使用场景}$</h3>\n<ol>\n<li>\n<p><font color=\"red\"> 解决缓存穿透的问题，和redis结合bitmap使用</font></p>\n<ul>\n<li>\n<p>思路</p>\n<ul>\n<li>\n<p>把已存在数据的key存在布隆过滤器中，相当于redis前面挡着一个布隆过滤器。当有新的请求时，先到布隆过滤器中查询是否存在:</p>\n<p>如果布隆过滤器中<code>不存在</code>该条数据则直接返回;如果布隆过滤器中<code>已存在</code>，才去查询缓存redis，如果redis里没查询到则再查询Mysql数据库</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><font color=\"red\"> 黑名单校验，识别垃圾邮件</font></p>\n<ul>\n<li>思路\n<ul>\n<li>发现存在黑名单中的，就执行特定操作。比如:识别垃圾邮件，只要是邮箱在黑名单中的邮件，就识别为垃圾邮件。把所有黑名单都放在布隆过滤器中，在收到邮件时，判断邮件地址是否在布隆过滤器中即可。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p><font color=\"red\">优点：</font></p>\n<ul>\n<li>高效地插入和查询，内存中占用bit空间小</li>\n</ul>\n<p>劣</p>\n<ul>\n<li>不能删除元素[布谷鸟过滤器可以删除]，因为删除元素会导致误判率增加，因为hash冲突同一个位置可能存的东西是多个共有的</li>\n<li>存在误差，不能 精准 过滤</li>\n</ul>\n<h2 id=\"缓存四问\">缓存四问</h2>\n<h5 id=\"预热\">预热</h5>\n<p><font color=\"red\">是什么</font></p>\n<ul>\n<li>缓存预热就是系统上线后，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</li>\n</ul>\n<p><font color=\"red\">怎么做</font></p>\n<ul>\n<li>将热点数据提前加载到<code>redis</code>缓存中，可以通过<code>@PostConstruct</code>提前在运行某个程序之前，将其加载到<code>redis</code>中</li>\n<li>或者使用 <code>预加载类在程序启动的时候 </code>存到<code>redis</code>中</li>\n</ul>\n<h5 id=\"雪崩\">雪崩</h5>\n<p><font color=\"red\">是什么</font></p>\n<ul>\n<li>缓存雪崩就是同一时段大量的缓存<code>key</code>同时失效或者<code>Redis服务宕机</code>，导致大量请求到达数据库，给数据库带来巨大压力。</li>\n</ul>\n<p><font color=\"red\">何时发生</font></p>\n<ul>\n<li>Redis主机挂了，Redis全盘崩溃</li>\n<li>Redis中有大量<code>key同时</code>过期<code>大面积失效</code>，</li>\n</ul>\n<p><font color=\"red\">解决 与 预防</font></p>\n<ul>\n<li>\n<p>Redis中key设置为<code>永不过期</code>或者过期时间为<code>指定时间+随机时间</code>，<code>错开同时过期的概率</code></p>\n</li>\n<li>\n<p>Redis缓存集群实现高可用 [ <code>主从+哨兵</code>   <code>集群</code>  <code>开启Redis持久化机制AOF/RDB，尽快恢复缓存集群</code>]</p>\n</li>\n<li>\n<p>多级缓存结合预防雪崩   <code>ehcache本地缓存 + Redis缓存</code></p>\n</li>\n<li>\n<p>服务降级               <code>Hystrix</code>或者阿里<code>sentinel</code>限流&amp;降级</p>\n</li>\n</ul>\n<h5 id=\"击穿-redis-先有后失效\">击穿&lt;redis 先有后失效&gt;</h5>\n<p><font color=\"red\">是什么</font></p>\n<ul>\n<li>大量请求同时查询一个key时，此时这个key正好失效了，就会导致大量的请求都打到数据库，<font color=\"red\">就是热点key突然失效了，MySQL压力增加</font></li>\n</ul>\n<p><font color=\"red\">热点key失效可能</font></p>\n<ul>\n<li>时间到了自然清除但还是被访问到</li>\n<li>delete掉的key，刚好又被访问到</li>\n</ul>\n<p><font color=\"red\">解决</font></p>\n<ul>\n<li>方案一：差异失效时间，对于访问频繁的热点key，干脆就<code>不设置过期时间</code>   而是设置逻辑过期时间，但是会有一定的数据不一致性</li>\n<li><font color=\"red\">方案二：互斥更新，采用双检加锁策略</font>        多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个互斥锁来锁住它。其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存</li>\n<li>互斥锁</li>\n</ul>\n<h5 id=\"穿透-两库都没\">穿透&lt;两库都没&gt;</h5>\n<p><font color=\"red\">是什么</font></p>\n<ul>\n<li>请求去查询一条记录，先查redis，后查mysql，都查询不到，说明数据源是不存在的，但是请求每次都会打到数据库上面去，导致后台数据库压力暴增，这种现象我们称为缓存穿透</li>\n</ul>\n<p><font color=\"red\">解决</font></p>\n<ul>\n<li>可以空对象缓存\n<ul>\n<li>回写增强: 如果发生了缓存穿透，我们可以针对要查询的数据，在Redis里存一个规定的缺省值(比如,零、负数、defaultNull等)\n<ul>\n<li>第一次来查询一旦 <code>redis</code>和<code>mysql</code>都没有，返回<code>nul</code>给<code>调用者</code>，同时也让<code>redis</code>存入刚刚查不到的<code>key</code>，并对应的填上<code>规定的缺省值</code>，那么第二次来查，此时redis就有值了。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>\n<p>一旦多次穿透，redis就会有很多 垃圾 key ，占用内存（可以设置ttl定期删除），</p>\n</li>\n<li>\n<p>但是因为这个<code>ttl</code> 可能会导致数据短期的不一致性 [mysql新增数据的时候同时存到redis,同样会有内存问题]</p>\n</li>\n</ul>\n<p>所以没有根本不能解决问题</p>\n</blockquote>\n<ul>\n<li>使用布隆过滤器(<code>Guava</code>)</li>\n</ul>\n<h5 id=\"小结：\">小结：</h5>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305261302771.png\" alt=\"image-20230526130227733\" style=\"zoom:33%;\">\n<hr>\n<h2 id=\"缓存策略\">缓存策略</h2>\n<blockquote>\n<p>Redis 过期键的删除策略</p>\n</blockquote>\n<ul>\n<li>\n<p>立即删除      对CPU不友好，用处理器性能换取存储空间（拿时间换空间）</p>\n</li>\n<li>\n<p>惰性删除      对memory 不友好，用存储空间换取处理器性能（拿空间换时间）</p>\n</li>\n<li>\n<p>定期删除    每隔一段时间执行一次删除过期键操作并通过限制删除操作执行时长和频率来减少删除操作对CPU时间的影响。定期抽样key，判断是否过期</p>\n<ul>\n<li>\n<p>定期清理的两种模式：</p>\n<p>SLOW模式执行频率默认为10，每次不超过25ms</p>\n<p>FAST模式执行频率不固定，但两次间隔不低于2ms，每次耗时不超过1ms</p>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>redis 缓存淘汰策略</p>\n</blockquote>\n<p>主要两类：</p>\n<ul>\n<li>LRU   最近最少使用的页面置换算法，淘汰最长时间未被使用的页面，看页面最后一次被使用到发生调度的时间长短，首先淘汰最长时间未被使用的页面</li>\n<li>LFU   最近最不常用页面置换算法，淘汰一定时期内被访问次数最少的页面，看一定时间段内被访问次数最少的页，看一定时间段内页面被使用的频率，淘汰一定时期内被访问次数最少的页</li>\n</ul>\n<p>细分8类：</p>\n<ul>\n<li>noevication ： 不会驱逐任何key，表示即使内存达到上限也不进行置换，所有能引起内存增加的命令都返回 error，<code>默认</code>就是这种策略。</li>\n<li><code>allkeys-lru</code>： 对所有key使用 LRU算法进行删除，优先删除掉最近不经常使用的key，用以保存新数据  <code>工作中常用</code></li>\n<li>volatie-lru : 对所有设置了过期时间的key使用LRU 算法删除</li>\n<li>allkeys-random ：对所有key随机删除</li>\n<li>volatie-random ： 对所有设置了过期时间的key随机删除</li>\n<li>volatie-ttl ：对所有设置了过期时间的key随即删除</li>\n<li>allkeys-lfu：对所有key使用LFU算法进行删除</li>\n<li>volatile-lfu：对所有设置了过期时间的key使用LFU算法进行删除</li>\n</ul>\n<blockquote>\n<p>上面8种模式:   2 * 4 得8、2个维度(过期键中筛选、所有键中筛选)、4个方面(LRU、LFU、random、ttl)、8个选项</p>\n</blockquote>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305272231603.png\" alt=\"image-20230527223142532\" style=\"zoom:35%;\">\n<blockquote>\n<p>选择原则；</p>\n</blockquote>\n<ul>\n<li>\n<p>在所有的key都是最近最经常使用，那么就需要选择<code>allkeys-lru</code>进行置换最近最不经常使用的key,如果你不确定使用哪种策略，那么推荐使用<code>allkeys-lru</code></p>\n</li>\n<li>\n<p>如果所有的key的访问概率都是差不多的，那么可以选用<code>allkeys-random</code>策略去置换数据</p>\n</li>\n<li>\n<p>如果对数据有足够的了解，能够为key指定<code>hint</code>(通过<code>expire/ttl</code>指定)，那么可以选择<code>volatile-ttl</code>进行置换</p>\n</li>\n</ul>\n<blockquote>\n<p>使用建议</p>\n</blockquote>\n<ul>\n<li>避免存储bigkey</li>\n<li>redis缓存淘汰策略配置性能建议开启橢性淘汰，<code>lazyfree-lazy-eviction=yes</code></li>\n</ul>\n<hr>\n<h2 id=\"IO多路复用和epoll-黑马-redis-160-171\">IO多路复用和epoll[==黑马 redis 160-171==]</h2>\n<p><font color=\"red\">是什么</font><br>\nI/O  : 网络 I/O<br>\n多路 : 多个客户端连接（连接就是套接字描述符，即socket 或者 channel），指的是多条 TCP 连接<br>\n复用:    用一个进程来处理多条的连接，使用单进程就能实现同时处理多个客户端的连接<br>\nIO多路复用: 实现了用一个进程来处理大量的用户连接</p>\n<p>文件描述符（File Descriptor）：简称FD，是一个从0 开始的无符号整数，用来关联Linux中的一个文件。在Linux中，一切皆文件。</p>\n<p><font color=\"red\">定义</font></p>\n<p>IO多路复用是利用单个线程来同时监听多个FD，并在某个FD可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。不过监听FD的方式、通知的方式又有多种实现，常见的有：</p>\n<ul>\n<li>select</li>\n<li>poll</li>\n<li>epoll</li>\n</ul>\n<p>其中select和pool相当于是当被监听的数据准备好之后，他会把你监听的FD整个数据都发给你，你需要到整个FD中去找，哪些是处理好了的，需要通过遍历的方式，所以性能也并不是那么好</p>\n<p>而epoll，则相当于内核准备好了之后，他会把准备好的数据，直接发给你，省去了遍历的动作。</p>\n<p><font color=\"red\">差异</font></p>\n<ul>\n<li>select和poll只会通知用户进程有FD就绪，但不确定具体是哪个FD,需要用户进程逐个遍历FD来确认</li>\n<li>epol则会在通知用户进程FD就绪的同时，把已就绪的FD写入用户空间</li>\n</ul>\n<p><code>Select</code></p>\n<p>存在的问题：</p>\n<ul>\n<li>需要将整个fd_set从用户空间拷贝到内核空间，select结束还要再次拷贝回用户空间<code>2次拷贝</code></li>\n<li>select无法得知具体是哪个fd就绪，需要遍历整个fd set    <code>知道有几个就绪 但是不知道具体是谁就绪了</code></li>\n<li>fd set监听的fd数量不能超过1024  <code>数量上有限制</code></li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305272140038.png\" alt=\"image-20230527214058848\" style=\"zoom:35%;\">\n<p><code>poll</code></p>\n<p>IO流程： &lt;和select差不多,唯一的改进就是 增加了监听的fd 数量，但是  监听FD越多，每次遍历消耗时间也越久，性能反而会下降 &gt;</p>\n<ul>\n<li>创建pollfd数组，向其中添加关注的fd信息，数组大小自定义</li>\n<li>调用poll函数，将pollfd数组拷贝到内核空间，转链表存储，<code>无上限</code></li>\n<li>内核遍历fd，判断是否就绪</li>\n<li>数据就绪或超时后，拷贝pollfd数组到用户空间，返回就绪fd数量n</li>\n<li>用户进程判断n是否大于0,大于0则遍历pollfd数组，找到就绪的fd数量</li>\n</ul>\n<p><code>epoll</code>  是非阻塞的</p>\n<ul>\n<li>\n<p>大大减少了fd拷贝的次数，大大减少了fd拷贝的数量</p>\n</li>\n<li>\n<p>监听的FD理论上无上限</p>\n</li>\n</ul>\n<blockquote>\n<p>多路复用快的原因在于，操作系统提供了<code>epoll</code>系统调用，使得原来的whi训e循环里多次系统调用，变成了<code>一次系统调用+内核层遍历这些文件描述符</code></p>\n<p>epoll 将拷贝与等待分开了</p>\n<p>epoll_ctl:  进行拷贝，只会拷贝一次</p>\n<p>epoll_wait:  等待就绪，之后每次只调用<code>epoll_wait</code>进行等待就可以了，无需再次拷贝</p>\n</blockquote>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305280012901.jpg\" alt></p>\n<p><code>总结</code></p>\n<blockquote>\n<p>select模式存在的三个问题：</p>\n</blockquote>\n<ul>\n<li>能监听的FD最大不超过1024</li>\n<li>每次select都需要把所有要监听的FD都拷贝到内核空间</li>\n<li>每次都要遍历所有FD来判断就绪状态</li>\n</ul>\n<blockquote>\n<p>poll模式的问题：</p>\n</blockquote>\n<ul>\n<li>poll利用链表解决了select中监听FD上限的问题，但依然要遍历所有FD，如果监听较多，性能会下降</li>\n</ul>\n<blockquote>\n<p>epoll模式中如何解决这些问题的？</p>\n</blockquote>\n<ul>\n<li>基于epoll实例中的<code>红黑树</code>保存要监听的FD，理论上无上限，而且增删改查效率都非常高</li>\n<li>每个FD只需要执行一次<code>epoll_ctl</code>添加到<code>红黑树</code>，以后每次<code>epol_wait</code>无需传递任何参数，无需重复拷贝<code>FD</code>到内核空间</li>\n<li>利用<code>ep_poll_callback</code>机制来监听FD状态，无需遍历所有FD，因此性能不会随监听的FD数量增多而下降</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305280006087.png\" alt=\"image-20230528000644005\" style=\"zoom: 43%;\">\n<p><font color=\"red\">事件通知机制</font></p>\n<p>当FD有数据可读时，我们调用epoll_wait（或者select、poll）可以得到通知。但是事件通知的模式有两种：</p>\n<ul>\n<li>LevelTriggered：简称LT，也叫做水平触发。只要某个FD中有数据可读，每次调用epoll_wait都会得到通知。</li>\n<li>EdgeTriggered：简称ET，也叫做边沿触发。只有在某个FD有状态变化时，调用epoll_wait才会被通知。</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305272209829.png\" alt=\"image-20230527220918750\" style=\"zoom:45%;\">\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305272214385.png\" alt=\"image-20230527221455305\" style=\"zoom:43%;\">\n<p><strong>为什么Redis要选择单线程？</strong></p>\n<ul>\n<li>抛开持久化不谈，Redis是纯  内存操作，执行速度非常快，它的性能瓶颈是网络延迟而不是执行速度，因此多线程并不会带来巨大的性能提升。</li>\n<li>多线程会导致过多的上下文切换，带来不必要的开销</li>\n<li>引入多线程会面临线程安全问题，必然要引入线程锁这样的安全手段，实现复杂度增高，而且性能也会大打折扣</li>\n</ul>\n<blockquote>\n<p>Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器。</p>\n<p>Reactor 模式，是指通过一个或多个输入同时传递给服务处理器的服务请求的事件驱动处理模式。服务端程序处理传入多路请求，并将它们同步分派给请求对应的处理线程，Reactor 模式也叫 Dispatcher 模式</p>\n</blockquote>\n<blockquote>\n<p><code>redis网络模型</code>[171]</p>\n</blockquote>\n<hr>\n<h2 id=\"源码-145-164\">源码[145-164]</h2>\n<blockquote>\n<p>redis6 数据结构</p>\n</blockquote>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305261720514.png\" alt=\"image-20230526172020470\" style=\"zoom:33%;\">\n<blockquote>\n<p>redis7    数据结构</p>\n</blockquote>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305261718238.png\" alt=\"image-20230526171836200\" style=\"zoom:33%;\">\n<blockquote>\n<p>时间复杂度</p>\n</blockquote>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305261721602.png\" alt=\"image-20230526172050397\" style=\"zoom:25%;\">\n<blockquote>\n<p>redis数据结构</p>\n</blockquote>\n<h4 id=\"动态字符串\">动态字符串</h4>\n<ul>\n<li>获取字符串长度的时间复杂度为O(1)</li>\n<li>支持动态扩容</li>\n<li>减少内存分配次数</li>\n<li>二进制安全</li>\n</ul>\n<h4 id=\"intset\">intset</h4>\n<ul>\n<li>Redis会确保Intset中的元素唯一、有序</li>\n<li>具备类型升级机制，可以节省内存空间</li>\n<li>底层采用二分查找方式来查询</li>\n</ul>\n<h4 id=\"Dict\">Dict</h4>\n<p>键与值的映射关系正是通过Dict来实现的</p>\n<p>Dict由三部分组成，分别是：哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）</p>\n<p>Dict的伸缩：</p>\n<ul>\n<li>当LoadFactor大于5或者LoadFactor大于1并且没有子进程任务时，Dict扩容</li>\n<li>当LoadFactor小于0.1时，Dict收缩</li>\n<li>扩容大小为第一个大于等于used + 1的2^n</li>\n<li>收缩大小为第一个大于等于used 的2^n</li>\n<li>Dict采用渐进式rehash，每次访问Dict时执行一次rehash</li>\n<li>rehash时ht[0]只减不增，新增操作只在ht[1]执行，其它操作在两个哈希表</li>\n</ul>\n<h4 id=\"ZipList\">ZipList</h4>\n<p>一种特殊的“双端链表” ,由一系列特殊编码的连续内存块组成。可以在任意一端进行压入/弹出操作, 并且该操作的时间复杂度为 O(1)。</p>\n<p><strong>ZipList特性：</strong></p>\n<ul>\n<li>压缩列表的可以看做一种连续内存空间的&quot;双向链表&quot;</li>\n<li>列表的节点之间不是通过指针连接，而是记录上一节点和本节点长度来寻址，内存占用较低</li>\n<li>如果列表数据过多，导致链表过长，可能影响查询性能</li>\n<li>增或删较大数据时有可能发生连续更新问题</li>\n</ul>\n<h4 id=\"QuickList\">QuickList</h4>\n<p>问题1：ZipList虽然节省内存，但申请内存必须是连续空间，如果内存占用较多，申请内存效率很低。怎么办？</p>\n<p>​\t答：为了缓解这个问题，我们必须限制ZipList的长度和entry大小。</p>\n<p>问题2：但是我们要存储大量数据，超出了ZipList最佳的上限该怎么办？</p>\n<p>​\t答：我们可以创建多个ZipList来分片存储数据。</p>\n<p>问题3：数据拆分后比较分散，不方便管理和查找，这多个ZipList如何建立联系？</p>\n<p>​\t答：Redis在3.2版本引入了新的数据结构QuickList，它是一个双端链表，只不过链表中的每个节点都是一个ZipList。</p>\n<p>特点</p>\n<ul>\n<li>是一个节点为ZipList的双端链表</li>\n<li>节点采用ZipList，解决了传统链表的内存占用问题</li>\n<li>控制了ZipList大小，解决连续内存空间申请效率问题</li>\n<li>中间节点可以压缩，进一步节省了内存</li>\n</ul>\n<h4 id=\"SkipList\">SkipList</h4>\n<p>SkipList（跳表）首先是链表，但与传统链表相比有几点差异：</p>\n<ul>\n<li>元素按照升序排列存储</li>\n<li>节点可能包含多个指针，指针跨度不同。</li>\n</ul>\n<p>SkipList的特点：</p>\n<ul>\n<li>跳跃表是一个双向链表，每个节点都包含score和ele值</li>\n<li>节点按照score值排序，score值一样则按照ele字典排序</li>\n<li>每个节点都可以包含多层指针，层数是1到32之间的随机数</li>\n<li>不同层指针到下一个节点的跨度不同，层级越高，跨度越大</li>\n<li>增删改查效率与红黑树基本一致，实现却更简单</li>\n</ul>\n<h4 id=\"RedisObject\">RedisObject</h4>\n<p>Redis中的任意数据类型的键和值都会被封装为一个RedisObject，也叫做Redis对象</p>\n<h3 id=\"String\">String</h3>\n<ul>\n<li>\n<p>其基本编码方式是RAW，基于简单动态字符串（SDS）实现，存储上限为512mb。</p>\n</li>\n<li>\n<p>底层实现⽅式：动态字符串sds 或者 long</p>\n<ul>\n<li>String的内部存储结构⼀般是sds（Simple Dynamic String，可以动态扩展内存），但是如果⼀个String类型的value的值是数字，那么Redis内部会把它转成long类型来存储，从⽽减少内存的使用。</li>\n<li>如果存储的字符串是整数值，并且大小在LONG_MAX范围内，则会采用INT编码：直接将数据保存在RedisObject的ptr指针位置（刚好8字节），不再需要SDS了</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"List\">List</h3>\n<ul>\n<li>List结构类似一个双端链表，可以从首、尾操作列表中的元素：</li>\n</ul>\n<h3 id=\"set\">set</h3>\n<ul>\n<li>\n<p>底层数据结构： HashTable，也就是Redis中的Dict，不过Dict是双列集合（可以存键、值对）</p>\n</li>\n<li>\n<p>为了查询效率和唯一性，set采用HT编码（Dict）。Dict中的key用来存储元素，value统一为null。</p>\n</li>\n<li>\n<p>当存储的所有数据都是整数，并且元素数量不超过set-max-intset-entries时，Set会采用IntSet编码，以节省内存</p>\n</li>\n</ul>\n<h3 id=\"zset\">zset</h3>\n<ul>\n<li>\n<p>底层数据结构：</p>\n<p>SkipList：可以排序，并且可以同时存储score和ele值（member）</p>\n<p>HT（Dict）：可以键值存储，并且可以根据key找value</p>\n</li>\n<li>\n<p>ziplist本身没有排序功能，而且没有键值对的概念，因此需要有zset通过编码实现：</p>\n<ul>\n<li>ZipList是连续内存，因此score和element是紧挨在一起的两个entry， element在前，score在后</li>\n<li>score越小越接近队首，score越大越接近队尾，按照score值升序排列</li>\n</ul>\n</li>\n<li>\n<p>当元素数量不多时，HT和SkipList的优势不明显，而且更耗内存。因此zset还会采用ZipList结构来节省内存，不过需要同时满足两个条件：</p>\n<ul>\n<li>元素数量小于zset_max_ziplist_entries，默认值128</li>\n<li>每个元素都小于zset_max_ziplist_value字节，默认值64</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"hash\">hash</h3>\n<ul>\n<li>与Redis中的Zset非常类似：\n<ul>\n<li>都是键值存储</li>\n<li>都需求根据键获取值</li>\n<li>键必须唯一</li>\n</ul>\n</li>\n<li>区别\n<ul>\n<li>zset的键是member，值是score；hash的键和值都是任意值</li>\n<li>zset要根据score排序；hash则无需排序</li>\n</ul>\n</li>\n<li>底层实现方式：压缩列表ziplist 或者 字典dict，当Hash中数据项比较少的情况下，Hash底层才⽤压缩列表ziplist进⾏存储数据，随着数据的增加，底层的ziplist就可能会转成dict</li>\n</ul>\n<hr>\n<h2 id=\"实战\">实战</h2>\n<h4 id=\"商户查询缓存\">商户查询缓存</h4>\n<ul>\n<li>\n<p>先查缓存，没有就去查数据库，并且写回到缓存中(<code>string</code> 存的是 <code>id+商品信息</code>)</p>\n</li>\n<li>\n<p><code>使用事务+ 先更新数据库再删除缓存</code>  保证数据的一致性</p>\n</li>\n<li>\n<p>为了解决缓存穿透的问题，在上面查询redis的数据的时候查不到 要将“空值”写到redis中</p>\n</li>\n<li>\n<p>为了解决缓存击穿的问题：</p>\n<ul>\n<li>互斥锁：\n<ul>\n<li>使用<code>set del </code>上锁 放锁</li>\n<li>获取互斥锁，并判断是否获取成功，一旦获取失败就休眠重试</li>\n<li>获取成功就 取查询数据库</li>\n<li>最后释放互斥锁</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305262306596.png\" alt=\"image-20230526230647466\" style=\"zoom:55%;\">\n</li>\n<li>\n<p>不设置过期时间</p>\n<ul>\n<li>如果<code>redis</code>中查找到数据，就先把<code>json</code>反序列化为对象</li>\n<li>随后判断是否过期</li>\n<li>未过期，直接返回商品的信息，但是已过期，需要缓存重建</li>\n<li>缓存重建\n<ul>\n<li>先进行 获取互斥锁，获取到锁\n<ul>\n<li>一方面  检查redis 缓存是否过期（双检）</li>\n<li>另一方面开启独立线程（使用<code>线程池</code> 创建线程） 进行 缓存重建</li>\n<li>缓存重建就是 : 再去数据库中查询数据，并写回redis中并设置过期时间</li>\n<li>重建完之后释放锁</li>\n</ul>\n</li>\n<li>没有获取到 互斥锁  直接返回</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305262346080.png\" alt=\"image-20230526234618031\" style=\"zoom:33%;\">\n<p>工具类封装</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CacheClient</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">ExecutorService</span> <span class=\"variable\">CACHE_REBUILD_EXECUTOR</span> <span class=\"operator\">=</span> Executors.newFixedThreadPool(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">CacheClient</span><span class=\"params\">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">set</span><span class=\"params\">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class=\"line\">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setWithLogicalExpire</span><span class=\"params\">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 设置逻辑过期</span></span><br><span class=\"line\">        <span class=\"type\">RedisData</span> <span class=\"variable\">redisData</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RedisData</span>();</span><br><span class=\"line\">        redisData.setData(value);</span><br><span class=\"line\">        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));</span><br><span class=\"line\">        <span class=\"comment\">// 写入Redis</span></span><br><span class=\"line\">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;R,ID&gt; R <span class=\"title function_\">queryWithPassThrough</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> keyPrefix + id;</span><br><span class=\"line\">        <span class=\"comment\">// 1.从redis查询商铺缓存</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">json</span> <span class=\"operator\">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class=\"line\">        <span class=\"comment\">// 2.判断是否存在</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 3.存在，直接返回</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> JSONUtil.toBean(json, type);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 判断命中的是否是空值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (json != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 返回一个错误信息</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 4.不存在，根据id查询数据库</span></span><br><span class=\"line\">        <span class=\"type\">R</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> dbFallback.apply(id);</span><br><span class=\"line\">        <span class=\"comment\">// 5.不存在，返回错误</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 将空值写入redis</span></span><br><span class=\"line\">            stringRedisTemplate.opsForValue().set(key, <span class=\"string\">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class=\"line\">            <span class=\"comment\">// 返回错误信息</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 6.存在，写入redis</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.set(key, r, time, unit);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;R, ID&gt; R <span class=\"title function_\">queryWithLogicalExpire</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> keyPrefix + id;</span><br><span class=\"line\">        <span class=\"comment\">// 1.从redis查询商铺缓存</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">json</span> <span class=\"operator\">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class=\"line\">        <span class=\"comment\">// 2.判断是否存在</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 3.存在，直接返回</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 4.命中，需要先把json反序列化为对象</span></span><br><span class=\"line\">        <span class=\"type\">RedisData</span> <span class=\"variable\">redisData</span> <span class=\"operator\">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class=\"line\">        <span class=\"type\">R</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);</span><br><span class=\"line\">        <span class=\"type\">LocalDateTime</span> <span class=\"variable\">expireTime</span> <span class=\"operator\">=</span> redisData.getExpireTime();</span><br><span class=\"line\">        <span class=\"comment\">// 5.判断是否过期</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 5.1.未过期，直接返回店铺信息</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 5.2.已过期，需要缓存重建</span></span><br><span class=\"line\">        <span class=\"comment\">// 6.缓存重建</span></span><br><span class=\"line\">        <span class=\"comment\">// 6.1.获取互斥锁</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">lockKey</span> <span class=\"operator\">=</span> LOCK_SHOP_KEY + id;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">isLock</span> <span class=\"operator\">=</span> tryLock(lockKey);</span><br><span class=\"line\">        <span class=\"comment\">// 6.2.判断是否获取锁成功</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isLock)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 6.3.成功，开启独立线程，实现缓存重建</span></span><br><span class=\"line\">            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 查询数据库</span></span><br><span class=\"line\">                    <span class=\"type\">R</span> <span class=\"variable\">newR</span> <span class=\"operator\">=</span> dbFallback.apply(id);</span><br><span class=\"line\">                    <span class=\"comment\">// 重建缓存</span></span><br><span class=\"line\">                    <span class=\"built_in\">this</span>.setWithLogicalExpire(key, newR, time, unit);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 释放锁</span></span><br><span class=\"line\">                    unlock(lockKey);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 6.4.返回过期的商铺信息</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;R, ID&gt; R <span class=\"title function_\">queryWithMutex</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> keyPrefix + id;</span><br><span class=\"line\">        <span class=\"comment\">// 1.从redis查询商铺缓存</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">shopJson</span> <span class=\"operator\">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class=\"line\">        <span class=\"comment\">// 2.判断是否存在</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 3.存在，直接返回</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> JSONUtil.toBean(shopJson, type);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 判断命中的是否是空值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (shopJson != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 返回一个错误信息</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 4.实现缓存重建</span></span><br><span class=\"line\">        <span class=\"comment\">// 4.1.获取互斥锁</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">lockKey</span> <span class=\"operator\">=</span> LOCK_SHOP_KEY + id;</span><br><span class=\"line\">        <span class=\"type\">R</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">isLock</span> <span class=\"operator\">=</span> tryLock(lockKey);</span><br><span class=\"line\">            <span class=\"comment\">// 4.2.判断是否获取成功</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!isLock) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 4.3.获取锁失败，休眠并重试</span></span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">50</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> queryWithMutex(keyPrefix, id, type, dbFallback, time, unit);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 4.4.获取锁成功，根据id查询数据库</span></span><br><span class=\"line\">            r = dbFallback.apply(id);</span><br><span class=\"line\">            <span class=\"comment\">// 5.不存在，返回错误</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 将空值写入redis</span></span><br><span class=\"line\">                stringRedisTemplate.opsForValue().set(key, <span class=\"string\">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class=\"line\">                <span class=\"comment\">// 返回错误信息</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 6.存在，写入redis</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.set(key, r, time, unit);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 7.释放锁</span></span><br><span class=\"line\">            unlock(lockKey);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 8.返回</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryLock</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Boolean</span> <span class=\"variable\">flag</span> <span class=\"operator\">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class=\"string\">&quot;1&quot;</span>, <span class=\"number\">10</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BooleanUtil.isTrue(flag);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">unlock</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        stringRedisTemplate.delete(key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"击穿\">击穿</h4>\n<blockquote>\n<p>功能 ：</p>\n<ul>\n<li>定时+高并发+分页</li>\n</ul>\n</blockquote>\n<p>基本实现：</p>\n<ul>\n<li>\n<p>查询数据库数据</p>\n</li>\n<li>\n<p><em>删除<code>redis </code>中对应数据,再写到 <code>redis</code> 中</em> —&gt;<font color=\"red\">优化： 先更新B缓存且让B缓存过期时间超过A缓存，如果A突然失效还有B兜底，防止击穿</font></p>\n</li>\n<li>\n<p><font color=\"red\">设置缓存B的过期时间</font></p>\n</li>\n<li>\n<p><font color=\"red\">随后删除缓存A ,再进行更新缓存A</font></p>\n</li>\n<li>\n<p>采用<code>redis</code> <code>list</code>结构里面的<code>range</code>命令来实现<code>加载和分页</code></p>\n</li>\n<li>\n<p>出异常(一般<code>redis</code>宕机了或者<code>redis</code>网络抖动导致<code>timeout</code>) , 重试机制 再次查询<code>mysql</code></p>\n</li>\n</ul>\n<p>问题：</p>\n<p><code>删除redis中对应数据，再写到 redis中 </code>  两个操作不是原子命令 ，会存在  <code>热点缓存Key突然失效导致缓存击穿 </code>的问题</p>\n<p>优化：</p>\n<ul>\n<li>思路</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305261319664.png\" alt=\"image-20230526131942584\" style=\"zoom:53%;\">\n<h4 id=\"优惠券秒杀\">优惠券秒杀</h4>\n<ul>\n<li>使用<code>全局ID生成器</code>(一种在分布式系统下用来生成全局唯一ID的工具)\n<ul>\n<li>唯一，递增，高可用，安全，高性能</li>\n<li>生成策略\n<ul>\n<li>UUID 、Redis自增、snowflake算法 、数据库自增</li>\n<li>Redis自增实现方案：\n<ul>\n<li>每天一个key,方便统计订单量</li>\n<li>ID构造是  <code>时间戳+计数器</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>此处使用基于redis 的<code>全局ID生成器</code></li>\n</ul>\n<p>思路：</p>\n<ul>\n<li>判断时间 是否开始</li>\n<li>判断库存是否充足</li>\n<li>创建订单（全局id  用户id  代金券id）</li>\n</ul>\n<blockquote>\n<p>解决超卖问题：</p>\n</blockquote>\n<ul>\n<li>\n<p>悲观锁：添加同步锁，想成串行执行</p>\n</li>\n<li>\n<p>乐观锁的版本号 ，不加锁</p>\n<ul>\n<li>版本号</li>\n<li>cas(用库存代替版本，让库存&gt;0 即可)</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305270105675.png\" alt=\"image-20230527010538607\" style=\"zoom:53%;\">\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305270100288.png\" alt=\"image-20230527010033208\" style=\"zoom:45%;\">\n</li>\n</ul>\n<blockquote>\n<p>解决一人一单</p>\n</blockquote>\n<ul>\n<li>简单加一层逻辑\n<ul>\n<li>在下订单之前 先去查询订单，获取用户<code>id</code>,判断用户<code>id</code>是否存在\n<ul>\n<li>需要使用悲观锁(<code>synchronized</code>)机制进行保护 <code>查询订单  判断订单 创建订单</code> 的逻辑,使其线程安全, 锁的是<code>用户id</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><code>乐观锁</code>比较适合更新数据，而插入数据则是需要使用<code>悲观锁</code>操作</p>\n</blockquote>\n<blockquote>\n<ul>\n<li>起初为了减少锁的粒度，并不是在方法上加<code>synchronized</code> ，所以锁的是<code>id</code></li>\n<li>因此 使用<code>intern() </code>这个方法是<code>从常量池</code>中拿到数据，如果我们直接使用<code>userId.toString() </code>他拿到的对象实际上是不同的对象，<code>new</code>出来的对象，我们使用锁必须保证锁必须是<code>同一把</code>，所以我们需要使用<code>intern()方法</code></li>\n<li>另外： 由于当前方法被<code>spring</code>的<code>事务控制</code>，如果你在方法内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放也会导致问题，所以我们选择将当前方法整体包裹起来，确保事务不会出现问题</li>\n<li>但是事务想要生效，还得利用<code>代理</code>(<code>AspectJ</code>)来生效，所以这个地方，我们需要获得原始的事务对象， 来操作事务</li>\n</ul>\n<p>所以完整代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Long</span> <span class=\"variable\">userId</span> <span class=\"operator\">=</span>  UserHolder.getUser().getId();  <span class=\"comment\">// 获取id</span></span><br><span class=\"line\"><span class=\"keyword\">synchronized</span> (userId.tostring().intern())&#123;    <span class=\"comment\">//加锁</span></span><br><span class=\"line\">    <span class=\"comment\">//获取代理对象（事务）</span></span><br><span class=\"line\">    IVoucherorderService <span class=\"title function_\">proxy</span> <span class=\"params\">(IVoucherorderService)</span>AopContext.currentProxy();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> proxy.createVoucherorder(voucherId);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>  Result <span class=\"title function_\">createVoucherOrder</span><span class=\"params\">(Long voucherId)</span> &#123;</span><br><span class=\"line\"> <span class=\"comment\">//查询   判断  创建 订单   </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><span style=\"color:red\">集群模式下的分布式锁</span></p>\n<blockquote>\n<p>单机下锁在集群下会产生锁失效</p>\n<ul>\n<li>由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，</li>\n<li>假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的，</li>\n<li>但是如果现在是服务器B的tomcat内部，又有两个线程线程3和线程4，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，</li>\n<li>所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥，</li>\n<li>这就是 集群环境下，syn锁失效的原因，在这种情况下，我们就需要使用分布式锁来解决这个问题。</li>\n<li>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306201521824.png\" alt=\"image-20230620152116636\" style=\"zoom:33%;\">\n</li>\n</ul>\n</blockquote>\n<h4 id=\"分布式锁\">分布式锁</h4>\n<blockquote>\n<p>分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。</p>\n<p>分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行</p>\n</blockquote>\n<p><font color=\"blue\">分类：</font></p>\n<ul>\n<li>\n<p>单机版  ——<code>synchronized</code>或者<code>Lock</code></p>\n</li>\n<li>\n<p>分布式  ——   分布式锁</p>\n</li>\n</ul>\n<p><font color=\"blue\">分布式锁的三种实现方式：</font></p>\n<ul>\n<li><code>Mysql</code>：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见</li>\n<li><code>Redis</code>：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用setnx这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁</li>\n<li><code>Zookeeper</code>：zookeeper也是企业级开发中较好的一个实现分布式锁的方案</li>\n</ul>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305271058635.png\" alt></p>\n<p><font color=\"blue\">一个靠谱的分布式锁需要具备的条件和刚需：</font></p>\n<ul>\n<li>\n<p>独占性     任何时刻有且只能有一个线程持有</p>\n</li>\n<li>\n<p>高可用     若为redis集群环境下，不能因为某一个节点挂了而出现获取锁和释放锁失败的情况 ，高并发请求下，性能依旧好使</p>\n</li>\n<li>\n<p>防死锁     杜绝死锁，必须有超时控制机制或者撤销操作，有个兜底终止跳出方案</p>\n</li>\n<li>\n<p>不乱抢     防止张冠李戴，不能私底下unlock别人的锁，只能自己加锁自己释放</p>\n</li>\n<li>\n<p>重入性     同一个节点的同一个线程如果获得锁之后，它也可以再次获取这个锁</p>\n</li>\n</ul>\n<blockquote>\n<p>无锁版本</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">sale</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">resMessgae</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1 抢锁成功，查询库存信息</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> stringRedisTemplate.opsForValue().get(<span class=\"string\">&quot;inventory01&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 2 判断库存书否足够</span></span><br><span class=\"line\">        <span class=\"type\">Integer</span> <span class=\"variable\">inventoryNum</span> <span class=\"operator\">=</span> result == <span class=\"literal\">null</span> ? <span class=\"number\">0</span> : Integer.parseInt(result);</span><br><span class=\"line\">        <span class=\"comment\">// 3 扣减库存，每次减少一个库存</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (inventoryNum &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            stringRedisTemplate.opsForValue().set(<span class=\"string\">&quot;inventory01&quot;</span>, String.valueOf(--inventoryNum));</span><br><span class=\"line\">            resMessgae = <span class=\"string\">&quot;成功卖出一个商品，库存剩余：&quot;</span> + inventoryNum + <span class=\"string\">&quot;\\t&quot;</span> + <span class=\"string\">&quot;，服务端口号：&quot;</span> + port;</span><br><span class=\"line\">            log.info(resMessgae);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            resMessgae = <span class=\"string\">&quot;商品已售罄。&quot;</span> + <span class=\"string\">&quot;\\t&quot;</span> + <span class=\"string\">&quot;，服务端口号：&quot;</span> + port;</span><br><span class=\"line\">            log.info(resMessgae);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> resMessgae;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>单机版写法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//lock</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">Lock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\">lock.lock();</span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;业务逻辑&#125;</span><br><span class=\"line\"><span class=\"keyword\">finally</span>&#123;lock.unlock();&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">或者 </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">//使用synchronized</span></span><br></pre></td></tr></table></figure>\n<p>分布式版本</p>\n<blockquote>\n<p>单机锁还是出现超卖现象，需要分布式锁</p>\n<p>原因分析:</p>\n<ul>\n<li>synchronized和ReentrantLock是单机锁，只能管住当前自己的jvm。</li>\n<li>在<font color=\"red\">单机环境</font>下，可以使用synchronized或Lock来实现;但是在分布式系统中，因为竞争的线程可能不在同一个节点上(同一个jvm中)，所以需要一个让所有进程都能访问到的锁来实现<font color=\"red\">(比如redis或者zookeeper来构建)</font></li>\n<li>不同进程ivm层面的锁就没用了，那么可以利用第三方的一个组件，来获取锁，未获取到锁，则阻塞当前想要运行的线程</li>\n</ul>\n</blockquote>\n<p>解决问题：</p>\n<ul>\n<li>跨进程+跨服务      解决超卖     防止缓存击穿</li>\n</ul>\n<blockquote>\n<p>版本一：  设置暂停时间 进行 判断是否能抢到锁[此处使用 ： set() 和 del()  进行解锁]，抢不到就在暂停时间之后进行   递归重试</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">sale</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">resMessgae</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;luojiaRedisLocak&quot;</span>;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">uuidValue</span> <span class=\"operator\">=</span> IdUtil.simpleUUID() + <span class=\"string\">&quot;:&quot;</span> + Thread.currentThread().getId();</span><br><span class=\"line\">    <span class=\"type\">Boolean</span> <span class=\"variable\">flag</span> <span class=\"operator\">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, uuidValue);</span><br><span class=\"line\">    <span class=\"comment\">// 抢不到的线程继续重试</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!flag) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 线程休眠20毫秒，进行递归重试</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            TimeUnit.MILLISECONDS.sleep(<span class=\"number\">20</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sale();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          ....</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            stringRedisTemplate.delete(key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> resMessgae;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>问题：<font color=\"red\">手工设置5000个线程来抢占锁，压测OK，但是容易导致StackOverflowError，不推荐，需要进一步完善</font></p>\n</blockquote>\n<blockquote>\n<p>版本二： 还是<code> set()  + del() 加锁解锁</code></p>\n<p>为了防止虚假唤醒： <code>用while替代if，用自旋锁代替递归重试</code></p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">sale</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">resMessgae</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;luojiaRedisLocak&quot;</span>;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">uuidValue</span> <span class=\"operator\">=</span> IdUtil.simpleUUID() + <span class=\"string\">&quot;:&quot;</span> + Thread.currentThread().getId();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 不用递归了，高并发容易出错，我们用自旋代替递归方法重试调用；也不用if，用while代替</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!stringRedisTemplate.opsForValue().setIfAbsent(key, uuidValue)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 线程休眠20毫秒，进行递归重试</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class=\"number\">20</span>);&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">       ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        stringRedisTemplate.delete(key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> resMessgae;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>问题:部署的微服务<code>挂了</code>，代码层面<code>根本没有走到finally</code>这块，没办法保证解锁(无过期时间该key一直存在)，这个key没有被删除，需要<code>加入一个过期时间限定key</code></p>\n</blockquote>\n<blockquote>\n<p>版本三： <code>加锁和过期时间设置必须同一行，保证原子性</code></p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (!stringRedisTemplate.opsForValue().setIfAbsent(key, uuidValue)) &#123;</span><br><span class=\"line\"> ......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 设置过期时间</span></span><br><span class=\"line\">stringRedisTemplate.expire(key, <span class=\"number\">30L</span>, TimeUnit.SECONDS);</span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;...&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\">         ||</span><br><span class=\"line\">         ||</span><br><span class=\"line\">    <span class=\"comment\">//原子性的改进</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (!stringRedisTemplate.opsForValue().setIfAbsent(key, uuidValue, <span class=\"number\">30L</span>, TimeUnit.SECONDS))&#123;....&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>问题：实际业务中，如果处理时间超过了设置的key的过期时间，那删除key的时候就<font color=\"blue\">删除了别人的锁</font></p>\n</blockquote>\n<blockquote>\n<p>版本四：只能自己删除自己的，不允许删除别人的锁—<code>判断是否与当前线程标识[uuidValue]一致</code></p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;\t</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 判断加锁与解锁是不同客户端，自己只能删除自己的锁，不误删别人的锁</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (stringRedisTemplate.opsForValue().get(key).equalsIgnoreCase(uuidValue)) &#123;</span><br><span class=\"line\">            stringRedisTemplate.delete(key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>问题：finally代码块的<code>判断是否是自己的锁+del删除</code>不是<code>原子性</code>的,极端情况下还是会误删</p>\n<ul>\n<li>做法一：redis的事务不能保证一致性，事务的操作是最终一次性执行，要加上乐观锁判断自己线程释放的时候没有别的线程在进行执行修改</li>\n<li>做法二： lua脚本</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>版本五：lua脚本</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 改进点，修改为Lua脚本的Redis分布式锁调用，必须保证原子性，参考官网脚本案例</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">luaScript</span> <span class=\"operator\">=</span></span><br><span class=\"line\">            <span class=\"string\">&quot;if redis.call(&#x27;get&#x27;,KEYS[1]) == ARGV[1] then &quot;</span> +</span><br><span class=\"line\">            <span class=\"string\">&quot;return redis.call(&#x27;del&#x27;,KEYS[1]) &quot;</span> +</span><br><span class=\"line\">            <span class=\"string\">&quot;else &quot;</span> +</span><br><span class=\"line\">            <span class=\"string\">&quot;return 0 &quot;</span> +</span><br><span class=\"line\">            <span class=\"string\">&quot;end&quot;</span>;</span><br><span class=\"line\">        stringRedisTemplate.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>(luaScript, Boolean.class), Arrays.asList(key), uuidValue);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>小总结：</p>\n<ul>\n<li>利用<code>set nx ex</code>获取锁，并设置过期时间，保存线程标识</li>\n<li>释放锁时先判断线程标示是否与自己一致，一致则删除锁\n<ul>\n<li>特性：\n<ul>\n<li>利用set nx满足互斥性</li>\n<li>利用set ex保证故障时锁依然能释放，避免死锁，提高安全性</li>\n<li>利用Redis集群保证高可用和高并发特性</li>\n</ul>\n</li>\n<li>缺陷：\n<ul>\n<li><strong>重入问题</strong>：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁</li>\n<li><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</li>\n<li>**超时释放：**我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</li>\n<li><strong>主从一致性：</strong> 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>问题：可重入性未能满足</p>\n</blockquote>\n<blockquote>\n<p>可重入锁</p>\n<ul>\n<li>可重入锁又名递归锁；是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁(前提，锁对象需要是同一个对象)，不会因为之前已经获取过还没释放而阻塞。可重入锁的一个优点是可以一定程度避免死锁。</li>\n<li>就是说：一个线程中的多个流程可以获取同一把锁，持有这把同步锁可以再次进入。自己可以获取自己的内部锁</li>\n</ul>\n<p>可重入锁种类</p>\n<ul>\n<li>\n<p>隐式锁(即synchronized关键字使用的锁)</p>\n<p>一个Synchronized修饰的方法或代码块的内部调用本类的其他Synchronized修饰的方法或代码块时，是永远可以得到锁</p>\n<ul>\n<li>Synchronized的重入的实现原理：\n<ul>\n<li>每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针。</li>\n<li>当执行monitorenter时，如果目标锁对象的计数器为零，那么说明它没有被其他线程所持有，Java虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器加1。</li>\n<li>在目标锁对象的计数器不为零的情况下，如果锁对象的持有线程是当前线程，那么 Java 虚拟机可以将其计数器加1，否则需要等待直至持有线程释放该锁。</li>\n<li>当执行monitorexit时，Java虚拟机则需将锁对象的计数器减1。计数器为零代表锁已被释放。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>显式锁(即Lock)&lt;也有ReentrantLock这样的可重入锁&gt;</p>\n</li>\n</ul>\n</blockquote>\n<p>对比：</p>\n<ul>\n<li>\n<p>setnx只能解决有无的问题，够用但是不完美</p>\n</li>\n<li>\n<p>hset，不但解决有无，还能解决可重入问题</p>\n</li>\n</ul>\n<blockquote>\n<p>版本 六： 考虑<code>可重入性</code>的实现方案：    使用 ： <code>hash</code>的数据结构  用lua 脚本代替  lock   unlock</p>\n</blockquote>\n<ul>\n<li><code>工厂设计模式</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DistributedLockFactory</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String lockName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String uuidValue;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">DistributedLockFactory</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.uuidValue = IdUtil.simpleUUID();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Lock <span class=\"title function_\">getDistributedLock</span><span class=\"params\">(String lockType)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lockType == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lockType.equalsIgnoreCase(<span class=\"string\">&quot;REDIS&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.lockName = <span class=\"string\">&quot;RedisLock&quot;</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 每次都是 new 的  注入uuidValue 保证每个线程的id是一样的</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RedisDistributedLock</span>(stringRedisTemplate, lockName, uuidValue);   </span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (lockType.equalsIgnoreCase(<span class=\"string\">&quot;ZOOKEEPER&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.lockName = <span class=\"string\">&quot;ZookeeperLock&quot;</span>;</span><br><span class=\"line\">            <span class=\"comment\">// TODO zoookeeper 版本的分布式锁</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (lockType.equalsIgnoreCase(<span class=\"string\">&quot;MYSQL&quot;</span>))&#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.lockName = <span class=\"string\">&quot;MysqlLock&quot;</span>;</span><br><span class=\"line\">            <span class=\"comment\">// TODO MYSQL 版本的分布式锁</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 自研的分布式锁，实现了Lock接口</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisDistributedLock</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Lock</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String lockName; <span class=\"comment\">// KEYS[1]</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String uuidValule; <span class=\"comment\">// ARGV[1]</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">long</span> expireTime; <span class=\"comment\">// ARGV[2]</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//String uuid 的作用就是：</span></span><br><span class=\"line\">    <span class=\"comment\">//testReEntry方法中，会创建一个新的锁Key，因为ThreadID一致了，但是UUID不OK</span></span><br><span class=\"line\">    <span class=\"comment\">//使用@Autowired创建的工厂类是一个单例的，在spring进行注入的时候已经初始化好了，所以所有线程产生的UUID都应该是一样的</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"title function_\">RedisDistributedLock</span><span class=\"params\">(StringRedisTemplate stringRedisTemplate, String lockName, String uuid)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.lockName = lockName;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.uuidValule = uuid + <span class=\"string\">&quot;:&quot;</span> + Thread.currentThread().getId();</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.expireTime = <span class=\"number\">50L</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">lock</span><span class=\"params\">()</span> &#123;tryLock();&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryLock</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;tryLock(-<span class=\"number\">1L</span>, TimeUnit.SECONDS);&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span>  <span class=\"comment\">//Lock</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryLock</span><span class=\"params\">(<span class=\"type\">long</span> time, TimeUnit unit)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (-<span class=\"number\">1</span> == time) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//在redis中，给Key键设置一个值，为避免死锁，并给定一个过期时间</span></span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span></span><br><span class=\"line\">                    <span class=\"string\">&quot;if redis.call(&#x27;exists&#x27;, KEYS[1]) == 0 or redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1 then &quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], 1) &quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[2]) &quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;return 1 &quot;</span> +</span><br><span class=\"line\">                    <span class=\"string\">&quot;else &quot;</span> +</span><br><span class=\"line\">                         <span class=\"string\">&quot;return 0 &quot;</span> +</span><br><span class=\"line\">                    <span class=\"string\">&quot;end&quot;</span>;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;lockName:&quot;</span> + lockName + <span class=\"string\">&quot;\\t&quot;</span> + <span class=\"string\">&quot;uuidValue:&quot;</span> + uuidValule);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 加锁失败需要自旋一直获取锁</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!stringRedisTemplate.execute(</span><br><span class=\"line\">                    <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class),</span><br><span class=\"line\">                    Arrays.asList(lockName),</span><br><span class=\"line\">                    uuidValule,</span><br><span class=\"line\">                    String.valueOf(expireTime))) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 休眠60毫秒再来重试</span></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class=\"number\">60</span>);&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span>  <span class=\"comment\">//unlock</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">unlock</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//将 Key 键删除，但是也不能乱删，只能自己删自己的锁</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;if redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 0 then &quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;return nil &quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;elseif redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], -1) == 0 then &quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;return redis.call(&#x27;del&#x27;, KEYS[1]) &quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;else &quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;return 0 &quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;end&quot;</span>;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;lockName:&quot;</span> + lockName + <span class=\"string\">&quot;\\t&quot;</span> + <span class=\"string\">&quot;uuidValue:&quot;</span> + uuidValule);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// LUA脚本由C语言编写，nil -&gt; false; 0 -&gt; false; 1 -&gt; true;</span></span><br><span class=\"line\">        <span class=\"comment\">// 所以此处DefaultRedisScript构造函数返回值不能是Boolean，Boolean没有nil</span></span><br><span class=\"line\">        <span class=\"type\">Long</span> <span class=\"variable\">flag</span> <span class=\"operator\">=</span> stringRedisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, Long.class),</span><br><span class=\"line\">                Arrays.asList(lockName),</span><br><span class=\"line\">                uuidValule);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"literal\">null</span> == flag) &#123;<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;this lock does not exists.&quot;</span>);&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 下面两个暂时用不到，不用重写</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">lockInterruptibly</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;&#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Condition <span class=\"title function_\">newCondition</span><span class=\"params\">()</span> &#123;<span class=\"keyword\">return</span> <span class=\"literal\">null</span>;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> DistributedLockFactory distributedLockFactory;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">sale</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">resMessgae</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"type\">Lock</span> <span class=\"variable\">redisLock</span> <span class=\"operator\">=</span> distributedLockFactory.getDistributedLock(<span class=\"string\">&quot;REDIS&quot;</span>, <span class=\"string\">&quot;luojiaRedisLock&quot;</span>);</span><br><span class=\"line\">    redisLock.lock();</span><br><span class=\"line\">    </span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        redisLock.unlock();</span><br><span class=\"line\">   .....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>给锁进行<code>自动续期</code>  ： 保证RedisLock过期时间大于业务执行时间的问题,如果规定时间内没有完成业务逻辑，会调用加钟自动续期的脚本</p>\n</blockquote>\n<p>lua脚本的实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryLock</span><span class=\"params\">(<span class=\"type\">long</span> time, TimeUnit unit)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">       ......</span><br><span class=\"line\">        <span class=\"comment\">// 新建一个后台扫描程序，来检查Key目前的ttl，是否到我们规定的剩余时间来实现锁续期</span></span><br><span class=\"line\">        resetExpire();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 自动续期</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">resetExpire</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">script</span> <span class=\"operator\">=</span></span><br><span class=\"line\">        <span class=\"string\">&quot;if redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1 then &quot;</span> +</span><br><span class=\"line\">        <span class=\"string\">&quot;return redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[2]) &quot;</span> +</span><br><span class=\"line\">        <span class=\"string\">&quot;else &quot;</span> +</span><br><span class=\"line\">        <span class=\"string\">&quot;return 0 &quot;</span> +</span><br><span class=\"line\">        <span class=\"string\">&quot;end&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 起一个定时任务Timer()</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">Timer</span>().schedule(<span class=\"keyword\">new</span> <span class=\"title class_\">TimerTask</span>() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (stringRedisTemplate.execute(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class),</span><br><span class=\"line\">                Arrays.asList(lockName),</span><br><span class=\"line\">                uuidValule,</span><br><span class=\"line\">                String.valueOf(expireTime))) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 续期成功，继续监听</span></span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;resetExpire() lockName:&quot;</span> + lockName + <span class=\"string\">&quot;\\t&quot;</span> + <span class=\"string\">&quot;uuidValue:&quot;</span> + uuidValule);</span><br><span class=\"line\">                resetExpire();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, (<span class=\"built_in\">this</span>.expireTime * <span class=\"number\">1000</span> / <span class=\"number\">3</span>));</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// unlock</span></span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"总结：\">总结：</h5>\n<ul>\n<li>\n<p>lock()加锁关键逻辑</p>\n<ul>\n<li>\n<p>加锁：加锁实际上就是在redis中，给key设置一个值，为了避免死锁，并给定一个过期时间</p>\n</li>\n<li>\n<p>可重入：加锁的LUA脚本，通过redis里面的hash数据模型，加锁和可重入性都要保证</p>\n</li>\n<li>\n<p>自旋：加锁不成，需要while进行重试并自旋，AQS</p>\n</li>\n<li>\n<p>续期：在过期时间内，一定时间内业务还未完成，自动给锁续期</p>\n</li>\n</ul>\n</li>\n<li>\n<p>unlock()解锁关键逻辑</p>\n<ul>\n<li>\n<p>将redis的key删除，但是也不能乱删，不能说客户端1的请求将客户端2的锁给删除掉了，只能自己删自己的锁</p>\n</li>\n<li>\n<p>考虑可重入性的递减，加锁几次就需要删除几次</p>\n</li>\n<li>\n<p>最后到零了，直接del删除</p>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>此时最终版本的问题</p>\n</blockquote>\n<ul>\n<li>当<code>redis</code>宕机了，也就是单点故障,但是并不能直接添加一个从机，作为主机的副本，当主机出现问题是使用它，这是因为redis复制是 异步的，这么做会产生竞争的关系.</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305261621454.png\" alt=\"image-20230526162135416\" style=\"zoom:33%;\">\n<blockquote>\n<p>解决： 使用 <code>redlock</code></p>\n</blockquote>\n<h5 id=\"Redission\">Redission</h5>\n<h5 id=\"redlock\">redlock</h5>\n<blockquote>\n<p>设计理念</p>\n</blockquote>\n<p>该方案也是基于(set加锁、Lua脚本解锁）进行改良的,底层也是lua脚本实现<code>加锁、解锁、续期</code></p>\n<p>假设我们有N个Redis主节点，例如 N = 5这些节点是完全独立的，我们不使用复制或任何其他隐式协调系统，为了取到锁客户端执行以下操作：</p>\n<p>&lt;为了解决数据不一致的问题，直接舍弃了异步复制只使用 master 节点，同时由于舍弃了 slave，为了保证可用性，引入了 N 个节点，官方建议是 5。&gt;</p>\n<table>\n<thead>\n<tr>\n<th>1</th>\n<th>获取当前时间，以毫秒为单位；</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>2</td>\n<td>依次尝试从5个实例，使用相同的 key 和随机值（例如 UUID）获取锁。当向Redis 请求获取锁时，客户端应该设置一个超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为 10 秒，则超时时间应该在 5-50 毫秒之间。这样可以防止客户端在试图与一个宕机的 Redis 节点对话时长时间处于阻塞状态。如果一个实例不可用，客户端应该尽快尝试去另外一个 Redis 实例请求获取锁；</td>\n</tr>\n<tr>\n<td>3</td>\n<td>客户端通过当前时间减去步骤 1 记录的时间来计算获取锁使用的时间。当且仅当从大多数（N/2+1，这里是 3 个节点）的 Redis 节点都取到锁，并且获取锁使用的时间小于锁失效时间时，锁才算获取成功</td>\n</tr>\n<tr>\n<td>4</td>\n<td>如果取到了锁，其真正有效时间等于初始有效时间减去获取锁所使用的时间（步骤 3 计算的结果）。</td>\n</tr>\n<tr>\n<td>5</td>\n<td>如果由于某些原因未能获得锁（无法在至少 N/2 + 1 个 Redis 实例获取锁、或获取锁的时间超过了有效时间），客户端应该在所有的 Redis 实例上进行解锁（即便某些Redis实例根本就没有加锁成功，防止某些节点获取到锁但是客户端没有得到响应而导致接下来的一段时间不能被重新获取锁）。</td>\n</tr>\n</tbody>\n</table>\n<p><font color=\"blue\">客户端只有在满足下面的这两个条件时，才能认为是加锁成功。</font></p>\n<p><font color=\"blue\">条件1:客户端从超过半数（大于等于N/2+1）的Redis实例上成功获取到了锁;</font></p>\n<p><font color=\"blue\">条件2:客户端获取锁的总耗时没有超过锁的有效时间。</font></p>\n<blockquote>\n<p>容错公式：</p>\n<ul>\n<li><code>N = 2X + 1 </code>（N是最终部署机器数，X是容错机器数）</li>\n</ul>\n</blockquote>\n<p>Redis分布式锁过期了，但是业务逻辑还没有处理完怎么办</p>\n<ul>\n<li>需要给对应的key续期</li>\n</ul>\n<p>守护线程“续命”</p>\n<ul>\n<li><font color=\"red\">额外起一个线程，定期检查线程是否还持有锁，如果有则延长过期时间</font>；Redisson里面就实现了这个方案，使用“看门狗”定期检查（每1/3的锁时间检查1次），如果线程还持有锁，则刷新过期时间。</li>\n<li>在获取锁成功后，给锁加一个watchdog，watchdog会起一个<code>定时任务</code>，在锁没有被释放且快要过期的时候会续期</li>\n</ul>\n<blockquote>\n<p>单机版</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Redisson <span class=\"title function_\">redisson</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Config</span> <span class=\"variable\">config</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Config</span>();</span><br><span class=\"line\">    \t<span class=\"comment\">//也可以使用config.useclusterServers()添加集群地址</span></span><br><span class=\"line\">        config.useSingleServer().setAddress(<span class=\"string\">&quot;redis: ip:port&quot;</span>).setDatabase(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (Redisson) Redisson.create(config);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Resource</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Redission redisson;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">RLock</span> <span class=\"variable\">redissonLock</span> <span class=\"operator\">=</span> redisson.getLock(<span class=\"string\">&quot;RedisLock&quot;</span>+UserId);</span><br><span class=\"line\">redissonLock.lock();</span><br><span class=\"line\">....</span><br><span class=\"line\"><span class=\"comment\">// 改进点，只能删除属于自己的 key，不能删除别人的</span></span><br><span class=\"line\"> <span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (redissonLock.isLocked() &amp;&amp; redissonLock.isHeldByCurrentThread())&#123;</span><br><span class=\"line\">     redissonLock.unlock();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>集群版</p>\n</blockquote>\n<p>问题引出：</p>\n<ul>\n<li>当我们去写命令，写在主机上， 主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了，导致了锁失效</li>\n</ul>\n<p>解决思路：</p>\n<ul>\n<li>为了解决这个问题，redission提出来了MutiLock锁，就是不使用主从了，每个节点的地位都是一样的， 这把锁加锁的逻辑需要写入到<code>每一个</code>主从节点上，只有所有的服务器都写入成功，此时才是加锁成功，假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Redisson <span class=\"title function_\">redisson1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Config</span> <span class=\"variable\">config</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Config</span>();</span><br><span class=\"line\">    \t<span class=\"comment\">//也可以使用config.useclusterServers()添加集群地址</span></span><br><span class=\"line\">        config.useSingleServer().setAddress(<span class=\"string\">&quot;redis: ip1:port1&quot;</span>).setDatabase(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (Redisson) Redisson.create(config);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Redisson <span class=\"title function_\">redisson2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Config</span> <span class=\"variable\">config</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Config</span>();</span><br><span class=\"line\">    \t<span class=\"comment\">//也可以使用config.useclusterServers()添加集群地址</span></span><br><span class=\"line\">        config.useSingleServer().setAddress(<span class=\"string\">&quot;redis: ip1:port1&quot;</span>).setDatabase(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (Redisson) Redisson.create(config);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">重复多次...</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Redission1 redisson1;</span><br><span class=\"line\"><span class=\"keyword\">private</span> Redission2 redisson2;</span><br><span class=\"line\"><span class=\"keyword\">private</span> Redission3 redisson3;</span><br><span class=\"line\"><span class=\"type\">RLock</span> <span class=\"variable\">lock1</span> <span class=\"operator\">=</span> redisson1.getLock(CACHE_KEY_REDLOCK);</span><br><span class=\"line\"><span class=\"type\">RLock</span> <span class=\"variable\">lock2</span> <span class=\"operator\">=</span> redisson2.getLock(CACHE_KEY_REDLOCK);</span><br><span class=\"line\"><span class=\"type\">RLock</span> <span class=\"variable\">lock3</span> <span class=\"operator\">=</span> redisson3.getLock(CACHE_KEY_REDLOCK);</span><br><span class=\"line\"><span class=\"type\">RedissonMultiLock</span> <span class=\"variable\">redLock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RedissonMultiLock</span>(lock1, lock2, lock3);</span><br><span class=\"line\"></span><br><span class=\"line\">redLock.lock();</span><br><span class=\"line\">....</span><br><span class=\"line\"><span class=\"comment\">// 改进点，只能删除属于自己的 key，不能删除别人的</span></span><br><span class=\"line\"> <span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (redissonLock.isLocked() &amp;&amp; redissonLock.isHeldByCurrentThread())&#123;</span><br><span class=\"line\">     redLock.unlock();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>redisson锁可重入原理  [原理 黑马 66 -68</code> ]</p>\n<ul>\n<li>\n<p>redis采用<code>hash</code>结构用来记录线程id  和 重入次数，其中大key表示表示这把锁是否存在，用小key表示当前这把锁被哪个线程持有  并  根据重入次数记录可重入锁</p>\n</li>\n<li>\n<p>每一次获取锁的时候先判断锁是否存在，不存在就直接获取并设置过期时间，存在就判断线程标识是否是自己的，是的话可以继续获取，锁计数+1；并设置过期时间，不是自己的才会失败，释放锁的时候，计数-1即可，直到重入次数为0 才真正的释放锁</p>\n</li>\n<li>\n<p>流程</p>\n</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305271142908.png\" alt=\"image-20230527114259849\" style=\"zoom:33%;\">\n<p><code>redission 可重试原理</code></p>\n<ul>\n<li>利用信号量 和 PubSub  功能实现等待、唤醒，获取锁失败的重试机制</li>\n<li>第一次尝试获取锁失败之后，会进行一个等待，等待释放锁的消息，利用redis 的<code>PubSub </code> 机制，释放锁的时候会发布这样的消息，从而被redis 的<code>PubSub </code> 机制捕获，当得到这样的消息就会重新获取锁了，再次获取失败，就会再次等待，重试，但是会有一个等待的时间，超过这个时间就不会再重试了</li>\n</ul>\n<p><code>redission 超时释放（看门狗）</code></p>\n<ul>\n<li>利用watchDog,每隔一段时间（releaseTime/3),重置超时时间</li>\n<li>在获取锁成功之后，会开启一个超时任务，每隔一段时间就会重置锁的超时时间，那么锁的超时时间就会重新计时</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305271155304.png\" alt=\"image-20230527115537163\" style=\"zoom:33%;\">\n<p><code>redission锁的MutiLock[连锁]原理</code></p>\n<p>当我们去设置了多个锁时，redission会将多个锁添加到一个集合中，然后用while循环去不停去尝试拿锁，但是会有一个总共的加锁时间，这个时间是用需要加锁的个数 * 1500ms ，假设有3个锁，那么时间就是4500ms，假设在这4500ms内，所有的锁都加锁成功， 那么此时才算是加锁成功，如果在4500ms有线程加锁失败，则会再次去进行重试.</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305271224013.png\" alt=\"image-20230527122406953\" style=\"zoom:53%;\">\n</blockquote>\n<blockquote>\n<p>加锁有性能降低，现在优化提升性能</p>\n</blockquote>\n<p>优化方案：</p>\n<ul>\n<li>我们将耗时比较短的逻辑判断放入到redis中，比如是否库存足够，比如是否一人一单，这样的操作，只要这种逻辑可以完成，就意味着我们是一定可以下单完成的，我们只需要进行快速的逻辑判断，根本就不用等下单逻辑走完，我们直接给用户返回成功， 再在后台开一个线程，后台线程慢慢的去执行queue里边的消息，这样程序不就超级快了吗？而且也不用担心线程池消耗殆尽的问题，因为这里我们的程序中并没有手动使用任何线程池，当然这里边有两个难点\n<ul>\n<li>第一个难点是我们怎么在redis中去快速校验一人一单&lt;<code>set</code>&gt;，还有库存判断&lt;<code>string</code>&gt;</li>\n<li>第二个难点是由于我们校验和tomct下单是两个线程，那么我们如何知道到底哪个单他最后是否成功，或者是下单完成，为了完成这件事我们在redis操作完之后，我们会将一些信息返回给前端，同时也会把这些信息丢到异步queue中去，后续操作中，可以通过这个id来查询我们tomcat中的下单逻辑是否完成了。</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305271232668.png\" alt=\"image-20230527123253611\" style=\"zoom:25%;\">\n<p>整体思路：</p>\n<ul>\n<li>\n<p>当用户下单之后，判断库存是否充足只需要导redis中去根据key找对应的value是否大于0即可，如果不充足，则直接结束，如果充足，继续在redis中判断用户是否可以下单，如果set集合中没有这条数据，说明他可以下单，如果set集合中没有这条记录，则将userId和优惠卷存入到redis中，并且返回0，整个过程需要保证是<code>原子性</code>的，我们可以使用<code>lua</code>来操作</p>\n</li>\n<li>\n<p>当以上判断逻辑走完之后，我们可以判断当前redis中返回的结果是否是0 ，如果是0，则表示可以下单，则将之前说的信息存入到到<code>queue</code>中去，然后返回，然后再来个线程<code>异步的下单</code>，前端可以通过返回的订单id来判断是否下单成功。</p>\n</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305271233460.png\" alt=\"image-20230527123353395\" style=\"zoom:45%;\">\n<ul>\n<li>\n<p>新增秒杀优惠券的同时，将优惠券信息保存到Redis中</p>\n<ul>\n<li>保存秒杀库存到Redis中<code> stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());</code></li>\n</ul>\n</li>\n<li>\n<p>执行Lua脚本</p>\n<ul>\n<li>判断秒杀库存是否充足</li>\n<li>保存用户id，决定用户是否抢购成功（判断购买资格），确保一人一单</li>\n<li><code>发送消息（用户id, 订单id ,优惠券id）到队列中</code></li>\n</ul>\n</li>\n<li>\n<p>如果抢购成功（结果为0：脚本规定的）</p>\n<ul>\n<li><span style=\"color:orange\">将用户id, 订单id ,优惠券id封装后存入阻塞队列</span>\n<ul>\n<li><span style=\"color:orange\"><em>阻塞队列创建：private BlockingQueue<VoucherOrder> orderTasks =new  ArrayBlockingQueue&lt;&gt;(1024 * 1024);</VoucherOrder></em></span>\n<ul>\n<li><span style=\"color:orange\"><em>JDK 的阻塞队列，所以会进行初始化，一旦初始化的大小用完了，就会有内存问题</em></span></li>\n</ul>\n</li>\n<li>使用消息队列：&lt;在lua脚本发送消息就可以了&gt;\n<ul>\n<li>rabbitmq、kafka</li>\n<li>redis提供的队列</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>开启线程任务[创建线程：<code>Executors.newSingleThreadExecutor()</code>]，不断从消息队列中获取信息，创建订单，实现异步下单功能</p>\n<ul>\n<li>获取消息队列中的订单信息&lt;<code>Stream</code>&gt;</li>\n<li>判断订单信息是否为空,如果为null，说明没有消息，继续下一次循环，不为null，就对消息中数据 进行解析 并 创建订单 最后进行消息ACK确认，之后将不再处理这个消息</li>\n<li>如果处理消息的时候出现异常，那么就进入<code>pending-list</code> 的消息队列中进行处理异常消息</li>\n<li><code>pending-list</code> 的消息处理异常 的逻辑和 消息队列的一样的，只是在出现异常的时候直接打印错误消息退出即可，会自行while循环</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   </span><br><span class=\"line\"><span class=\"keyword\">private</span> IVoucherOrderService proxy;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Result <span class=\"title function_\">seckillVoucher</span><span class=\"params\">(Long voucherId)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Long</span> <span class=\"variable\">userId</span> <span class=\"operator\">=</span> UserHolder.getUser().getId();</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">orderId</span> <span class=\"operator\">=</span> redisIdWorker.nextId(<span class=\"string\">&quot;order&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 1.执行lua脚本</span></span><br><span class=\"line\">        <span class=\"type\">Long</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> stringRedisTemplate.execute(</span><br><span class=\"line\">                SECKILL_SCRIPT,</span><br><span class=\"line\">                Collections.emptyList(),</span><br><span class=\"line\">                voucherId.toString(), userId.toString(), String.valueOf(orderId)</span><br><span class=\"line\">        );</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> result.intValue();</span><br><span class=\"line\">        <span class=\"comment\">// 2.判断结果是否为0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 2.1.不为0 ，代表没有购买资格</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> Result.fail(r == <span class=\"number\">1</span> ? <span class=\"string\">&quot;库存不足&quot;</span> : <span class=\"string\">&quot;不能重复下单&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//3.获取代理对象</span></span><br><span class=\"line\">         proxy = (IVoucherOrderService)AopContext.currentProxy();</span><br><span class=\"line\">        <span class=\"comment\">//4.返回订单id</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Result.ok(orderId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//异步处理线程池</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">ExecutorService</span> <span class=\"variable\">SECKILL_ORDER_EXECUTOR</span> <span class=\"operator\">=</span> Executors.newSingleThreadExecutor();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在类初始化之后执行线程池</span></span><br><span class=\"line\"><span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">   SECKILL_ORDER_EXECUTOR.submit(<span class=\"keyword\">new</span> <span class=\"title class_\">VoucherOrderHandler</span>());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用于线程池处理的任务    </span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">class</span> <span class=\"title class_\">VoucherOrderHandler</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 1.获取消息队列中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;</span></span><br><span class=\"line\">                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class=\"line\">                    Consumer.from(<span class=\"string\">&quot;g1&quot;</span>, <span class=\"string\">&quot;c1&quot;</span>),</span><br><span class=\"line\">                    StreamReadOptions.empty().count(<span class=\"number\">1</span>).block(Duration.ofSeconds(<span class=\"number\">2</span>)),</span><br><span class=\"line\">                    StreamOffset.create(<span class=\"string\">&quot;stream.orders&quot;</span>, ReadOffset.lastConsumed())</span><br><span class=\"line\">                );</span><br><span class=\"line\">                <span class=\"comment\">// 2.判断订单信息是否为空</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (list == <span class=\"literal\">null</span> || list.isEmpty()) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果为null，说明没有消息，继续下一次循环</span></span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 解析数据</span></span><br><span class=\"line\">                MapRecord&lt;String, Object, Object&gt; record = list.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">                Map&lt;Object, Object&gt; value = record.getValue();</span><br><span class=\"line\">                <span class=\"type\">VoucherOrder</span> <span class=\"variable\">voucherOrder</span> <span class=\"operator\">=</span> BeanUtil.fillBeanWithMap(value, <span class=\"keyword\">new</span> <span class=\"title class_\">VoucherOrder</span>(), <span class=\"literal\">true</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 3.创建订单</span></span><br><span class=\"line\">                createVoucherOrder(voucherOrder);</span><br><span class=\"line\">                <span class=\"comment\">// 4.确认消息 XACK</span></span><br><span class=\"line\">                stringRedisTemplate.opsForStream().acknowledge(<span class=\"string\">&quot;s1&quot;</span>, <span class=\"string\">&quot;g1&quot;</span>, record.getId());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                log.error(<span class=\"string\">&quot;处理订单异常&quot;</span>, e);</span><br><span class=\"line\">                <span class=\"comment\">//处理异常消息</span></span><br><span class=\"line\">                handlePendingList();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handlePendingList</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 1.获取pending-list中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 0</span></span><br><span class=\"line\">                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class=\"line\">                    Consumer.from(<span class=\"string\">&quot;g1&quot;</span>, <span class=\"string\">&quot;c1&quot;</span>),</span><br><span class=\"line\">                    StreamReadOptions.empty().count(<span class=\"number\">1</span>),</span><br><span class=\"line\">                    StreamOffset.create(<span class=\"string\">&quot;stream.orders&quot;</span>, ReadOffset.from(<span class=\"string\">&quot;0&quot;</span>))</span><br><span class=\"line\">                );</span><br><span class=\"line\">                <span class=\"comment\">// 2.判断订单信息是否为空</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (list == <span class=\"literal\">null</span> || list.isEmpty()) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果为null，说明没有异常消息，结束循环</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 解析数据</span></span><br><span class=\"line\">                MapRecord&lt;String, Object, Object&gt; record = list.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">                Map&lt;Object, Object&gt; value = record.getValue();</span><br><span class=\"line\">                <span class=\"type\">VoucherOrder</span> <span class=\"variable\">voucherOrder</span> <span class=\"operator\">=</span> BeanUtil.fillBeanWithMap(value, <span class=\"keyword\">new</span> <span class=\"title class_\">VoucherOrder</span>(), <span class=\"literal\">true</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 3.创建订单</span></span><br><span class=\"line\">                createVoucherOrder(voucherOrder);</span><br><span class=\"line\">                <span class=\"comment\">// 4.确认消息 XACK</span></span><br><span class=\"line\">                stringRedisTemplate.opsForStream().acknowledge(<span class=\"string\">&quot;s1&quot;</span>, <span class=\"string\">&quot;g1&quot;</span>, record.getId());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                log.error(<span class=\"string\">&quot;处理pendding订单异常&quot;</span>, e);</span><br><span class=\"line\">                <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">20</span>);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//获取锁，调用创建订单</span></span><br><span class=\"line\">       <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleVoucherOrder</span><span class=\"params\">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//1.获取用户</span></span><br><span class=\"line\">            <span class=\"type\">Long</span> <span class=\"variable\">userId</span> <span class=\"operator\">=</span> voucherOrder.getUserId();</span><br><span class=\"line\">            <span class=\"comment\">// 2.创建锁对象</span></span><br><span class=\"line\">            <span class=\"type\">RLock</span> <span class=\"variable\">redisLock</span> <span class=\"operator\">=</span> redissonClient.getLock(<span class=\"string\">&quot;lock:order:&quot;</span> + userId);</span><br><span class=\"line\">            <span class=\"comment\">// 3.尝试获取锁</span></span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">isLock</span> <span class=\"operator\">=</span> redisLock.lock();</span><br><span class=\"line\">            <span class=\"comment\">// 4.判断是否获得锁成功</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!isLock) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 获取锁失败，直接返回失败或者重试</span></span><br><span class=\"line\">                log.error(<span class=\"string\">&quot;不允许重复下单！&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//注意：由于是spring的事务是放在threadLocal中，此时的是多线程，事务会失效</span></span><br><span class=\"line\">                proxy.createVoucherOrder(voucherOrder);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 释放锁</span></span><br><span class=\"line\">                redisLock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//真正的创建订单</span></span><br><span class=\"line\">   <span class=\"meta\">@Transactional</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">createVoucherOrder</span><span class=\"params\">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Long</span> <span class=\"variable\">userId</span> <span class=\"operator\">=</span> voucherOrder.getUserId();</span><br><span class=\"line\">        <span class=\"comment\">// 5.1.查询订单</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> query().eq(<span class=\"string\">&quot;user_id&quot;</span>, userId).eq(<span class=\"string\">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()).count();</span><br><span class=\"line\">        <span class=\"comment\">// 5.2.判断是否存在</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (count &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 用户已经购买过了</span></span><br><span class=\"line\">           log.error(<span class=\"string\">&quot;用户已经购买过了&quot;</span>);</span><br><span class=\"line\">           <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 6.扣减库存</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">success</span> <span class=\"operator\">=</span> seckillVoucherService.update()</span><br><span class=\"line\">                .setSql(<span class=\"string\">&quot;stock = stock - 1&quot;</span>) <span class=\"comment\">// set stock = stock - 1</span></span><br><span class=\"line\">                .eq(<span class=\"string\">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()).gt(<span class=\"string\">&quot;stock&quot;</span>, <span class=\"number\">0</span>) <span class=\"comment\">// where id = ? and stock &gt; 0</span></span><br><span class=\"line\">                .update();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!success) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 扣减失败</span></span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;库存不足&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        save(voucherOrder);</span><br><span class=\"line\"> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>基于List的消息队列有哪些优缺点？</p>\n<ul>\n<li>优点\n<ul>\n<li>利用Redis存储，不受限于JVM内存上限</li>\n<li>基于Redis的持久化机制，数据安全性有保证</li>\n<li>可以满足消息有序性</li>\n</ul>\n</li>\n<li>缺点\n<ul>\n<li>无法避免消息丢失</li>\n<li>只支持单消费者</li>\n</ul>\n</li>\n</ul>\n<p>基于PubSub的消息队列有哪些优缺点？</p>\n<ul>\n<li>\n<p>优点：</p>\n<ul>\n<li>采用发布订阅模型，支持多生产、多消费</li>\n</ul>\n</li>\n<li>\n<p>缺点：</p>\n<ul>\n<li>\n<p>不支持数据持久化</p>\n</li>\n<li>\n<p>无法避免消息丢失</p>\n</li>\n<li>\n<p>消息堆积有上限，超出时数据丢失</p>\n</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305271320979.png\" alt=\"image-20230527132059880\" style=\"zoom:25%;\">\n</blockquote>\n<h4 id=\"达人探店\">达人探店</h4>\n<ul>\n<li>\n<p>基本需求</p>\n<ul>\n<li>图片上传到 oos 上</li>\n<li>发布文章</li>\n<li>查看文章</li>\n</ul>\n</li>\n<li>\n<p>点赞功能  和 前面几个点赞的会进行头像的显示</p>\n<blockquote>\n<p>直接<code>操作数据库</code>  的 <code>点赞数量的值</code>;这种方式会导致一个用户无限点赞，明显是不合理的</p>\n<p>造成这个问题的原因是，我们现在的逻辑，发起请求只是给数据库+1，所以才会出现这个问题</p>\n</blockquote>\n<ul>\n<li>同一个用户只能点赞一次，再次点击则 取消点赞\n<ul>\n<li>给Blog类中添加一个isLike字段，标示是否被当前用户点赞</li>\n<li>修改点赞功能，<code>&lt;使用sortset&gt;</code>    <code>opsForZSet</code>  ，判断条件是查分数是否存在\n<ul>\n<li>不存在，表示未点赞过则点赞数+1,数据库实时+1，并将用户id保存到redis的set集合中 <code>opsForSet</code></li>\n<li>存在，表示已点赞过则点赞数-1,取消点赞，从Redis的set集合移除用户id</li>\n</ul>\n</li>\n<li>修改根据id查询Blog的业务，判断当前登录用户是否点赞过，赋值给isLike字段</li>\n<li>修改分页查询Blog业务，判断当前登录用户是否点赞过，赋值给isLike字段</li>\n</ul>\n</li>\n<li>如果当前用户已经点赞，则点赞按钮高亮显示（前端已实现，判断字段Blog类的isLike属性）</li>\n<li>随后进行查询<code>top5</code>的点赞用户 <code>opsForZSet.range(key, 0, 4)</code>\n<ul>\n<li>此处注意的是数据库会有问题，查询语句需要改进  使用 <code>IN(5,1)</code>会按照id排序，而不是给定的顺序</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//解析出其中的用户id</span></span><br><span class=\"line\">   List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class=\"line\">   <span class=\"type\">String</span> <span class=\"variable\">idStr</span> <span class=\"operator\">=</span> StrUtil.join(<span class=\"string\">&quot;,&quot;</span>, ids);</span><br><span class=\"line\">   <span class=\"comment\">// 根据用户id查询用户 WHERE id IN ( 5 , 1 ) ORDER BY FIELD(id, 5, 1)</span></span><br><span class=\"line\">   List&lt;UserDTO&gt; userDTOS = userService.query()</span><br><span class=\"line\">           .in(<span class=\"string\">&quot;id&quot;</span>, ids).last(<span class=\"string\">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class=\"string\">&quot;)&quot;</span>).list()</span><br><span class=\"line\">           .stream()</span><br><span class=\"line\">           .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))</span><br><span class=\"line\">           .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>\n<h4 id=\"好友关注\">好友关注</h4>\n<p>思路：</p>\n<ul>\n<li>关注是User之间的关系，是博主与粉丝的关系，一张关联表</li>\n</ul>\n<p><span style=\"color:red\">关注取关[<code>mysql</code>]   共同关注(求交集<code>set</code>)</span></p>\n<ul>\n<li>\n<p>获取登录用户</p>\n</li>\n<li>\n<p>判断是否关注   —根据登录的用户的id，查询(<code>查关联表</code>)是否关注</p>\n</li>\n<li>\n<p>没关注就去新增数据，随后   将 用户的id，放入redis的<code>set</code>集合</p>\n</li>\n<li>\n<p>关注过就删除,随后  将 用户的id，从redis的<code>set</code>集合 删除</p>\n</li>\n<li>\n<p>随后 获取当前用户和目标用户的交集</p>\n<ul>\n<li>没有交集返回 null</li>\n<li>有的话就 解析数据查询用户，返回结果</li>\n</ul>\n</li>\n</ul>\n<p><span style=\"color:red\">推送到粉丝收件箱</span></p>\n<ul>\n<li>\n<p>在保存blog到数据库之后，去数据库中获取博主的所有粉丝，逐个推送笔记到粉丝的收件箱，就是设置到redis中，值：<code>zset</code>,键： 粉丝id ，推送的内容： 文章id, 设置 过期时间</p>\n</li>\n<li>\n<p>收件箱可以根据时间戳排序</p>\n</li>\n<li>\n<p>查询收件箱数据时</p>\n<ul>\n<li>获取当前用户的key ，从而得到当前用户的收件箱，进行滚动分页  查询\n<ul>\n<li><code>Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate.opsForZSet() .reverseRangeByScoreWithScores(key, 0, max, offset, 2);</code> //2 <code>每页2条</code></li>\n</ul>\n</li>\n<li>每次查询完成后，我们要分析出查询出数据的最小时间戳，这个值会作为下一次查询的条件\n<ul>\n<li>如果查询 结果非空 ，解析数据，得到对应的id,（score）时间戳，偏移量，</li>\n<li>遍历判断，找到相同的<code>score</code>值，就++；找不到就进行替换，并将<code>偏移量</code>定为1；</li>\n<li>从而：我们就能找到与上一次查询相同的查询个数作为<code>偏移量</code>，下次查询时，跳过这些查询过的数据，拿到我们需要的数据</li>\n</ul>\n</li>\n<li>最后 由 id 查询数据博文 和 博文 的用户与是否点赞的信息</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>注意：</p>\n<ul>\n<li>Feed流中的数据会不断更新，所以数据的角标也在变化，因此不能采用传统的分页模式。</li>\n<li>传统了分页在feed流是不适用的，因为我们的数据会随时发生变化</li>\n<li>假设在t1 时刻，我们去读取第一页，此时page = 1 ，size = 5 ，那么我们拿到的就是10~6 这几条记录，假设现在t2时候又发布了一条记录，此时t3 时刻，我们来读取第二页，读取第二页传入的参数是page=2 ，size=5 ，那么此时读取到的第二页实际上是从6 开始，然后是6~2 ，那么我们就读取到了重复的数据，所以feed流的分页，不能采用原始方案来做。</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305271605923.png\" alt=\"image-20230527160511761\" style=\"zoom:25%;\">\n<p>解决：</p>\n<ul>\n<li>Feed流的滚动分页   <code>每次查询都 记录  上一次查询的最小值   并 从上一次查询的最小值开始查询</code></li>\n<li>我们需要记录每次操作的最后一条，然后从这个位置开始去读取数据</li>\n<li>举个例子：我们从t1时刻开始，拿第一页数据，拿到了10~6，然后记录下当前最后一次拿取的记录，就是6，t2时刻发布了新的记录，此时这个11放到最顶上，但是不会影响我们之前记录的6，此时t3时刻来拿第二页，第二页这个时候拿数据，还是从6后一点的5去拿，就拿到了5-1的记录。我们这个地方可以采用sortedSet来做，可以进行范围查询，并且还可以记录当前获取数据时间戳最小值，就可以实现滚动分页了</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305271605036.png\" alt=\"image-20230527160558969\" style=\"zoom:25%;\">\n<p>使用的数据结果：<code>zset</code></p>\n</blockquote>\n<blockquote>\n<p>当我们关注了用户后，这个用户发了动态，那么我们应该把这些数据推送给用户，这个需求，其实我们又把他叫做Feed流，关注推送也叫做Feed流，直译为投喂。为用户持续的提供“沉浸式”的体验，通过无限下拉刷新获取新的信息。</p>\n</blockquote>\n<blockquote>\n<p>对于新型的<code>Feed流</code>的的效果：不需要我们用户再去推送信息，而是系统分析用户到底想要什么，然后直接把内容推送给用户，从而使用户能够更加的节约时间，不用主动去寻找。</p>\n</blockquote>\n<blockquote>\n<p>Feed流的实现有两种模式：</p>\n</blockquote>\n<p>Feed流产品有两种常见模式：<br>\nTimeline：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注。例如朋友圈</p>\n<ul>\n<li>优点：信息全面，不会有缺失。并且实现也相对简单</li>\n<li>缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低</li>\n</ul>\n<p>智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容。推送用户感兴趣信息来吸引用户</p>\n<ul>\n<li>优点：投喂用户感兴趣信息，用户粘度很高，容易沉迷</li>\n<li>缺点：如果算法不精准，可能起到反作用<br>\n本例中的个人页面，是基于关注的好友来做Feed流，因此采用Timeline的模式。该模式的实现方案有三种：</li>\n</ul>\n<blockquote>\n<p>我们本次针对好友的操作，采用的就是<code>Timeline</code>的方式，只需要拿到我们关注用户的信息，然后按照时间排序即可，因此采用Timeline的模式。该模式的实现方案有三种：</p>\n</blockquote>\n<ul>\n<li>拉模式</li>\n<li>推模式</li>\n<li>推拉结合</li>\n</ul>\n<blockquote>\n<p><strong>拉模式</strong>：也叫做读扩散</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305271557654.png\" alt=\"image-20230527155629693\" style=\"zoom:25%;\">\n</blockquote>\n<p>该模式的核心含义就是：当张三和李四和王五发了消息后，都会保存在自己的邮箱中，假设赵六要读取信息，那么他会从读取他自己的收件箱，此时系统会从他关注的人群中，把他关注人的信息全部都进行拉取，然后在进行排序</p>\n<p>优点：比较节约空间，因为赵六在读信息时，并没有重复读取，而且读取完之后可以把他的收件箱进行清楚。</p>\n<p>缺点：比较延迟，当用户读取数据时才去关注的人里边去读取数据，假设用户关注了大量的用户，那么此时就会拉取海量的内容，对服务器压力巨大。</p>\n<blockquote>\n<p><strong>推模式</strong>：也叫做写扩散。</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305271558003.png\" alt=\"image-20230527155703838\" style=\"zoom:25%;\">\n</blockquote>\n<p>推模式是没有写邮箱的，当张三写了一个内容，此时会主动的把张三写的内容发送到他的粉丝收件箱中去，假设此时李四再来读取，就不用再去临时拉取了</p>\n<p>优点：时效快，不用临时拉取</p>\n<p>缺点：内存压力大，假设一个大V写信息，很多人关注他， 就会写很多分数据到粉丝那边去</p>\n<blockquote>\n<p><strong>推拉结合模式</strong>：也叫做读写混合，兼具推和拉两种模式的优点。</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305271557979.png\" alt=\"image-20230527155713821\" style=\"zoom:25%;\">\n</blockquote>\n<p>推拉模式是一个折中的方案，站在发件人这一段，如果是个普通的人，那么我们采用写扩散的方式，直接把数据写入到他的粉丝中去，因为普通的人他的粉丝关注量比较小，所以这样做没有压力，如果是大V，那么他是直接将数据先写入到一份到发件箱里边去，然后再直接写一份到活跃粉丝收件箱里边去，现在站在收件人这端来看，如果是活跃粉丝，那么大V和普通的人发的都会直接写入到自己收件箱里边来，而如果是普通的粉丝，由于他们上线不是很频繁，所以等他们上线时，再从发件箱里边去拉信息。</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305271559390.png\" alt=\"image-20230527155921137\" style=\"zoom:25%;\">\n<h4 id=\"附近的商户\">附近的商户</h4>\n<p>思路：<code>&lt;geo&gt;</code></p>\n<ul>\n<li>\n<p>将数据库表中的数据导入到redis中去，redis中的GEO，GEO在redis中就一个menber和一个经纬度，</p>\n</li>\n<li>\n<p>我们把x和y轴传入到redis做的经纬度位置去，但我们不能把所有的数据都放入到menber中去，</p>\n<p>但是毕竟作为redis是一个内存级数据库，如果存海量数据，redis还是力不从心，所以我们在这个地方<code>存储他的id</code>即可。</p>\n</li>\n<li>\n<p>但是这个时候还有一个问题，就是在redis中并没有存储type，所以我们无法根据type来对数据进行筛选</p>\n<p>所以我们可以按照<code>商户类型做分组</code>，类型相同的商户作为同一组，以<code>typeId为key</code>存入同一个GEO集合中即可</p>\n</li>\n</ul>\n<p>实现</p>\n<ul>\n<li>\n<p>判断是否需要根据坐标查询</p>\n<ul>\n<li>\n<p>不需要坐标查询，按数据库查询并返回数据</p>\n</li>\n<li>\n<p>查询redis、按照距离排序、分页。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> SHOP_GEO_KEY + typeId;</span><br><span class=\"line\">        GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = stringRedisTemplate.opsForGeo() <span class=\"comment\">// GEOSEARCH key BYLONLAT x y BYRADIUS 10 WITHDISTANCE</span></span><br><span class=\"line\">                .search(</span><br><span class=\"line\">                        key,</span><br><span class=\"line\">                        GeoReference.fromCoordinate(x, y),</span><br><span class=\"line\">                        <span class=\"keyword\">new</span> <span class=\"title class_\">Distance</span>(<span class=\"number\">5000</span>),           RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end)</span><br><span class=\"line\">                );</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>随后解析数据[ 获取 店铺id 、获取距离]   分页展示</p>\n<ul>\n<li>\n<p><code>手动的截取分页 </code>和<code>数据解析</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> List&lt;Long&gt; ids = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(list.size());</span><br><span class=\"line\">Map&lt;String, Distance&gt; distanceMap = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;(list.size());</span><br><span class=\"line\">list.stream().skip(from).forEach(result -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 4.2.获取店铺id</span></span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">shopIdStr</span> <span class=\"operator\">=</span> result.getContent().getName();</span><br><span class=\"line\">            ids.add(Long.valueOf(shopIdStr));</span><br><span class=\"line\">            <span class=\"comment\">// 4.3.获取距离</span></span><br><span class=\"line\">            <span class=\"type\">Distance</span> <span class=\"variable\">distance</span> <span class=\"operator\">=</span> result.getDistance();</span><br><span class=\"line\">            distanceMap.put(shopIdStr, distance);</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p>最后 由 id  查询 <code>Shop</code></p>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><code>es+mq</code>的写法：</p>\n</blockquote>\n<p>Es   的基本步骤：</p>\n<blockquote>\n<ul>\n<li>准备Request</li>\n<li>准备DSL  &lt;进行封装得到各种<code>XXXQuery()</code>&gt;</li>\n<li>发送请求</li>\n<li>解析响应</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>搜索  分页</p>\n</blockquote>\n<ul>\n<li>\n<p>准备<code>request</code></p>\n</li>\n<li>\n<p>准备 <code>DSL</code></p>\n<ul>\n<li>\n<p>利用<code>QueryBuilders.matchAllQuery()</code>进行全文检索</p>\n</li>\n<li>\n<p>分页查询</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">page</span> <span class=\"operator\">=</span> params.getPage();</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> params.getSize();</span><br><span class=\"line\">request.source().from((page - <span class=\"number\">1</span>) * size).size(size);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p>进行查询，发送请求</p>\n</li>\n<li>\n<p>解析响应</p>\n<ul>\n<li>获取总共的数目 ；生成文档数组，遍历文档数组，获取文档，反序列化之后放入集合中，封装返回即可</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>结果过滤</p>\n</blockquote>\n<ul>\n<li>使用<code>QueryBuilders.boolQuery()</code>进行过滤，随后进行<code>关键字搜索</code> <code>boolQuery.must()</code></li>\n<li>进行条件过滤<code> boolQuery.filter()</code></li>\n</ul>\n<blockquote>\n<p>周边的酒店</p>\n</blockquote>\n<ul>\n<li>在上述代码的基础上 添加<code>排序</code>逻辑</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">location</span> <span class=\"operator\">=</span> params.getLocation();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (location != <span class=\"literal\">null</span> &amp;&amp; !location.equals(<span class=\"string\">&quot;&quot;</span>)) &#123;</span><br><span class=\"line\">          request.source().sort(SortBuilders</span><br><span class=\"line\">                                .geoDistanceSort(<span class=\"string\">&quot;location&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">GeoPoint</span>(location))</span><br><span class=\"line\">                                .order(SortOrder.ASC)</span><br><span class=\"line\">                                .unit(DistanceUnit.KILOMETERS)</span><br><span class=\"line\">                               );</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>解析响应<code>handleResponse</code>的时候除了解析source部分以外，还要得到sort部分，也就是排序的距离，然后放到响应结果中。</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305271810318.png\" alt=\"image-20230527181011248\" style=\"zoom:25%;\">\n<blockquote>\n<p>自动补全</p>\n</blockquote>\n<ul>\n<li>\n<p>在实体类中需要进行切割 获取多个不同可能分词</p>\n</li>\n<li>\n<p>还是还上面四步的基础上在解析响应的时候，</p>\n</li>\n<li>\n<p>要先根据补全查询名称，获取补全结果</p>\n</li>\n<li>\n<p>并得到补全的选项，随后遍历添加到集合中</p>\n</li>\n</ul>\n<blockquote>\n<p>结合<code>mq</code>实现 <code>es 和 mysql</code> 的消息同步</p>\n</blockquote>\n<ul>\n<li>声明交换机和队列  以及之间的绑定关系</li>\n<li>每当<code>数据库</code>进行  增删 等操作就 让 进行  发送消息</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rabbitTemplate.convertAndSend(MqConstants.HOTEL_EXCHANGE,MqConstants.HOTEL_INSERT_KEY,hotel.getId());</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"comment\">// 交换机                  // rountyKey                     //消息内容</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>监听 和接收消息,随后进行 对<code>es</code>的 删除和新增等操作\n<ul>\n<li>根据id查询酒店数据</li>\n<li>转换为文档类型</li>\n<li>准备Request对象</li>\n<li>准备Json文档</li>\n<li>发送请求</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RabbitListener(queues = MqConstants.HOTEL_INSERT_QUEUE)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">listenHotelInsertOrUpdate</span><span class=\"params\">(Long id)</span>&#123;</span><br><span class=\"line\">        hotelService.insertById(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"meta\">@RabbitListener(queues = MqConstants.HOTEL_DELETE_QUEUE)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">listenHotelDelete</span><span class=\"params\">(Long id)</span>&#123;</span><br><span class=\"line\">        hotelService.deleteById(id);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">insertById</span><span class=\"params\">(Long id)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 0.根据id查询酒店数据</span></span><br><span class=\"line\">        <span class=\"type\">Hotel</span> <span class=\"variable\">hotel</span> <span class=\"operator\">=</span> getById(id);</span><br><span class=\"line\">        <span class=\"comment\">// 转换为文档类型</span></span><br><span class=\"line\">        <span class=\"type\">HotelDoc</span> <span class=\"variable\">hotelDoc</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HotelDoc</span>(hotel);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 1.准备Request对象</span></span><br><span class=\"line\">        <span class=\"type\">IndexRequest</span> <span class=\"variable\">request</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IndexRequest</span>(<span class=\"string\">&quot;hotel&quot;</span>).id(hotel.getId().toString());</span><br><span class=\"line\">        <span class=\"comment\">// 2.准备Json文档</span></span><br><span class=\"line\">        request.source(JSON.toJSONString(hotelDoc), XContentType.JSON);</span><br><span class=\"line\">        <span class=\"comment\">// 3.发送请求</span></span><br><span class=\"line\">        client.index(request, RequestOptions.DEFAULT);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">deleteById</span><span class=\"params\">(Long id)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1.准备Request</span></span><br><span class=\"line\">        <span class=\"type\">DeleteRequest</span> <span class=\"variable\">request</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DeleteRequest</span>(<span class=\"string\">&quot;hotel&quot;</span>, id.toString());</span><br><span class=\"line\">        <span class=\"comment\">// 2.发送请求</span></span><br><span class=\"line\">        client.delete(request, RequestOptions.DEFAULT);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>产生的效果就是： 当后台数据发生修改的时候，会使得消息队列 能接受到消息，随即es中的数据也发生了变化</code></p>\n</blockquote>\n<h4 id=\"用户签到\">用户签到</h4>\n<p><code>bitmap   </code>     <code>签到记录为1，未签到则记录为0.</code></p>\n<p>用户签到-实现签到功能</p>\n<ul>\n<li>获取当前登录用户</li>\n<li>获取今天的日期  并  拼接key  计算   今天是本月的第几天</li>\n<li>写入<code>Redis</code> <code>SETBIT key offset 1</code>       <code>stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - 1, true);</code></li>\n</ul>\n<p>用户签到-连续签到的统计</p>\n<ul>\n<li>\n<p>获取当前登录用户</p>\n</li>\n<li>\n<p>获取今天的日期  并  拼接key  计算   今天是本月的第几天</p>\n</li>\n<li>\n<p>写入<code>Redis</code> <code>SETBIT key offset 1</code>       <code>stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - 1, true);</code></p>\n</li>\n<li>\n<p>获取本月截止今天为止的所有的签到记录，返回的是一个十进制的数字</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(</span><br><span class=\"line\">            key,</span><br><span class=\"line\">            BitFieldSubCommands.create()</span><br><span class=\"line\">           .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class=\"number\">0</span>)</span><br><span class=\"line\">    );</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>获取结果  并   循环遍历</p>\n<ul>\n<li>让这个数字与1做与运算，得到数字的最后一个bit位  判断这个bit位是否为0\n<ul>\n<li>如果为0，说明未签到，结束</li>\n<li>如果不为0，说明已签到，计数器+1</li>\n</ul>\n</li>\n<li>把数字右移一位，抛弃最后一个bit位，继续下一个bit位</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>什么叫做连续签到天数？</p>\n<ul>\n<li>从最后一次签到开始向前统计，直到遇到第一次未签到为止，计算总的签到次数，就是连续签到天数。</li>\n</ul>\n<p>如何得到本月到今天为止的所有签到数据？</p>\n<ul>\n<li><code>  BITFIELD key GET u[dayOfMonth] 0</code></li>\n</ul>\n<p>如何从后向前遍历每个bit位</p>\n<ul>\n<li>我们只需要让得到的10进制数字和1做与运算就可以了，因为1只有遇见1 才是1，其他数字都是0 ，我们把签到结果和1进行与操作，每与一次，就把签到结果向右移动一位，依次内推，我们就能完成逐个遍历的效果了</li>\n</ul>\n</blockquote>\n<h4 id=\"UV统计\">UV统计</h4>\n<p><code>hyperloglog</code></p>\n<p>简单的单元测试： 内存占用极小</p>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305271736460.png\" alt></p>\n<h4 id=\"双写一致性\">双写一致性</h4>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305271743480.png\" alt=\"image-20230527174335410\" style=\"zoom:33%;\">\n<p>前置：</p>\n<ul>\n<li><code>canal</code>工作原理\n<ul>\n<li>canal 模拟<code>MySQL slave</code>的交互协议，伪装自己为<code>MySQL slave</code>，向<code>MySQL master</code>发送<code>dump</code>协议</li>\n<li><code>MySQL master</code>收到<code>dump</code>请求，开始推送<code>binary log</code>给<code>slave</code> (即canal )</li>\n<li>canal<code> 解析</code>binary log<code>对象(原始为</code>byte流)</li>\n</ul>\n</li>\n</ul>\n<p><code>优于MQ</code>  — <code>代码0侵入</code></p>\n<p>思路：我们可以利用Canal提供的Java客户端，监听Canal通知消息。当收到变化的消息时，完成对缓存的更新。</p>\n<p>写法：参考官网[<a href=\"https://github.com/alibaba/canal/wiki/ClientExample\">https://github.com/alibaba/canal/wiki/ClientExample</a>] +对应笔记  ==代码库==</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.luojia.canaldemo.biz;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.otter.canal.client.CanalConnector;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.otter.canal.client.CanalConnectors;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.otter.canal.common.utils.AddressUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.otter.canal.protocol.CanalEntry.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.otter.canal.protocol.Message;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.luojia.canaldemo.utils.RedisUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.lettuce.core.RedisClient;</span><br><span class=\"line\"><span class=\"keyword\">import</span> redis.clients.jedis.Jedis;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.InetSocketAddress;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.UUID;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisCanalClientExample</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Integer</span> <span class=\"variable\">_60SECONDS</span> <span class=\"operator\">=</span> <span class=\"number\">60</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">REDIS_IP_ADDR</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;127.0.0.1&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">redisInsert</span><span class=\"params\">(List&lt;Column&gt; columns)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">JSONObject</span> <span class=\"variable\">jsonObject</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JSONObject</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Column column : columns) &#123;</span><br><span class=\"line\">            System.out.println(column.getName() + <span class=\"string\">&quot;: &quot;</span> + column.getValue() + <span class=\"string\">&quot; insert = &quot;</span> + column.getUpdated());</span><br><span class=\"line\">            jsonObject.put(column.getName(), column.getValue());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (columns.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> (<span class=\"type\">Jedis</span> <span class=\"variable\">jedis</span> <span class=\"operator\">=</span> RedisUtils.getJedis()) &#123;</span><br><span class=\"line\">                jedis.set(columns.get(<span class=\"number\">0</span>).getValue(), jsonObject.toJSONString());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">redisDelete</span><span class=\"params\">(List&lt;Column&gt; columns)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">JSONObject</span> <span class=\"variable\">jsonObject</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JSONObject</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Column column : columns) &#123;</span><br><span class=\"line\">            System.out.println(column.getName() + <span class=\"string\">&quot;: &quot;</span> + column.getValue() + <span class=\"string\">&quot; delete = &quot;</span> + column.getUpdated());</span><br><span class=\"line\">            jsonObject.put(column.getName(), column.getValue());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (columns.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> (<span class=\"type\">Jedis</span> <span class=\"variable\">jedis</span> <span class=\"operator\">=</span> RedisUtils.getJedis()) &#123;</span><br><span class=\"line\">                jedis.del(columns.get(<span class=\"number\">0</span>).getValue());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">redisUpdate</span><span class=\"params\">(List&lt;Column&gt; columns)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">JSONObject</span> <span class=\"variable\">jsonObject</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JSONObject</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Column column : columns) &#123;</span><br><span class=\"line\">            System.out.println(column.getName() + <span class=\"string\">&quot;: &quot;</span> + column.getValue() + <span class=\"string\">&quot; update = &quot;</span> + column.getUpdated());</span><br><span class=\"line\">            jsonObject.put(column.getName(), column.getValue());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (columns.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> (<span class=\"type\">Jedis</span> <span class=\"variable\">jedis</span> <span class=\"operator\">=</span> RedisUtils.getJedis()) &#123;</span><br><span class=\"line\">                jedis.set(columns.get(<span class=\"number\">0</span>).getValue(), jsonObject.toJSONString());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">printEntry</span><span class=\"params\">(List&lt;Entry&gt; entrys)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Entry entry : entrys) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (entry.getEntryType() == EntryType.TRANSACTIONBEGIN || entry.getEntryType() == EntryType.TRANSACTIONEND) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">RowChange</span> <span class=\"variable\">rowChage</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                rowChage = RowChange.parseFrom(entry.getStoreValue());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;ERROR ## parser of eromanga-event has an error , data:&quot;</span> + entry.toString(),</span><br><span class=\"line\">                        e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">EventType</span> <span class=\"variable\">eventType</span> <span class=\"operator\">=</span> rowChage.getEventType();</span><br><span class=\"line\">            System.out.println(String.format(<span class=\"string\">&quot;================&amp;gt; binlog[%s:%s] , name[%s,%s] , eventType : %s&quot;</span>,</span><br><span class=\"line\">                    entry.getHeader().getLogfileName(), entry.getHeader().getLogfileOffset(),</span><br><span class=\"line\">                    entry.getHeader().getSchemaName(), entry.getHeader().getTableName(),</span><br><span class=\"line\">                    eventType));</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (RowData rowData : rowChage.getRowDatasList()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (eventType == EventType.DELETE) &#123;</span><br><span class=\"line\">                    redisDelete(rowData.getBeforeColumnsList());</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (eventType == EventType.INSERT) &#123;</span><br><span class=\"line\">                    redisInsert(rowData.getAfterColumnsList());</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;-------&amp;gt; before&quot;</span>);</span><br><span class=\"line\">                    redisUpdate(rowData.getBeforeColumnsList());</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;-------&amp;gt; after&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建链接</span></span><br><span class=\"line\">        <span class=\"type\">CanalConnector</span> <span class=\"variable\">connector</span> <span class=\"operator\">=</span> CanalConnectors.newSingleConnector(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(AddressUtils.getHostIp(),</span><br><span class=\"line\">                <span class=\"number\">11111</span>), <span class=\"string\">&quot;example&quot;</span>, <span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">batchSize</span> <span class=\"operator\">=</span> <span class=\"number\">1000</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">emptyCount</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            connector.connect();</span><br><span class=\"line\">            <span class=\"comment\">// 监听当前库的所有表</span></span><br><span class=\"line\">            <span class=\"comment\">// connector.subscribe(&quot;.*\\\\..*&quot;);  .*\\\\..* 所有库所有表</span></span><br><span class=\"line\">            connector.subscribe(<span class=\"string\">&quot;jmall.t_user&quot;</span>);  <span class=\"comment\">// 指定库指定表 速度更快</span></span><br><span class=\"line\">            connector.rollback();</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">totalEmptyCount</span> <span class=\"operator\">=</span> <span class=\"number\">10</span> * _60SECONDS;<span class=\"comment\">//指定监听时间</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (emptyCount &lt; totalEmptyCount) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;我是canal，每秒监听一次：&quot;</span> + UUID.randomUUID().toString());</span><br><span class=\"line\">                <span class=\"type\">Message</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> connector.getWithoutAck(batchSize); <span class=\"comment\">// 获取指定数量的数据</span></span><br><span class=\"line\">                <span class=\"type\">long</span> <span class=\"variable\">batchId</span> <span class=\"operator\">=</span> message.getId();</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> message.getEntries().size();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (batchId == -<span class=\"number\">1</span> || size == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// MySQL数据没有变动</span></span><br><span class=\"line\">                    emptyCount++;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;empty count : &quot;</span> + emptyCount);</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        Thread.sleep(<span class=\"number\">1000</span>);  <span class=\"comment\">// 监听，一秒一次</span></span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    emptyCount = <span class=\"number\">0</span>; <span class=\"comment\">// 计数器</span></span><br><span class=\"line\">                    <span class=\"comment\">// System.out.printf(&quot;message[batchId=%s,size=%s] \\n&quot;, batchId, size);</span></span><br><span class=\"line\">                    printEntry(message.getEntries());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                   connector.ack(batchId); <span class=\"comment\">// 提交确认</span></span><br><span class=\"line\">                <span class=\"comment\">// connector.rollback(batchId); // 处理失败, 回滚数据</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;empty too many times, exit&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            connector.disconnect();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"短信验证码的点击次数\">短信验证码的点击次数</h4>\n<ul>\n<li>\n<p>连接jedis</p>\n</li>\n<li>\n<p>使用redis 对 <code>key-&gt;手机号</code>，时间，<code>value -&gt;次数</code>进行缓存</p>\n</li>\n<li>\n<p>由key 拿到对应的 value 并进行次数判断</p>\n</li>\n<li>\n<p>次数没到就继续发送并对对应的 key +1;</p>\n</li>\n<li>\n<p>次数到 不再发送，并且关闭jedis</p>\n</li>\n<li>\n<p>将验证码也放入jedis中，进行缓存，并随后进行判断校验即可</p>\n</li>\n</ul>\n<h4 id=\"手写布隆过滤器\">手写布隆过滤器</h4>\n<ul>\n<li>思路架构</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305261116008.png\" alt=\"image-20230526111610941\" style=\"zoom: 25%;\">\n<blockquote>\n<p><code>布隆过滤器</code>到 <code>redis</code> 的过程</p>\n</blockquote>\n<ul>\n<li>建立<code>布隆过滤器</code>白/黑名单初始化工具类，一开始就设置一部分数据为白/黑名单所有\n<ul>\n<li>白/黑名单客户加载到布隆过滤器</li>\n<li>计算<code>hashValue</code>，由于存在计算出来负数的可能，取绝对值</li>\n<li>通过<code>hashValue</code> 和 2的32次方后取余，获得对应的下标位置</li>\n<li>设置<code>redis</code>里面的<code>bitmap</code>对应类型的位置，并在<code>redis</code>中将该值设置<code>setBit</code>为1</li>\n</ul>\n</li>\n<li>检查是否在白/黑名单内\n<ul>\n<li>将<code>key</code> 进行<code>hash</code>计算  后  得到 <code>hashValue</code>并进行转化为下标位置，判断是否存在</li>\n<li>无则必无，有则能有</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>说明:</p>\n<ul>\n<li>布隆过滤器有，Redis有，一切都能正常访问</li>\n<li>布隆过滤器有，Redis无，可以正常访问并会写Redis</li>\n<li>布隆过滤器无，直接返回数据，不再继续走下去</li>\n</ul>\n</blockquote>\n<blockquote>\n<p><code>redis</code> 到 <code>mysql</code>  的过程</p>\n</blockquote>\n<ul>\n<li>\n<p>写操作： 低QPS的实现代码思路&lt;<code>没有布隆过滤器的一般思路</code>&gt;</p>\n<ul>\n<li>向 <code>mysql</code> 插入数据\n<ul>\n<li>当 <code>mysql</code> 插入成功就重新查新一次并将 查询结果 写到 <code>redis</code> 中</li>\n</ul>\n</li>\n<li>去<code>redis</code>上查询\n<ul>\n<li>如果<code>redis</code>有，直接返回  如果<code>redis</code>没有，在<code>mysql</code>上查询</li>\n<li><code>redis</code>无，再去查询我们的<code>mysql</code>  并 回写 到<code>redis</code>中</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>读操作： 高QPS的实现代码思路  【<code>双检加锁 </code>】</p>\n<ul>\n<li>去<code>redis</code>上查询\n<ul>\n<li><code>redis</code>有，直接返回  如果<code>redis</code>没有，在<code>mysql</code>上查询</li>\n<li>去<code>mysql</code>查询的时候会先加锁，保证一个请求操作，让外面的<code>redis</code>等待一下，避免击穿<code>mysql</code>（大公司的操作 ）</li>\n</ul>\n</li>\n<li>加锁后，第二次查询<code>redis</code>\n<ul>\n<li><code>mysql</code>有，<code>redis</code>无，再去查询<code>mysql</code>\n<ul>\n<li>都没有就缓存一个规定的空值（防止穿透）</li>\n<li>否则就 把<code>mysql</code>查询到的数据会写到<code>redis</code>并设置过期时间</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Guava布隆过滤器-—穿透\">Guava布隆过滤器 —穿透</h4>\n<blockquote>\n<p>和<code>redis</code> 是<code>解耦</code>的，所以优于 手写的 <code>布隆过滤器</code></p>\n<p><code>private static BloomFilter&lt;Integer&gt; bloomFilter = BloomFilter.create(Funnels.integerFunnel(), SIZE, fpp);</code></p>\n<p><strong>+</strong></p>\n<p>调用<code>api </code></p>\n</blockquote>\n<ul>\n<li>思路架构</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305261243415.png\" alt=\"image-20230526124311334\" style=\"zoom:43%;\">\n<ul>\n<li>流程</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305261253961.png\" alt=\"image-20230526125309880\" style=\"zoom:33%;\">\n<ul>\n<li>黑名单</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305261256361.png\" alt=\"image-20230526125602973\" style=\"zoom:33%;\">\n<h4 id=\"抢红包\">抢红包</h4>\n<p>需求：</p>\n<ul>\n<li>\n<p>不加锁保证原子性，支持高并发</p>\n</li>\n<li>\n<p>红包算法（二倍均值法）</p>\n<ul>\n<li>所有人抢到的金额之和 必须要 等于红包金额</li>\n<li>每个人至少抢到一分钱</li>\n<li>要保证所有人抢到金额的几率相等</li>\n<li>公式： <code>每次抢到的金额 = 随机取件（0，（剩余红包金额 ÷ 剩余人数N）× 2）</code></li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>分析：</p>\n<ul>\n<li>\n<p>发红包 抢红包  ：使用的数据结构： <code>list</code></p>\n</li>\n<li>\n<p>记录红包：<code>hash</code></p>\n</li>\n<li>\n<p>redis 每个命令都是<code>单线程</code> <code>原子性</code></p>\n</li>\n</ul>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> RedisTemplate redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">RED_PACKAGE_KEY</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;redpackage:&quot;</span>;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">RED_PACKAGE_CONSUME_KEY</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;redpackage:consume&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 拆红包的算法 ---&gt;  二倍均值算法</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> totalMoney</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> redpackageNumber</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> Integer[] splitRedPackageAlgorithm(<span class=\"type\">int</span> totalMoney, <span class=\"type\">int</span> redpackageNumber) &#123;</span><br><span class=\"line\">       Integer[] redPackageNums = <span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>[redpackageNumber];</span><br><span class=\"line\">       <span class=\"comment\">// 已经被抢夺的红包金额</span></span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">useMoney</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; redpackageNumber; i++) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (i == redpackageNumber - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">               redPackageNums[i] = totalMoney - useMoney;</span><br><span class=\"line\">           &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">               <span class=\"comment\">// 二倍均值算法，每次拆分后塞进子红包的金额</span></span><br><span class=\"line\">               <span class=\"comment\">// 金额 = 随机取件（0，（剩余红包金额 / 未被抢的剩余红包数 N ）* 2 ）</span></span><br><span class=\"line\">               <span class=\"type\">int</span> <span class=\"variable\">avgMoney</span> <span class=\"operator\">=</span> ((totalMoney - useMoney) / (redpackageNumber - i)) * <span class=\"number\">2</span>;</span><br><span class=\"line\">               redPackageNums[i] = <span class=\"number\">1</span> + <span class=\"keyword\">new</span> <span class=\"title class_\">Random</span>().nextInt(avgMoney - <span class=\"number\">1</span>);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           useMoney = useMoney + redPackageNums[i];</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> redPackageNums;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 发红包</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> totalMoney</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> redPackageNumber</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> String <span class=\"title function_\">sendRedPackage</span><span class=\"params\">(<span class=\"type\">int</span> totalMoney, <span class=\"type\">int</span> redPackageNumber)</span> &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 1. 拆红包，将总金额totalMoney拆分成 redpackageNumber 个子红包</span></span><br><span class=\"line\">       Integer[] splitRedPackages = splitRedPackageAlgorithm(totalMoney, redPackageNumber);     <span class=\"comment\">// 拆分红包算法（二倍均值算法）通过后获得的多个子红包数组</span></span><br><span class=\"line\">       <span class=\"comment\">// 2. 发红包并保存进 list 结构 并且设置过期时间</span></span><br><span class=\"line\">       <span class=\"type\">String</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> RED_PACKAGE_KEY + IdUtil.simpleUUID();</span><br><span class=\"line\">       redisTemplate.opsForList().leftPushAll(key, splitRedPackages);</span><br><span class=\"line\">       redisTemplate.expire(key, <span class=\"number\">1</span>, TimeUnit.DAYS);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">// 3.发红包ok，返回前台显示</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> key + <span class=\"string\">&quot;\\t&quot;</span> + Ints.asList(Arrays.stream(splitRedPackages).mapToInt(Integer::valueOf).toArray());</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> String <span class=\"title function_\">robRedPackage</span><span class=\"params\">(String redPackageKey, String userId)</span> &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 1.验证某个用户是否抢过红包，不可以多抢</span></span><br><span class=\"line\">       <span class=\"type\">Object</span> <span class=\"variable\">redPackage</span> <span class=\"operator\">=</span> redisTemplate.opsForHash().get(RED_PACKAGE_CONSUME_KEY + redPackageKey, userId);</span><br><span class=\"line\">       <span class=\"comment\">// 2.没有抢过红包可以抢，如果抢过返回 -2 表示抢过</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (<span class=\"literal\">null</span> == redPackage) &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 2.1 从 list 结构中出队一个作为抢的红包</span></span><br><span class=\"line\">           <span class=\"type\">Object</span> <span class=\"variable\">partRedPackage</span> <span class=\"operator\">=</span> redisTemplate.opsForList().leftPop(RED_PACKAGE_KEY + redPackageKey);</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (partRedPackage != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">               <span class=\"comment\">// 2.2 抢到红包后 需要记录到hash结构中 记录每人抢到的红包</span></span><br><span class=\"line\">               redisTemplate.opsForHash().put(RED_PACKAGE_CONSUME_KEY + redPackageKey, userId, partRedPackage);</span><br><span class=\"line\">               System.out.println(<span class=\"string\">&quot;用户&quot;</span> + userId + <span class=\"string\">&quot;\\t 抢到了多少钱的红包：&quot;</span> + partRedPackage);</span><br><span class=\"line\">               <span class=\"comment\">// TODO  后续异步进mysql或者MQ进一步做统计处理，每一年你发出多少红包，抢到了多少红包</span></span><br><span class=\"line\">               <span class=\"keyword\">return</span> String.valueOf(partRedPackage);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"comment\">// 2. 抢完了</span></span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"string\">&quot;errorCode: -1, 红包抢完了&quot;</span>;</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 3. 抢过了红包</span></span><br><span class=\"line\">           <span class=\"type\">int</span> <span class=\"variable\">myRedPackage</span> <span class=\"operator\">=</span> (<span class=\"type\">int</span>) redisTemplate.opsForHash().get(RED_PACKAGE_CONSUME_KEY + redPackageKey, userId);</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"string\">&quot;errorCode: -2,  message:&quot;</span> + userId + <span class=\"string\">&quot;\\t  你已经抢过了红包，不能在抢了,你抢的金额是&quot;</span> + myRedPackage;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>拆红包—目标:将总金额拆分为n 个子红包</p>\n<ul>\n<li>使用 <code>2倍均值算法</code> 分配不同的红包金额</li>\n</ul>\n</li>\n<li>\n<p>发红包</p>\n<ul>\n<li>将红包存放到<code>list</code>中，并设置<code>过期时间</code></li>\n<li>发完之后进行回显</li>\n</ul>\n</li>\n<li>\n<p>抢红包</p>\n<ul>\n<li>先验证用户是否抢过红包，就是 判断 get能不能取到值</li>\n<li>取不到，就是没抢过红包，可以从<code>list</code>中取出来，并将用户id 和抢到的金额 存到 <code>hash</code>中</li>\n<li>否则不能抢</li>\n</ul>\n</li>\n</ul>\n<p>批量删除</p>\n<blockquote>\n<p><code>redis-cli keys &quot;***&quot; | xargs redis-cli del</code>        <code>“***” 代表 key前缀</code></p>\n</blockquote>\n<hr>\n<h2 id=\"Redis的最佳实践\">Redis的最佳实践</h2>\n<p>键值设计</p>\n<ul>\n<li>\n<p>优雅的key结构</p>\n<ul>\n<li>\n<p>Redis的Key虽然可以自定义，但最好遵循下面的几个最佳实践约定：</p>\n<ul>\n<li>遵循基本格式：[业务名称]:[数据名]:[id]</li>\n<li>长度不超过44字节</li>\n<li>不包含特殊字符</li>\n</ul>\n</li>\n<li>\n<p>这样设计的好处：</p>\n<ul>\n<li>可读性强</li>\n<li>避免key冲突</li>\n<li>方便管理</li>\n<li>更节省内存： key是string类型，底层编码包含int、embstr和raw三种。\n<ul>\n<li>embstr在小于44字节使用，采用连续内存空间，内存占用更小。</li>\n<li>当字节数大于44字节时，会转为raw模式存储，在raw模式下，内存空间不是连续的，而是采用一个指针指向了另外一段内存空间，在这段空间里存储SDS内容，这样空间不连续，访问的时候性能也就会收到影响，还有可能产生内存碎片</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>拒绝BigKey</p>\n<ul>\n<li>BigKey通常以Key的大小和Key中成员的数量来综合判定</li>\n</ul>\n<p>恰当的数据结构例题</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305272018632.png\" alt=\"image-20230527201830448\" style=\"zoom:33%;\">\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305272019941.png\" alt=\"image-20230527201908854\" style=\"zoom:33%;\">\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305272020140.png\" alt=\"image-20230527202048068\" style=\"zoom:33%;\">\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305272021214.png\" alt=\"image-20230527202148144\" style=\"zoom:33%;\">\n<ul>\n<li>Key的最佳实践\n<ul>\n<li>固定格式：[业务名]:[数据名]:[id]</li>\n<li>足够简短：不超过44字节</li>\n<li>不包含特殊字符</li>\n</ul>\n</li>\n<li>Value的最佳实践：\n<ul>\n<li>合理的拆分数据，拒绝BigKey</li>\n<li>选择合适数据结构</li>\n<li>Hash结构的entry数量不要超过1000</li>\n<li>设置合理的超时时间</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"相关建议\">相关建议</h3>\n<blockquote>\n<p>持久化配置相关建议</p>\n</blockquote>\n<ul>\n<li>用来做缓存的Redis实例尽量不要开启持久化功能</li>\n<li>建议关闭RDB持久化功能，使用AOF持久化</li>\n<li>利用脚本定期在slave节点做RDB，实现数据备份</li>\n<li>设置合理的rewrite阈值，避免频繁的bgrewrite</li>\n<li>配置no-appendfsync-on-rewrite = yes，禁止在rewrite期间做aof，避免因AOF引起的阻塞</li>\n<li>部署有关建议：\n<ul>\n<li>Redis实例的物理机要预留足够内存，应对fork和rewrite</li>\n<li>单个Redis实例内存上限不要太大，例如4G或8G。可以加快fork的速度、减少主从同步、数据迁移压力</li>\n<li>不要与CPU密集型应用部署在一起</li>\n<li>不要与高硬盘负载应用一起部署。例如：数据库、消息队列</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>慢查询优化 建议</p>\n</blockquote>\n<p>注意此处的慢查询指的是：  <font color=\"red\">在Redis执行时耗时超过某个阈值的命令，称为慢查询</font></p>\n<p>危害</p>\n<ul>\n<li>会导致大量请求阻塞，从而引起报错</li>\n</ul>\n<p>配置</p>\n<ul>\n<li><code>slowlog-log-slower-than：慢查询阈值，单位是微秒。默认是10000，建议1000</code></li>\n<li><code>slowlog-max-len：慢查询日志（本质是一个队列）的长度。默认是128，建议1000</code></li>\n</ul>\n<p>查看慢查询</p>\n<ul>\n<li>slowlog len：查询慢查询日志长度</li>\n<li>slowlog get [n]：读取n条慢查询日志</li>\n<li>slowlog reset：清空慢查询列表</li>\n</ul>\n<h3 id=\"命令及安全配置\">命令及安全配置</h3>\n<p>漏洞出现的核心的原因有以下几点：</p>\n<ul>\n<li>Redis未设置密码</li>\n<li>利用了Redis的config set命令动态修改Redis配置</li>\n<li>使用了Root账号权限启动Redis</li>\n</ul>\n<p>解决：</p>\n<ul>\n<li>Redis一定要设置密码</li>\n<li>禁止线上使用下面命令：keys、flushall、flushdb、config set等命令。可以利用rename-command禁用。</li>\n<li>bind：限制网卡，禁止外网网卡访问</li>\n<li>开启防火墙</li>\n<li>不要使用Root账户启动Redis</li>\n<li>尽量不使用默认的端口</li>\n</ul>\n<h3 id=\"Redis内存划分和内存配置\">Redis内存划分和内存配置</h3>\n<p>危害</p>\n<ul>\n<li>当Redis内存不足时，可能导致Key频繁被删除、响应时间变长、QPS不稳定等问题。当内存使用率达到90%以上时就需要我们警惕，并快速定位到内存占用的原因。</li>\n</ul>\n<p>碎片问题的产生：</p>\n<ul>\n<li>Redis底层分配并不是这个key有多大，他就会分配多大，而是有他自己的分配策略，比如8,16,20等等，假定当前key只需要10个字节，此时分配8肯定不够，那么他就会分配16个字节，多出来的6个字节就不能被使用，这就是我们常说的 碎片问题</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>内存占用</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数据内存</td>\n<td>是Redis最主要的部分，存储Redis的键值信息。主要问题是BigKey问题、内存碎片问题</td>\n</tr>\n<tr>\n<td>进程内存</td>\n<td>Redis主进程本身运⾏肯定需要占⽤内存，如代码、常量池等等；这部分内存⼤约⼏兆，在⼤多数⽣产环境中与Redis数据占⽤的内存相⽐可以忽略。</td>\n</tr>\n<tr>\n<td>缓冲区内存</td>\n<td>一般包括客户端缓冲区、AOF缓冲区、复制缓冲区等。客户端缓冲区又包括输入缓冲区和输出缓冲区两种。这部分内存占用波动较大，不当使用BigKey，可能导致内存溢出。</td>\n</tr>\n</tbody>\n</table>\n<p>查看到Redis目前的内存分配状态</p>\n<ul>\n<li>info memory：查看内存分配的情况</li>\n<li>memory xxx：查看key的主要占用情况</li>\n</ul>\n<p>缓冲区内存常见的有三种：</p>\n<ul>\n<li>复制缓冲区：主从复制的repl_backlog_buf，如果太小可能导致频繁的全量复制，影响性能。通过replbacklog-size来设置，默认1mb</li>\n<li>AOF缓冲区：AOF刷盘之前的缓存区域，AOF执行rewrite的缓冲区。无法设置容量上限</li>\n<li><code>客户端缓冲区</code>：分为输入缓冲区和输出缓冲区，输入缓冲区最大1G且不能设置。输出缓冲区可以设置</li>\n</ul>\n<p>以上复制缓冲区和AOF缓冲区 不会有问题，最关键就是<code>客户端缓冲区</code>的问题</p>\n<p>客户端缓冲区：指的就是我们发送命令时，客户端用来缓存命令的一个缓冲区，也就是我们向redis输入数据的输入端缓冲区和redis向客户端返回数据的响应缓存区，输入缓冲区最大1G且不能设置，所以这一块我们根本不用担心，如果超过了这个空间，redis会直接断开，因为本来此时此刻就代表着redis处理不过来了，我们需要担心的就是输出端缓冲区</p>\n<p>在处理大量的big value，解决方案有两个</p>\n<p>1、设置一个大小</p>\n<p>2、增加我们带宽的大小，避免我们出现大量数据从而直接超过了redis的承受能力</p>\n<h3 id=\"集群的一系列问题\">集群的一系列问题</h3>\n<p>集群虽然具备高可用特性，能实现自动故障恢复，但是如果使用不当，也会存在一些问题：</p>\n<ul>\n<li>集群完整性问题</li>\n<li>集群带宽问题</li>\n<li>数据倾斜问题</li>\n<li>客户端性能问题</li>\n<li>命令的集群兼容性问题</li>\n<li>lua和事务问题[<code>如果key不在一个节点，那么是无法保证lua的执行和事务的特性的，所以在集群模式是没有办法执行lua和事务的</code>]</li>\n</ul>\n<blockquote>\n<p>单体Redis（主从Redis）已经能达到万级别的QPS，并且也具备很强的高可用特性。如果主从能满足业务需求的情况下，所以如果不是在万不得已的情况下，尽量不搭建Redis集群</p>\n</blockquote>\n<h3 id=\"redis的其他用法\">redis的其他用法</h3>\n<ul>\n<li>\n<p>数据共享，分布式Session</p>\n</li>\n<li>\n<p>分布式锁</p>\n</li>\n<li>\n<p>全局ID</p>\n</li>\n<li>\n<p>计算器、点赞</p>\n</li>\n<li>\n<p>位统计</p>\n</li>\n<li>\n<p>购物车</p>\n</li>\n<li>\n<p>轻量级消息队列     list  &amp;   stream</p>\n</li>\n<li>\n<p>抽奖</p>\n</li>\n<li>\n<p>点赞、签到、打卡</p>\n</li>\n<li>\n<p>交集差集并集，用户关注，可能认识的人</p>\n</li>\n<li>\n<p>热点新闻、热搜排行</p>\n</li>\n</ul>\n<blockquote>\n<p>CAP 中</p>\n<ul>\n<li>redis <code>集群</code>是<code>AP</code>  redis <code>单机</code> 是 <code>C</code></li>\n</ul>\n</blockquote>\n","_path":"post/fa4c2b27.html","_link":"http://rycan.top/post/fa4c2b27.html","_id":"clm7xl5n9004k8l0pav6gc5zw"}}