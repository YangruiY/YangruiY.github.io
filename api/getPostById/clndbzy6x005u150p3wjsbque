{"type":"getPostById","data":{"title":"redis缓存","date":"2023-07-03T09:48:56.000Z","description":"redis缓存相关","categories":[{"name":"redis","_id":"clndbzy65002l150pfhmegzit"}],"tags":[{"name":"redis","_id":"clndbzy6b0046150pd9z39ioz"}],"content":"<meta name=\"referrer\" content=\"no-referrer\">\n<h2 id=\"缓存四问\">缓存四问</h2>\n<h3 id=\"1-缓存预热\">1.缓存预热</h3>\n<h4 id=\"font-color-red-是什么-font\"><font color=\"red\">是什么</font></h4>\n<ul>\n<li>缓存预热就是系统上线后，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据进行写回到缓存的问题！用户直接查询事先被预热的缓存数据！</li>\n</ul>\n<h4 id=\"font-color-red-怎么做-font\"><font color=\"red\">怎么做</font></h4>\n<ul>\n<li>将热点数据提前加载到<code>redis</code>缓存中，可以通过<code>@PostConstruct</code>提前在运行某个程序之前，将其加载到<code>redis</code>中</li>\n<li>或者使用 <code>Spring FrameFramework 提供的接口CommandLineRunner 自定义 预加载类在程序启动的时候 </code>存到<code>redis</code>中</li>\n</ul>\n<h3 id=\"2-缓存雪崩\">2.缓存雪崩</h3>\n<h4 id=\"font-color-red-是什么-font-2\"><font color=\"red\">是什么</font></h4>\n<ul>\n<li>缓存雪崩就是同一时段大量的缓存<code>key</code>同时失效或者<code>Redis服务宕机</code>，导致大量请求到达数据库，给数据库带来巨大压力。</li>\n</ul>\n<h4 id=\"font-color-red-何时发生-font\"><font color=\"red\">何时发生</font></h4>\n<ul>\n<li>Redis主机挂了，Redis全盘<code>崩溃</code></li>\n<li>Redis中有大量<code>key同时</code>过期<code>大面积失效</code>，</li>\n</ul>\n<h4 id=\"font-color-red-解决-与-预防-font\"><font color=\"red\">解决 与 预防</font></h4>\n<ol>\n<li>\n<p>Redis中key设置为<code>永不过期</code>或者过期时间为<code>指定时间+随机时间</code>，<code>错开同时过期的概率</code></p>\n<p>比如可以在原有的失效时间基础上增加一个<code>随机值</code>，比如 1-5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p>\n</li>\n<li>\n<p>Redis缓存集群实现高可用 [ <code>主从+哨兵</code>   <code>集群</code>  <code>开启Redis持久化机制AOF/RDB，尽快恢复缓存集群</code>]</p>\n</li>\n<li>\n<p>多级缓存结合预防雪崩   <code>ehcache本地缓存 + Redis缓存</code></p>\n<p>多级缓存架构示例  <code> nginx 缓存 + redis 缓存 + 本地缓存+tomcat缓存 + 其他缓存(ehcache 等)</code></p>\n</li>\n<li>\n<p>服务降级               <code>Hystrix</code>或者阿里<code>sentinel</code>限流&amp;降级</p>\n</li>\n<li>\n<p>设置过期标志更新缓存     记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际 key 的缓存。</p>\n</li>\n<li>\n<p>使用锁或队列：用加锁或者队列的方式来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上，该方法<code>不适用高并发</code>情况</p>\n</li>\n</ol>\n<h3 id=\"3-缓存击穿-redis-先有后失效\">3.缓存击穿&lt;redis 先有后失效&gt;</h3>\n<h4 id=\"font-color-red-是什么-font-3\"><font color=\"red\">是什么</font></h4>\n<ul>\n<li>大量请求同时查询一个key时，此时这个key正好失效了，就会导致大量的请求都打到数据库，<font color=\"red\">就是热点key突然失效了，MySQL压力增加</font></li>\n</ul>\n<h4 id=\"发生之后的现象\">发生之后的现象</h4>\n<ul>\n<li>数据库访问压力瞬时增加，数据库崩溃</li>\n<li>redis 正常运行</li>\n</ul>\n<h4 id=\"font-color-red-热点key失效可能-font\"><font color=\"red\">热点key失效可能</font></h4>\n<ul>\n<li>时间到了自然清除但还是被访问到</li>\n<li>delete掉的key，刚好又被访问到</li>\n</ul>\n<h4 id=\"font-color-red-解决-font\"><font color=\"red\">解决</font></h4>\n<ol>\n<li>\n<p>差异失效时间，对于访问频繁的热点key，干脆就<code>不设置过期时间</code>   而是设置<code>逻辑过期时间</code>，但是会有一定的数据不一致性</p>\n</li>\n<li>\n<p><font color=\"red\">互斥锁，互斥更新，采用双检加锁策略</font>        多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个互斥锁来锁住它。其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存</p>\n</li>\n<li>\n<p><code>预先设置热门数据</code>：在 redis 高峰访问之前，把一些热门数据提前存入到 redis 里面，加大这些热门数据 key 的时长。</p>\n</li>\n<li>\n<p>实时调整：现场监控哪些数据热门，实时调整 key 的过期时长。</p>\n</li>\n</ol>\n<h4 id=\"font-color-red-案例-font\"><font color=\"red\">案例</font></h4>\n<ul>\n<li>\n<p>方案一：使用互斥锁解决</p>\n<ul>\n<li>\n<p>使用<code>set del </code>上锁 放锁</p>\n</li>\n<li>\n<p>获取互斥锁，并判断是否获取成功，一旦获取失败就休眠重试</p>\n</li>\n<li>\n<p>获取成功就  去查询数据库</p>\n</li>\n<li>\n<p>最后释放互斥锁</p>\n<p><code>try &#123; boolean isLock = tryLock(lockKey); // 判断是否获取成功 if (!isLock) &#123; // 获取锁失败，休眠并重试 Thread.sleep(50); return queryWithMutex(keyPrefix, id, type, dbFallback, time, unit); &#125; // 获取锁成功，根据id查询数据库 r = dbFallback.apply(id); // 不存在，返回错误 if (r == null) &#123; // 将空值写入redis stringRedisTemplate.opsForValue().set(key, &quot;&quot;, CACHE_NULL_TTL, TimeUnit.MINUTES); // 返回错误信息 return null; &#125; // 存在，写入redis this.set(key, r, time, unit); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125;finally &#123; // 释放锁 unlock(lockKey); &#125;</code></p>\n</li>\n</ul>\n</li>\n<li>\n<p>方案二：设置逻辑过期时间</p>\n<ul>\n<li>\n<p>从redis查询商铺缓存  <code> String json = stringRedisTemplate.opsForValue().get(key);</code></p>\n</li>\n<li>\n<p>如果<code>redis</code>中查找到数据，就先把<code>json</code>反序列化为对象</p>\n<p><code>    RedisData redisData = JSONUtil.toBean(json, RedisData.class); R r = JSONUtil.toBean((JSONObject) redisData.getData(), type); LocalDateTime expireTime = redisData.getExpireTime();</code></p>\n</li>\n<li>\n<p>随后判断是否过期</p>\n</li>\n<li>\n<p>未过期，直接返回商品的信息</p>\n<p><code> if(expireTime.isAfter(LocalDateTime.now())) &#123; //未过期，直接返回店铺信息 return r; &#125;</code></p>\n</li>\n<li>\n<p>但是已过期，需要缓存重建</p>\n<ul>\n<li>\n<p>缓存重建</p>\n<ul>\n<li>\n<p>先进行 获取互斥锁，获取到锁   <code> boolean isLock = tryLock(lockKey);</code></p>\n<ul>\n<li>\n<p>一方面  检查redis 缓存是否过期（双检）</p>\n</li>\n<li>\n<p>另一方面开启独立线程（使用<code>线程池</code> 创建线程） 进行 缓存重建</p>\n<ul>\n<li>缓存重建:  就是再去数据库中查询数据，并写回redis中并设置过期时间</li>\n</ul>\n</li>\n<li>\n<p>重建完之后释放锁</p>\n<p><code>//成功，开启独立线程，实现缓存重建 CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123; try &#123; // 查询数据库 R newR = dbFallback.apply(id); // 重建缓存   步骤就是： 1、设置逻辑过期  2、 写入Redis this.setWithLogicalExpire(key, newR, time, unit); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125;finally &#123; // 释放锁 unlock(lockKey); &#125; &#125;);</code></p>\n</li>\n</ul>\n</li>\n<li>\n<p>没有获取到 互斥锁  直接返回</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-缓存穿透-两库都没\">4.缓存穿透&lt;两库都没&gt;</h3>\n<h4 id=\"font-color-red-是什么-font-4\"><font color=\"red\">是什么</font></h4>\n<ul>\n<li>请求去查询一条记录，先查redis，后查mysql，都查询不到，说明数据源是不存在的，但是请求每次都会打到数据库上面去，导致后台数据库压力暴增，这种现象我们称为缓存穿透</li>\n</ul>\n<h4 id=\"何时发生\">何时发生</h4>\n<p>黑客或者其他非正常用户<code>频繁</code>进行很多<code>非正常的 url 访问</code>，使得 redis 查询不到数据库。</p>\n<h4 id=\"发生之后产生的情况\">发生之后产生的情况</h4>\n<ul>\n<li>\n<p>应用服务器压力变大</p>\n</li>\n<li>\n<p>redis 命中率降低</p>\n</li>\n<li>\n<p>一直查询数据库，使得数据库压力太大而压垮</p>\n</li>\n</ul>\n<p>其实 redis 在这个过程中一直平稳运行，崩溃的是我们的数据库（如 MySQL）。</p>\n<h4 id=\"font-color-red-解决-font-2\"><font color=\"red\">解决</font></h4>\n<ol>\n<li>\n<p>使用布隆过滤器(<code>Guava</code>)</p>\n<p>它实际上是一个很长的<code>二进制向量 (位图)</code> 和一系列<code>随机映射函数（哈希函数）</code>。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都<code>远远超过一般</code>的算法，缺点是有一定的误识别率和删除困难。</p>\n</li>\n<li>\n<p>对空对象缓存</p>\n</li>\n</ol>\n<ul>\n<li>\n<p>回写增强: 如果发生了缓存穿透，我们可以针对要查询的数据，在Redis里存一个规定的缺省值(比如,零、负数、defaultNull等)</p>\n<p>第一次来查询一旦 <code>redis</code>和<code>mysql</code>都没有，返回<code>nul</code>给<code>调用者</code>，同时也让<code>redis</code>存入刚刚查不到的<code>key</code>，并对应的填上<code>规定的缺省值</code>，那么第二次来查，此时redis就有值了。</p>\n</li>\n</ul>\n<blockquote>\n<p>对空值缓存的弊端</p>\n<ul>\n<li>\n<p>一旦多次穿透，redis就会有很多 垃圾 key ，占用内存（可以设置ttl定期删除），</p>\n</li>\n<li>\n<p>但是因为这个<code>ttl</code> 可能会导致数据短期的不一致性 [mysql新增数据的时候同时存到redis,同样会有内存问题]</p>\n</li>\n</ul>\n<p>所以没有根本不能解决问题</p>\n</blockquote>\n<ol start=\"3\">\n<li>设置可访问的名单（白名单）：使用 bitmaps 类型定义一个可以访问的名单，名单 id 作为 bitmaps 的偏移量，每次访问和 bitmap 里面的 id 进行比较，如果访问 id 不在 bitmaps 里面，进行拦截，不允许访问。</li>\n<li>进行实时监控：当发现 Redis 的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务。</li>\n</ol>\n<h4 id=\"font-color-red-案例-font-2\"><font color=\"red\">案例</font></h4>\n<h5 id=\"手写布隆过滤器\">手写<code>布隆过滤器</code></h5>\n<ul>\n<li>\n<p><code>布隆过滤器</code>到 <code>redis</code> 的过程</p>\n<ul>\n<li>\n<p>建立<code>布隆过滤器</code>白/黑名单初始化<code>工具类</code>，一开始就设置一部分数据为白/黑名单所有</p>\n<ul>\n<li>白/黑名单客户<code>加载到布隆过滤器</code></li>\n<li>计算<code>hashValue</code>，由于存在计算出来负数的可能，取绝对值</li>\n<li>通过<code>hashValue</code> 和 2的32次方后取余，获得对应的下标位置</li>\n<li>设置<code>redis</code>里面的<code>bitmap</code>对应类型的位置，并在<code>redis</code>中将该值设置<code>setBit</code>为1</li>\n</ul>\n</li>\n<li>\n<p>检查是否在白/黑名单内</p>\n<ul>\n<li>将<code>key</code> 进行<code>hash</code>计算  后  得到 <code>hashValue</code>并进行转化为下标位置，判断是否存在\n<ul>\n<li>无则必无，有可能有</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>流程</p>\n</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305261253961.png\" alt=\"image-20230526125309880\" style=\"zoom:43%;\">\n<h5 id=\"Guava布隆过滤器\">Guava布隆过滤器</h5>\n<ul>\n<li>\n<p>和<code>redis</code> 是<code>解耦</code>的，所以优于 手写的 <code>布隆过滤器</code></p>\n</li>\n<li>\n<p>``private static BloomFilter<Integer> bloomFilter = BloomFilter.create(Funnels.integerFunnel(), SIZE, fpp);`</Integer></p>\n<p><strong>+</strong></p>\n<p>调用<code>api </code></p>\n</li>\n<li>\n<p>白名单思路：</p>\n</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305261243415.png\" alt=\"image-20230526124311334\" style=\"zoom:43%;\">\n<ul>\n<li>黑名单思路：</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305261256361.png\" alt=\"image-20230526125602973\" style=\"zoom:43%;\">\n<h3 id=\"小结：\">小结：</h3>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202307031742656.png\" alt=\"image-20230526130227733\" style=\"zoom:33%;\">\n<h2 id=\"缓存删除过期键的策略\">缓存删除过期键的策略</h2>\n<h3 id=\"Redis-过期键的删除策略\">Redis 过期键的删除策略</h3>\n<ul>\n<li>\n<p>立即删除      对CPU不友好，用处理器性能换取存储空间（拿时间换空间）</p>\n</li>\n<li>\n<p>惰性删除      对 内存 不友好，用存储空间换取处理器性能（拿空间换时间）</p>\n</li>\n<li>\n<p>定期删除    每隔一段时间执行一次删除过期键操作并通过限制删除操作执行时长和频率来减少删除操作对CPU时间的影响。定期抽样key，判断是否过期</p>\n</li>\n</ul>\n<blockquote>\n<p>定期清理的<code>两种模式</code>：</p>\n<ol>\n<li>\n<p><code>SLOW</code>模式执行频率默认为10，每次不超过25ms</p>\n</li>\n<li>\n<p><code>FAST</code>模式执行频率不固定，但两次间隔不低于2ms，每次耗时不超过1ms</p>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"缓存淘汰的策略\">缓存淘汰的策略</h2>\n<h3 id=\"redis-缓存淘汰策略\">redis 缓存淘汰策略</h3>\n<h4 id=\"主要两类：\">主要两类：</h4>\n<ul>\n<li>LRU   <code>最近最少</code>使用的页面置换算法，淘汰最长时间未被使用的页面，看页面<code>最后一次被使用到发生调度的时间长短</code>，首先<code>淘汰最长时间未被使用</code>的页面</li>\n<li>LFU   <code>最近最不常用</code>页面置换算法，淘汰一定时期内被访问次数最少的页面，看<code>一定时间段内被访问次数最少的页</code>，<code>看一定时间段内页面被使用的频率</code>，淘汰一定时期内被访问<code>次数最少的页</code></li>\n</ul>\n<h4 id=\"细分8类：\">细分8类：</h4>\n<ul>\n<li>noevication ： <code>不会驱逐任何key</code>，表示<code>即使内存达到上限也不进行置换</code>，所有能引起内存增加的命令都返回 error，<code>默认</code>就是这种策略。</li>\n<li><code>allkeys-lru</code>： 对所有key使用 LRU算法进行删除，<code>优先删除掉最近不经常使用的key</code>，用以保存新数据  <code>工作中常用</code></li>\n<li><code>volatie</code>-lru : 对所有<code>设置了过期时间的key</code>使用<code>LRU 算法</code>删除</li>\n<li>allkeys-random ：对所有key<code>随机删除</code></li>\n<li><code>volatie</code>-random ： 对所有<code>设置了过期时间的key</code> <code>随机删除</code></li>\n<li>volatie-ttl ：对所有设置了过期时间的key<code>随即删除</code></li>\n<li>allkeys-lfu：对所有key使用LFU算法进行删除</li>\n<li>volatile-lfu：对所有设置了过期时间的key使用LFU算法进行删除</li>\n</ul>\n<blockquote>\n<p>上面8种模式:   2 * 4 =8、<code>2</code>个维度(过期键中筛选、所有键中筛选)、<code>4</code>个方面(LRU、LFU、random、ttl)、<code>8</code>个选项</p>\n</blockquote>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202307031742321.png\" alt=\"image-20230527223142532\" style=\"zoom=55%;\">\n<h3 id=\"选择原则\">选择原则</h3>\n<ul>\n<li>\n<p>在所有的key都是最近最经常使用，那么就需要选择<code>allkeys-lru</code>进行置换最近最不经常使用的key,如果你不确定使用哪种策略，那么推荐使用<code>allkeys-lru</code></p>\n</li>\n<li>\n<p>如果所有的key的访问概率都是差不多的，那么可以选用<code>allkeys-random</code>策略去置换数据</p>\n</li>\n<li>\n<p>如果对数据有足够的了解，能够为key指定<code>hint</code>(通过<code>expire/ttl</code>指定)，那么可以选择<code>volatile-ttl</code>进行置换</p>\n</li>\n</ul>\n<h3 id=\"使用建议\">使用建议</h3>\n<ul>\n<li><code>避免</code>存储bigkey</li>\n<li>redis缓存淘汰策略配置性能建议<code>开启橢性淘汰</code>，<code>lazyfree-lazy-eviction=yes</code></li>\n</ul>\n<h2 id=\"缓存一致性\">缓存一致性</h2>\n<h3 id=\"要求\">要求</h3>\n<ul>\n<li>如果redis中<font color=\"red\">有数据</font> ，需要和数据库中的值相同</li>\n<li>如果redis中<font color=\"red\">无数据</font> ，数据库中的值要是最新值，且准备回写redis</li>\n</ul>\n<h3 id=\"缓存一致性的2种发生情况\">缓存一致性的2种发生情况</h3>\n<ul>\n<li>\n<p><code>只读缓存</code></p>\n</li>\n<li>\n<p><code>读写缓存</code></p>\n<ul>\n<li>\n<p>同步直写策略<code>[就是只要查到数据库就立刻回写到缓存，保持同步,及时生效]</code></p>\n<ul>\n<li>\n<p>写数据库之后也同步写redis缓存，缓存和数据库中的数据一致；</p>\n</li>\n<li>\n<p>对于读写缓存来说，要想保证缓存和数据库中的数据一致，就要采用<code>同步直写策略</code></p>\n</li>\n</ul>\n</li>\n<li>\n<p>异步缓写策略<code>[业务上有一定的延时允许]</code></p>\n<ul>\n<li>\n<p>正常业务中，MySQL数据变了，但是可以在业务上容许出现一定时间后才作用于redis，比如仓库、物流系统</p>\n</li>\n<li>\n<p>异常情况出现了， 不得不将失败的动作重新修补，有可能需要借助kafka或者RabbitMQ等消息中间件，实现重试重写</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"优化使用\">优化使用</h3>\n<blockquote>\n<p>采用  <code>双检加锁</code>的思想</p>\n</blockquote>\n<h4 id=\"没有加锁的隐患：\">没有加锁的隐患：</h4>\n<ol>\n<li>\n<p>对于mysql的请求会大量增加<code>（mysql会被打爆）</code>0</p>\n</li>\n<li>\n<p>对于redis 的回写操作可能会 数据覆盖（不是原子操作，多线程就会并发，引发问题）</p>\n</li>\n</ol>\n<h4 id=\"实现思路：\">实现思路：</h4>\n<p>当有多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个<code>互斥锁</code>来锁住它。</p>\n<p>其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存；后面的线程进来发现已经有缓存了，就直接走缓存。</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202307031742344.png\" alt=\"image-20230525225420679\" style=\"zoom: 25%;\">\n<h3 id=\"一致性的更新策略\">一致性的更新策略</h3>\n<h4 id=\"目的\">目的</h4>\n<p>达到数据的 <code>最终一致性</code></p>\n<h4 id=\"一致性要求\">一致性要求</h4>\n<h5 id=\"弱一致性：\">弱一致性：</h5>\n<ul>\n<li>过期剔除：   使用<code>redis</code>的内存淘汰机制 ； <font color=\"blue\">给缓存设置过期时间，定期清理缓存并回写，是保证最终一致性的解决方案。</font></li>\n</ul>\n<p>我们可以对存入缓存的数据设置过期时间，所有的<font color=\"red\">写操作以数据库为准</font>，对缓存操作只是尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存，达到一致性，<font color=\"red\">切记，要以mysql的数据库写入库为准</font>。</p>\n<h5 id=\"强一致性：\">强一致性：</h5>\n<ol>\n<li>\n<p>可以停机：停机升级，服务降级</p>\n</li>\n<li>\n<p>不可以停机：四种策略</p>\n<ul>\n<li>\n<p>先更新数据库，在更新缓存</p>\n</li>\n<li>\n<p>先更新缓存，再更新数据库</p>\n</li>\n<li>\n<p>先删除缓存，在更新数据库</p>\n</li>\n<li>\n<p>先更新数据库，在删除缓存</p>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"细说四种方式\">细说四种方式</h4>\n<h5 id=\"span-style-color-red-先更新数据库，再更新缓存-span\"><span style=\"color:red\">先更新数据库，再更新缓存</span></h5>\n<h6 id=\"异常情况：\"><strong>异常情况：</strong></h6>\n<p>多线程环境下，A、B两个线程有快有慢，有前有后有并行</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 A update mysql 100</span><br><span class=\"line\">3 B update mysql 80</span><br><span class=\"line\">4 B update redis 80</span><br><span class=\"line\">2 A update redis 100</span><br></pre></td></tr></table></figure>\n<p>最终结果，mysql和lredis数据不一致，  <code>mysql  80,redis   100</code></p>\n<h5 id=\"span-style-color-red-先更新缓存，再更新数据库-span\"><span style=\"color:red\">先更新缓存，再更新数据库</span></h5>\n<h6 id=\"异常情况：-2\"><strong>异常情况</strong>：</h6>\n<p>多线程环境下，A、B两个线程有快有慢，有前有后有并行</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A update redis 100</span><br><span class=\"line\">B update redis 80</span><br><span class=\"line\">B update mysql 80</span><br><span class=\"line\">A update mysql 100</span><br><span class=\"line\">mysql 100,redis 80</span><br></pre></td></tr></table></figure>\n<p>最终结果，mysql和lredis数据不一致，  <code>mysql  100,redis  80</code></p>\n<h5 id=\"span-style-color-red-先删除缓存，再更新数据库-span\"><span style=\"color:red\"> 先删除缓存，再更新数据库 </span></h5>\n<h6 id=\"异常情况\"><strong>异常情况</strong></h6>\n<ol>\n<li>\n<p>A线程先成功删除了redis里面的数据，然后去更新mysql,  此时mysql正在更新中，还没有结束。(比如网络延时)</p>\n</li>\n<li>\n<p>B突然出现要来读取缓存数据。此时redis里面的数据是空的，B线程来读取，先去读redis里数据(已经被A线程delete掉了)，</p>\n</li>\n</ol>\n<p>此处出来2个问题:<br>\n2.1 B从mysql获得了旧值   B线程发现redis里没有(缓存缺失)马上去mysql里面读取，从数据库里面读取来的是旧值。<br>\n2.2 B会把获得的旧值写回redis  获得旧值数据后返回前台并回写进redis(刚被A线程删除的旧数据有极大可能早被写回了)。</p>\n<ol start=\"3\">\n<li>\n<p>就是说   A线程更新完mysql,发现redis里面的缓存是脏数据，两个并发操作，一个是更新操作，另一个是查询操作，A删除缓存后，B查询操作没有命中缓存，B先把老数据读出来后放到缓存中，然后A更新操作更新了数据库。于是，在缓存中的数据还是老的数据，导致缓存中的数据是脏的，而且还一直这样脏下去了。</p>\n</li>\n<li>\n<p>总结流程:<br>\n(1)请求A进行写操作，删除redis缓存后，工作正在进行中，更新mysql… A还没有彻底更新完mysql,还没commit<br>\n(2)请求B开工查询，查询redis发现缓存不存在(被A从redis中删除了)<br>\n(3)请求B继续，去数据库查询得到了mysql中的旧值(A还没有更新完)<br>\n(4)请求B将旧值写回redis缓存<br>\n(5)请求A将新值写入mysql数据库</p>\n</li>\n</ol>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202307031742941.png\" alt=\"image-20230525231633568\" style=\"zoom:43%;\">\n<p>问题：如果数据库更新失败或超时或返回不及时，导致B线程请求访问缓存时发现redis里面没数据，缓存缺失，B再去读取mysql时，从数据库中读取到旧值，还写回redis， 导致A白干了</p>\n<h6 id=\"解决方案：\"><strong>解决方案：</strong></h6>\n<blockquote>\n<p>$\\textcolor{blue}{\\large延时双删}$：<font color=\"red\">采用<code>延时双删</code>[ 在第一次删除缓存值后，延迟一段时间再次进行删除]  策略 </font></p>\n</blockquote>\n<p>主要思想就是： 让一个线程删除前先进行休眠，并且其sleep的时间  需要大于另一个正在进行  <code>读取数据+ 写入缓存</code>的线程 的耗时之和</p>\n<h6 id=\"font-color-red-追问-font\"><font color=\"red\"><strong>追问</strong></font></h6>\n<ul>\n<li>\n<p><strong>这个删除该休眠多久呢</strong>？</p>\n<ul>\n<li>线程A <code>sleep的时间</code>，就需要<code>大于</code>线程B<code>读取数据再写入缓存的时间之和</code>。</li>\n</ul>\n</li>\n<li>\n<p><strong>这个时间怎么确定呢</strong>?<br>\n<font color=\"blue\">第一种方法：</font>在业务程序运行的时候，统计下线程读数据和写缓存的操作时间，<code>自行评估</code>自己的项目的读数据业务逻辑的耗时，以此为基础来进行估算。然后写数据的<code>休眠时间</code>则在<code>读数据业务逻辑的耗时基础上</code>加<code>百毫秒</code>即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。<br>\n<font color=\"blue\">第二种方法：</font><font color=\"blue\">新启动一个后台监控程序，比如 <code>WatchDog</code>监控程序，会自动续费加时</font></p>\n</li>\n<li>\n<p><strong>这种同步淘汰策略，吞吐量降低怎么办？</strong></p>\n<ul>\n<li>将第二次删除作为异步的，再启动一个线程进行异步删除，就可以不让写请求进行sleep 之后再返回，即可加大吞吐量</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202307031742326.png\" alt=\"image-20230525233149371\" style=\"zoom:50%;\">\n<p>​</p>\n<h5 id=\"span-style-color-red-先更新数据库，再删除缓存-span\"><span style=\"color:red\"> 先更新数据库，再删除缓存 </span></h5>\n<table>\n<thead>\n<tr>\n<th>时间</th>\n<th>线程A</th>\n<th>线程B</th>\n<th>出现的问题</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>t1</td>\n<td>更新数据库中的值…</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>t2</td>\n<td></td>\n<td>缓存立刻命中，此时B读取的是缓存旧值</td>\n<td>A还没来得及删除缓存的值，导致B缓存命中读到旧值</td>\n</tr>\n<tr>\n<td>t3</td>\n<td>更新缓存的数据，over</td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h6 id=\"问题：\">问题：</h6>\n<p>先更新数据库，在删除缓存，假如缓存删除失败或者来不及删除，导致请求再次访问redis时缓存命中，<font color=\"red\">读取到的是缓存的旧值。</font></p>\n<h6 id=\"解决：\">解决：</h6>\n<ul>\n<li>使用MQ</li>\n<li>使用 基于 订阅MySQL的 binlog程序的中间件<code>canal</code>   [代码0侵入，所以会更优]</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202307031742833.png\" alt=\"image-20230525233703703\" style=\"zoom:35%;\">\n<p>使用<code>消息队列</code>的基本思想</p>\n<ul>\n<li>可以把要删除的缓存值或者是要更新的数据库值<code>暂存</code>到<code>消息队列</code>中（例如使用Kafka/RabbitMQ等)。</li>\n<li>当程序<code>没有能够成功地删除</code>缓存值或者是更新数据库值时，可以从消息队列中<code>重新读取</code>这些值，然后再次进行删除或更新。</li>\n<li>如果<code>能够成功地删除或更新</code>，我们就要把这些值<code>从消息队列中去除</code>，以免重复操作，此时，我们也可以保证数据库和缓存的数据一致了，否则还需要再次进行重试</li>\n<li>如果<code>重试超过的一定次数后还是没有成功</code>，我们就需要向业务层发送报错信息了，通知运维人员。</li>\n</ul>\n<p>此种模式下严格意义上的 <code>强一致性</code>：</p>\n<ul>\n<li>如果业务层要求必须读取一致性的数据，那么我们就需要在更新数据库时，先在Redis缓存客户端暂停并发读请求，等数据库更新完、缓存值删除后，再读取数据，从而保证数据一致性</li>\n</ul>\n<p><font color=\"blue\" size=\"4\">只能达到最终一致性!!!</font></p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305262244890.png\" alt=\"image-20230526224429842\" style=\"zoom:35%;\">\n<h4 id=\"textcolor-red-总结\">$\\textcolor{red}{总结}$</h4>\n<table>\n<thead>\n<tr>\n<th>策略</th>\n<th>是否是高并发多线程条件下</th>\n<th>问题</th>\n<th>现象</th>\n<th>解决方案</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>先删再更</td>\n<td>否</td>\n<td>缓存删除成功但数据库更新失败</td>\n<td>Java程序从数据库中读到旧值</td>\n<td>再次更新数据库，重试</td>\n</tr>\n<tr>\n<td>先删再更</td>\n<td>是</td>\n<td>缓存删除成功但数据库更新中…有并发请求</td>\n<td>并发请求从数据库读到旧值并回写到redis，导致后续都是从redis读取到旧值</td>\n<td>延迟双删</td>\n</tr>\n<tr>\n<td>先更再删</td>\n<td>否</td>\n<td>数据库更新成功，但缓存删除失败</td>\n<td>Java程序从redis中读到旧值</td>\n<td>再次删除缓存，重试</td>\n</tr>\n<tr>\n<td>先更再删</td>\n<td>是</td>\n<td>数据库更新成功但缓存删除中…有并发读请求</td>\n<td>并发请求从缓存读到旧值</td>\n<td>等待redis删除完成，这段时间数据不一致，短暂存在。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"三种缓存的设计模式：\">三种缓存的设计模式：</h2>\n<ul>\n<li>\n<p><code>Cache Aside Pattern</code> 旁路缓存模式：缓存调用者在<code>更新完数据库后再去更新缓存</code>，也称之为双写方案</p>\n</li>\n<li>\n<p><code>Read/Write Through Pattern</code> 读写穿透模式: 由系统本身完成，<code>数据库与缓存的问题交由系统本身去处理</code></p>\n</li>\n<li>\n<p><code>Write Behind Caching Pattern</code> 异步缓存写入模式：调用者只操作缓存，其他线程去<code>异步处理数据库</code>，实现最终一致</p>\n</li>\n</ul>\n<h4 id=\"如何保证缓存与数据库的操作的同时成功或失败\">如何保证缓存与数据库的操作的同时成功或失败</h4>\n<ul>\n<li>单体系统，将缓存与数据库操作放在一个<code>事务</code></li>\n<li>分布式系统，利用<code>TCC等分布式事务</code>方案</li>\n</ul>\n<h2 id=\"细说canal实现一致性问题\">细说canal实现一致性问题</h2>\n<p>Canal 原理:</p>\n<ul>\n<li>对<code>MySQL</code>数据库增量日志(<code>binlog</code>)数据进行的<code>订阅、消费和解析</code>,从而将数据库的变更操作（如增、删、改）<code>解析成</code> <code>易于消费的格式</code>，并将这些事件存储到消息队列中，以供用程序进行<code>实时消费</code>或者进一步处理；这种方式可以实现数据库<code>变更的实时通知和异步处理</code>，提高系统的实<code>时性和可伸缩性</code></li>\n<li>就是说\n<ul>\n<li>canal 模拟<code>MySQL slave</code>的交互协议，伪装自己为<code>MySQL slave</code>，向<code>MySQL master</code>发送<code>dump</code>协议</li>\n<li><code>MySQL master</code>收到<code>dump</code>请求，开始推送<code>binary log</code>给<code>slave</code> (即canal )  随后  <code>canal</code> 解析<code>binary log</code>对象(原始为<code>byte流</code>)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"主要包括：\">主要包括：</h3>\n<ul>\n<li>数据库的日志获取： 获取数据库的<code>binlog</code> 日志  或者 <code>本地日志</code>，从而获取数据库的变更操作</li>\n<li>解析<code>binlog</code>日志： 将数据库的变更操作（如增、删、改）<code>解析成</code> <code>易于消费的格式</code></li>\n<li>进行过滤操作： 通过支持配置的过滤规则，可以根据库名、表名和事件类型等条件对解析得到的事件进行过滤。从而实现了 就只会对感兴趣的数据进行后续处理，提高消费效率。</li>\n<li>存储事件：Canal 将<code>解析得到的事件</code>存储到<code>消息队列</code>（如 Kafka）中，供<code>应用程序进行消费</code></li>\n<li>消费事件: 从<code>消息队列</code>中订阅并消费事件</li>\n</ul>\n<h3 id=\"能做什么\">能做什么</h3>\n<ul>\n<li>数据库镜像</li>\n<li>数据库实时备份</li>\n<li>索引构建和实时维护(拆分异构索引、倒排索引等)</li>\n<li>业务 cache 刷新</li>\n<li>带业务逻辑的增量数据处理</li>\n</ul>\n<h3 id=\"进行使用\">进行使用</h3>\n<h4 id=\"canal-服务端\">canal 服务端</h4>\n<ol>\n<li>\n<p>对 <code>canal</code>  进行配置 ,更换其中的  <code>canal</code> 配置文件中的 <code>mysql</code>  的地址,并进更换 <code>canal</code> 的账号name 和 密码</p>\n</li>\n<li>\n<p>启动 <code>canal</code></p>\n</li>\n</ol>\n<h4 id=\"canal客户端\">canal客户端</h4>\n<ol>\n<li>\n<p>在  yml  文件中 进行 配置连接的数据库</p>\n</li>\n<li>\n<p>使用 <code> springBoot</code>   使用 <code>jedis</code>  进行配置连接到<code>redis</code></p>\n</li>\n<li>\n<p>创建了一个 CanalConnector 对象，用于与 Canal 服务器建立连接。连接<code>参数</code>包括 <code>Canal 服务器的 IP 地址和端口</code>，<code>需要监听的数据库实例名</code>，<code>用户名和密码</code></p>\n</li>\n<li>\n<p>设置每次<code>获取数据的批处理大小</code>和<code>空数据计数器</code></p>\n</li>\n<li>\n<p>连接canal  , 并让 <code>canal</code>  进行订阅 指定的数据库与表&lt;<code> connector.subscribe(&quot;jmall.t_user&quot;);  // 指定库指定表 速度更快</code>&gt;</p>\n<ul>\n<li>\n<p>java程序下 <code>connector.subscribe</code>配置的过滤正则</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202307061843264.png\" alt=\"image-20230706184348231\" style=\"zoom:33%;\">\n</li>\n</ul>\n</li>\n<li>\n<p>获取<code>指定数量的数据</code>（batchSize），并获取<code>消息的批次号</code>（batchId）和<code>变更数据的数量</code>（size）。</p>\n</li>\n<li>\n<p>设置监听时间，如果 <code>batchId</code> 为 -1 或 size 为 0，说明数据库数据没有变动，将 <code>emptyCount</code> 计数加一，然后休眠一秒钟。如果连续获取空数据的次数超过  监听时间 <code>totalEmptyCount</code>（在示例中为 10 * 60 秒），则<code>退出循环</code></p>\n</li>\n<li>\n<p>如果 <code>batchId</code> 和 <code>size</code> 都大于 0，则表示有数据变动，进行处理</p>\n<p>处理过程就是 ： 对 Canal 的变更数据进行<code>解析和处理</code>的逻辑，<code>根据不同的事件类型调用相应的方法</code>处理数据</p>\n<ol>\n<li>\n<p>如果事件类型是 <code>DELETE</code>，代码调用 <code>redisDelete</code>方法，即处理<code>删除</code>操作。</p>\n<p><code> jedis.del(columns.get(0).getValue());</code></p>\n</li>\n<li>\n<p>如果事件类型是 <code>INSERT</code>，代码调用 <code>redisInsert </code>方法，即处理<code>插入</code>操作。</p>\n<p><code> jedis.set(columns.get(0).getValue(), jsonObject.toJSONString());</code></p>\n</li>\n</ol>\n</li>\n<li>\n<p>最后 <code>connector.ack(batchId)</code>  来<code>提交确认</code>，代表已经成功消费了这个批次的数据。如果<code>处理失败</code>，也可以使用<code>connector.rollback(batchId)</code>进行数据回滚</p>\n</li>\n<li>\n<p>执行结束后，通过 <code>connector.disconnect() </code>断开与 <code>Canal</code> 服务器的连接</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisCanalClientExample</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Integer</span> <span class=\"variable\">_60SECONDS</span> <span class=\"operator\">=</span> <span class=\"number\">60</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">REDIS_IP_ADDR</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;127.0.0.1&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">redisInsert</span><span class=\"params\">(List&lt;Column&gt; columns)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">JSONObject</span> <span class=\"variable\">jsonObject</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JSONObject</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Column column : columns) &#123;</span><br><span class=\"line\">            System.out.println(column.getName() + <span class=\"string\">&quot;: &quot;</span> + column.getValue() + <span class=\"string\">&quot; insert = &quot;</span> + column.getUpdated());</span><br><span class=\"line\">            jsonObject.put(column.getName(), column.getValue());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (columns.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> (<span class=\"type\">Jedis</span> <span class=\"variable\">jedis</span> <span class=\"operator\">=</span> RedisUtils.getJedis()) &#123;</span><br><span class=\"line\">                jedis.set(columns.get(<span class=\"number\">0</span>).getValue(), jsonObject.toJSONString());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">redisDelete</span><span class=\"params\">(List&lt;Column&gt; columns)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">JSONObject</span> <span class=\"variable\">jsonObject</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JSONObject</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Column column : columns) &#123;</span><br><span class=\"line\">            System.out.println(column.getName() + <span class=\"string\">&quot;: &quot;</span> + column.getValue() + <span class=\"string\">&quot; delete = &quot;</span> + column.getUpdated());</span><br><span class=\"line\">            jsonObject.put(column.getName(), column.getValue());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (columns.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> (<span class=\"type\">Jedis</span> <span class=\"variable\">jedis</span> <span class=\"operator\">=</span> RedisUtils.getJedis()) &#123;</span><br><span class=\"line\">                jedis.del(columns.get(<span class=\"number\">0</span>).getValue());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">redisUpdate</span><span class=\"params\">(List&lt;Column&gt; columns)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">JSONObject</span> <span class=\"variable\">jsonObject</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JSONObject</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Column column : columns) &#123;</span><br><span class=\"line\">            System.out.println(column.getName() + <span class=\"string\">&quot;: &quot;</span> + column.getValue() + <span class=\"string\">&quot; update = &quot;</span> + column.getUpdated());</span><br><span class=\"line\">            jsonObject.put(column.getName(), column.getValue());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (columns.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> (<span class=\"type\">Jedis</span> <span class=\"variable\">jedis</span> <span class=\"operator\">=</span> RedisUtils.getJedis()) &#123;</span><br><span class=\"line\">                jedis.set(columns.get(<span class=\"number\">0</span>).getValue(), jsonObject.toJSONString());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">printEntry</span><span class=\"params\">(List&lt;Entry&gt; entrys)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Entry entry : entrys) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (entry.getEntryType() == EntryType.TRANSACTIONBEGIN || entry.getEntryType() == EntryType.TRANSACTIONEND) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">RowChange</span> <span class=\"variable\">rowChage</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                rowChage = RowChange.parseFrom(entry.getStoreValue());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;ERROR ## parser of eromanga-event has an error , data:&quot;</span> + entry.toString(),</span><br><span class=\"line\">                        e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">EventType</span> <span class=\"variable\">eventType</span> <span class=\"operator\">=</span> rowChage.getEventType();</span><br><span class=\"line\">            System.out.println(String.format(<span class=\"string\">&quot;================&amp;gt; binlog[%s:%s] , name[%s,%s] , eventType : %s&quot;</span>,</span><br><span class=\"line\">                    entry.getHeader().getLogfileName(), entry.getHeader().getLogfileOffset(),</span><br><span class=\"line\">                    entry.getHeader().getSchemaName(), entry.getHeader().getTableName(),</span><br><span class=\"line\">                    eventType));</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (RowData rowData : rowChage.getRowDatasList()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (eventType == EventType.DELETE) &#123;</span><br><span class=\"line\">                    redisDelete(rowData.getBeforeColumnsList());</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (eventType == EventType.INSERT) &#123;</span><br><span class=\"line\">                    redisInsert(rowData.getAfterColumnsList());</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;-------&amp;gt; before&quot;</span>);</span><br><span class=\"line\">                    redisUpdate(rowData.getBeforeColumnsList());</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;-------&amp;gt; after&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建链接</span></span><br><span class=\"line\">        <span class=\"type\">CanalConnector</span> <span class=\"variable\">connector</span> <span class=\"operator\">=</span> CanalConnectors.newSingleConnector(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(AddressUtils.getHostIp(),</span><br><span class=\"line\">                <span class=\"number\">11111</span>), <span class=\"string\">&quot;example&quot;</span>, <span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">batchSize</span> <span class=\"operator\">=</span> <span class=\"number\">1000</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">emptyCount</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            connector.connect();</span><br><span class=\"line\">            <span class=\"comment\">// 监听当前库的所有表</span></span><br><span class=\"line\">            <span class=\"comment\">// connector.subscribe(&quot;.*\\\\..*&quot;);  .*\\\\..* 所有库所有表</span></span><br><span class=\"line\">            connector.subscribe(<span class=\"string\">&quot;jmall.t_user&quot;</span>);  <span class=\"comment\">// 指定库指定表 速度更快</span></span><br><span class=\"line\">            connector.rollback();</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">totalEmptyCount</span> <span class=\"operator\">=</span> <span class=\"number\">10</span> * _60SECONDS;<span class=\"comment\">//指定监听时间</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (emptyCount &lt; totalEmptyCount) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;我是canal，每秒监听一次：&quot;</span> + UUID.randomUUID().toString());</span><br><span class=\"line\">                <span class=\"type\">Message</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> connector.getWithoutAck(batchSize); <span class=\"comment\">// 获取指定数量的数据</span></span><br><span class=\"line\">                <span class=\"type\">long</span> <span class=\"variable\">batchId</span> <span class=\"operator\">=</span> message.getId();</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> message.getEntries().size();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (batchId == -<span class=\"number\">1</span> || size == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// MySQL数据没有变动</span></span><br><span class=\"line\">                    emptyCount++;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;empty count : &quot;</span> + emptyCount);</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        Thread.sleep(<span class=\"number\">1000</span>);  <span class=\"comment\">// 监听，一秒一次</span></span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    emptyCount = <span class=\"number\">0</span>; <span class=\"comment\">// 计数器</span></span><br><span class=\"line\">                    <span class=\"comment\">// System.out.printf(&quot;message[batchId=%s,size=%s] \\n&quot;, batchId, size);</span></span><br><span class=\"line\">                    printEntry(message.getEntries());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                connector.ack(batchId); <span class=\"comment\">// 提交确认</span></span><br><span class=\"line\">                <span class=\"comment\">// connector.rollback(batchId); // 处理失败, 回滚数据</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;empty too many times, exit&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            connector.disconnect();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","_path":"post/d27b7f98.html","_link":"http://rycan.top/post/d27b7f98.html","_id":"clndbzy6x005u150p3wjsbque"}}