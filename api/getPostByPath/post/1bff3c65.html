{"type":"getPostByPath","data":{"title":"MyBatis","date":"2023-09-13T15:44:55.000Z","description":"面试精选","categories":[{"name":"FaceToFace","_id":"cln1a3w9f000kgg0pg1jj2cur"}],"tags":[{"name":"MyBatis","_id":"cln1a3w9p002cgg0p14f6bkgu"}],"content":"<meta name=\"referrer\" content=\"no-referrer\">\n<h2 id=\"MyBatis\">MyBatis</h2>\n<ul>\n<li>\n<p>持久层框架，半自动的ORM（Object Relation Mapping）框架</p>\n</li>\n<li>\n<p>MyBatis中可以面向接口操作数据，要保证两个一致</p>\n<p>1、mapper接口的<strong>全类名</strong>和**映射文件的命名空间（namespace）**保持一致</p>\n<p>2、mapper接口中<strong>方法的方法名</strong>和映射文件中编写<strong>SQL的标签的id属性</strong>保持一致</p>\n</li>\n</ul>\n<h4 id=\"MyBatis获取参数值的两种方式\">MyBatis获取参数值的两种方式</h4>\n<p>1、<code>$&#123;&#125;  </code>本质就是<code>字符串拼接</code>；若为字符串类型或日期类型的字段进行赋值时，需要<strong>手动加单引号</strong></p>\n<p>2、<code>#&#123;&#125;</code>  本质就是<code>占位符赋值</code>；若为字符串类型或日期类型的字段进行赋值时，可以<strong>自动添加单引号</strong></p>\n<h4 id=\"查询：\">查询：</h4>\n<p>1、查询时 标签的设置；必须设置属性<code>resultType</code>或<code>resultMap</code>，用于设置实体类和数据库表的映射关系</p>\n<p>​\t1、resultType：自动映射，用于<strong>属性名和表中字段名一致</strong>的情况</p>\n<p>​\t<code>&lt;select id=&quot;getUserById&quot;  resultType=&quot;com.ry.mybatis.pojo.User&quot; &gt; select * from t_user  where id = 1       &lt;/select&gt;</code></p>\n<p>​\t2、resultMap：自定义映射，用于<strong>一对多</strong><code>或</code><strong>多对一</strong><code>或</code><strong>字段名和属性名不一致</strong>的情况</p>\n<p>2、当查询的数据为<strong>多条时</strong>，<strong>不能使用实体类作为返回值</strong>，只能使用集合，否则会抛出异常<code>TooManyResultsException</code>；但是若查询的数据<strong>只有一条</strong>，<strong>可以使用实体类或集合作为返回值</strong></p>\n<p>3、若查询出的数据只有一条[下面的方式都可以进行]</p>\n<ul>\n<li>a&gt;可以通过实体类对象接收</li>\n</ul>\n<ul>\n<li>b&gt;可以通过list集合接收</li>\n<li>c&gt;可以通过map集合接收 -----&gt; eg:结果：{password=123456, sex=男, id=3, age=23, <a href=\"mailto:email=12345@qq.com\">email=12345@qq.com</a>, username=admin}</li>\n</ul>\n<p>2、若查询出的数据有多条</p>\n<ul>\n<li>a&gt;可以通过实体类类型的list集合接收   <code> List&lt;User&gt; getAllUser();</code></li>\n<li>b&gt;可以通过map类型的list集合接收      <code> Map&lt;String,Object&gt; getUserByIdWithMap(Integer id);</code></li>\n<li>c&gt;可以在mapper接口的方法上添加@MapKey注解，此时就可以将每条数据转换的map集合作为值，以某个字段的值作为键，放在同一个map集合中（<code>@MapKey(&quot;id&quot;) //将唯一的字段作为键             Map&lt;String,Object&gt; getAllUserWithMap();</code>）</li>\n</ul>\n<ul>\n<li>注意：一定不能通过实体类对象接收，此时会抛异常TooManyResultsException</li>\n</ul>\n<h4 id=\"一些特别的功能\">一些特别的功能</h4>\n<p>1、可以进行模糊查询   <code>like &quot;%&quot;#&#123;username&#125;&quot;%&quot;</code></p>\n<p>2、可以进行批量操作   <code> where id in ($&#123;ids&#125;)</code></p>\n<p>3、可以设置表名          <code>$&#123;tableName&#125;</code></p>\n<p>4、可以获取自增主键    <code>    &lt;insert id=&quot;insertUser&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;  useGeneratedKeys:设置当前标签中的sql使用了自增的主键   keyProperty:将自增的主键的值赋值给传输到映射文件中参数的某个属性</code></p>\n<h4 id=\"映射问题\">映射问题</h4>\n<ul>\n<li>\n<p>解决： 字段和属性名不一样的情况的方法</p>\n<p>1、字段和属性名不一样的，为字段设置别名，保持和属性名一致  <code>select  eid,emp_name empName</code></p>\n<p>2、设置mybati-config.xml 进行全局配置 为驼峰式  <code>&lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;</code></p>\n<p>3、使用resultMap设置自定义映射   <code>&lt;resultMap id=&quot;EmpResultMap&quot; type=&quot;Emp&quot;&gt;  &lt;id property=&quot;eid&quot;  column=&quot;eid&quot;&gt;&lt;/id&gt;   &lt;result column=&quot;emp_name&quot; property=&quot;empName&quot;&gt;&lt;/result&gt;  ...  &lt;/resultMap&gt;</code></p>\n</li>\n<li>\n<p>解决：多对一映射处理</p>\n<p>1、级联方式处理映射关系</p>\n<p>2、使用association处理映射关系</p>\n<p>3、分步查询</p>\n</li>\n<li>\n<p>解决：一对多映射处理</p>\n<p>1、collection</p>\n<p>2、分步查询</p>\n</li>\n</ul>\n<h4 id=\"动态SQL\">动态SQL :</h4>\n<blockquote>\n<p>Mybatis框架的动态SQL技术是一种根据特定条件<strong>动态拼装SQL</strong>语句的功能，它存在的意义是为了解决拼接SQL语句字符串时的痛点问题。</p>\n</blockquote>\n<p>1、<code>if</code>标签可通过test属性的表达式进行判断，若表达式的结果为true，则标签中的内容会执行；反之标签中的内容不会执行</p>\n<p>2、<code>where</code>和if一般结合使用：只有where标签中的if条件满足，则where标签会自动添加where关键字，并将条件最前方多余的and去掉，但是不能去掉最后多余的and</p>\n<p>3、<code>trim</code>用于去掉或添加标签中的内容    <code>\tprefix：前面添加  prefixOverrides: 前面去掉某些内容   suffix: 后面添加  suffixOverrids:后面去掉的  </code></p>\n<p>4、<code>choose when、otherwise</code>: 相当于if…else if…else</p>\n<p>5、<code>foreach</code>   <code>collection：设置要循环的数组或集合      item：表示集合或数组中的每一个数据     separator：设置循环体之间的分隔符    open：设置foreach标签中的内容的开始符    close：设置foreach标签中的内容的结束符</code></p>\n<p>6、<code>SQL片段</code>  用于定义可重用的 SQL 片段。可以在 <code>&lt;sql&gt;</code> 标签中定义一段 SQL 片段，并在其他地方通过 <code>&lt;include&gt;</code> 标签引用。</p>\n<p>7、set：用于在 UPDATE 语句中动态生成 SET 子句。可以在 <code>&lt;set&gt;</code> 标签中包含多个列的更新逻辑，这些列的更新逻辑将会被包含在 SET 子句中</p>\n<p>8、bind：用于在 SQL 语句中创建一个新的变量，并将其绑定到指定的值。可以通过 <code>&lt;bind&gt;</code> 标签中的属性指定变量名和绑定值。</p>\n<p>9、include：用于包含其他 XML 文件中的 SQL 片段，提高 SQL 语句的复用性和可维护性。可以通过 <code>&lt;include&gt;</code> 标签引用其他定义好的 <code>&lt;sql&gt;</code> 或其他包含 SQL 片段的 XML 文件</p>\n<h4 id=\"MyBatis的缓存\">MyBatis的缓存</h4>\n<p>​\t1、一级缓存是SqlSession级别的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问</p>\n<p>​\t2、二级缓存是SqlSessionFactory级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取</p>\n<h5 id=\"MyBatis缓存查询的顺序\">MyBatis缓存查询的顺序</h5>\n<p>​\t1、先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用。<br>\n​\t2、如果二级缓存没有命中，再查询一级缓存<br>\n​\t3、如果一级缓存也没有命中，则查询数据库<br>\n​\t4、SqlSession关闭之后，一级缓存中的数据会写入二级缓存</p>\n<blockquote>\n<p>log4j的日志级别：</p>\n<p><code>FATAL(致命)&gt;ERROR(错误)&gt;WARN(警告)&gt;INFO(信息)&gt;DEBUG(调试)     从左到右打印的内容越来越详细</code></p>\n</blockquote>\n<h1>MyBatisPlus</h1>\n<p>MyBatis-Plus在实现插入数据时，会==默认基于雪花算法==的策略生成id</p>\n<h4 id=\"常见注解\">常见注解</h4>\n<ol>\n<li>\n<p>@TableName  <code>@TableName(&quot;t_user&quot;)     public class User&#123;&#125;</code></p>\n</li>\n<li>\n<p>@TableId       默认将id作为主键列，并在插入数据时，默认基于雪花算法的策略生成id<code>@TableId//(value = &quot;uid&quot;)//,type = IdType.AUTO)    private Long uid;</code></p>\n<p>1、value指定主键字段</p>\n<p>2、type设置主键生成策略    <strong>type属性用来定义主键策略：默认雪花算法</strong></p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">值</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">IdType.ASSIGN_ID（默认）</td>\n<td style=\"text-align:center\">基于雪花算法的策略生成数据id，与数据库id是否设置自增无关</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">IdType.AUTO</td>\n<td style=\"text-align:center\">使用数据库的自增策略，注意，该类型请==确保==数据库==已经==设置了id自增</td>\n</tr>\n</tbody>\n</table>\n<p>全部主键策略定义在了枚举类<code>IdType</code>中，<code>IdType</code>有如下的取值</p>\n<ul>\n<li>\n<p><code>AUTO </code>数据库ID自增，<strong>依赖于数据库</strong>。该类型请确保数据库设置了 ID自增 否则无效</p>\n</li>\n<li>\n<p><code>NONE</code>未设置主键类型。若在代码中没有手动设置主键，则会根据<strong>主键的全局策略</strong>自动生成（默认的主键全局策略是基于雪花算法的自增ID）</p>\n</li>\n<li>\n<p><code>INPUT</code>需要手动设置主键，若不设置。插入操作生成SQL语句时，主键这一列的值会是<code>null</code>。</p>\n</li>\n<li>\n<p><code>ASSIGN_ID</code>当没有手动设置主键，即实体类中的主键属性为空时，才会自动填充，使用雪花算法</p>\n</li>\n<li>\n<p><code>ASSIGN_UUID</code>当实体类的主键属性为空时，才会自动填充，使用UUID</p>\n</li>\n</ul>\n<ol start=\"3\">\n<li>\n<p>@TableField       保证实体类中的属性名和表中的字段名一致           <code>@TableField(&quot;name&quot;)      private String u_name;</code></p>\n<p>1、<code>fill</code>  属性来设置字段的自动填充</p>\n</li>\n<li>\n<p>@TableLogic    逻辑删除：假删除，将对应数据中代表是否被删除字段的状态修改为“被删除状态”，之后在数据库中仍旧能看到此条数据记录，可以进行数据恢复</p>\n</li>\n</ol>\n<h4 id=\"常见插件\">常见插件</h4>\n<p><code>  MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();</code></p>\n<p>1、分页插件  <code>interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));</code></p>\n<p>2、乐观锁插件  <code>interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());</code></p>\n<p>3、MyBatisX插件</p>\n<h1>MySQL主从复制</h1>\n<p><a href=\"https://blog.csdn.net/Guzarish/article/details/123244487\">https://blog.csdn.net/Guzarish/article/details/123244487</a></p>\n","_path":"post/1bff3c65.html","_link":"http://rycan.top/post/1bff3c65.html","_id":"cln1a3w9h000zgg0p37zp23ah"}}