<!-- - var pageType = is_post() ? 'post' : 'page'--><!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><div id="myscoll"></div><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Netty 学习(黑马) | RyCanの学习手记</title><meta name="author" content="Ryang"><meta name="copyright" content="Ryang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Netty-2">
<meta property="og:type" content="article">
<meta property="og:title" content="Netty 学习(黑马)">
<meta property="og:url" content="http://rycan.top/post/7d3cd9cc.html">
<meta property="og:site_name" content="RyCanの学习手记">
<meta property="og:description" content="Netty-2">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://rycan.top/img/5.jpg">
<meta property="article:published_time" content="2023-07-03T12:25:57.000Z">
<meta property="article:modified_time" content="2023-07-03T12:27:55.516Z">
<meta property="article:author" content="Ryang">
<meta property="article:tag" content="Netty">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://rycan.top/img/5.jpg"><link rel="shortcut icon" href="/img/"><link rel="canonical" href="http://rycan.top/post/7d3cd9cc.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.19/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?https://hm.baidu.com/hm.js?d8e3a0b8a30b7b4c269ee5f0b81bda2d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"该文章创建于","messageNext":"前，请以最新文章为主"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Ryang","link":"链接: ","source":"来源: RyCanの学习手记","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Netty 学习(黑马)',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2023-07-03 20:27:55'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="//at.alicdn.com/t/font_2264842_b004iy0kk2b.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><script type="text/javascript" src="https://cdn1.tianlelectric_clock:i0.top/npm/jquery@latest/dist/jquery.min.js"></script><script type="text/javascript" src="/js/rightmenu.js"></script><span id="fps"></span><script type="text/javascript" src="https://unpkg.zhimg.com/jquery@latest/dist/jquery.min.js"></script><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><script src="https://npm.elemecdn.com/echarts@4.9.0/map/js/china.js"></script><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><link rel="stylesheet" href="/css/car.css"><link rel="stylesheet" href="/css/emoji.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/mainColor/heoMainColor.css"><link rel="stylesheet" type="text/css" href="/css/404.css"><script async src="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/categoryBar/categoryBar.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/categoryBar/categoryBar.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/mainColor/heoMainColor.css"><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="https://unpkg.com/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><link rel="stylesheet" href="/css/collections.css"><link rel="stylesheet" href="/css/modify.css"><link rel="stylesheet" href="/css/style.css"><script src="http://cdn.bootcss.com/pace/1.0.2/pace.min.js" async></script><link rel="stylesheet" href="/css/duotone.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhheo/JS-Heo@master/mainColor/heoMainColor.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhheo/JS-Heo@main/tag-link/tag-link.css"><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"></div><div class="carplay"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/13.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr class="custom-hr"/><!--if theme.menu--><!--  .menus_items--><!--    each value, label in theme.menu--><!--      if typeof value !== 'object'--><!--        .menus_item--><!--          - const valueArray = value.split('||')--><!--          a.site-page(href=url_for(trim(valueArray[0])))--><!--            if valueArray[1]--><!--              i.fa-fw(class=trim(valueArray[1]))--><!--            span=' '+label--><!--      else--><!--        .menus_item--><!--          - const labelArray = label.split('||')--><!--          - const hideClass = labelArray[2] && trim(labelArray[2]) === 'hide' ? 'hide' : ''--><!--          a.site-page.group(class=`${hideClass}` href='javascript:void(0);')--><!--            if labelArray[1]--><!--              i.fa-fw(class=trim(labelArray[1]))--><!--            span=' '+ trim(labelArray[0])--><!--            i.fas.fa-chevron-down--><!--          ul.menus_item_child--><!--            each val,lab in value--><!--              - const valArray = val.split('||')--><!--              li--><!--                a.site-page.child(href=url_for(trim(valArray[0])))--><!--                  if valArray[1]--><!--                    i.fa-fw(class=trim(valArray[1]))--><!--                  span=' '+ lab--><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-shouye"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shouye"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-shijianzhou"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shijianzhou"></use></svg><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover" href="javascript:void(0);" rel="external nofollow noreferrer"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shu"></use></svg><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-biaoqian"></use></svg><span> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenlei"></use></svg><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:randomPost();" rel="external nofollow noreferrer"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-suiji"></use></svg><span> 随机文章</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/MessageBoard/"><i class="fa-fw icon-liuyanzhi"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-liuyanzhi"></use></svg><span> 给我留言</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover" href="javascript:void(0);" rel="external nofollow noreferrer"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-yu"></use></svg><span> 摸鱼</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.4399.com/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youxi"></use></svg><span> 4399</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.bilibili.com/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili"></use></svg><span> B站</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener external nofollow noreferrer" href="https://y.qq.com/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-mianxingerji"></use></svg><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/camera/"><i class="fa-fw icon-tupian1"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-tupian1"></use></svg><span> 图床</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/charts/"><i class="fa-fw icon-tongjifenxi"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-tongjifenxi"></use></svg><span> 统计</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover" href="javascript:void(0);" rel="external nofollow noreferrer"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lianjie"></use></svg><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-pengyoufill"></use></svg><span> 友情链接</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guanyuwo"></use></svg><span> 关于我</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/4.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="RyCanの学习手记"></a></span><div id="he-plugin-simple"></div><div id="none_space"><span class="site-name">RyCanの学习手记</span></div><div id="menus"><div id="search-button"><!--a.site-page.social-icon.search(href="javascript:void(0);")--><!--  i.fas.fa-search.fa-fw--><a class="search faa-parent animated-hover" title="检索站内任何你想要的信息"><svg class="faa-tada icon" style="height:24px;width:24px;fill:currentColor;position:relative;top:6px" aria-hidden="true"><use xlink:href="#icon-sousuo"></use></svg><span> 搜索</span></a></div><!--if theme.menu--><!--  .menus_items--><!--    each value, label in theme.menu--><!--      if typeof value !== 'object'--><!--        .menus_item--><!--          - const valueArray = value.split('||')--><!--          a.site-page(href=url_for(trim(valueArray[0])))--><!--            if valueArray[1]--><!--              i.fa-fw(class=trim(valueArray[1]))--><!--            span=' '+label--><!--      else--><!--        .menus_item--><!--          - const labelArray = label.split('||')--><!--          - const hideClass = labelArray[2] && trim(labelArray[2]) === 'hide' ? 'hide' : ''--><!--          a.site-page.group(class=`${hideClass}` href='javascript:void(0);')--><!--            if labelArray[1]--><!--              i.fa-fw(class=trim(labelArray[1]))--><!--            span=' '+ trim(labelArray[0])--><!--            i.fas.fa-chevron-down--><!--          ul.menus_item_child--><!--            each val,lab in value--><!--              - const valArray = val.split('||')--><!--              li--><!--                a.site-page.child(href=url_for(trim(valArray[0])))--><!--                  if valArray[1]--><!--                    i.fa-fw(class=trim(valArray[1]))--><!--                  span=' '+ lab--><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-shouye"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shouye"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-shijianzhou"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shijianzhou"></use></svg><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover" href="javascript:void(0);" rel="external nofollow noreferrer"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shu"></use></svg><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-biaoqian"></use></svg><span> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenlei"></use></svg><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:randomPost();" rel="external nofollow noreferrer"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-suiji"></use></svg><span> 随机文章</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/MessageBoard/"><i class="fa-fw icon-liuyanzhi"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-liuyanzhi"></use></svg><span> 给我留言</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover" href="javascript:void(0);" rel="external nofollow noreferrer"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-yu"></use></svg><span> 摸鱼</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.4399.com/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youxi"></use></svg><span> 4399</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.bilibili.com/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili"></use></svg><span> B站</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener external nofollow noreferrer" href="https://y.qq.com/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-mianxingerji"></use></svg><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/camera/"><i class="fa-fw icon-tupian1"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-tupian1"></use></svg><span> 图床</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/charts/"><i class="fa-fw icon-tongjifenxi"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-tongjifenxi"></use></svg><span> 统计</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover" href="javascript:void(0);" rel="external nofollow noreferrer"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lianjie"></use></svg><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-pengyoufill"></use></svg><span> 友情链接</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guanyuwo"></use></svg><span> 关于我</span></a></li></ul></div></div><a class="sun_moon faa-parent animated-hover" onclick="switchNightMode()" title="浅色和深色模式转换" id="nightmode-button"><svg class="faa-tada" style="height:25px;width:25px;fill:currentColor;position:relative;top:7px" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div><!--#randomPost--><!--  a.site-page.social-icon.search(href="javascript:;" onclick="randomPost()" title="随机访问一篇文章")--><!--    i.fas.fa-circle-notch.fa-fw--></nav><div id="post-info"><h1 class="post-title">Netty 学习(黑马)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-03T12:25:57.000Z" title="发表于 2023-07-03 20:25:57">2023-07-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-03T12:27:55.516Z" title="更新于 2023-07-03 20:27:55">2023-07-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">2.5w</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>93分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Netty 学习(黑马)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div><!----><!--span.post-qrcode--><!--  span.post-meta__separator |--><!--  i.fa.fa-qrcode.post-meta__icon.fa-fw(aria-hidden="true")--><!--  a(href="javasvript:;" onmouseover='document.getElementById("post-qrcode").style.display="block"' onmouseout='document.getElementById("post-qrcode").style.display="none"')='二维码'--><!--  div#post-qrcode.post-qrcode-img--><!--    img#post-img(src=qrcode(page.permalink))--></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><div class="top-img gist" style="background-image: url(/img/4.jpg)"></div><article class="post-content" id="article-container"><meta name="referrer" content="no-referrer">


<h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><h2 id="三大组件"><a href="#三大组件" class="headerlink" title="三大组件"></a>三大组件</h2><h3 id="1-Channel"><a href="#1-Channel" class="headerlink" title="1. Channel"></a>1. Channel</h3><blockquote>
<p>基本介绍</p>
</blockquote>
<ul>
<li><code>channel</code> 有一点类似于 <code>stream</code>，它就是读写<code>数据的双向通道</code>，可以从 <code>channel</code> 将数据读入 <code>buffer</code>，也可以将 buffer 的数据写入 <code>channel</code>，而之前的 <code>stream</code> 要么是输入，要么是输出，<code>channel</code> 比 <code>stream</code>更为底层</li>
<li>通道可以<code>同时进行读写</code>，而<code>流</code> <code>只能读或者只能写</code>,通道可以<code>实现异步读写数据</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">channel --&gt; buffer</span><br><span class="line">buffer --&gt; channel</span><br></pre></td></tr></table></figure>
<blockquote>
<p>常见的Channel</p>
</blockquote>
<ul>
<li>FileChannel                       <code>文件的数据读写</code></li>
<li>DatagramChannel           <code>UDP 的数据读</code></li>
<li>SocketChannel                 <code>TCP 的数据读写</code></li>
<li>ServerSocketChannel     <code>TCP 的数据读写</code></li>
</ul>
<blockquote>
<p><code>ServerSocketChanne</code> 类似 <code>ServerSocket</code>、<code>SocketChannel</code> 类似 <code>Socket</code></p>
</blockquote>
<h4 id="文件编程"><a href="#文件编程" class="headerlink" title="文件编程"></a><em>文件编程</em></h4><h5 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h5><ul>
<li><p>只能工作在阻塞模式下</p>
</li>
<li><p>方法</p>
<ul>
<li><p>获取</p>
<ul>
<li><code>不能直接打开</code> FileChannel，<code>必须</code>通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法<ul>
<li>通过 <code>FileInputStream</code> 获取的 channel <code>只能读</code></li>
<li>通过 <code>FileOutputStream</code> 获取的 channel <code>只能写</code></li>
<li>通过 RandomAccessFile 是否能读写根据构造 <code>RandomAccessFile</code>时的<code>读写模式</code>决定</li>
</ul>
</li>
</ul>
</li>
<li><p>读取</p>
<ul>
<li><p><code>read</code>  会从 <code>channel</code> 读取数据填充 <code>ByteBuffer</code>，返回值表示读到了多少字节，<code>-1</code> 表示到达了文件的末尾</p>
<p>使用方式：<code>channel.read(buffer);</code></p>
</li>
</ul>
</li>
<li><p>写入</p>
<ul>
<li>使用方式：<code>channel.write(buffer);</code> 一般会使用<code>while</code>循环的调用<code>write</code> ，只有这样才能确保一定能将所有的数据都写到channel中</li>
</ul>
</li>
<li><p>关闭</p>
<ul>
<li><code>channel</code> 必须<code>关闭</code>，不过调用了 FileInputStream、FileOutputStream 或者 RandomAccessFile 的 <code>close</code> 方法会间接地调用 channel 的 <code>close</code> 方法</li>
</ul>
</li>
<li><p>位置</p>
<ul>
<li>获取当前位置   <code>long pos  = channel.position();</code></li>
<li>设置当前位置   <code>channel.position(newPosition);</code></li>
<li><p>设置当前位置时，如果设置为文件的末尾</p>
<ul>
<li>这时读取会返回<code>-1</code></li>
<li>这时写入，会追加内容，但要注意如果 <code>position</code> 超过了文件末尾，再写入时在<code>新内容和原末尾之间</code>会有空洞（00）</li>
</ul>
</li>
</ul>
</li>
<li><p>大小</p>
<p>使用 <code>size</code> 方法获取文件的大小</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>强制写入</p>
<p>操作系统出于性能的考虑，会将数据缓存，不是立刻写入磁盘。可以调用 <code>force(true)</code> 方法将文件内容和元数据（文件的权限等信息）立刻写入磁盘</p>
</li>
</ul>
<h5 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h5><ul>
<li>类： <code>path,paths</code></li>
<li><code>Path</code> 用来表示<code>文件路径</code></li>
<li><code>Paths</code> 是工具类，用来<code>获取 Path 实例</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;1.txt&quot;</span>); <span class="comment">// 相对路径 使用 user.dir 环境变量来定位 1.txt</span></span><br><span class="line"></span><br><span class="line"><span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;d:\\1.txt&quot;</span>); <span class="comment">// 绝对路径 代表了  d:\1.txt</span></span><br><span class="line"></span><br><span class="line"><span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;d:/1.txt&quot;</span>); <span class="comment">// 绝对路径 同样代表了  d:\1.txt</span></span><br><span class="line"></span><br><span class="line"><span class="type">Path</span> <span class="variable">projects</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;d:\\data&quot;</span>, <span class="string">&quot;projects&quot;</span>); <span class="comment">// 代表了  d:\data\projects</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>.</code> 代表了当前路径</li>
<li><code>..</code> 代表了上一级路径</li>
</ul>
<p>例如目录结构如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d:</span><br><span class="line">	|- data</span><br><span class="line">		|- projects</span><br><span class="line">			|- a</span><br><span class="line">			|- b</span><br></pre></td></tr></table></figure>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;d:\\data\\projects\\a\\..\\b&quot;</span>);</span><br><span class="line">System.out.println(path);</span><br><span class="line">System.out.println(path.normalize()); <span class="comment">// 正常化路径</span></span><br></pre></td></tr></table></figure>
<p>会输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d:\data\projects\a\..\b</span><br><span class="line">d:\data\projects\b</span><br></pre></td></tr></table></figure>
<h5 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h5><p><code>Path path = Paths.get(&quot;......&quot;);</code></p>
<ul>
<li>检查是否存在：<code>System.out.println(Files.exists(path));</code></li>
<li>创建一级目录：<code>Files.createDirectory(path);</code><ul>
<li>如果目录<code>已存在</code>，会抛异常 <code>FileAlreadyExistsException</code></li>
<li><code>不能一次创建多级目录</code>，否则会抛异常 <code>NoSuchFileException</code></li>
</ul>
</li>
<li>创建多级目录: <code>Files.createDirectories(path);</code></li>
<li>拷贝文件  <code>Files.copy(source, target);</code>   其中 <code>source target</code>都要进行获取<ul>
<li>如果文件已存在，会抛异常 <code>FileAlreadyExistsException</code></li>
<li>用 <code>source</code> 覆盖掉 <code>target</code>，需要用 <code>StandardCopyOption</code> 来控制<code>Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);</code></li>
</ul>
</li>
<li>移动文件<ul>
<li><code>Files.move(source, target, StandardCopyOption.ATOMIC_MOVE);</code>  <code>StandardCopyOption.ATOMIC_MOVE</code> 保证文件移动的原子性</li>
</ul>
</li>
<li><p>删除文件<code>Files.delete(target);</code></p>
<ul>
<li>如果文件不存在，会抛异常 <code>NoSuchFileException</code></li>
</ul>
</li>
<li><p>删除目录<code>Files.delete(target);</code></p>
<ul>
<li>如果目录还有内容，会抛异常 <code>DirectoryNotEmptyException</code></li>
</ul>
</li>
<li>遍历目录文件<code>Files.walkFileTree(Paths.get(&quot;/Users/yangrui/Downloads/&quot;), new SimpleFileVisitor&lt;Path&gt;()</code></li>
<li>统计文件数目<code>Files.walkFileTree(Paths.get(&quot;/Users/yangrui/Pictures&quot;), new SimpleFileVisitor&lt;Path&gt;()</code></li>
<li>删除多级目录 <code>Files.walkFileTree(Paths.get(&quot;E:\\aio1 - 副本 - 副本&quot;), new SimpleFileVisitor&lt;Path&gt;()</code></li>
</ul>
<p>​    ⚠️ 删除很危险⚠️     删除是危险操作，确保要递归删除的文件夹没有重要内容</p>
<ul>
<li>拷贝多级目录 <code>Files.walk(Paths.get(source)).forEach(path -&gt; &#123;...&#125;</code></li>
</ul>
<h3 id="2-Buffer"><a href="#2-Buffer" class="headerlink" title="2. Buffer"></a>2. Buffer</h3><blockquote>
<p>基本介绍</p>
</blockquote>
<p>buffer 则用来<code>缓冲读写数据</code></p>
<p>常见的 buffer 有<code>ByteBuffer</code>（MappedByteBuffer、DirectByteBuffer、HeapByteBuffer）| <code>ShortBuffer</code>| <code>IntBuffer</code>|<code>LongBuffer</code>|<code>FloatBuffer</code>|<code>DoubleBuffer</code>|<code>CharBuffer</code></p>
<h5 id="ByteBuffer"><a href="#ByteBuffer" class="headerlink" title="ByteBuffer"></a><code>ByteBuffer</code></h5><blockquote>
<p><code>ByteBuffer</code>结构：</p>
<ul>
<li><code>capacity</code>&lt;容量&gt;</li>
<li><code>position</code>&lt;读到哪/写到哪 的 指针/索引下标&gt;</li>
<li><code>limit</code>&lt;限制&gt;</li>
</ul>
<p><span style="color:red">一开始</span></p>
</blockquote>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202306141856487.png" alt="image-20230614185614467" style="zoom:33%;"></p>
<blockquote>
<p><span style="color:red">写模式下，position 是写入位置，limit 等于容量，下图表示写入了 4 个字节后的状态</span></p>
<p>==注意：根据<code>读写模式</code>的不同 <code>position</code>的数值也是不同的==</p>
</blockquote>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202306141856067.png" alt="image-20230614185623653" style="zoom:33%;"></p>
<blockquote>
<p><span style="color:red">此时要读了 ，调用flip 切换为读 ，flip 动作发生后，position 切换为读取位置，limit 切换为读取限制</span></p>
</blockquote>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202306141906794.png" style="zoom:33%;"></p>
<blockquote>
<p><span style="color:red">读取 4 个字节后，状态</span></p>
</blockquote>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202306141856617.png" alt="image-20230614185649599" style="zoom:33%;"></p>
<blockquote>
<p><span style="color:red"> 从头开始写，调用  clear()，clear 动作发生后，状态</span></p>
</blockquote>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202306141856944.png" alt="image-20230614185657928" style="zoom:33%;"></p>
<blockquote>
<p><span style="color:red">开始上次未读完的地方继续写，调用 compact 方法，是把未读完的部分向前压缩，然后切换至写模式</span></p>
</blockquote>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202306141857030.png" alt="image-20230614185733003" style="zoom:33%;"></p>
<blockquote>
<p>使用方式：</p>
</blockquote>
<ol>
<li>向 <code>buffer</code> 写入数据，例如调用<code>channel.read(buffer)</code></li>
<li>调用 <code>flip()</code> 切换至<strong>读模式</strong></li>
<li>从 <code>buffer</code> 读取数据，例如调用 <code>buffer.get()</code></li>
<li>调用 <code>clear()</code> 或 <code>compact()</code>切换至<strong>写模式</strong></li>
<li>重复 1~4 步骤</li>
</ol>
<blockquote>
<p>常见方法：</p>
</blockquote>
<ul>
<li><p>分配空间——<code>allocate()</code>                     <code>Bytebuffer buf = ByteBuffer.allocate(16);</code></p>
</li>
<li><p>向<code>buffer</code> 中写数据</p>
<ul>
<li>调用 <code>channel</code> 的 <code>read</code> 方法         <code>int readBytes = channel.read(buf);</code></li>
<li>调用 <code>buffer</code> 自己的 <code>put</code> 方法      <code>buf.put((byte)127);</code></li>
</ul>
</li>
<li><p>从 <code>buffer</code> 读取数据</p>
<ul>
<li><p>调用 <code>channel</code> 的 <code>write</code> 方法        <code>int writeBytes = channel.write(buf);</code></p>
</li>
<li><p>调用 <code>buffer</code> 自己的 <code>get</code> 方法       <code>byte b = buf.get();</code></p>
<blockquote>
<p>注意：<code>get</code> 方法会让 <code>position</code> 读指针向后走，如果想重复读取数据</p>
<ul>
<li>可以调用 <code>rewind</code> 方法将 <code>position</code> 重新置为 <code>0</code></li>
<li>或者调用<code>get(int i)</code>含参的方法获取索引<code>i</code> 的内容，它不会移动读指针</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p><code>mark</code> &amp; <code>reset</code></p>
<ul>
<li><code>mark</code> 是在读取时，做一个标记，即使 <code>position</code> 改变，只要调用 <code>reset</code> 就能回到 <code>mark</code> 的位置</li>
<li><code>rewind</code> 和 <code>flip</code> 都会清除 mark 位置</li>
</ul>
</li>
<li><p>切换<code>读写</code>模式——<code>flip</code>    <code>compact</code></p>
<ul>
<li><p><code>buffer.flip(); // 切换至</code>读<code>模式 [position指针才指向开头，limit指向写入的最后位置 (内存长度)]</code></p>
</li>
<li><p><code>buffer.compact(); // 未读完的部分向前压缩，然后切换至</code>写<code>模式,下标position到压缩后的字符长度的位置，limit到写入限制</code></p>
</li>
</ul>
</li>
<li><p>分配空间</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ByteBuffer.allocate(<span class="number">10</span>).getClass()); </span><br><span class="line"><span class="comment">//class java.nio.HeapByteBuffer --java 堆内存，在堆中，读写效率较低，会受到gc的影响</span></span><br><span class="line"></span><br><span class="line">System.out.println(ByteBuffer.allocateDirect(<span class="number">10</span>).getClass());</span><br><span class="line"><span class="comment">//class java.nio.DirectByteBuffer -- 在直接内存中，在内存中读写效率较高，不会受到gc的影响，分配内存的效率较低，可能会内存泄漏,所以在使用完后，需要彻底的释放，以免内存泄露</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>字符串</code>与 <code>ByteBuffer</code> 互转</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">bu1</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式一： nio提供的工具类 wrap 方法， 将字节数组 ===&gt; 包装成ByteBuffer  也会自动切换为 读模式了</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">bu3</span> <span class="operator">=</span> ByteBuffer.wrap(<span class="string">&quot;buffer&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二： 字符串 转 字节数组 ===&gt; 使用put方法放 进去</span></span><br><span class="line">bu1.put(<span class="string">&quot;buffer&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式三： 使用 字符集类 Charset</span></span><br><span class="line"> <span class="type">ByteBuffer</span> <span class="variable">bu4</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;utf-8&quot;</span>).encode(<span class="string">&quot;Charset.format()&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式四： 使用 字符集类 Charset , 它本身就支持 和 ByteBuffer 相互转换 会自动切换为 读模式了</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">bu2</span> <span class="operator">=</span> StandardCharsets.UTF_8.encode(<span class="string">&quot;你好,buffer&quot;</span>);  <span class="comment">//此处中文在字符数组中不显示</span></span><br></pre></td></tr></table></figure>
<ul>
<li>分散读——<code>Scattering Reads</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;/Users/yangrui/Downloads/A_Java学习资源/Java_Netty/black-horse-netty-master/netty-1-nio/words.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>).getChannel();</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">bu1</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">3</span>); <span class="comment">// one</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">bu2</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">3</span>); <span class="comment">// two</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">bu3</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">5</span>); <span class="comment">// three</span></span><br><span class="line">        channel.read(<span class="keyword">new</span> <span class="title class_">ByteBuffer</span>[]&#123;bu1,bu2,bu3&#125;);</span><br><span class="line">        bu1.flip();</span><br><span class="line">        bu2.flip();</span><br><span class="line">        bu3.flip();</span><br><span class="line">        <span class="comment">//写的时候才能debugAll()</span></span><br><span class="line">        debugAll(bu1);</span><br><span class="line">        debugAll(bu2);</span><br><span class="line">        debugAll(bu3);</span><br></pre></td></tr></table></figure>
<ul>
<li>集中写——<code>Gathering Writes</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">b1</span> <span class="operator">=</span> StandardCharsets.UTF_8.encode(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// 5字节</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">b2</span> <span class="operator">=</span> StandardCharsets.UTF_8.encode(<span class="string">&quot;world&quot;</span>);  <span class="comment">// 5字节</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">b3</span> <span class="operator">=</span> StandardCharsets.UTF_8.encode(<span class="string">&quot;你好&quot;</span>);   <span class="comment">// 6字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">FileChannel</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;/Users/yangrui/Downloads/A_Java学习资源/Java_Netty/black-horse-netty-master/netty-1-nio/writes1.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>).getChannel();</span><br><span class="line">            ch.write(<span class="keyword">new</span> <span class="title class_">ByteBuffer</span>[]&#123;b1, b2, b3&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 另一例</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;/Users/yangrui/Downloads/A_Java学习资源/Java_Netty/black-horse-netty-master/netty-1-nio/words.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> file.getChannel();</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">d</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">e</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">    channel.position(<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">    d.put(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;r&#x27;</span>&#125;);</span><br><span class="line">    e.put(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;);</span><br><span class="line">    d.flip();</span><br><span class="line">    e.flip();</span><br><span class="line">    debug(d);</span><br><span class="line">    debug(e);</span><br><span class="line">    channel.write(<span class="keyword">new</span> <span class="title class_">ByteBuffer</span>[]&#123;d, e&#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>Buffer</code>是<code>非线程安全的</code></p>
</blockquote>
<h3 id="3-Selector"><a href="#3-Selector" class="headerlink" title="3. Selector"></a>3. Selector</h3><h5 id="3-1-多线程版本"><a href="#3-1-多线程版本" class="headerlink" title="3.1 多线程版本"></a>3.1 多线程版本</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">subgraph 多线程版</span><br><span class="line">t1(thread) --&gt; s1(socket1)</span><br><span class="line">t2(thread) --&gt; s2(socket2)</span><br><span class="line">t3(thread) --&gt; s3(socket3)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<ul>
<li>缺点<ul>
<li>内存占用高</li>
<li>线程上下文切换成本高</li>
<li>只适合连接数少的场景</li>
</ul>
</li>
</ul>
<h5 id="3-2线程池版本"><a href="#3-2线程池版本" class="headerlink" title="3.2线程池版本"></a>3.2线程池版本</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">subgraph 线程池版</span><br><span class="line">t4(thread) --&gt; s4(socket1)</span><br><span class="line">t5(thread) --&gt; s5(socket2)</span><br><span class="line">t4(thread) -.-&gt; s6(socket3)</span><br><span class="line">t5(thread) -.-&gt; s7(socket4)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<ul>
<li>缺点<ul>
<li><code>socket工作在阻塞模式下</code>，线程仅能处理一个 socket 连接</li>
<li>仅适合[短连接] [<code>就是链接之后处理完时间就立即断开</code>]场景</li>
</ul>
</li>
</ul>
<h5 id="3-2-Selector版本"><a href="#3-2-Selector版本" class="headerlink" title="3.2 Selector版本"></a>3.2 Selector版本</h5><ul>
<li><p><code>selector</code> 的作用就是配合<code>一个线程</code>来管理<code>多个 channel</code>，获取这些 <code>channel</code> 上发生的事件，这些 <code>channel 工作在非阻塞模式</code>下，不会让线程只在一个 <code>channel</code> 上工作。</p>
</li>
<li><p>适合连接数特别多，但流量低<code>[就是非频繁]</code>的场景（low traffic）</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">subgraph selector 版</span><br><span class="line">thread --&gt; selector</span><br><span class="line">selector --&gt; c1(channel)</span><br><span class="line">selector --&gt; c2(channel)</span><br><span class="line">selector --&gt; c3(channel)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<ul>
<li>好处<ul>
<li>一个线程配合 <code>selector</code> 就可以监控多个 <code>channel</code> 的事件，事件发生线程才去处理。避免非阻塞模式下所做无用功</li>
<li>让这个线程能够被充分利用</li>
<li>节约了线程的数量</li>
<li>减少了线程上下文切换</li>
</ul>
</li>
</ul>
<blockquote>
<p>思想流程就是：</p>
<p>调用 <code>selector</code> 的 <code>select()</code>会进行阻塞，直到 <code>channel</code> 发生了<code>读写就绪</code>事件，<code>select</code> 方法才会返回<code>这些事件</code>并交给 <code>thread</code> 来处理</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Selector</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Selector <span class="title function_">open</span><span class="params">()</span>; <span class="comment">//得到一个选择器对象</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">long</span> timeout)</span>);<span class="comment">//监控所有注册的通道，当其中有IO操作可以进行时，将对应的SelectionKey加入到内部集合中并返回，参数用来设置超时时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Set&lt;SelectionKey&gt;selectedKeys();<span class="comment">//从内部集合中得到所有的SelectionKey</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Selector</code> 相关方法说明</p>
<ul>
<li><code>selector.select();</code> //阻塞</li>
<li><code>selector.select(1000);</code> //阻塞 1000 毫秒，在 1000 毫秒后返回</li>
<li><code>selector.wakeup();</code> //唤醒 selector</li>
<li><p><code>selector.selectNow();</code> //不阻塞，立马返还</p>
</li>
<li><p>创建：<code>Selector selector = Selector.open();</code></p>
</li>
<li>绑定<code>Channel</code>事件： 注册事件，绑定的事件 selector 才会关心<ul>
<li><code>channel.configureBlocking(false);     SelectionKey key = channel.register(selector, 绑定事件);</code></li>
<li><code>channel</code> 必须工作在<code>非阻塞</code>模式</li>
<li><code>FileChannel</code> 没有<code>非阻塞</code>模式，因此不能配合 selector 一起使用</li>
<li>绑定的事件类型可以有<ul>
<li><code>connect - 客户端连接成功时触发</code></li>
<li><code>accept - 服务器端成功接受连接时触发</code></li>
<li><code>read - 数据可读入时触发，有因为接收能力弱，数据暂不能读入的情况</code></li>
<li><code>write - 数据可写出时触发，有因为发送能力弱，数据暂不能写出的情况</code></li>
</ul>
</li>
</ul>
</li>
<li>监听 <code>Channel</code> 事件<ul>
<li>可以通过下面三种方法来监听是否有事件发生，方法的返回值代表有多少 channel 发生了事件<ul>
<li>阻塞直到绑定事件发生<code>int count = selector.select();</code></li>
<li>阻塞直到绑定事件发生，或是超时（时间单位为 ms）<code>int count = selector.select(long timeout);</code></li>
<li>不会阻塞，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件<code>int count = selector.selectNow();</code></li>
</ul>
</li>
</ul>
</li>
<li><code>select()</code>何时不会阻塞<ul>
<li>事件发生时<ul>
<li>客户端发起连接请求，会触发 <code>accept</code> 事件</li>
<li>客户端发送数据过来、客户端正常、异常关闭时，都会触发 <code>read</code> 事件，另外如果发送的数据大于 <code>buffer</code> 缓冲区也会触发多次读取事件</li>
<li><code>channel</code> 可写，会触发 <code>write</code> 事件</li>
<li>在 <code>linux</code> 下 <code>nio bug</code> 发生时</li>
</ul>
</li>
<li>调用<code>selector.wakeup()</code></li>
<li>调用 <code>selector.close()</code></li>
<li><code>selector</code> 所在线程<code>interrupt</code></li>
</ul>
</li>
</ul>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><ul>
<li>阻塞：&lt;所谓的<code>阻塞</code> :   就是 线程<code>没有得到 连接</code>就会 <code>停止运行</code>   线程<code>没有得到数据</code>的时候 也会<code>停止运行</code>&gt;<ul>
<li><code>阻塞模式</code>下，下面的方法都会导致线程<code>暂停</code><ul>
<li><code>ServerSocketChannel.accept</code> 会在<code>没有连接建立</code>时让线程暂停</li>
<li><code>SocketChannel.read</code> 会在<code>没有数据可读</code>时让线程暂停</li>
<li>阻塞的表现其实就是线程暂停了，<code>暂停期间不会占用 cpu</code>，线程相当于闲置</li>
</ul>
</li>
<li>单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持</li>
<li>但多线程下，有新的问题，体现在以下方面<ul>
<li>32 位 <code>jvm</code> 一个线程 <code>320k</code>，64 位 <code>jvm</code> 一个线程 <code>1024</code>k，如果连接数过多，必然导致 <code>OOM</code>，并且线程太多，反而会因为频繁上下文切换导致性能降低</li>
<li>可以采用<code>线程池技术</code>来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间 <code>inactive</code>，会阻塞线程池中所有线程，因此不适合长连接，<code>只适合短连接</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>流程模拟</p>
<p>服务端：</p>
<ul>
<li>创建一个全局<code>ByteBuffer</code>的缓冲区，进行存储数据，可读可写</li>
<li>创建一个通道类型为<code>ServerSocketChannel</code>的通道，进行监听客户端连接请求和接受客户端发送过来的数据，并进行绑定端口</li>
<li>创建一个<code>Channel</code>的类型的数组，使用<code>ArrayList</code>进行存储，便于管理</li>
<li>建立 客户端连接,使用 TCP 三次握手, 使用<code>acccept</code>的方法，其默认是阻塞的，就是会让线程暂停，等待客户端连接，要是只启动了客户端那么会在这里进行阻塞，直到客户端也启动了才结束阻塞，产生一个 <code>SocketChannel</code> 的读写通道<code>sc</code>，方便与客户端通信 进行数据读写</li>
<li>接收 <code>客户端</code>的数据， 进行遍历处理，按照通道顺序进行遍历，==但是要是第一个通道没数据就会一直阻塞，第二个有数据也读不到（下面的非阻塞会对其进行改进）==</li>
<li>调用<code>read</code> 的方法进行读取<code>channel</code>的数据到<code>buffer</code>中，切换为<code>写</code>模式</li>
<li>将 <code>ByteBuffer</code> 类型的 <code>buffer</code> 转换为 <code>CharBuffer</code> 类型的 <code>string</code>，并且使用默认字符集进行解码</li>
<li>在写模式下继续循环写</li>
</ul>
<p>客户端：</p>
<ul>
<li>创建<code>SocketChannel</code> 并指定连接的<code>端口号</code>和<code>服务器</code></li>
</ul>
</blockquote>
<ul>
<li><p>非阻塞：</p>
<ul>
<li><p>非阻塞模式下，下面到的相关方法都不会让线程暂停</p>
<ul>
<li><p>在 <code>ServerSocketChannel.accept</code> 在没有连接建立时，会返回 <code>null</code>，继续运行</p>
</li>
<li><p><code>SocketChannel.read</code> 在没有数据可读时，会返回<code>0</code>，但线程不必阻塞，可以去执行其它 <code>SocketChannel</code> 的 <code>read</code> 或是去执行 <code>ServerSocketChannel.accept</code></p>
</li>
<li><p>写数据时，线程只是等待数据写入 <code>Channel</code> 即可，无需等 <code>Channel</code> 通过网络把数据发送出去</p>
</li>
</ul>
</li>
<li><p>弊端</p>
<ul>
<li>但非阻塞模式下，即使没有连接建立，和可读数据，线程仍然在不断运行，白白浪费了 cpu</li>
<li>数据复制过程中，线程实际还是阻塞的（AIO 改进的地方）</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>服务端：</p>
<ul>
<li>创建一个全局<code>ByteBuffer</code>的缓冲区，进行存储数据，可读可写</li>
<li>创建一个通道类型为<code>ServerSocketChannel</code>的通道，进行监听客户端连接请求和接受客户端发送过来的数据，并进行绑定端口</li>
<li>切换 <code>ServerSocketChannel</code> 为 非阻塞 模式， 默认<code>true</code>是阻塞的,将  <code>accept</code> 设置为 非阻塞方法<code>ssc.configureBlocking(false)</code></li>
<li>创建一个<code>Channel</code>的类型的数组，使用<code>ArrayList</code>进行存储，便于管理</li>
<li>建立 客户端连接,使用 TCP 三次握手, 使用<code>acccept</code>的方法，此时<code>acccept</code>是非阻塞方法【如果没建立连接，程序继续跑，但是<code>sc=null</code>】</li>
<li>切换 <code>SocketChannel</code> 为 <code>非阻塞</code> 模式， 默认<code>true</code>是<code>阻塞</code>的,将 <code>read</code> 变成 <code>非阻塞方法</code> <code>sc.configureBlocking(false);</code></li>
<li>接收 <code>客户端</code>的数据， 进行遍历处理，按照通道顺序进行遍历</li>
<li>此时<code>read</code>是 非阻塞方法,【如果没读到数据返回 0】,否则返回读取到的长度</li>
<li>调用<code>read</code> 的方法进行读取<code>channel</code>的数据到<code>buffer</code>中，切换为<code>写</code>模式</li>
<li>将 <code>ByteBuffer</code> 类型的 <code>buffer</code> 转换为 <code>CharBuffer</code> 类型的 <code>string</code>，并且使用默认字符集进行解码</li>
<li>在写模式下继续循环写</li>
</ul>
<p>客户端：</p>
<ul>
<li>同上，不变</li>
</ul>
</blockquote>
<h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>单线程可以配合 <code>Selector</code> 完成对多个 <code>Channel</code> 可读写<code>事件的监控</code>，这称之为<code>多路复用</code></p>
<ul>
<li><code>多路复用</code>仅针对<code>网络 IO</code>,普通文件 IO <code>无法</code>利用多路复用</li>
<li>如果不用 <code>Selector</code> 的非阻塞模式，线程大部分时间都在做无用功，而 <code>Selector</code> 能够保证<ul>
<li>有可连接事件时才去连接</li>
<li>有可读事件才去读取</li>
<li>有可写事件才去写入<ul>
<li>限于网络传输能力，<code>Channel</code> 未必时时可写，一旦 <code>Channel</code> 可写，会触发 <code>Selector</code> 的可写事件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="处理-accept-事件"><a href="#处理-accept-事件" class="headerlink" title="处理 accept 事件"></a>处理 accept 事件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断事件类型</span></span><br><span class="line"><span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">   <span class="type">ServerSocketChannel</span> <span class="variable">c</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">   <span class="comment">// 必须处理</span></span><br><span class="line">   <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> c.accept();</span><br><span class="line">   sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">   sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">   log.debug(<span class="string">&quot;连接已建立: &#123;&#125;&quot;</span>, sc);</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">// 处理完毕，必须将事件移除</span></span><br><span class="line">   iter.remove();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>事件发生后，要么处理，要么取消（<code>cancel</code>），不能什么都不做，否则下次该事件仍会触发，这是因为 nio 底层使用的是<code>水平触发</code></p>
</blockquote>
<h3 id="处理-read-事件"><a href="#处理-read-事件" class="headerlink" title="处理 read 事件"></a>处理 read 事件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> sc.read(buffer);</span><br><span class="line">    <span class="keyword">if</span>(read == -<span class="number">1</span>) &#123;</span><br><span class="line">        key.cancel();</span><br><span class="line">        sc.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理完毕，必须将事件移除</span></span><br><span class="line">     iter.remove();</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>为何要 <code>iter.remove()</code></strong></p>
<p>因为 <code>select</code> 在事件发生后，就会将相关的 <code>key</code> 放入 <code>selectedKeys</code> 集合，但不会在处理完后从 <code>selectedKeys</code> 集合中移除，需要<code>我们自己编码删除</code>。例如</p>
<ul>
<li>第一次触发了 <code>ssckey</code> 上的 <code>accept</code> 事件，没有移除 <code>ssckey</code></li>
<li>第二次触发了 <code>sckey</code> 上的 <code>read</code> 事件，但这时 <code>selectedKeys</code> 中还有上次的 <code>ssckey</code> ，在处理时因为没有真正的 <code>serverSocket</code> 连上了，就会导致<code>空指针异常</code></li>
</ul>
<p><strong>cancel的作用</strong></p>
<p><code>cancel</code> 会取消注册在 <code>selector</code> 上的 <code>channel</code>，并从 <code>keys</code> 集合中<code>删除 key</code>后续不会再监听事件</p>
<p><strong>不处理边界</strong></p>
<ul>
<li><p>问题：会导致边界会被拆分</p>
</li>
<li><p>解决：==&lt;具体见进阶部分&gt;==</p>
<ul>
<li>方案一： 固定消息长度，数据包大小一样，服务器按预定长度读取，<code>缺点</code>是浪费带宽</li>
<li>方案二： 按分隔符<code>\n</code>拆分，<code>缺点</code>是效率低</li>
<li>方案三： TLV 格式，即 Type 类型、Length 长度、Value 数据，类型和长度已知的情况下，就可以方便获取消息大小，分配合适的 buffer，<code>缺点</code>是 <code>buffer</code> 需要提前分配，如果内容过大，则影响 <code>server</code> 吞吐量</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305231301015.png" alt="image-20230523130146931" style="zoom:53%;"></p>
<p><strong>ByteBuffer 大小分配</strong></p>
<ul>
<li>每个 channel 都需要记录可能被切分的消息，<code>因为 ByteBuffer 不能被多个 channel 共同使用 所以不考虑多线程问题</code>，因此需要为每个 channel 维护一个独立的 ByteBuffer</li>
<li><code>ByteBuffer</code> 不能太大，比如一个<code>ByteBuffer 1Mb</code>的话，要支持百万连接就要 1Tb 内存，因此需要设计大小可变的 <code>ByteBuffer</code><ul>
<li>一种思路是首先分配一个较小的 <code>buffer</code><ul>
<li>例如 4k，如果发现数据不够，再分配 8k 的 buffer，将 4k buffer 内容拷贝至 8k buffer，优点是消息连续容易处理，缺点是数据拷贝耗费性能，[参考实现][<a target="_blank" rel="noopener external nofollow noreferrer" href="http://tutorials.jenkov.com/java-performance/resizable-array.html">http://tutorials.jenkov.com/java-performance/resizable-array.html</a>]</li>
</ul>
</li>
<li>另一种思路是用多个数组组成 <code>buffer</code>，一个数组不够，把多出来的内容写入新的数组，与前面的区别(缺点是)是消息存储<code>不连续</code>,解析复杂，优点是避免了拷贝引起的性能损耗</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="处理-write-事件"><a href="#处理-write-事件" class="headerlink" title="处理 write 事件"></a>处理 write 事件</h3><h5 id="一次性无法写完例子"><a href="#一次性无法写完例子" class="headerlink" title="一次性无法写完例子"></a>一次性无法写完例子</h5><ul>
<li><code>非阻塞模式</code>下，无法保证把 <code>buffer</code> 中所有数据都写入 <code>channel</code>，因此需要<code>追踪</code> <code>write</code> 方法的返回值（代表实际写入字节数）</li>
<li>用 <code>selector</code> 监听所有 <code>channel</code> 的可写事件，每个 <code>channel</code> 都需要一个 <code>key</code> 来跟踪 <code>buffer</code>，但这样又会导致占用内存过多，就有<code>两阶段策略</code><ul>
<li>当消息处理器第一次写入消息时，才将 <code>channel</code> 注册到 <code>selector</code> 上</li>
<li><code>selector</code> 检查 <code>channel</code> 上的可写事件，如果所有的数据写完了，就取消 <code>channel</code> 的注册</li>
<li>如果不取消，会每次写时，均会触发 <code>write</code> 事件</li>
</ul>
</li>
</ul>
<p>==注意==</p>
<blockquote>
<p><code>ssc.register(selector, SelectionKey.OP_ACCEPT);
     等价于：
SelectionKey sscKey = ssc.register(selector, 0, null);
sscKey.interestOps(SelectionKey.OP_ACCEPT);// 指明 SelectionKey  绑定的事件 selector 才会关心</code></p>
<p> <strong>write 为何要取消</strong>   <code>key.interestOps(key.interestOps() - SelectionKey.OP_WRITE);</code></p>
<p> 只要向 <code>channel</code> 发送数据时，<code>socket</code> 缓冲可写，这个事件会频繁触发，因此应当只在 <code>socket</code> 缓冲区<code>写不下</code>时<code>再关注可写</code>事件，数据<code>写完之后再取消关注</code></p>
</blockquote>
<h3 id="多线程的优化"><a href="#多线程的优化" class="headerlink" title="多线程的优化"></a>多线程的优化</h3><p>总结：</p>
<ul>
<li><p>多线程的使用的时候需要设置多个选择器进行分工</p>
<ul>
<li><p>单线程配一个选择器   <code>boss</code>，专门处理 accept 事件</p>
</li>
<li><p>创建 cpu 核心数的线程是   <code>worker</code>，每个线程配一个选择器，轮流处理 <code>read</code> 事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiThreadServer</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        Thread.currentThread().setName(<span class="string">&quot;boss&quot;</span>);<span class="comment">// 创建主线程 命名为 boss</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="literal">false</span>);<span class="comment">//  selector必须 工作在 非阻塞模式， 影响accept() 编程非阻塞方法</span></span><br><span class="line">        ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Selector</span> <span class="variable">boss</span> <span class="operator">=</span> Selector.open();<span class="comment">// 创建 selector来管理多个channel</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">SelectionKey</span> <span class="variable">bossKey</span> <span class="operator">=</span> ssc.register(boss, <span class="number">0</span>, <span class="literal">null</span>);<span class="comment">// 将 服务器 通道注册到 selector</span></span><br><span class="line">        bossKey.interestOps(SelectionKey.OP_ACCEPT); <span class="comment">// 关注连接事件</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;worker-0&quot;</span>);<span class="comment">// 1. 创建固定数量的 worker 并初始化</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            boss.select();</span><br><span class="line">            <span class="keyword">final</span> Iterator&lt;SelectionKey&gt; iter = boss.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                iter.remove();</span><br><span class="line">                <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept();<span class="comment">// 与客户端  读写通道</span></span><br><span class="line">                    sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                   </span><br><span class="line"><span class="comment">//注意：这里必须先 sc.register关注 read事件，然后 再 静态内部类 里执行 selector.select() 才能顺利完成读取</span></span><br><span class="line">                    <span class="comment">//但是,select() 先执行的话，会将 register阻塞住</span></span><br><span class="line"><span class="comment">//多线程的初步解决</span></span><br><span class="line">                    worker.register(); <span class="comment">// 这里 将 开启 多线程 并 和 下面方法 同步执行</span></span><br><span class="line">                    <span class="comment">// 关联 worker 里的 选择器 selector</span></span><br><span class="line">                    <span class="comment">// 这里的 客户端读写通道  注册到 内部类worker里的 selector</span></span><br><span class="line">                    sc.register(worker.selector, SelectionKey.OP_READ, <span class="literal">null</span>); <span class="comment">// 可以直接访问 内部类 的 私有变量</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//worker 的内部类;有独立的线程 和 自己的 selector</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Thread thread;</span><br><span class="line">        <span class="keyword">private</span> Selector  selector;</span><br><span class="line">        <span class="keyword">private</span> String name; <span class="comment">// 每个 selector的名字</span></span><br><span class="line"><span class="comment">//volatile的回顾</span></span><br><span class="line"><span class="comment">//volatile 声明变量的值可能随时会别的线程修改,修饰的变量会强制,将修改的值立即写入主存,主存中值的更新会使缓存中的值失效</span></span><br><span class="line"><span class="comment">//但是(非volatile变量不具备这样的特性，非volatile变量的值会被缓存，线程A更新了这个值，线程B读取这个变量的值时可能读到的并不是是线程A更新后的值)</span></span><br><span class="line"><span class="comment">//volatile具有可见性、有序性，不具备原子性</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">start</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 还未初始化</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(String name)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">   <span class="comment">//初始化 线程 和 selector，期望 一个 worker 使用一个线程，创建了 Thread就不再重复创建了</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">            <span class="comment">// 保证 这段代码 只执行一遍</span></span><br><span class="line">            <span class="keyword">if</span>(!start) &#123;</span><br><span class="line">                thread = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>, name);</span><br><span class="line">                <span class="comment">// 先创建 selector,然后再start线程。不然selector会报空指针</span></span><br><span class="line">                selector = Selector.open();</span><br><span class="line">                thread.start();</span><br><span class="line">                start = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="comment">//   先 select()   【因为在boss线程里面已经 强行wakeup() 了 所以 首次 不阻塞】</span></span><br><span class="line">     <span class="comment">//   再 register() 【先注册 关注了read事件，首次 有事件将继续，没事件将到下个循环   】</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    selector.select();<span class="comment">// 有未处理或未取消事件，不阻塞 继续运行 ； 否则 阻塞</span></span><br><span class="line">                    <span class="keyword">final</span> Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                        iter.remove();</span><br><span class="line">                        <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                            <span class="keyword">final</span> <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">                            <span class="keyword">final</span> <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                            log.debug(<span class="string">&quot;read...... &#123;&#125;&quot;</span>, channel.getRemoteAddress());</span><br><span class="line">                            channel.read(buffer);</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            ByteBufferUtil.debugAll(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>两个线程之间的消息传递问题</p>
<ul>
<li>利用<code>队列(ConcurrentLinkedQueue)</code> 解决</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 第一部分： 开一个分线程 ,使用 &quot;线程安全队列&quot;，进行分离 测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 多线程 的selector应用</span></span><br><span class="line"><span class="comment"> *  分工操作 （boss 和 worker 都有自己独立的线程和 selector）</span></span><br><span class="line"><span class="comment"> *      Boss   : 负责接待 连接操作</span></span><br><span class="line"><span class="comment"> *      worker : 负责读写，每个work负责 一或多个SockerChannel读写事件</span></span><br><span class="line"><span class="comment"> * 核心：模仿 netty的 操作步骤</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiThreadServer1</span> &#123;</span><br><span class="line">    <span class="comment">//原来是：   worker.register();         sc.register(worker.selector, SelectionKey.OP_READ, null);</span></span><br><span class="line">                    <span class="comment">//...</span></span><br><span class="line">                    worker.register(sc);  <span class="comment">// work-0  被boss线程  调用</span></span><br><span class="line">  	                <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  worker 的内部类  有独立的线程 和 自己的 selector</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"><span class="comment">//开一个分线程 ,使用 &quot;线程安全队列&quot;，进行分离 测试</span></span><br><span class="line">    	<span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(SocketChannel sc)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">     	<span class="comment">//...</span></span><br><span class="line">	    <span class="keyword">private</span> ConcurrentLinkedQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedQueue</span>&lt;&gt;();</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">        <span class="comment">// boss 线程 里 ： 向 队列里 添加任务 ，但是并没有执行</span></span><br><span class="line">        <span class="comment">// 任务内容：主线程的 读写通道 注册到 子线程的 selector，交给子线程管理</span></span><br><span class="line">        queue.add(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sc.register(selector, SelectionKey.OP_READ, <span class="literal">null</span>); <span class="comment">//boss</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClosedChannelException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">		</span><br><span class="line">        selector.wakeup(); <span class="comment">// 唤醒 select方法 为了执行 关注 read事件</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这 先 select()   【因为在boss线程里面已经 强行wakeup() 了 所以 首次 不阻塞】</span></span><br><span class="line"><span class="comment">         * 再 register() 【先注册 关注了read事件，首次 有事件将继续，没事件将到下个循环   】</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">          <span class="keyword">try</span>&#123;</span><br><span class="line">             selector.select();<span class="comment">// 有未处理或未取消事件，不阻塞 继续运行 ； 否则 阻塞</span></span><br><span class="line">             <span class="comment">//从 队列里拿出 任务程序 进行执行   </span></span><br><span class="line">             <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">             <span class="keyword">if</span>(task != <span class="literal">null</span>)&#123;</span><br><span class="line">                task.run(); <span class="comment">// worker-0 线程里执行了： sc.register(selector, SelectionKey.OP_READ, null);</span></span><br><span class="line">             &#125;</span><br><span class="line">                   <span class="comment">// 首次 到这里 可能还没 任务事件，但是 读事件 已经注册好了(就可以 关注 客户端是否传数据了)</span></span><br><span class="line">                   <span class="comment">//... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>仅用<code>wakeup</code>解决</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiThreadOnlyWakeup</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    worker.register(sc); <span class="comment">// 这里 将 开启 多线程 并 和 下面方法 同步执行</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">worker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(SocketChannel sc)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    	<span class="comment">// 保证 这段代码 只执行一遍</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">         selector.wakeup(); <span class="comment">// 唤醒 select方法</span></span><br><span class="line">        <span class="comment">// 客户端读写通道  注册到 内部类worker里的 selector</span></span><br><span class="line">        sc.register(selector, SelectionKey.OP_READ, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多 worker  使用 数组保存多 内部类对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiThreadServerMultiWorker</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     1. 创建固定数量的 worker 并初始化</span></span><br><span class="line"><span class="comment">        数组的线程数 至少设置为 CPU 的核心数</span></span><br><span class="line"><span class="comment">        得到 CPU核心数 ： Runtime.getRuntime().availableProcessors() 【注意拿的不是容器申请的核心数，而是物理的CPU核心数，直到 JDK10才修复】</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         建议 手工指定下 更好</span></span><br><span class="line"><span class="comment">         根据实际情况，如果是 CPU 密集型运算, 线程数 设为 CPU核心数</span></span><br><span class="line"><span class="comment">         如果 IO频繁， CPU用的少 ，参考 阿姆达尔定律 ，根据 IO跟 计算的比例 来确认 多少线程 ，一般是 大于 CPU核心的</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> Worker[] workers = <span class="keyword">new</span> <span class="title class_">Worker</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; workers.length; i++) &#123;</span><br><span class="line">            workers[i] = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;worker-&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计数器</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">index</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(); <span class="comment">// 初始值 是 0</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">          <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 使用 round robin 轮流交替使用， 负载均衡的 方法</span></span><br><span class="line"><span class="comment">            *  index.getAndIncrement 获取索引 并 自增一次</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            * 0 % 2 = 0</span></span><br><span class="line"><span class="comment">            * 1 % 2 = 1</span></span><br><span class="line"><span class="comment">            * 2 % 2 = 0</span></span><br><span class="line"><span class="comment">            * 3 % 2 = 1</span></span><br><span class="line"><span class="comment">            * 4 % 2 = 0</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           workers[index.getAndIncrement() % workers.length] . register(sc);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 创建 一个 线程安全的队列 ，用来 让两个线程之间传输数据</span></span><br><span class="line"><span class="comment">      *  目的：就是把 要注册的 channel传过来</span></span><br><span class="line"><span class="comment">      * &lt; 任务对象 &gt;</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">	<span class="keyword">private</span> ConcurrentLinkedQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedQueue</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(SocketChannel sc)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">         queue.add(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sc.register(selector, SelectionKey.OP_READ, <span class="literal">null</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;*** 子线程 里 注册 读写通道 到 selector 并关注 读事件 ***&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClosedChannelException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        selector.wakeup(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p><strong>如何拿到 cpu 个数</strong></p>
<ul>
<li><code>Runtime.getRuntime().availableProcessors()</code>如果工作在 <code>docker</code> 容器下，因为容器不是物理隔离的，会拿到物理 <code>cpu</code> 个数，而不是容器申请时的个数</li>
<li>这个问题直到 jdk 10 才修复，使用 <code>jvm</code> 参数 <code>UseContainerSupport</code> 配置， 默认开启</li>
</ul>
</blockquote>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><ul>
<li><code>UDP</code> 是无连接的，<code>client</code> 发送数据不会管 <code>server</code> 是否开启</li>
<li><code>server</code> 这边的 <code>receive</code> 方法会将接收到的数据存入 <code>byte buffer</code>，但如果数据报文超过 <code>buffer</code> 大小，多出来的数据会被默默抛弃</li>
</ul>
<h1 id="NIO-VS-BIO"><a href="#NIO-VS-BIO" class="headerlink" title="NIO VS BIO"></a>NIO VS BIO</h1><h3 id="Stream-VS-channel"><a href="#Stream-VS-channel" class="headerlink" title="Stream VS channel"></a>Stream VS channel</h3><ul>
<li><code>stream</code> 不会自动缓冲数据，<code>channel</code> 会利用系统提供的发送缓冲区、接收缓冲区（更为底层）</li>
<li><code>stream</code> 仅支持阻塞 API，<code>channel</code> 同时支持阻塞、非阻塞 API，网络中  <code>channel</code> 可配合 <code>selector</code> 实现多路复用</li>
<li>二者均为<code>全双工</code>，即读写可以<code>同时</code>进行</li>
</ul>
<h3 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h3><ul>
<li>分类  <code>同步阻塞、同步非阻塞、同步多路复用、异步阻塞（没有此情况）、异步非阻塞</code></li>
</ul>
<ul>
<li>同步：线程自己去获取结果（一个线程）</li>
<li>异步：线程自己不去获取结果，而是由其它线程送结果（至少两个线程）</li>
</ul>
<p>当调用一次 <code>channel.read</code>或 <code>stream.read</code> 后，会切换至操作系统内核态来完成真正数据读取，而读取又分为两个阶段，分别为：</p>
<ul>
<li>等待数据阶段</li>
<li>复制数据阶段</li>
</ul>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202306160104198.png" alt="image-20230616010438166" style="zoom:33%;"></p>
<blockquote>
<p>阻塞 IO      &lt;指的就是用户程序被阻塞了  一次系统调用&gt;</p>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202306160104711.png" alt="image-20230616010452667" style="zoom:33%;"></p>
<p>非阻塞  IO     &lt;指的就是等待阶段用户程序 不会阻塞，但是当有数据之后到达复制数据阶段还是阻塞了的&gt;</p>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202306160105474.png" alt="image-20230616010525429" style="zoom:33%;"></p>
<p>多路复用   （等待数据阶段是阻塞的   复制数据的阶段也是阻塞的  两次系统调用）</p>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202306160105408.png" alt="image-20230616010552361" style="zoom:33%;"> </p>
<p>异步 IO</p>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202306160106873.png" alt="image-20230616010613821" style="zoom:33%;"></p>
<p>阻塞<code>IO</code> 与 多路复用</p>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202306160108962.png" alt="image-20230616010759817" style="zoom:33%;">      <img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305232047942.png" alt="image-20230523204737809" style="zoom:43%;">    </p>
</blockquote>
<h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><h5 id="传统IO的流程"><a href="#传统IO的流程" class="headerlink" title="传统IO的流程"></a>传统IO的流程</h5><ul>
<li><p>传统的 IO 将一个文件通过 socket 写出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;helloword/data.txt&quot;</span>);</span><br><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>)f.length()];</span><br><span class="line">file.read(buf);</span><br><span class="line"></span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ...;</span><br><span class="line">socket.getOutputStream().write(buf);</span><br></pre></td></tr></table></figure>
</li>
<li><p>工作流程</p>
<ul>
<li><p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202306160112802.png" alt="image-20230616011241775" style="zoom:33%;"></p>
</li>
<li><p>上述<code>1、2、3、4</code>的说明</p>
<ul>
<li><p>java 本身并不具备 IO 读写能力，因此 <code>read</code> 方法调用后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，去调用操作系统内核（Kernel）的读能力，将数据读入<strong>内核缓冲区</strong>。这期间用户线程阻塞，操作系统使用 DMA（Direct Memory Access）来实现文件读，期间也不会使用 cpu</p>
<blockquote>
<p>DMA 也可以理解为硬件单元，用来解放 cpu 完成文件 IO</p>
</blockquote>
</li>
<li><p>从<strong>内核态</strong>切换回<strong>用户态</strong>，将数据从<strong>内核缓冲区</strong>读入<strong>用户缓冲区</strong>（即 byte[] buf），这期间 cpu 会参与拷贝，无法利用 DMA</p>
</li>
<li><p>调用 write 方法，这时将数据从<strong>用户缓冲区</strong>（<code>即 byte[] buf</code>）写入 <strong>socket 缓冲区</strong>，cpu 会参与拷贝</p>
</li>
<li><p>接下来要向网卡写数据，这项能力 java 又不具备，因此又得从<strong>用户态</strong>切换至<strong>内核态</strong>，调用操作系统的写能力，使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 cpu</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>小结：</p>
<ul>
<li><p>可以看到的是 中间环节较多，java 的 IO 实际<code>是缓存的复制</code>，<code>底层的真正读写</code>是<code>操作系统</code>来完成的</p>
<ul>
<li>用户态与内核态的切换发生了 3 次(<code>1、2、4</code>)，这个操作比较重量级</li>
<li>数据拷贝了共 4 次</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="NIO优化一"><a href="#NIO优化一" class="headerlink" title="NIO优化一"></a>NIO优化一</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过 `DirectByteBuf` </span></span><br><span class="line">ByteBuffer.allocate(<span class="number">10</span>)  `HeapByteBuffer 使用的还是 java 内存`</span><br><span class="line">ByteBuffer.allocate`Direct`(<span class="number">10</span>)  `DirectByteBuffer 使用的是操作系统内存`</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202306160118148.png" alt="image-20230616011834111" style="zoom:33%;"></p>
<p>大部分步骤与优化前相同，不再赘述。</p>
<p><code>唯有一点是有区别的：</code>java 可以使用 <code>DirectByteBuf</code> 将堆外内存映射到 jvm 内存中来直接访问使用</p>
<ul>
<li>这块内存不受 <code>jvm</code> 垃圾回收的影响，因此<code>内存地址固定</code>，有助于 <code>IO</code> 读写</li>
<li>java 中的 <code>DirectByteBuf</code> 对象<code>仅维护</code>了此内存的<code>虚引用</code>，内存回收分成两步<ul>
<li><code>DirectByteBuf</code> 对象被垃圾<code>回收</code>，将<code>虚引用加入引用队列</code></li>
<li>通过专门线程<code>访问</code>引用队列，根据<code>虚引用释放堆外内存</code></li>
</ul>
</li>
<li>减少了一次数据拷贝，用户态与内核态的<code>切换次数</code>没有减少</li>
</ul>
<h5 id="NIO优化二"><a href="#NIO优化二" class="headerlink" title="NIO优化二"></a>NIO优化二</h5><p>底层采用了 linux 2.1 后提供的 <code>sendFile</code> 方法；java 中对应着两个 <code>channel</code> 调用 <code>transferTo/transferFrom</code>方法拷贝数据</p>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202306160127391.png" alt="image-20230616012741314" style="zoom:33%;"></p>
<ul>
<li>java 调用 <code>transferTo</code> 方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 cpu</li>
<li>数据从<strong>内核缓冲区</strong>传输到 <strong>socket 缓冲区</strong>，cpu 会参与拷贝</li>
<li>最后使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 cpu</li>
</ul>
<p>可以看到</p>
<ul>
<li>只发生了<code>一次</code>用户态与内核态的切换</li>
<li>数据拷贝了 <code>3</code> 次</li>
</ul>
<h5 id="NIO优化三"><a href="#NIO优化三" class="headerlink" title="NIO优化三"></a>NIO优化三</h5><p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202306160129502.png" alt="image-20230616012908471" style="zoom:33%;"></p>
<ul>
<li><p>java 调用<code>transferTo</code>方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 cpu</p>
<p>只会将一些 offset 和 length 信息拷入 <strong>socket 缓冲区</strong>，几乎无消耗</p>
</li>
<li><p>使用 DMA 将 <strong>内核缓冲区</strong>的数据写入网卡，不会使用 cpu</p>
</li>
</ul>
<p>整个过程仅只发生了一次用户态与内核态的切换，数据拷贝了 <code>2</code> 次。所谓的【<code>零拷贝</code>】，并不是真正无拷贝，而是在<code>不会拷贝重复数据到 jvm 内存中</code></p>
<ul>
<li><p>零拷贝的优点有</p>
<ul>
<li><p>更少的用户态与内核态的切换</p>
</li>
<li><p>不利用 cpu 计算，减少 cpu 缓存伪共享</p>
</li>
<li><p>零拷贝适合小文件传输</p>
</li>
</ul>
</li>
</ul>
<h1 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h1><p>AIO 用来解决<code>数据复制阶段</code>的阻塞问题</p>
<ul>
<li><code>同步</code>意味着，在进行读写操作时，<code>线程</code>需要等待结果，<code>相当于闲置</code></li>
<li><code>异步</code>意味着，在进行读写操作时，<code>线程</code>不必等待结果，而是将来由操作系统来通过回调方式由另外的线程来获得结果</li>
</ul>
<blockquote>
<p><code>异步模型</code>需要底层操作系统内核（Kernel）提供支持</p>
<ul>
<li>Windows 系统通过 <code>IOCP</code> 实现了真正的异步<code>IO</code></li>
<li>Linux 系统异步 <code>IO</code>在 2.6 版本引入，但其底层实现还是用多路复用模拟了异步 <code>IO</code>，性能没有优势</li>
</ul>
</blockquote>
<h4 id="文件AIO"><a href="#文件AIO" class="headerlink" title="文件AIO"></a>文件AIO</h4><blockquote>
<p>默认文件的<code>AIO</code> 使用的线程是守护线程，所以最后要执行 <code>System.in.read()</code> 以避免守护线程意外结束</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AioDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">AsynchronousFileChannel</span> <span class="variable">s</span> <span class="operator">=</span> </span><br><span class="line">                AsynchronousFileChannel.open(</span><br><span class="line">                	Paths.get(<span class="string">&quot;1.txt&quot;</span>), StandardOpenOption.READ);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">2</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">            s.read(buffer, <span class="number">0</span>, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;read completed...&#123;&#125;&quot;</span>, result);</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    debug(buffer);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;read failed...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;do other things...&quot;</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="网络AIO"><a href="#网络AIO" class="headerlink" title="网络AIO"></a>网络AIO</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AioServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">AsynchronousServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> AsynchronousServerSocketChannel.open();</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">        ssc.accept(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">AcceptHandler</span>(ssc));</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeChannel</span><span class="params">(AsynchronousSocketChannel sc)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;[%s] %s close\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());</span><br><span class="line">            sc.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReadHandler</span> <span class="keyword">implements</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AsynchronousSocketChannel sc;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ReadHandler</span><span class="params">(AsynchronousSocketChannel sc)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.sc = sc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (result == -<span class="number">1</span>) &#123;</span><br><span class="line">                    closeChannel(sc);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.printf(<span class="string">&quot;[%s] %s read\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());</span><br><span class="line">                attachment.flip();</span><br><span class="line">                System.out.println(Charset.defaultCharset().decode(attachment));</span><br><span class="line">                attachment.clear();</span><br><span class="line">                <span class="comment">// 处理完第一个 read 时，需要再次调用 read 方法来处理下一个 read 事件</span></span><br><span class="line">                sc.read(attachment, attachment, <span class="built_in">this</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class="line">            closeChannel(sc);</span><br><span class="line">            exc.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WriteHandler</span> <span class="keyword">implements</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AsynchronousSocketChannel sc;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">WriteHandler</span><span class="params">(AsynchronousSocketChannel sc)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.sc = sc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> &#123;</span><br><span class="line">            <span class="comment">// 如果作为附件的 buffer 还有内容，需要再次 write 写出剩余内容</span></span><br><span class="line">            <span class="keyword">if</span> (attachment.hasRemaining()) &#123;</span><br><span class="line">                sc.write(attachment);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class="line">            exc.printStackTrace();</span><br><span class="line">            closeChannel(sc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AcceptHandler</span> <span class="keyword">implements</span> <span class="title class_">CompletionHandler</span>&lt;AsynchronousSocketChannel, Object&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AsynchronousServerSocketChannel ssc;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">AcceptHandler</span><span class="params">(AsynchronousServerSocketChannel ssc)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.ssc = ssc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(AsynchronousSocketChannel sc, Object attachment)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;[%s] %s connected\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">            <span class="comment">// 读事件由 ReadHandler 处理</span></span><br><span class="line">            sc.read(buffer, buffer, <span class="keyword">new</span> <span class="title class_">ReadHandler</span>(sc));</span><br><span class="line">            <span class="comment">// 写事件由 WriteHandler 处理</span></span><br><span class="line">            sc.write(Charset.defaultCharset().encode(<span class="string">&quot;server hello!&quot;</span>), ByteBuffer.allocate(<span class="number">16</span>), <span class="keyword">new</span> <span class="title class_">WriteHandler</span>(sc));</span><br><span class="line">            <span class="comment">// 处理完第一个 accpet 时，需要再次调用 accept 方法来处理下一个 accept 事件</span></span><br><span class="line">            ssc.accept(<span class="literal">null</span>, <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, Object attachment)</span> &#123;</span><br><span class="line">            exc.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><blockquote>
<p>是什么</p>
</blockquote>
<ul>
<li>Netty 是一个<code>异步的(多线程)、基于事件驱动</code>的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端，IO模型是<code>IO多路复用</code>的IO模型</li>
<li>主要的作用就是 提供 高性能、可扩展的网络应用程序开发框架<ul>
<li>高性能是因为它基于<code>NIO</code>的实现，使用了异步的方式进行网络数据处理，采用了零拷贝技术、内存池等一系列机制来提高网络数据的传输和处理效率，具有极高的并发性能和吞吐量</li>
<li>简化网络编程：<code>Netty</code> 封装了很多底层的网络编程细节，提供了易于使用的 <code>API</code>，如事件驱动模型、高性能的编解码器、线程池等，使得开发者可以专注于业务逻辑的实现，而不必过度关注网络编程的底层实现</li>
<li>可扩展性：<code>Netty</code> 提供了丰富的扩展点和插件机制，可以根据实际需要选择合适的插件</li>
<li>协议支持：<code>Netty</code> 支持很多主流的网络协议，如 <code>TCP、UDP、HTTP/HTTPS、WebSocket</code> 等，可以满足不同场景下的网络通信需求</li>
</ul>
</li>
</ul>
<blockquote>
<p>应用</p>
</blockquote>
<ul>
<li>Cassandra - nosql 数据库</li>
<li>Spark - 大数据分布式计算框架</li>
<li>Hadoop - 大数据分布式存储框架</li>
<li>RocketMQ - ali 开源的消息队列</li>
<li>ElasticSearch - 搜索引擎</li>
<li>gRPC - rpc 框架</li>
<li>Dubbo - rpc 框架</li>
<li>Spring 5.x - flux api 完全抛弃了 tomcat ，使用 netty 作为服务器端</li>
<li>Zookeeper - 分布式协调框架</li>
</ul>
<blockquote>
<p>优势</p>
</blockquote>
<ul>
<li>与NIO进行对比的话； <code>NIO</code>工作量大，bug 多,需要自己构建协议，<code>epoll</code>的空转会导致<code>cpu</code>占用率达到100%</li>
<li>与其他网络架构的对比：<code>Mina</code>的开发不如<code>netty</code>简洁，文档不如<code>netty</code>优秀</li>
</ul>
<h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.39.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>服务端的</code>配置举例说明</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">    <span class="comment">//NioEventLoopGroup 简单理解：包含了线程 和 选择器 selector</span></span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>()) </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//选择一个 通用的 基于 NIO  ServerSocketChannel的 实现</span></span><br><span class="line">    .channel(NioServerSocketChannel.class) </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//childHandler 添加的各种处理器 给 每个子线程的 SocketChannel用的</span></span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> &#123;</span><br><span class="line">            <span class="comment">//将接收到的数据 ByteBuffer 解码 为 String</span></span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//自定义 的 handler</span></span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;String&gt;() &#123; </span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="comment">//msg  是上一个处理器得到的 经由 ByteBuf 转为 String 之后的结果</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> &#123;</span><br><span class="line">                    System.out.println(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .bind(<span class="number">8080</span>); </span><br></pre></td></tr></table></figure>
<ul>
<li><code>ServerBootstrap</code></li>
<li><code>new NioEventLoopGroup()</code>  创建一个新的 <code>NIO EventLoopGroup</code>，用于处理服务器端的 I/O 操作。</li>
<li><code>NioServerSocketChannel.class</code> 指定服务器监听的 <code>SocketChannel</code> 类型为 <code>NIO</code> 的 <code>ServerSocketChannel</code>。</li>
<li><code>childHandler</code>的配置，用于给之后的<code>SocketChannel</code>使用<ul>
<li><code>new ChannelInitializer&lt;NioSocketChannel&gt;() &#123; ... &#125;</code> 创建一个新的 <code>ChannelInitializer&lt;仅处理一次&gt;</code>，用于初始化客户端连接后的 <code>ChannelPipeline</code>，也就是说：待客户端 <code>SocketChannel</code> 建立连接后，执行 <code>initChannel</code> 以便添加更多的处理器</li>
<li><code>&#123;...&#125;</code>中<ul>
<li><code>ch.pipeline().addLast(new StringDecoder())</code> 向 <code>ChannelPipeline</code> 添加一个 <code>StringDecoder</code>，用于将客户端发送的 <code>ByteBuf</code> 数据<code>解码</code>成字符串。</li>
<li><code>ch.pipeline().addLast(new SimpleChannelInboundHandler&lt;String&gt;() &#123; ... &#125;)</code> 向 <code>ChannelPipeline</code> 添加一个 <code>SimpleChannelInboundHandler</code>，是一个业务处理器，处理上一个处理器的结果，就是用于<code>处理</code>客户端发送过来的字符串消息。在此处，通过覆盖 <code>channelRead0()</code> 方法实现了对客户端消息的输出</li>
</ul>
</li>
</ul>
</li>
<li><code>.bind(8080)</code> 绑定服务器监听的端口号为 8080。</li>
</ul>
<blockquote>
<p><code>客户端的</code>配置举例说明</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    <span class="comment">//设置客户端连接的EventLoopGroup</span></span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置Channel类型及相关属性</span></span><br><span class="line">    .channel(NioSocketChannel.class) </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置ChannelPipeline，即一组ChannelHandler链；</span></span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123; </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> &#123;</span><br><span class="line">            <span class="comment">//StringEncoder 把  发送的字符串 编码为   ByteBuffer</span></span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>()); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>) <span class="comment">//等价于：.remoteAddress(new InetSocketAddress(&quot;localhost&quot;, 8080))</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//阻塞式的链接，等待至连接成功;sync为了让客户端先以同步的方式连上，然后再执行后面信息发送逻辑</span></span><br><span class="line">    .sync() </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获得连接成功后的 Channel 对象</span></span><br><span class="line">    .channel() </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将要发送的数据写入到 Channel 中，并刷新缓冲区，以确保数据被发送出去</span></span><br><span class="line">    .writeAndFlush(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;: hello world!&quot;</span>);   </span><br></pre></td></tr></table></figure>
<p>重要参数的介绍</p>
<ul>
<li><p>服务端连接的引导类<code>ServerBootstrap</code></p>
<blockquote>
<p>继承自 <code>AbstractBootstrap</code> 并基于其基础上扩展了一些服务器特有的方法。</p>
</blockquote>
<ul>
<li><p>作用</p>
<ul>
<li><p><code>初始化服务器端启动参数</code>。<code>ServerBootstrap</code> 的实例化过程中，可以设置一些启动参数，例如 NIO 线程池、Channel 类型以及 ChannelHandler 等。</p>
</li>
<li><p><code>绑定服务器端口并启动服务器</code>。<code>ServerBootstrap</code> 提供了 <code>bind()</code> 方法，用于绑定服务器端口，并注册一个 ChannelFuture 对象保存启动状态。</p>
</li>
<li><p><code>设置处理客户端连接的 ChannelHandler</code>。<code>ServerBootstrap</code> 提供了 <code>childHandler()</code> 方法，用于为每个新连接的客户端创建一个 ChannelPipeline，以处理客户端的网络事件。</p>
</li>
<li><p>提供了一些<code>优雅停机</code>的方法。<code>ServerBootstrap</code> 提供了 <code>shutDownGracefully()</code> 等方法，用于关闭应用程序并释放资源。</p>
</li>
</ul>
</li>
<li><p>在使用 <code>ServerBootstrap</code> 的过程中需要注意以下几点：</p>
<ul>
<li><code>ServerBootstrap</code> 需要调用 <code>group()</code> 方法来指定处理 I/O 操作的线程池。</li>
<li><code>ServerBootstrap</code> 需要调用 <code>channel()</code> 方法来指定传输协议的类型（TCP 或 UDP），同时也可以通过 <code>option()</code> 方法设置相应的选项。</li>
<li><code>ServerBootstrap</code> 还需要调用 <code>handler()</code> 方法将自定义的 ChannelHandler 添加到 ChannelPipeline 中，以对服务器端的网络事件进行处理。</li>
<li><code>ServerBootstrap</code> 需要调用 <code>childHandler()</code> 方法来设置处理客户端连接的 ChannelHandler。</li>
<li>在完成所有 <code>ServerBootstrap</code> 的配置后，需要使用 <code>bind()</code> 方法绑定服务器端口，以启动服务器。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>客户端连接的引导类<code>Bootstrap</code></p>
<ul>
<li><p>作用：</p>
<ul>
<li>用于<code>初始化客户端和服务器端的启动参数</code>。<code>Bootstrap</code> 的实例化过程中，可以设置一些参数，例如 NIO 线程池、Channel 类型以及 ChannelHandler 等。</li>
<li><code>开启、连接或绑定网络端口</code>。<code>Bootstrap</code> 提供了多种方法，例如 <code>bind()</code>、<code>connect()</code> 和 <code>accept()</code> 等方法，用于启动 Netty 应用程序并建立网络连接。</li>
<li>提供了一些<code>优雅停机</code>的方法，例如 <code>shutdownGracefully()</code> 和 <code>awaitTermination()</code> 等，用于关闭应用程序并释放资源。</li>
</ul>
</li>
<li><p>在使用 <code>Bootstrap</code> 的过程中需要注意以下几点：</p>
<ul>
<li><code>Bootstrap</code> 需要在 Netty 应用程序<code>启动时创建</code>，并在整个应用程序的<code>生命周期内保持不变</code>。</li>
<li><code>Bootstrap</code> 需要调用 <code>group()</code> 方法来指定处理 I/O 操作的线程池。</li>
<li><code>Bootstrap</code> 需要调用 <code>channel()</code> 方法来<code>指定传输协议的类型</code>（TCP 或 UDP），同时也可以通过 <code>option()</code> 方法设置相应的选项。</li>
<li><code>Bootstrap</code> 还需要调用 <code>handler()</code> 方法将自定义的 <code>ChannelHandler</code> 添加到 <code>ChannelPipeline</code> 中，以对网络事件进行处理。</li>
<li>在完成所有 Bootstrap 的配置后，需要使用 <code>connect()</code>、<code>bind()</code> 或 <code>accept()</code> 方法<code>启动 Netty</code> 应用程序</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>多线程时间循环处理器：<code>NioEventLoopGroup</code></p>
<ul>
<li><p>介绍</p>
<ul>
<li>封装了<code>NIO</code>中的<code>Selector</code>机制，在<code>Netty</code>中，每个<code>EventLoop</code>都对应一个<code>Selector</code>对象。当有I/O事件发生时，<code>EventLoop</code>会从<code>Selector</code>中选择处于就绪状态的<code>Channel</code>进行处理，并触发相应的事件<code>回调函数</code></li>
<li>处理IO操作，内部维护了一个线程池，通过这个线程池来管理多个<code>NioEventLoop</code>对象。每个<code>NioEventLoop</code>负责管理一个或多个<code>Channel</code>的事件循环</li>
<li>在<code>Netty</code>应用程序中，通常会创建两个<code>EventLoopGroup</code>。一个是<code>bossGroup</code>，用于接受客户端连接请求，另一个是<code>workerGroup</code>，用于处理客户端连接后的I/O事件。当然也可以只使用一个<code>EventLoopGroup</code>，但是会存在性能瓶颈。</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li>它是多线程的，可以并发处理多个任务；</li>
<li>它使用<code>Java NIO Selector</code>实现事件监听和分发，可以监控多个<code>Channel</code>的I/O事件；</li>
<li>它支持异步化的、非阻塞的I/O操作，避免了I/O线程被阻塞的情况，提高了并发处理能力；</li>
<li>它能够自动根据CPU数量和处理器核心数创建适当数量的线程池，最大程度地利用系统资源；</li>
<li>它支持灵活的线程管理策略，可以自定义线程模型，满足不同场景下的需求</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>流程梳理</p>
</blockquote>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202306161259063.png" alt="image-20230616125918990"></p>
<p>正确的流程理解的思路：</p>
<ul>
<li>把 <code>channel</code> 理解为数据的<code>通道</code></li>
<li>把 <code>msg</code> 理解为流动的数据，最开始输入是 ByteBuf，但经过 <code>pipeline</code> 的<code>加工</code>，会变成<code>其它类型对象(此处是String)</code>，最后输出又变成 ByteBuf</li>
<li>把 handler 理解为<code>数据的处理工序</code><ul>
<li>工序有多道，合在一起就是 <code>pipeline</code>，<code>pipeline</code> 负责发布事件（读、读取完成…）传播给每个 <code>handler</code>， <code>handler</code> 对自己感兴趣的事件进行处理（重写了相应事件处理方法）</li>
<li><code>handler</code> 分 <code>Inbound</code> 和 <code>Outbound</code> 两类</li>
</ul>
</li>
<li>把 <code>eventLoop</code> 理解为处理数据的<code>工人</code> <eventLoop底层是`单线程的线程池`><ul>
<li>工人可以管理多个 <code>channel</code> 的 <code>io</code> 操作，并且一旦工人负责了某个 channel，就要负责<code>到底</code>（绑定）&lt;可以保证线程安全&gt;</li>
<li>工人既可以执行 <code>io 操作</code>，也可以进行<code>任务处理</code>，每位工人有任务队列，<code>队列</code>里可以堆放多个 <code>channel</code> 的待处理任务，任务分为普通任务、定时任务</li>
<li>工人按照 <code>pipeline</code> 顺序，依次按照 <code>handler</code> 的规划（代码）处理数据，可以为每道工序指定不同的<code>工人</code></li>
</ul>
</eventLoop底层是`单线程的线程池`></li>
</ul>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><h4 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h4><blockquote>
<p>事件循环对象</p>
</blockquote>
<p>本质：</p>
<ul>
<li>是一个单线程执行器，同时维护了一个<code>selector</code>,里面的<code>run</code>方法处理 <code>Channel</code> 上源源不断的<code>io</code>事件。</li>
<li>它的继承关系比较复杂<ul>
<li>一条线是继承自<code>juc.ScheduledExecutorService</code> 因此包含了线程池中所有的方法</li>
<li>另一条线是继承自 <code>netty</code> 自己的 <code>OrderedEventExecutor</code><ul>
<li>提供了<code>boolean inEventLoop(Thread thread)</code>方法判断一个线程是否属于此 <code>EventLoop</code></li>
<li>提供了 <code>parent</code> 方法来看看自己属于哪个 <code>EventLoopGroup</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="EventLoopGroup"><a href="#EventLoopGroup" class="headerlink" title="EventLoopGroup"></a>EventLoopGroup</h4><blockquote>
<p>事件循环组</p>
</blockquote>
<p>一组 <code>EventLoop</code>，<code>Channel</code> 一般会调用 <code>EventLoopGroup</code> 的 <code>register</code> 方法来绑定其中一个 <code>EventLoop</code>，后续这个 <code>Channel</code> 上的 <code>io</code> 事件都由此 <code>EventLoop</code> 来处理（保证了<code>io</code>事件处理时的线程安全）</p>
<ul>
<li>继承自 <code>netty</code> 自己的 <code>EventExecutorGroup</code><ul>
<li>实现了 <code>Iterable</code> 接口提供遍历 <code>EventLoop</code> 的能力</li>
<li>另有 <code>next</code> 方法获取集合中下一个 <code>EventLoop</code></li>
</ul>
</li>
</ul>
<ul>
<li>创建<ul>
<li>事件循环组 的时候： 未指定的话，则默认读取系统配置<code>io.netty.eventLoopThreads</code>，没有配置，则根据<code>cpu核心数*2</code>  创建线程    <code>EventLoopGroup group1 = new NioEventLoopGroup(2);</code></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通任务 交给EventLoop 执行;提交到 事件循环组 中，让 某一个事件循环对象 去执行;作用： 譬如 某件耗时的工作交给子线程完成</span></span><br><span class="line"></span><br><span class="line">		group1.next().submit(()-&gt;&#123;  <span class="comment">// 也可以 group1.next().execute(()-&gt;&#123;</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;1️⃣子线程运行。。。&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">&quot;2️⃣主线程 运行。。。&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 定时任务  初始延时事件0，间隔时间1， 时间单位 TimeUnit.SECONDS</span></span><br><span class="line">        group1.next().scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;3️⃣子线程运行......&quot;</span>);</span><br><span class="line">            &#125;, <span class="number">0</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>方法：</p>
<ul>
<li><p><code>next()</code>                                                     获取下一个循环对象   ——可以达到<code>轮询效果</code></p>
</li>
<li><p><code>next().submit()</code>                                 普通任务</p>
</li>
<li><code>next().scheduleAtFixedRate()</code>     定时任务</li>
</ul>
</li>
<li><p>优雅关闭</p>
<ul>
<li><code>shutdownGracefully</code> ：会首先切换 <code>EventLoopGroup</code> 到<code>关闭状态</code>从而<code>拒绝新的任务的加入</code>，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的</li>
</ul>
</li>
</ul>
<h5 id="NioEventLoop-处理-io-事件"><a href="#NioEventLoop-处理-io-事件" class="headerlink" title="NioEventLoop 处理 io 事件"></a>NioEventLoop 处理 io 事件</h5><blockquote>
<p> <code>Channel</code>  建立连接之后 会和 <code>EventLoop</code> 绑定 ，随后都是由同一个<code>EventLoop</code>执行</p>
</blockquote>
<ul>
<li><p>职责划分，为不<code>同的组分配不同的任务</code>： <code>.group(new NioEventLoopGroup(), new NioEventLoopGroup(2))</code>，此时，<code>一个线程 是可以管理 多个channel</code></p>
</li>
<li><p>创建一个独立的<code>EventLoopGroup</code> 去处理处理耗时较长的操作      <code>final DefaultEventLoopGroup defEventLoopGroup = new DefaultEventLoopGroup();</code>创建独立的   <code>EventLoopGroup</code></p>
</li>
<li><p>值得注意的是： 所有的<code>EentLoopGroup</code>都会和线程进行绑定</p>
</li>
</ul>
<blockquote>
<p><code>ChannelInboundHandlerAdapter</code>的介绍</p>
<ul>
<li>是 <code>Netty</code> 提供的用于处理网络事件的基础类之一</li>
<li><code>ChannelInboundHandlerAdapter</code> 类中定义了一些可以被子类重写的方法，用于处理各种网络事件</li>
</ul>
<p><code>addLast()方法：</code>可以向 <code>ChannelPipeline</code> 的尾部添加一个新的 <code>ChannelHandler</code></p>
<p><code>DefaultEventLoopGroup</code></p>
<p><code>final DefaultEventLoopGroup defEventLoopGroup = new DefaultEventLoopGroup()</code></p>
<ul>
<li>一个用于<code>处理网络事件</code>的线程池组。它实现了 <code>EventLoopGroup</code> 接口，并且<code>使用默认的线程数量</code>来处理所有的网络事件</li>
<li>由于<code>没有指定参数</code>，在创建时将使用默认的参数，即线程数为<code>CPU 核心数乘以 2</code></li>
<li><code>defEventLoopGroup</code> 是一个线程池组，它包含<code>多个线程</code>来处理各种网络事件</li>
<li>使用时，可以将其传递给 <code>Netty</code> 的 <code>Bootstrap</code> 或 <code>ServerBootstrap</code> 对象，用于处理各种网络连接</li>
</ul>
</blockquote>
<h5 id="更换不同的handler"><a href="#更换不同的handler" class="headerlink" title="更换不同的handler"></a>更换不同的<code>handler</code></h5><blockquote>
<p>源码分析</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">Object</span> <span class="variable">m</span> <span class="operator">=</span> next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="string">&quot;msg&quot;</span>), next);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 下一个 handler 的事件循环是否与当前的事件循环是同一个线程</span></span><br><span class="line">   <span class="type">EventExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> next.executor();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是，直接调用</span></span><br><span class="line">   <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">       next.invokeChannelRead(m);</span><br><span class="line">   &#125; </span><br><span class="line">   <span class="comment">// 不是，将要执行的代码作为任务提交给下一个事件循环处理（换人）</span></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">       executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">               next.invokeChannelRead(m);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>如果两个 <code>handler</code> 绑定的<code>是同一个线程</code>，那么就<code>直接调用</code></li>
<li>如果两个 <code>handler</code> 绑定的<code>不是同一个线程</code>，把要<code>调用的代码</code>封装为一个任务对象，由下一个 <code>handler</code> 的线程来调用</li>
</ul>
</blockquote>
<h5 id="NioEventLoop处理任务"><a href="#NioEventLoop处理任务" class="headerlink" title="NioEventLoop处理任务"></a><code>NioEventLoop</code>处理任务</h5><ul>
<li>定时任务</li>
<li>普通任务</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NioEventLoopGroup</span> <span class="variable">nioWorkers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>);</span><br><span class="line">nioWorkers.execute(()-&gt;&#123;  <span class="comment">//NioEventLoop 除了可以处理 io 事件，同样可以向它提交普通任务,可以用来执行耗时较长的任务</span></span><br><span class="line">    log.debug(<span class="string">&quot;normal task...&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nioWorkers.scheduleAtFixedRate(() -&gt; &#123; <span class="comment">//NioEventLoop 处理定时任务,可以用来执行定时任务</span></span><br><span class="line">    log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><blockquote>
<p>主要作用：</p>
</blockquote>
<ul>
<li><code>close</code>可以用来关闭<code>channel</code></li>
<li><code>closeFuture()</code>用来处理 <code>channel</code> 的关闭<ul>
<li><code>sync</code> 方法作用是<code>同步</code>等待 <code>channel</code> 关闭</li>
<li>而 <code>addListener</code> 方法是<code>异步</code>等待 <code>channel</code> 关闭</li>
</ul>
</li>
<li><code>pipeline()</code>方法添加处理器</li>
<li><code>write()</code>方法将数据写入</li>
<li><code>writeAndFlush()</code> 方法将数据写入并刷出</li>
</ul>
<h5 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h5><blockquote>
<p>使用<code>ChannelFuture</code>  对该代码进行改进</p>
<p>原来：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>)</span><br><span class="line">    .sync()</span><br><span class="line">    .channel()</span><br><span class="line">    .writeAndFlush(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;: hello world!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>修改之后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">channelFuture.sync().channel().writeAndFlush(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;: hello world!&quot;</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明</p>
</blockquote>
<ul>
<li><p><code>1</code> 处返回的是<code>ChannelFuture</code> 对象,作用是利用 <code>channel()</code>方法来获取 <code>Channel</code> 对象</p>
</li>
<li><p><strong>注意</strong> <code>connect</code> 方法是异步的，意味着不用等待连接的建立，方法执行就可以返回了。因此 <code>channelFuture</code> 对象中不能【立刻】获得到正确的 <code>Channel</code> 对象</p>
</li>
</ul>
<blockquote>
<p>除了用 <code>sync</code> 方法可以让<code>异步操作同步</code>以外，还可以使用<code>回调的方式</code>：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">System.out.println(channelFuture.channel()); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">//回调函数</span></span><br><span class="line">channelFuture.addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">    System.out.println(future.channel()); <span class="comment">// 2</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ChannelFutureListener 会在连接建立时被调用（其中 operationComplete 方法），因此执行到 2 时，连接肯定建立了</span></span><br></pre></td></tr></table></figure>
<p><strong>小结：异步操作同步</strong></p>
<blockquote>
<p> <code>方法一</code>同步处理结果：<code>channelFuture.sync();</code>   :  表示  【阻塞等待中…】，直到<code>nio</code>线程 连接建立完毕  再继续往下执行</p>
<ul>
<li>无阻塞的向下运行， 如果没有上面的 <code>sync()</code>方法 的话，这里获取的 <code>channel</code>还是<code>未建立好连接</code>的</li>
<li><p>如果有上面的 <code>sync()</code>方法 的话，这里获取的 <code>channel</code>是 <code>建立好连接</code>的</p>
<p><code>方法二</code> 使用 <code>addListener</code>(回调对象) 异步处理结果[<code>lambda</code>表达式的简化写见上]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">channelFuture.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">          <span class="comment">// nio 线程 建立好之后，会调用 此方法</span></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">              <span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> future.channel();</span><br><span class="line">              log.debug(<span class="string">&quot;用addListener() 异步处理结果后 得到的 channel = &#123;&#125;&quot;</span>, channel);</span><br><span class="line">              channel.writeAndFlush(<span class="string">&quot;线程建立好后的回调对象addListener异步处理结果);</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">      &#125;);</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h5 id="CloseFuture"><a href="#CloseFuture" class="headerlink" title="CloseFuture"></a>CloseFuture</h5><p>获取 <code>CloseFuture</code> 对象:   <code>ChannelFuture closeFuture = channel.closeFuture();</code></p>
<ul>
<li>同步处理关闭    : <code>closeFuture.sync();</code></li>
<li>异步处理关闭    : <code>channelFuture.addListener((ChannelFutureListener) future -&gt; &#123;
System.out.println(future.channel()); // 2
&#125;);</code></li>
</ul>
<blockquote>
<p>什么是优雅的关闭：</p>
<ul>
<li>首先切换 <code>EventLoopGroup</code> 到关闭状态 ,<code>拒绝新的任务的加入</code></li>
<li>其次   任务队列的任务<code>都处理完成后</code>，<code>停止线程</code>的运行</li>
</ul>
</blockquote>
<h5 id="异步提升的是什么"><a href="#异步提升的是什么" class="headerlink" title="异步提升的是什么"></a>异步提升的是什么</h5><blockquote>
<p>提升的是：<code>效率</code>      <code>吞吐量</code>  <code>合理进行任务拆分</code></p>
</blockquote>
<ul>
<li>单线程没法异步提高<code>效率</code>，必须配合多线程、多核 cpu 才能发挥异步的优势</li>
<li>异步并没有缩短响应时间，反而有所增加,但是<code>吞吐量</code>有了很大的提升</li>
<li><code>合理进行任务拆分</code> ，也是利用异步的关键</li>
</ul>
<h4 id="Future-amp-Promise"><a href="#Future-amp-Promise" class="headerlink" title="Future &amp; Promise"></a>Future &amp; Promise</h4><p>==注意==：<code>netty 中的 Future</code> 与<code>jdk 中的 Future</code> 同名，但是是<code>两个接口</code>，<code>netty 的 Future</code> 继承自 <code>jdk 的 Future</code>，而 <code>Promise</code> 又对 <code>netty Future</code> 进行了扩展</p>
<ul>
<li><code>jdk Future</code> 只能<code>同步等待任务结束</code>（或成功、或失败）才能得到结果</li>
<li><code>netty Future</code> 可以<code>同步等待任务结束</code>得到结果，也可以<code>异步方式</code>得到结果，但都是<code>要等任务结束</code></li>
<li><code>netty Promise</code> 不仅有 <code>netty Future</code>的功能，而且脱离了<code>任务独立存在</code>，只作为<code>两个线程间传递结果的容器</code></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>功能/名称</th>
<th>jdk Future</th>
<th>netty Future</th>
<th>Promise</th>
</tr>
</thead>
<tbody>
<tr>
<td>cancel</td>
<td>取消任务</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>isCanceled</td>
<td>任务是否取消</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>isDone</td>
<td>任务是否完成，不能区分成功失败</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>get</td>
<td>获取任务结果，<code>阻塞</code>等待</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>getNow</td>
<td>-</td>
<td>获取任务结果，<code>非阻塞</code> 还未产生结果时返回 <code>null</code></td>
<td>-</td>
</tr>
<tr>
<td>await</td>
<td>-</td>
<td>等待任务结束，如果任务失败，不会抛异常，而是通过 <code>isSuccess</code> 判断</td>
<td>-</td>
</tr>
<tr>
<td>sync</td>
<td>-</td>
<td>等待任务结束，如果任务失败，抛出异常</td>
<td>-</td>
</tr>
<tr>
<td>isSuccess</td>
<td>-</td>
<td>判断任务是否成功</td>
<td>-</td>
</tr>
<tr>
<td>cause</td>
<td>-</td>
<td>获取失败信息，非阻塞，如果没有失败，返回<code>null</code></td>
<td>-</td>
</tr>
<tr>
<td>addLinstener</td>
<td>-</td>
<td>添加回调，异步接收结果</td>
<td>-</td>
</tr>
<tr>
<td>setSuccess</td>
<td>-</td>
<td>-</td>
<td>设置成功结果</td>
</tr>
<tr>
<td>setFailure</td>
<td>-</td>
<td>-</td>
<td>设置失败结果</td>
</tr>
</tbody>
</table>
</div>
<h5 id="JDK-FUTURE"><a href="#JDK-FUTURE" class="headerlink" title="JDK FUTURE"></a><code>JDK FUTURE</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建线程池</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 提交任务 ，call()执行完毕，结果填充Future里，然后把下面 get() 阻塞方法 唤醒</span></span><br><span class="line">        <span class="keyword">final</span> Future&lt;Integer&gt; future = service.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;执行计算...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 主线程通过 future 来获取结果</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> future.get(); <span class="comment">// 阻塞方法，等待 子线程运行完毕</span></span><br></pre></td></tr></table></figure>
<h5 id="NETTY-FUTURE"><a href="#NETTY-FUTURE" class="headerlink" title="NETTY FUTURE"></a><code>NETTY FUTURE</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1. EventLoopGroup 里包含 多个EventLoop      一个 EventLoop里面包含一个线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">EventLoop</span> <span class="variable">eventLoop</span> <span class="operator">=</span> group.next();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Future&lt;Integer&gt; future = eventLoop.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;执行计算...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">666</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 主线程通过 future 来获取结果</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式一. 同步获取结果</span></span><br><span class="line"><span class="comment">//        final Integer i = future.get(); // 阻塞方法，等待 子线程运行完毕</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式二. 异步获取结果</span></span><br><span class="line">        <span class="comment">// 注意这里不能用 ChannelFutureListener，因为上面 NioEventLoopGroup 不属于channel的</span></span><br><span class="line">        future.addListener(future1 -&gt; &#123;</span><br><span class="line">            <span class="comment">// getNow非阻塞方法； get()阻塞方法也可以（因为当前回调方法执行了，说明子线程已经完成了）</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> (Integer) future1.getNow(); </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="NETTY-PROMISE"><a href="#NETTY-PROMISE" class="headerlink" title="NETTY PROMISE"></a><code>NETTY PROMISE</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">		<span class="comment">// 1. 准备 EventLoop 对象</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">EventLoop</span> <span class="variable">eventLoop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>().next();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建 promise  的 结果容器</span></span><br><span class="line">        <span class="keyword">final</span> DefaultPromise&lt;Integer&gt; promise = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>&lt;&gt;(eventLoop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 任意一线程 执行计算，计算完毕后向 promise 填充结果</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;开始计算......&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"><span class="comment">//                int i = 1/0;</span></span><br><span class="line">                <span class="comment">// 设置成功结果</span></span><br><span class="line">                promise.setSuccess(<span class="number">80</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// 设置失败结果</span></span><br><span class="line">                promise.setFailure(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 主线程接收 结果</span></span><br><span class="line">        log.debug(<span class="string">&quot;结果是： &#123;&#125;&quot;</span>, promise.get()); <span class="comment">// get 同步阻塞</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>DefaultPromise&lt;Integer&gt; promise = new DefaultPromise&lt;&gt;(eventExecutors);</code></p>
<p>==成功==</p>
<ul>
<li><p><code>promise.get());     get 同步阻塞      同步处理任务成功</code></p>
</li>
<li><p>`promise.addListener(promise -&gt; {</p>
<pre><code>log.debug(&quot;&#123;&#125;&quot;,promise.getNow());
</code></pre><p>}); 异步处理任务成功`</p>
<p><code>promise.setSuccess(10);</code></p>
</li>
</ul>
<p>==失败==</p>
<ul>
<li>同步处理任务失败 -<code>sync &amp; get</code>      <code>promise.get(); // sync() 也会出现异常，只是 get 会再用 ExecutionException 包一层异常</code></li>
<li><p>同步处理任务失败 - <code>await</code>        <code>promise.await(); // 与 sync 和 get 区别在于，不会抛异常</code></p>
</li>
<li><p>异步处理任务失败   `promise.addListener(future -&gt; {</p>
<pre><code>log.debug(&quot;result &#123;&#125;&quot;, (promise.isSuccess() ? promise.getNow() :           promise.cause()).toString());
</code></pre><p>  });`</p>
</li>
</ul>
<p>==死锁检查==</p>
<ul>
<li><code>await 死锁检查</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">eventExecutors.submit(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        promise.await();</span><br><span class="line"><span class="comment">// 注意不能仅捕获 InterruptedException 异常</span></span><br><span class="line"><span class="comment">// 否则 死锁检查抛出的 BlockingOperationException 会继续向上传播</span></span><br><span class="line"><span class="comment">// 而提交的任务会被包装为 PromiseTask，它的 run 方法中会 catch 所有异常 然后设置为 Promise 的失败结果而不会抛出</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="Handler-amp-Pipeline"><a href="#Handler-amp-Pipeline" class="headerlink" title="Handler &amp; Pipeline"></a>Handler &amp; Pipeline</h4><p><code>ChannelHandler</code> 是用来处理<code>Channel</code>上的各种事件，分为<code>入站、出站</code>两种。所有 <code>ChannelHandler</code> 被连成一串，就是 <code>Pipeline</code></p>
<ul>
<li><p><code>入站</code>处理器： <code>ChannelInboundHandlerAdapter</code> 的子类，主要用来<code>读取客户端数据，写回结果</code></p>
</li>
<li><p><code>出站</code>处理器： <code>ChannelOutboundHandlerAdapter</code> 的子类，主要对<code>写回结果进行加工</code></p>
</li>
</ul>
<blockquote>
<p><code>入站</code> 里 调用 <code>ch.writeAndFlush()</code>方法 才能<code>触发出站</code> 动作   <code>ctx.alloc()</code>创建<code>Bytebuf</code> 对象</p>
</blockquote>
<ul>
<li><p>创建<code>pipeline</code>：通过 <code>channel</code> 拿到 <code>pipeline</code>        <code>final ChannelPipeline pipeline = ch.pipeline();</code></p>
</li>
<li><p>添加<code>handler</code>:    添加处理器  <code>netty</code>加<code>handler</code>时 有两个 <code>handler  head -&gt; tail</code>       <code>addLast</code> 每次添加的位置 是 这两个中间 ：<code>head -&gt; handler1 handler2 handler3 -&gt; tail</code></p>
<ul>
<li><p>当添加多个<code>出站入站处理器</code>的时候要注意的是处理器之间需要进行唤醒：(二选一即可)</p>
<ul>
<li><p><code>ctx.fireChannelRead(student);</code> :一般出现在自定义的 <code>ChannelInboundHandler</code> 中的 <code>channelRead()</code>方法中</p>
</li>
<li><p><code>super.channelRead(ctx, student);</code>:在 <code>ChannelInboundHandlerAdapter</code> 的<code>channelRead()</code> 方法中调用的，用于将<code>从网络中读取的数据</code>向 <code>ChannelPipeline</code> 中的<code>下一个处理器</code>传递，并由<code>下一个处理器</code>对这个数据进行处理</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>ch.writeAndFlush(ctx.alloc().buffer().writeBytes(&quot;...&quot;.getBytes()));</code>是将字节数组<code>...</code>写入到 <code>Channel</code> 中并刷新的操作,主要的就是<code>通过 writeBytes()方法将 &quot;…&quot; 字节数组写入缓冲区中</code>,最后调用 <code>writeAndFlush()</code> 方法将缓冲区中的数据写入到 <code>Channel</code> 中并刷新；另外<code>ctx.alloc().buffer()</code> 用来分配一个 <code>ByteBuf</code> 缓冲区，用于存储要写入的数据</p>
<p><strong>数据的传递和处理的：</strong></p>
<ul>
<li><code>super.write(ctx, msg, promise)</code> 方法与 <code>ctx.write()</code> 方法类似，是用于将数据写入到 <code>ChannelPipeline</code> 中的<code>下一个出站处理器进行处理的方法</code></li>
<li><code>super.write</code>是从当前出站处理器<code>向前找上一个</code>出站处理器来处理数据的</li>
<li>这个方法会将要写入的消息 <code>msg</code> 和异步操作结果 <code>promise</code> 传递给当前 <code>ChannelHandler</code> 类的<code>父类</code>（即 <code>ChannelOutboundHandlerAdapter</code>），由它来完成将消息写入到 <code>ChannelPipeline</code> 中的下一个出站处理器的操作。在写入过程中，如果数据被<code>阻塞</code>或<code>发送失败</code>，就会通过 <code>promise</code> 对象返回相应的错误信息</li>
<li>该方法可以将数据从<code>出站处理器</code>传递到<code>下一个出站处理器</code>，并<code>最终写入到发送缓冲区</code>中等待发送</li>
</ul>
</blockquote>
<p>入栈处理器是顺序的传递值给到下一个处理器进行处理任务，而出站处理器的逆序的处理处理器，具体的话有两种<code>出站</code>处理器的方法：</p>
<ul>
<li><b>ctx.<code>channel()</code>.write(msg,promise)</b> 从<code>尾部开始</code>向前查找出站处理器</li>
<li><b>ctx.write(msg,promise)</b>           是从<code>当前节点</code>向前找到上一个出站处理器</li>
</ul>
<p>值得注意的是 入站和出站之间是需要进行数据传递的,使用的方法就是</p>
<ul>
<li><p>方式一：<code>ctx.channel().writeAndFlush(msg)</code>    ：先获取当前处理器所关联的 <code>Channel</code>，然后调用 <code>Channel</code> 对象的 <code>writeAndFlush()</code> 方法来将消息写入到 <code>Channel</code> 中并刷新;可以保证消息的<code>写入和刷新</code>操作发生在 <code>ChannelPipeline</code> 的出<code>站处理器</code>中，从而<code>使得其他的出站处理器</code>也能够对<code>数据进行处理</code>,从 最后一个handler往前找</p>
</li>
<li><p>方式二：<code>ctx.writeAndFlush(msg);</code>  ： 将消息写入到 <code>Channel</code> 中<code>并刷新</code>,由于调用 <code>writeAndFlush()</code> 方法时，实际上会将消息从当前的<code>出站处理器</code>开始一路传递到下一个出站处理器，从而最终写入到 <code>Channel</code>中并刷新。因此，这种方式也可以<code>完成消息的写入和刷新操作</code>，但是<code>它只能够保证消息被当前出站处理器处理</code>，从当前节点往上找 出站处理器</p>
<blockquote>
<p>如果想要保证<code>所有的出站处理器</code>都能够<code>对数据进行处理</code>，建议使用方式一；</p>
<p>如果仅需要在<code>当前出站处理器</code>进行<code>数据的处理</code>，则可以使用方式二。</p>
</blockquote>
</li>
</ul>
<p>也就是说：</p>
<p><code>`ChannelInboundHandlerAdapter</code> 是按照 <code>addLast</code> 的<code>顺序</code>执行的</p>
<p>而 <code>ChannelOutboundHandlerAdapter</code> 是按照 <code>addLast</code> 的<code>逆序</code>执行的</p>
<p><code>ChannelPipeline</code> 的实现是一个 <code>ChannelHandlerContext</code>（包装了 <code>ChannelHandler</code>） 组成的<code>双向链表</code></p>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202306172057180.png" alt="image-20230617205749098"></p>
<ul>
<li><p>入站处理器中，<code>ctx.fireChannelRead(msg)</code>是 <strong>调用下一个入站处理器</strong></p>
</li>
<li><p>出站处理器中</p>
<ul>
<li><code>ctx.channel().write(msg)</code>会 <strong>从尾部开始触发</strong> 后续出站处理器的执行</li>
<li><code>ctx.write(msg, promise)</code>  会 <strong>触发上一个出站处理器</strong></li>
</ul>
</li>
</ul>
<h4 id="EmbeddedChannel"><a href="#EmbeddedChannel" class="headerlink" title="EmbeddedChannel"></a><code>EmbeddedChannel</code></h4><blockquote>
<ul>
<li>Netty 框架提供的一个<code>嵌入式 Channel</code>实现</li>
<li>可以用于<code>在测试时</code>模拟 <code>Channel</code> 的行为和事件</li>
<li>它<code>可以在不创建实际的网络连接的情况下</code>，对 <code>ChannelHandler</code> 进行测试</li>
</ul>
</blockquote>
<p>使用注意：</p>
<ul>
<li>使用 <code>EmbeddedChannel</code> 来 ==创建==一个指定的 <code>ChannelPipeline</code>，并将需要测试的 <code>ChannelHandler</code> 添加到其中</li>
<li>然后通过调用 <code>EmbeddedChannel.writeInbound()</code> 和 <code>EmbeddedChannel.writeOutbound()</code> 方法向 <code>ChannelPipeline</code> 中写入数据，从而触发 <code>ChannelHandler</code> 的相应操作    (==模拟入站==)</li>
<li>并可以通过 <code>EmbeddedChannel.readInbound()</code> 和 <code>EmbeddedChannel.readOutbound()</code> 方法获取 <code>ChannelHandler</code> 处理后的结果，进而进行<code>断言和验证</code>                    ( ==模拟出站==)</li>
</ul>
<p>好处：</p>
<ul>
<li>可以避免创建真实的 <code>Channel</code>、编写繁琐的 <code>mock 测试</code></li>
<li>并且<code>使测试更加快速和高效</code></li>
<li>在测试中，我们可以通过创建多个 <code>EmbeddedChannel</code> 来模拟复杂的网络环境，比如同时存在多个客户端和服务器，以便测试我们的 <code>ChannelHandler</code> 在这样的场景下的正确性。</li>
</ul>
<h4 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h4><blockquote>
<p>对<code>字节数据</code>的<code>封装</code></p>
</blockquote>
<h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><p><code>ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(10);</code></p>
<ul>
<li><p>上面代码创建了一个初始容量是 <code>10</code>的 <code>ByteBuf</code>（<code>池化基于直接内存的 ByteBuf</code>）</p>
</li>
<li><p>但是什么都不写的话就是 <code>256</code>   获取直接内存，获取<code>堆内存 heapBuffer</code></p>
</li>
</ul>
<h5 id="直接内存-vs-堆内存"><a href="#直接内存-vs-堆内存" class="headerlink" title="直接内存 vs 堆内存"></a>直接内存 vs 堆内存</h5><ul>
<li><p><code>创建池化基于直接内存的ByteBuf</code>          <code>ByteBuf buffer = ByteBufAllocator.DEFAULT.heapBuffer(10);</code></p>
</li>
<li><p><code>创建池化基于堆的 ByteBuf</code>                  <code>ByteBuf buffer = ByteBufAllocator.DEFAULT.directBuffer(10);</code></p>
</li>
</ul>
<p>对比</p>
<ul>
<li>直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合<code>配合池化</code>功能一起用</li>
<li>直接内存对<code>GC</code> 压力小，因为这部分内存不受<code>JVM</code> 垃圾回收的管理，但也要注意及时主动释放</li>
</ul>
<h5 id="池化-vs-非池化"><a href="#池化-vs-非池化" class="headerlink" title="池化 vs 非池化"></a>池化 vs 非池化</h5><ul>
<li>池化的最大意义在于重用<code>ByteBuf</code></li>
<li>优点<ul>
<li>没有<code>池化</code>，则<code>每次都得创建</code>新的 <code>ByteBuf</code> 实例，这个操作<code>对直接内存</code>代价昂贵，就算<code>是堆内存</code>，也会增加 GC 压力</li>
<li>有了<code>池化</code>，则可以<code>重用</code>池中 <code>ByteBuf</code> 实例，并且采用了与 <code>jemalloc</code> 类似的<code>内存分配算法提升分配效率</code></li>
<li><code>高并发</code>时，池化功能更<code>节约内存</code>，<code>减少内存溢出的可能</code></li>
</ul>
</li>
</ul>
<p>池化功能是否开启，可以通过下面的系统环境变量来设置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Dio.netty.allocator.type=unpooled</span><br><span class="line">    ||</span><br><span class="line">-Dio.netty.allocator.type=pooled </span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：</p>
<ul>
<li>Netty4.1 <code>以后</code>，<code>非 Android 平台默认启用池化</code>实现，<code>Android 平台启用非池化</code>实现</li>
<li>Netty4.1 <code>之前</code>，池化功能还不成熟，默认是<code>非池化实现</code></li>
</ul>
</blockquote>
<h5 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h5><blockquote>
<p>ByteBuf 由<code>四部分组成</code></p>
</blockquote>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202306172205988.png" alt="image-20230617220548955" style="zoom:33%;"></p>
<p>最开始<code>读、写指针</code>都在 <code>0</code> 位置</p>
<blockquote>
<p><code>读写模式(指针)分离</code>  +  <code>读写分离</code></p>
</blockquote>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><blockquote>
<p>写入<code>buffer.writeBytes(new byte[]&#123;1, 2, 3, 4&#125;);...</code></p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法签名</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>writeBoolean(boolean value)</td>
<td>写入 boolean 值</td>
<td>用一字节 01\</td>
<td>00 代表 true\</td>
<td>false</td>
</tr>
<tr>
<td>writeByte(int value)</td>
<td>写入 byte 值</td>
<td></td>
</tr>
<tr>
<td>writeShort(int value)</td>
<td>写入 short 值</td>
<td></td>
</tr>
<tr>
<td>writeInt(int value)</td>
<td>写入 int 值</td>
<td><code>Big Endian</code>   即 0x250   写入后 00 00 02 50</td>
</tr>
<tr>
<td>writeIntLE(int value)</td>
<td>写入 int 值</td>
<td><code>Little Endian</code> 即 0x250 写入后 50 02 00 00</td>
</tr>
<tr>
<td>writeLong(long value)</td>
<td>写入 long 值</td>
<td></td>
</tr>
<tr>
<td>writeChar(int value)</td>
<td>写入 char 值</td>
<td></td>
</tr>
<tr>
<td>writeFloat(float value)</td>
<td>写入 float 值</td>
<td></td>
</tr>
<tr>
<td>writeDouble(double value)</td>
<td>写入 double 值</td>
<td></td>
</tr>
<tr>
<td>writeBytes(ByteBuf src)</td>
<td>写入 netty 的 ByteBuf</td>
<td></td>
</tr>
<tr>
<td>writeBytes(byte[] src)</td>
<td>写入 byte[]</td>
<td></td>
</tr>
<tr>
<td>writeBytes(ByteBuffer src)</td>
<td>写入 nio 的 ByteBuffer</td>
<td></td>
</tr>
<tr>
<td>int writeCharSequence(CharSequence sequence, Charset charset)</td>
<td>写入字符串</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<ul>
<li>这些方法是<code>未指明返回值</code>的，其返回值都是 <code>ByteBuf</code>，意味着<code>可以链式调用</code></li>
<li>网络传输，默认习惯是<code>Big Endian</code></li>
<li>还有一类方法是 <code>set 开头</code>的一系列方法，也可以写入数据，但不会改变写指针位置</li>
</ul>
<p>扩容</p>
</blockquote>
<ul>
<li>发生条件： 容量不够了（初始容量是 10），这时会引发扩容</li>
<li>扩容规则：<ul>
<li>如何写入后数据大小<code>未超过 512</code>，则选择<code>下一个 16 的整数倍</code>，例如写入后大小为 12 ，则扩容后 capacity 是 16</li>
<li>如果写入后数据大小<code>超过 512</code>，则选择下一个 2^n^，例如写入后大小为 513，则扩容后 capacity 是 2^10^=1024（2^9^=512 已经不够了）</li>
<li>扩容<code>不能超过 max capacity</code>（默认：<code>Integer.MAX_VALUE</code>） ,否则会报错</li>
</ul>
</li>
</ul>
<blockquote>
<p>读取    <code>buffer.readByte()</code></p>
</blockquote>
<ul>
<li><p>读过的内容，就属于废弃部分了，再读只能读那些<code>尚未读取</code>的部分</p>
</li>
<li><p>读取之前进行标记位置：     <code>buffer.markReaderIndex();</code></p>
</li>
<li><p>需要重复读取的话，重置到标记位置 ： <code>buffer.resetReaderIndex();</code></p>
</li>
<li><p>还有种办法是采用<code>get 开头</code>的一系列方法，这些方法不会改变 <code>readindex</code></p>
</li>
</ul>
<blockquote>
<p><code>retain &amp; release</code></p>
</blockquote>
<p>由于 Netty 中有<code>堆外内存</code>的 ByteBuf 实现，堆外内存最好是手动来释放，而不是等<code>GC垃圾回收</code>。</p>
<ul>
<li><code>UnpooledHeapByteBuf</code> 使用的是<code>JVM 内存</code>，只需等 <code>GC 回收内存</code>即可</li>
<li><code>UnpooledDirectByteBuf</code> 使用的就是<code>直接内存</code>了，需要<code>特殊的方法来回收内存</code></li>
<li><code>PooledByteBuf</code> 和它的子类使用了<code>池化机制</code>，需要更<code>复杂的规则来回收内存</code></li>
</ul>
<blockquote>
<p>回收内存的源码实现，请关注下面方法的不同实现</p>
<p><code>protected abstract void deallocate()</code></p>
</blockquote>
<p>Netty 这里采用了<code>引用计数法</code>来控制回收内存，每个 <code>ByteBuf</code>都实现了 <code>ReferenceCounted</code> 接口</p>
<ul>
<li>每个 <code>ByteBuf</code> 对象的初始计数为 1</li>
<li>调用 <code>release</code> 方法计数<code>减 1</code>，如果计数为 <code>0</code>，<code>ByteBuf 内存被回收</code></li>
<li>调用 <code>retain</code> 方法计数<code>加 1</code>，表示调用者没用完之前，其它 <code>handler</code> 即使调用了 <code>release</code> 也不会造成回收</li>
<li>当计数为 <code>0</code> 时，底层内存会被回收，这时即使 <code>ByteBuf</code> 对象还在，其<code>各个方法均无法正常使用</code></li>
</ul>
<blockquote>
<p>谁来负责 <code>release</code> 呢？</p>
</blockquote>
<p>基本规则是，<strong><code>谁是最后Bytebuf的使用者，谁负责 release</code></strong>，详细分析如下</p>
<ul>
<li><p>起点，对于 NIO 实现来讲，在<code>io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read</code>方法中首次创建 <code>ByteBuf</code> 放入 <code>pipeline</code>（line 163 pipeline.fireChannelRead(byteBuf)）</p>
</li>
<li><p>入站 ByteBuf 处理原则</p>
<ul>
<li><p>对原始 <code>ByteBuf</code> 不做处理，调用<code>ctx.fireChannelRead(msg)</code>向后传递，这时无须 <code>release</code></p>
</li>
<li><p>将原始 <code>ByteBuf</code> 转换为其它类型的<code>Java 对象</code>，这时 <code>ByteBuf</code> 就没用了，必须 <code>release</code></p>
</li>
<li><p>如果不调用<code>ctx.fireChannelRead(msg)</code>向后传递，那么也必须 <code>release</code></p>
</li>
<li><p>注意各种异常，如果 <code>ByteBuf</code> 没有成功传递到下一个 <code>ChannelHandler</code>，必须 <code>release</code></p>
</li>
<li><p>假设消息<code>一直向后传</code>，那么 <code>TailContext</code> 会负责<code>释放未处理消息</code>（原始的 <code>ByteBuf</code>）</p>
<blockquote>
<p>源码见下</p>
</blockquote>
</li>
</ul>
</li>
<li><p>出站 <code>ByteBuf</code> 处理原则</p>
<ul>
<li>出站消息最终都会转为 <code>ByteBuf</code> 输出，一直向前传，由 <code>HeadContext</code>    <code>flush</code> 后 <code>release</code></li>
</ul>
</li>
<li><p>异常处理原则</p>
<ul>
<li>有时候不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以循环调用 release 直到返回 true</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202306172239597.png" alt="image-20230617223943504"></p>
<blockquote>
<p> <code>TailContext</code> 会负责<code>释放未处理消息</code>的源码</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.channel.DefaultChannelPipeline#onUnhandledInboundMessage(java.lang.Object)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onUnhandledInboundMessage</span><span class="params">(Object msg)</span> &#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     logger.debug(</span><br><span class="line">         <span class="string">&quot;Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. &quot;</span> +</span><br><span class="line">         <span class="string">&quot;Please check your pipeline configuration.&quot;</span>, msg);</span><br><span class="line"> &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     ReferenceCountUtil.release(msg);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <code>具体代码</code></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.util.ReferenceCountUtil#release(java.lang.Object)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(Object msg)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> ReferenceCounted) &#123;</span><br><span class="line">     <span class="keyword">return</span> ((ReferenceCounted) msg).release();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <code>Head&lt;详见源码分析&gt;</code></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(Object msg, ChannelPromise promise)</span> &#123;</span><br><span class="line">         assertEventLoop(); 			</span><br><span class="line">			<span class="type">ChannelOutboundBuffer</span> <span class="variable">outboundBuffer</span> <span class="operator">=</span> <span class="built_in">this</span>.outboundBuffer;</span><br><span class="line">         <span class="keyword">if</span> (outboundBuffer == <span class="literal">null</span>) &#123;</span><br><span class="line">             <span class="comment">// If the outboundBuffer is null we know the channel was closed and so</span></span><br><span class="line">             <span class="comment">// need to fail the future right away. If it is not null the handling of the rest</span></span><br><span class="line">             <span class="comment">// will be done in flush0()</span></span><br><span class="line">             <span class="comment">// See https://github.com/netty/netty/issues/2362</span></span><br><span class="line">             safeSetFailure(promise, newClosedChannelException(initialCloseCause));</span><br><span class="line">             <span class="comment">// release message now to prevent resource-leak</span></span><br><span class="line">             ReferenceCountUtil.release(msg);</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>
<p>slice</p>
</blockquote>
<p>【零拷贝】的体现之一，对原始 <code>ByteBuf</code> 进行<code>切片成多个 ByteBuf</code>，切片后的 <code>ByteBuf</code> 并没有发生<code>内存复制</code>，还是使用<code>原始 ByteBuf</code>的内存，切片后的 <code>ByteBuf</code> 维护独立的 <code>read，write 指针</code></p>
<font color="red">注意点：</font>

<ol>
<li><p>切片的 ByteBuf 将<code>已限制最大容量</code>，不得追加，就是内存已经满了之后就不能在向<code>ByteBuf</code> 中写数据了 ，否则会有异常<code>java.lang.IndexOutOfBoundsException:</code></p>
</li>
<li><p><code>ByteBuf</code> 和 <code>slice</code> 分别维护自己独立的<code>read，write</code> 指针</p>
</li>
<li>对 <code>ByteBuf release</code>【引用计数<code>-1</code>】操作之后，不得使用 <code>slice</code>切片的数据，除非 先使用 <code>retain</code>【引用计数+1】,否则会出现异常<code>io.netty.util.IllegalReferenceCountException: refCnt: 0</code></li>
<li><p>正确用法：对单个切片进行 retain 和 release 成对处理，不会乱</p>
</li>
<li><p>无论 对 <code>原buf</code> 还是 <code>slice</code> 得到的 <code>ByteBuf</code> <code>引用计数</code> 都是一样的，都是对<code>物理内存</code>进行<code>引用计数</code></p>
</li>
<li><p>修改 <code>slice</code>  的 某个字节 将看到   原始<code>ByteBuf</code>值也被修改了</p>
</li>
</ol>
<p>切片函数：</p>
<ul>
<li><code>无参 slice</code>是从原始 <code>ByteBuf</code> 的<code>read index</code>到<code>write index</code>之间的内容进行切片，切片后的 <code>max capacity</code>被固定为这个区间的大小，因此<code>不能追加 write</code></li>
<li><p>之后对于原始数据的读写都不会对切片<code>slice</code>的数据产生影响，因为<code>slice</code>有独立的读写指针</p>
</li>
<li><p>但是如果 <code>slice</code> 的内容发生了更改,原始 ByteBuf 也会受影响，因为底层都是同一块内存</p>
</li>
</ul>
<blockquote>
<p>duplicate</p>
</blockquote>
<p>【零拷贝】的体现之一，就好比截取了原始 ByteBuf 所有内容，并且没有 max capacity 的限制，也是与原始 ByteBuf 使用同一块底层内存，只是读写指针是独立的</p>
<blockquote>
<p>copy</p>
</blockquote>
<p>会将底层内存数据进行<code>深拷贝</code>，因此无论读写，都与原始 ByteBuf 无关</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">ByteBuf</span> <span class="variable">buf1</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line">buf1.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;);</span><br><span class="line"><span class="comment">//copy buf1</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">ByteBuf</span> <span class="variable">bufferCopy</span> <span class="operator">=</span> buf1.copy();</span><br><span class="line"><span class="comment">// 修改 buf1</span></span><br><span class="line">buf1.setByte(<span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line">log(bufferCopy);  <span class="comment">// 不会因为 buf1 的修改 而改变</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>CompositeByteBuf</p>
</blockquote>
<p>【零拷贝】的体现之一，可以将多个 ByteBuf <code>合并</code>为一个逻辑上的 ByteBuf，避免拷贝</p>
<ul>
<li><p>实现方式</p>
<ul>
<li><p>方式一：   不太好，会  进行 数据的内存复制操作</p>
<p><code>ByteBuf buf3 = ByteBufAllocator.DEFAULT .buffer(buf1.readableBytes()+buf2.readableBytes());
buf3.writeBytes(buf1);
buf3.writeBytes(buf2);</code></p>
<blockquote>
<p> <code>writeBytes 链式赋值拷贝</code></p>
<p> <code>readableBytes 返回可读取的字节数</code></p>
</blockquote>
</li>
<li><p>方式二：</p>
<p><code>CompositeByteBuf buf3 = ByteBufAllocator.DEFAULT.compositeBuffer();
// true 表示增加新的 ByteBuf 自动递增 write index, 否则 write index 会始终为 0
buf3.addComponents(true, buf1, buf2);</code></p>
<ul>
<li><code>CompositeByteBuf</code> 是一个组合的 <code>ByteBuf</code>，它内部维护了一个 <code>Component</code> 数组，每个 <code>Component</code> 管理一个 <code>ByteBuf</code>，记录了这个 <code>ByteBuf</code> 相对于整体偏移量等信息，代表着整体中某一段的数据。<ul>
<li><code>优点</code>，对外是一个虚拟视图，组合这些 ByteBuf 不会产生内存复制</li>
<li><code>缺点</code>，复杂了很多，多次操作会带来性能的损耗</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//composite 【零拷贝-false】</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">CompositeByteBuf</span> <span class="variable">compositeByteBuf1</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.compositeBuffer();</span><br><span class="line">compositeByteBuf1.addComponents(buf1, buf2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//composite 【零拷贝-true】  布尔参数 true : 表示自动增长写指针</span></span><br><span class="line"><span class="comment">//此时: 修改源buf 还是会影响到 composite 之后的 ByteBuf 所得到的数据</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">CompositeByteBuf</span> <span class="variable">compositeByteBuf1</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.compositeBuffer();</span><br><span class="line">compositeByteBuf1.addComponents(<span class="literal">true</span>,buf1, buf2);</span><br><span class="line"><span class="comment">//这里的 true 参数表示，当真正使用 CompositeByteBuf 时，是否需要释放被合并的 ByteBuf 对象。</span></span><br><span class="line"><span class="comment">//如果将该参数设置为 true，表示合并后的 CompositeByteBuf 使用完毕后会   自动释放   其中的 ByteBuf 对象。</span></span><br><span class="line"><span class="comment">//而如果将该参数设置为 false（默认值），则需要   手动释放     CompositeByteBuf 和其中的 ByteBuf 对象。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//值得注意的是</span></span><br><span class="line"><span class="comment">//使用 addComponents() 方法添加 ByteBuf 对象时，</span></span><br><span class="line"><span class="comment">//如果传入的第一个参数为 true，则需要确保所有的 ByteBuf 对象都是从事先分配的 ByteBufAllocator 中分配的，否则有可能导致内存泄漏或崩溃等问题</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Unpooled</p>
</blockquote>
<p><code>Unpooled</code> 是一个工具类，提供了<code>非池化的 ByteBuf 创建、组合、复制等操作</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当包装 ByteBuf 个数超过一个时, 底层使用了 CompositeByteBuf</span></span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf3</span> <span class="operator">=</span> Unpooled.wrappedBuffer(buf1, buf2);</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf3));</span><br><span class="line"><span class="comment">// 但是一旦改变 buf1 就会发现 引用地址的 buf3 数据改了</span></span><br><span class="line">buf1.setByte(<span class="number">0</span>,<span class="number">16</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以用来包装普通字节数组，底层也不会有拷贝操作</span></span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf4</span> <span class="operator">=</span> Unpooled.wrappedBuffer(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, <span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">ByteBuf</span> <span class="variable">buf1</span> <span class="operator">=</span> Unpooled.buffer(<span class="number">5</span>);  <span class="comment">// [--- 创建非池化 + 堆内存的 ByteBuf ---]</span></span><br><span class="line">buf1.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;);</span><br><span class="line"><span class="keyword">final</span> <span class="type">ByteBuf</span> <span class="variable">buf2</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf2.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(buf1.getClass()); <span class="comment">// : class io.netty.buffer.UnpooledByteBufAllocator$InstrumentedUnpooledUnsafeHeapByteBuf   非池化堆内存</span></span><br><span class="line">System.out.println(buf2.getClass()); <span class="comment">// : class io.netty.buffer.PooledUnsafeDirectByteBuf     池化直接内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非池化堆内存 进行零拷贝</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">ByteBuf</span> <span class="variable">s</span> <span class="operator">=</span> buf1.slice(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">System.out.println(s.getClass()); <span class="comment">//  class io.netty.buffer.UnpooledSlicedByteBuf</span></span><br></pre></td></tr></table></figure>
<h4 id="ByteBuf-优势"><a href="#ByteBuf-优势" class="headerlink" title="ByteBuf 优势"></a>ByteBuf 优势</h4><ul>
<li>池化 - 可以重用池中 <code>ByteBuf</code> 实例，更节约内存，减少内存溢出的可能</li>
<li><code>读写指针分离</code>，不需要像 <code>ByteBuffer</code> 一样需要进行<code>切换读写模式</code></li>
<li>可以<code>自动扩容</code></li>
<li><code>支持链式调用</code>，使用更流畅</li>
<li>很多地方体现<code>零拷贝</code>，例如 slice、duplicate、CompositeByteBuf</li>
</ul>
<h3 id="双向通信"><a href="#双向通信" class="headerlink" title="双向通信"></a>双向通信</h3><p>注意</p>
<ul>
<li><p>不推荐使用 <code>ByteBufAllocator.DEFAULT.buffer(5);</code>  创建<code>ByteBuf</code></p>
</li>
<li><p>推荐使用 <code>ctx.alloc().buffer();</code>  创建<code>ByteBuf</code></p>
</li>
</ul>
<blockquote>
<p>回声代码服务端</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                    System.out.println(buffer.toString(Charset.defaultCharset()));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 建议使用 ctx.alloc() 创建 ByteBuf</span></span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">response</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                    response.writeBytes(buffer);</span><br><span class="line">                    ctx.writeAndFlush(response);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 思考：需要释放 buffer 吗</span></span><br><span class="line">                    <span class="comment">// 思考：需要释放 response 吗</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).bind(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>回声代码客户端</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(group)</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                    System.out.println(buffer.toString(Charset.defaultCharset()));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 思考：需要释放 buffer 吗</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>).sync().channel();</span><br><span class="line"></span><br><span class="line">channel.closeFuture().addListener(future -&gt; &#123;</span><br><span class="line">    group.shutdownGracefully();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;q&quot;</span>.equals(line)) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        channel.writeAndFlush(line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<p>误区❌</p>
<blockquote>
<p>只有在 <code>netty，nio</code>这样的<code>多路复用 IO 模型</code>时，<code>读写才不会相互阻塞</code>，才可以实现高效的双向通信</p>
</blockquote>
<p>正解✅</p>
<blockquote>
<p><code>Java Socket</code> 是<code>全双工</code>的：在任意时刻，线路上存在<code>A 到 B</code> 和 <code>B 到 A</code> 的双向信号传输。即使是阻塞 IO，读和写是可以同时进行的，只要分别采用读线程和写线程即可，读不会阻塞写、写也不会阻塞读</p>
</blockquote>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="黏包半包"><a href="#黏包半包" class="headerlink" title="黏包半包"></a>黏包半包</h3><ul>
<li>复现半包现象的时候： 使用 <code>serverBootstrap.option(ChannelOption.SO_RCVBUF, 10)</code>实惠影响底层接收缓冲区（即滑动窗口）的大小的，仅决定了 <code>netty</code> 读取的<code>最小单位</code>，<code>netty</code> 实际<code>每次读取的一般是它的整数倍</code></li>
</ul>
<h4 id="现象复现"><a href="#现象复现" class="headerlink" title="现象复现"></a>现象复现</h4><h5 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h5><blockquote>
<p>服务器代码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldServer</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldServer.class);</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            serverBootstrap.group(boss, worker);</span><br><span class="line">            serverBootstrap.option(ChannelOption.SO_RCVBUF, <span class="number">10</span>);</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> &#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="comment">// 连接建立时会执行该方法</span></span><br><span class="line">                            log.debug(<span class="string">&quot;connected &#123;&#125;&quot;</span>, ctx.channel());</span><br><span class="line">                            <span class="built_in">super</span>.channelActive(ctx);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="comment">// 连接断开时会执行该方法</span></span><br><span class="line">                            log.debug(<span class="string">&quot;disconnect &#123;&#125;&quot;</span>, ctx.channel());</span><br><span class="line">                            <span class="built_in">super</span>.channelInactive(ctx);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;&#123;&#125; binding...&quot;</span>, channelFuture.channel());</span><br><span class="line">            channelFuture.sync();</span><br><span class="line">            log.debug(<span class="string">&quot;&#123;&#125; bound...&quot;</span>, channelFuture.channel());</span><br><span class="line">            <span class="comment">// 关闭channel</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;server error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> </span><br><span class="line">            log.debug(<span class="string">&quot;stopped&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">StudyServer</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 客户端代码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;connected...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">                            <span class="comment">// 每次发送16个字节的数据，共发送10次</span></span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                                <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer(<span class="number">16</span>);</span><br><span class="line">                                buffer.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;);</span><br><span class="line">                                ctx.writeAndFlush(buffer);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="半包"><a href="#半包" class="headerlink" title="半包"></a>半包</h5><blockquote>
<p>对<code>服务器代码</code>进行修改即可,添加下面这句</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调整channel的容量</span></span><br><span class="line">serverBootstrap.option(ChannelOption.SO_RCVBUF, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<h4 id="现象分析"><a href="#现象分析" class="headerlink" title="现象分析"></a>现象分析</h4><ul>
<li><p>粘包：</p>
<ul>
<li><p>现象： 发送 abc def，接收 abcdef</p>
</li>
<li><p>原因</p>
<ul>
<li><p>应用层：接收方 <code>ByteBuf</code> 设置太大（Netty 默认 1024）</p>
</li>
<li><p>滑动窗口：<code>假设</code>发送方 256 bytes 表示一个完整报文，但由于<code>接收方处理不及时</code>且<code>窗口大小足够大</code>，这 256 bytes 字节<code>就会缓冲在接收方的滑动窗口中</code>，当滑动窗口中<code>缓冲了多个报文就会粘包</code></p>
</li>
<li><p>Nagle 算法：会造成粘包</p>
<blockquote>
<p><code>Nagle 算法</code></p>
<p>引入的目的是：<code>通过将多个小数据包</code>合并成<code>较大的数据包</code>来减少网络上的流量和提高网络传输效率</p>
<p>实现机制: 在发送缓冲区中积累尽可能多的数据，直到达到<code>下列条件之一</code>才将<code>数据发送出去</code>：</p>
<ul>
<li><p>缓冲区中的数据量已经达到了MSS（最大报文段大小）</p>
</li>
<li><p>之前发送出去的广播、多播或已确认的数据块的确认已经全部收到</p>
</li>
<li>应用程序主动调用<code>TCP_NODELAY</code>选项禁止Nagle算法</li>
</ul>
<p>Nagle算法采用这种方式发送数据的<code>好处</code>在于</p>
<ul>
<li>它可以充分利用网络带宽，并减少网络拥塞的发生</li>
</ul>
<p>问题是：</p>
<ul>
<li>但是，如果应用程序发送的数据包含大量较小的数据块，则Nagle算法会将这些数据块合并成一个大的数据包后再传输，这样会导致数据<code>传输的时延增加</code>，<code>从而降低实时性</code>。此时，应该使用<code>TCP_NODELAY</code>选项进行关闭</li>
</ul>
<p>注意：</p>
<ul>
<li><code>Nagle</code>算法并不是完全适用于所有情况</li>
<li>对于某些<code>交互性强</code>的应用程序，例如远程终端、游戏等，需要实时性进行控制，此时<code>禁用Nagle算法是必要</code>的</li>
<li>在数据传输量<code>非常巨大</code>的情况下，Nagle算法可能会降低网络传输的效率，因此也需要<code>根据具体的应用场景进行针对性的调整</code></li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>半包</p>
<ul>
<li><p>现象：发送 <code>abcdef</code>，接收 <code>abc</code>  + <code>def</code></p>
</li>
<li><p>原因</p>
<ul>
<li>应用层：接收方 ByteBuf <code>小于</code>实际发送数据量</li>
<li>滑动窗口：<code>假设</code>接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时放不下了，只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包</li>
<li><code>MSS 限制</code>：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包</li>
</ul>
<blockquote>
<ul>
<li><p><code>MSS（Maximum Segment Size）限制</code>  是指 <code>TCP</code>协议中的窗口大小，它表示在 TCP 协议中，每个数据包可以传输的最大有效载荷大小</p>
</li>
<li><p><code>MSS</code> 取决于网络链路的 <code>MTU（Maximum Transmission Unit，最大传输单元）</code>和<code>TCP 的头部大小</code>。例如，在一个 MTU 为 1500 字节的以太网中，TCP 每个数据包的头部大小为 20 字节，此时 MSS 的值就为 1480 字节。</p>
</li>
<li><p><code>MSS 主要作用是</code>用于控制 <code>TCP</code> 流量，确保在网络中不会出现过大的数据包，从而减少拥塞和丢包等问题，提高数据传输的效率和稳定性。<code>MSS</code> 的大小可以通过协商双方的 <code>TCP</code> 标识字段进行约定，如果两端都支持 <code>Path MTU Discovery（PMTUD）</code>协议，则可以通过发送 <code>ICMP</code>包来自适应地调整 <code>MSS</code> 的大小。</p>
</li>
<li><p>一般来说，在高速网络中可以使用较大的 <code>MSS</code> 值，在低速网络或者网络质量较差的情况下，可以适当地减小 <code>MSS</code> 值</p>
</li>
<li><code>MSS</code> 的默认值可以在操作系统或者网络设备中进行配置，以满足具体的应用场景需要。</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>发生的本质原因是：</p>
<ul>
<li>TCP 是<code>流式协议，消息无边界</code></li>
</ul>
<blockquote>
<p>滑动窗口的介绍：</p>
</blockquote>
<ul>
<li>TCP 以一个<code>段（segment）</code>为单位，每发送一个段就需要进行一次确认应答（ack）处理，但如果这么做，缺点是包的往返时间越长性能就越差</li>
</ul>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202306180041356.png" alt="image-20230618004100237" style="zoom:33%;"></p>
<ul>
<li>引入了窗口概念，<code>窗口大小</code>即<code>决定了无需等待应答而可以继续发送的数据最大值</code></li>
</ul>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202306180042940.png" alt="image-20230618004230838" style="zoom:33%;"></p>
<ul>
<li><p>窗口实际就起到一个<code>缓冲区</code>的作用，同时也能起到<code>流量控制</code>的作用</p>
<ul>
<li><p>图中深色的部分即要发送的数据，高亮的部分即窗口</p>
</li>
<li><p>窗口内的数据才允许被发送，当<code>应答</code>未到达前，窗口<code>必须停止滑动</code></p>
</li>
<li><p>如果 1001~2000 这个段的数据 ack 回来了，窗口就可以向前滑动</p>
</li>
<li><p>接收方也会维护一个窗口，只有落在窗口内的数据才能允许接收</p>
</li>
</ul>
</li>
</ul>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>短链接，发一个包建立一次连接，这样连接建立到连接断开之间就是消息的边界，<code>缺点</code>效率太低</li>
<li>每一条消息采用固定长度，<code>缺点</code>浪费空间</li>
<li>每一条消息采用分隔符，例如<code>\n</code>，<code>缺点</code>需要转义</li>
<li>每一条消息分为 <code>head</code> 和 <code>body</code>，<code>head</code> 中包含 <code>body</code> 的长度</li>
</ul>
<blockquote>
<p>短链接 —— 可以去解决<code>粘包</code>问题,但是难以解决<code>半包</code>问题,因为接收方的缓冲区大小是有限的</p>
</blockquote>
<p><strong>客户端</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 【使 每发完一次消息 就关闭一次 ，这样连接建立到连接断开之间就是消息的边界】</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer(<span class="number">16</span>);</span><br><span class="line">    buffer.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;);</span><br><span class="line">    ctx.writeAndFlush(buffer);</span><br><span class="line">    <span class="comment">// 使用短链接，每次发送完毕后就断开连接</span></span><br><span class="line">    ctx.channel().close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>服务端</strong></p>
<p>不再指定缓冲区大小： 即有<code>serverBootstrap.option(ChannelOption.SO_RCVBUF, 10);</code>的话就将其注释掉</p>
<blockquote>
<p>固定长度:<code>定长解码器</code></p>
<ul>
<li><code>缺点</code>是，数据包的大小不好把握<ul>
<li>长度定的太大，浪费</li>
<li>长度定的太小，对某些数据包又显得不够</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>让所有数据包长度固定（假设长度为 8 字节）</li>
</ul>
<p><strong>服务器端</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">FixedLengthFrameDecoder</span>(<span class="number">8</span>));     <span class="comment">//可以查看 源码： FixedLengthFrameDecoder</span></span><br></pre></td></tr></table></figure>
<p><strong>客户端</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 约定最大长度为16</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 被发送的数据</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="comment">// 向服务器发送10个报文</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer(maxLength);</span><br><span class="line">    <span class="comment">// 定长byte数组，未使用部分会以0进行填充</span></span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[maxLength];</span><br><span class="line">    <span class="comment">// 生成长度为0~15的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; (<span class="type">int</span>)(Math.random()*(maxLength-<span class="number">1</span>)); j++) &#123;</span><br><span class="line">        bytes[j] = (<span class="type">byte</span>) c;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer.writeBytes(bytes);</span><br><span class="line">    c++;</span><br><span class="line">    <span class="comment">// 将数据发送给服务器</span></span><br><span class="line">    ctx.writeAndFlush(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 固定分隔符</p>
<ul>
<li>可以通过<code>LineBasedFrameDecoder(int maxLength)</code>来拆分以<strong>换行符(\n)</strong>为分隔符的数据，也可以通过<code>DelimiterBasedFrameDecoder(int maxFrameLength, ByteBuf... delimiters)</code>来<strong>指定通过什么分隔符来拆分数据（可以传入多个分隔符）</strong></li>
<li><p>两种解码器<strong>都需要传入数据的最大长度</strong>，若超出最大长度，会抛出<code>TooLongFrameException</code>异常</p>
</li>
<li><p>缺点，处理字符数据比较合适，但如果内容本身包含了分隔符（字节数据常常会有此情况），那么就会解析错误</p>
</li>
</ul>
</blockquote>
<p><strong>服务端</strong></p>
<ul>
<li>默认以<code>\n</code> 或<code>\r\n</code> 作为分隔符，如果超出指定长度仍未出现分隔符，则抛出异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LineBasedFrameDecoder</span>(<span class="number">1024</span>)); <span class="comment">// 超出1024报错</span></span><br></pre></td></tr></table></figure>
<p><strong>客户端</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title function_">getStr</span><span class="params">(<span class="type">char</span> c, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(len + <span class="number">2</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">           s.append(c);</span><br><span class="line">       &#125;</span><br><span class="line">       s.append(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">       <span class="keyword">return</span> s;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">         log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">         <span class="keyword">final</span> <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">         <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">         <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">final</span> <span class="type">StringBuilder</span> <span class="variable">tmpStr</span> <span class="operator">=</span> getStr(c, r.nextInt(<span class="number">256</span>) + <span class="number">1</span>); <span class="comment">// 随机生成 1-257 长度的 字符串</span></span><br><span class="line">         c++;</span><br><span class="line">          buf.writeBytes(tmpStr.toString().getBytes());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ctx.writeAndFlush(buf);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 自定义定界符 帧解码器</p>
</blockquote>
<p><strong>服务端</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将分隔符放入ByteBuf中</span></span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">bufSet</span> <span class="operator">=</span> ch.alloc().buffer().writeBytes(<span class="string">&quot;\\c&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line"><span class="comment">// 通过行解码器对粘包数据进行拆分，以 \c 为分隔符</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">DelimiterBasedFrameDecoder</span>(<span class="number">64</span>, ch.alloc().buffer().writeBytes(bufSet)));</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br></pre></td></tr></table></figure>
<p><strong>客户端</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 数据以 \c 结尾</span></span><br><span class="line">sb.append(<span class="string">&quot;\\c&quot;</span>);</span><br><span class="line">buffer.writeBytes(sb.toString().getBytes(StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>预设长度:</p>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202306180425682.png" alt="image-20230618042512634" style="zoom:33%;"></p>
<p><code>源码： LengthFieldBasedFrameDecoder.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LengthFieldBasedFrameDecoder(</span><br><span class="line">        <span class="type">int</span> maxFrameLength,     <span class="comment">//限制最大长度，超过他 没找到分隔符报错</span></span><br><span class="line">        <span class="type">int</span> lengthFieldOffset,  <span class="comment">//长度字段 的 偏移量</span></span><br><span class="line">        <span class="type">int</span> lengthFieldLength,  <span class="comment">//长度字段 本身长度</span></span><br><span class="line">        <span class="type">int</span> lengthAdjustment,   <span class="comment">//长度字段 为基准，跳过几个字节 才是内容</span></span><br><span class="line">        <span class="type">int</span> initialBytesToStrip <span class="comment">//从头剥离 几个字节，解析后将不出现</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>服务端</strong></p>
<ul>
<li>在发送消息前，先约定用<code>定长字节</code>表示接下来数据的长度</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">										<span class="comment">// 最大长度，长度偏移，长度占用字节，长度调整，剥离字节数</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecoder</span>(<span class="number">1024</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">7</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(ByteBuf buf, String s)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] bytes = s.getBytes();        <span class="comment">// 实际内容</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> bytes.length;    <span class="comment">// 实际内容长度</span></span><br><span class="line">        <span class="comment">// 指定长度 和 存储模式为： 大端模式  【writeInt本身长度 4字节】 【服务端 lengthFieldLength设为4】</span></span><br><span class="line">        buf.writeInt(length);</span><br><span class="line">        <span class="comment">// 版本号 100，  【服务端 lengthAdjustment 设为 3】 【注意：如果设0 会报错(除非主体内容最后四位都是0)】</span></span><br><span class="line">        buf.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>&#125;);</span><br><span class="line">        buf.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>完整代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLengthFieldDecoder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*###############################*/</span></span><br><span class="line">        <span class="comment">/*###       当成 服务器端       ###*/</span></span><br><span class="line">        <span class="comment">/*###############################*/</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">EmbeddedChannel</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmbeddedChannel</span>(</span><br><span class="line">                <span class="comment">// 注意：解码器 放debug上面</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecoder</span>(</span><br><span class="line">                        <span class="number">1024</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG)</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*###############################*/</span></span><br><span class="line">        <span class="comment">/*###       当成 客户端        ###*/</span></span><br><span class="line">        <span class="comment">/*###############################*/</span></span><br><span class="line">        <span class="comment">// 指定：长度字段-4字节；</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line">        send(buf, <span class="string">&quot;hello, world&quot;</span>);</span><br><span class="line">        send(buf, <span class="string">&quot;hi&quot;</span>);</span><br><span class="line">        <span class="comment">// 将消息 写入 Channel</span></span><br><span class="line">        ch.writeInbound(buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(ByteBuf buf, String s)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] bytes = s.getBytes();        <span class="comment">// 实际内容</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> bytes.length;    <span class="comment">// 实际内容长度</span></span><br><span class="line">        <span class="comment">// 指定长度 和 存储模式为： 大端模式  【writeInt本身长度 4字节】 【服务端 lengthFieldLength设为4】</span></span><br><span class="line">        buf.writeInt(length);</span><br><span class="line">        <span class="comment">// 版本号 100，  【服务端 lengthAdjustment 设为 3】 【注意：如果设0 会报错(除非主体内容最后四位都是0)】</span></span><br><span class="line">        buf.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>&#125;);</span><br><span class="line">        buf.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="协议设计与解析"><a href="#协议设计与解析" class="headerlink" title="协议设计与解析"></a>协议设计与解析</h3><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><ul>
<li><p>重要性</p>
<ul>
<li><p><code>TCP/IP</code> 中消息传输基于流的方式，没有边界。</p>
</li>
<li><p>协议的<code>目的</code>就是划定消息的边界，制定通信双方要共同遵守的通信规则</p>
</li>
</ul>
</li>
<li><p>如何设计协议</p>
<ul>
<li><code>定长字节  表示内容长度   +   实际内容</code></li>
</ul>
</li>
</ul>
<h4 id="Redis协议"><a href="#Redis协议" class="headerlink" title="Redis协议"></a>Redis协议</h4><p>就是 向Redis服务器发送一条<code>set name Nyima</code>的指令，需要遵守协议符合一定的格式才可以</p>
<h4 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议"></a>Http协议</h4><ul>
<li><p>HTTP协议在请求行请求头中都有很多的内容，可以使用<code>HttpServerCodec</code>作为<strong>服务器端的解码器与编码器，来处理HTTP请求</strong></p>
<ul>
<li>代码中添加：<code>ch.pipeline().addLast(new HttpServerCodec());</code></li>
</ul>
</li>
<li><p>服务器负责处理请求并响应浏览器。所以<strong>只需要处理HTTP请求</strong>即可</p>
<ul>
<li>代码中添加：<code>ch.pipeline().addLast(new SimpleChannelInboundHandler&lt;HttpRequest&gt;() //服务器只处理HTTPRequest</code></li>
</ul>
</li>
<li><p>获得请求后，需要返回响应给浏览器。需要创建响应对象<code>DefaultFullHttpResponse</code>，设置HTTP版本号及状态码，为避免浏览器获得响应后，因为获得<code>CONTENT_LENGTH</code>而一直空转，需要添加<code>CONTENT_LENGTH</code>字段，表明响应体中数据的<code>具体长度</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得完整响应，设置版本号与状态码</span></span><br><span class="line"><span class="type">DefaultFullHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultFullHttpResponse</span>(msg.protocolVersion(), HttpResponseStatus.OK);</span><br><span class="line"><span class="comment">// 设置响应内容</span></span><br><span class="line"><span class="type">byte</span>[] bytes = <span class="string">&quot;&lt;h1&gt;Hello, World!&lt;/h1&gt;&quot;</span>.getBytes(StandardCharsets.UTF_8);</span><br><span class="line"><span class="comment">// 设置响应体长度，避免浏览器一直接收响应内容</span></span><br><span class="line">response.headers().setInt(CONTENT_LENGTH, bytes.length);</span><br><span class="line"><span class="comment">// 设置响应体</span></span><br><span class="line">response.content().writeBytes(bytes);</span><br></pre></td></tr></table></figure>
<h4 id="自定义协议"><a href="#自定义协议" class="headerlink" title="自定义协议"></a>自定义协议</h4><ul>
<li>要素<ul>
<li><code>魔数</code>，用来在第一时间判定是否是无效数据包</li>
<li><code>版本号</code>，可以支持协议的升级</li>
<li><code>序列化算法</code>，消息正文到底采用哪种序列化反序列化方式，可以由此扩展，例如：json、protobuf、hessian、jdk</li>
<li><code>指令类型</code>，是登录、注册、单聊、群聊… 跟业务相关</li>
<li><code>请求序号</code>，为了双工通信，提供异步能力</li>
<li><code>正文长度</code></li>
<li><code>消息正文</code></li>
</ul>
</li>
</ul>
<h4 id="什么时候可以加-Sharable"><a href="#什么时候可以加-Sharable" class="headerlink" title="什么时候可以加 @Sharable"></a>什么时候可以加 @Sharable</h4><blockquote>
<p>就是说什么时候应该让<code>handler</code>可以<code>共享使用</code></p>
</blockquote>
<ul>
<li>当 <code>handler</code> 不保存状态时，就可以<code>安全地在多线程下被共享</code></li>
<li>但要注意对于<code>编解码器类</code>，不能继承 <code>ByteToMessageCodec</code> 或 <code>CombinedChannelDuplexHandler</code> 父类，他们的构造方法对<code>@Sharable</code> 有限制</li>
<li>如果能确保编解码器<code>不会保存状态</code>的时候，就可以继承 <code>MessageToMessageCodec</code> 父类</li>
</ul>
<blockquote>
<p> 源码上中添加<code>@Sharable</code>  就是可以共享使用的，创建的时候只要创建一个实例就可以了</p>
</blockquote>
<h2 id="强化"><a href="#强化" class="headerlink" title="强化"></a>强化</h2><h3 id="聊天室"><a href="#聊天室" class="headerlink" title="聊天室"></a>聊天室</h3><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><ul>
<li><p>客户端</p>
<ul>
<li><font color="blue">1.</font>将与业务无关的代码先准备好，并在<code>pipline</code>中加入三个 <code>handler</code>   ，分别是：<code>处理半包的，打印日志的，对发送的消息编解码的 handler</code></li>
<li><font color="blue">2.</font>加上处理器<code>ChannelInboundHandlerAdapter</code>  重写 <code>channelActive</code> &lt;关心连接建立事件&gt;，并在该方法中新启一个线程，接受用户的登录消息(密码，用户名)，并将输入构造成一个<code>LoginRequestMessage 的消息对象</code>发送到<code>服务端</code>上</li>
<li><font color="blue">5.</font>重写<code>channelRead()</code> 的方法，获取到<code>服务器</code>传来的结果</li>
<li><font color="blue">6.</font> 使用<code>CountDownLatch</code>的进行设置倒计时锁，实现在线程之间通信【发送的<code>channelActive</code>方法使用<code>await()</code> 方法进行等待,这个方法有一个<code>新启的线程</code>； 接受的<code>channelRead()</code>方法使用<code>countDown()</code>方法进行唤醒<code>新启的线程</code>；这个方法的线程是一个<code>NIO</code>线程 】，设置倒计时锁的初始基数为1，直到<code>减为零</code>才继续往下运行，否则等待  【倒计时锁的两个方法：<code>countDown()</code>  倒计时<code>-1</code> ，唤醒新的线程；<code>await()</code> 进行等待被唤醒】</li>
<li><font color="blue">7.</font> 使用<code>AtomicBoolean</code> 设定变量表示 线程的<code>登录状态</code></li>
<li><font color="blue">8.</font> 在<code>channelRead</code>中接受并处理登录传来的消息是不是<code>success</code>的，是的话就登录状态设置为<code>true</code>，随后在<code>channelRead</code>方法中使用<code>countDown()</code>方法唤醒<code>新启的线程</code></li>
<li><font color="blue">9.</font> <code>channelActive()</code>中判断如果<code>登录失败</code>的话就应该关闭<code>新启的线程</code>的连接，停止运行，退出整个客户端;；如果<code>登录成功</code>的话执行后续流程</li>
<li><font color="blue">10.</font>在后续的流程中，有控制台进行输入<code>Scanner()</code>,并对输入的值进行<code>swictch...case</code> 的判断解析得到对应的处理方式（这里写了很多的<code>XXXmessage</code>的类进行解析<code>message</code>）</li>
<li><font color="blue">17.</font><code>假死连接</code><ul>
<li>同样的在客户端也要加上<code>IdleStateHandler</code>空闲状态检测器判断<code>假死连接</code></li>
<li>判断指定时间要是<code>没有向服务器</code>写数据，就会触发一个<code>WRITER_IDLE</code>的事件,自主发送指定的<code>心跳消息包</code>(就是<code>一般自定义的消息</code>)</li>
</ul>
</li>
</ul>
</li>
<li><p>服务端</p>
<ul>
<li><font color="blue">3.</font>服务端同样的可以在<code>pipline</code>中加入三个 <code>handler</code>   ，分别是：<code>处理半包的，打印日志的，对发送的消息编解码的 handler</code></li>
<li><font color="blue">4.</font>《登录功能》<ul>
<li>添加<code>SimpleChannelInboundHandler</code>  对接受的信息<code>LoginRequestMessage</code>进行处理，重写<code>channelRead0()</code>的方法获取到传过来的<code>密码和用户名</code>，并判断是否成功获取到用户的信息，并做相应的处理，返回结果给客户端</li>
</ul>
</li>
<li><font color="blue">11.</font>通过用户会话管理器进行绑定<code>channel</code> 和<code>username</code></li>
<li><font color="blue">12.</font>  《单聊——聊天功能》<ul>
<li>简单的定义<code>事件的处理器ChatRequestMessageHandler</code>  并加入到<code>pipline</code>中<ul>
<li>思路就是获取<code>msg 就是 用户名</code>   并通过会话管理器将得到对应<code>msg</code>的<code>channel</code> ,<ul>
<li><code>channel</code>如果不是<code>null</code> ，就进行发送消息</li>
<li>否则发送失败</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>此时测试的时候要启动多个<code>Client</code></p>
</blockquote>
<ul>
<li><font color="blue">13.</font>《群聊——创建群聊组》<ul>
<li>简单的定义<code>事件的处理器XXXMessageHandler</code>  并加入到<code>pipline</code>中，具体思路和上面的类似</li>
<li>简单的定义<code>事件的处理器GroupCreateRequestMessageHandler</code>  并加入到<code>pipline</code>中<ul>
<li>定义类<code>GroupCreateRequestMessageHandler</code>的逻辑<ul>
<li>群管理器创建聊天组<ul>
<li>判断聊天组是否存在，不存在创建成功，并向所有发送组成员发送拉群消息；否则创建失败</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><font color="blue">14. </font>《群聊——聊天功能》</p>
<ul>
<li>根据组名得到所有组员姓名及对应的绑定的<code>channel</code>，并经过<code>channel</code>发送信息给对应的组员</li>
</ul>
</li>
<li><p><font color="blue">15.</font>《处理退出》</p>
<ul>
<li><code>QuitHandler</code><ul>
<li>当连接断开时触发 <code>inactive</code> 事件<ul>
<li>取消<code>username</code>绑定 的 <code>channel</code></li>
</ul>
</li>
<li>当出现异常时触发<ul>
<li>取消<code>username</code>绑定 的 <code>channel</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><font color="blue">16.</font>假死连接<ul>
<li>解决：判断但是不是读空闲或者写空闲时间过长，<code>IdleStateHandler</code> 空闲状态检测器判断<code>假死连接</code></li>
<li>可以通过设置处理器中的<code>IdleStateHandler</code>中的参数指定时间进行判断是否没有收到<code>channel</code>的数据，没有的话会触发该处理器的<code>Read_IDLE</code>事件</li>
<li>向<code>pipeline</code>中加上<code>ChannelDuplexHandler</code>处理器，其可以同时作为出站和入站处理器，可以用来处理出发特殊的事件<ul>
<li>处理<code>读空闲</code>的事件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<h4 id="连接假死"><a href="#连接假死" class="headerlink" title="连接假死"></a>连接假死</h4><p>原因</p>
<ul>
<li>网络设备出现故障，例如网卡，机房等，底层的 TCP 连接已经断开了，但应用程序没有感知到，仍然占用着资源。</li>
<li>公网网络不稳定，出现丢包。如果连续出现丢包，这时现象就是客户端数据发不出去，服务端也一直收不到数据，就这么一直耗着</li>
<li>应用程序线程阻塞，无法进行数据读写</li>
</ul>
<p>问题</p>
<ul>
<li>假死的连接占用的资源不能自动释放</li>
<li>向假死的连接发送数据，得到的反馈是发送超时</li>
</ul>
<p>服务器端解决</p>
<ul>
<li>如果能收到客户端数据，说明没有假死。因此策略就可以定为，每隔一段时间就检查这段时间内是否接收到客户端数据，没有就可以判定为连接假死</li>
</ul>
<p>客户端定时心跳</p>
<ul>
<li>客户端可以定时向服务器端发送数据，只要这个时间间隔小于服务器定义的空闲检测的时间间隔，那么就能防止前面提到的误判，客户端可以定义如下心跳处理器</li>
</ul>
</blockquote>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="序列化算法"><a href="#序列化算法" class="headerlink" title="序列化算法"></a>序列化算法</h3><p>序列化，反序列化主要用在消息正文的转换上</p>
<ul>
<li><code>序列化时</code>，需要将 Java 对象变为要传输的数据（可以是 byte[]，或 json 等， <code>最终</code>都需要变成 <code>byte[]</code>）</li>
<li><code>反序列化时</code>，需要将传入的正文数据<code>还原成</code> Java 对象，便于处理</li>
</ul>
<ul>
<li><p>目前的代码仅支持 <code>Java</code> 自带的序列化，反序列化机制</p>
</li>
<li><p>为了支持更多序列化算法，可以将所有的序列化算法抽象成一个 <code>Serializer</code> 接口</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line">    <span class="comment">// 反序列化方法</span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span>;</span><br><span class="line">    <span class="comment">// 序列化方法</span></span><br><span class="line">    &lt;T&gt; <span class="type">byte</span>[] serialize(T object);</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Algorithm</span> <span class="keyword">implements</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line">        Java &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes));</span><br><span class="line">                    <span class="keyword">return</span> (T) ois.readObject();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;反序列化失败&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T object) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">                    <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">                    oos.writeObject(object);</span><br><span class="line">                    <span class="keyword">return</span> bos.toByteArray();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;序列化失败&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        Json &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">                <span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GsonBuilder</span>().registerTypeAdapter(Class.class, <span class="keyword">new</span> <span class="title class_">Serializer</span>.ClassCodec()).create();</span><br><span class="line">                <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, StandardCharsets.UTF_8);</span><br><span class="line">                <span class="keyword">return</span> gson.fromJson(json, clazz);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T object) &#123;</span><br><span class="line">                <span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GsonBuilder</span>().registerTypeAdapter(Class.class, <span class="keyword">new</span> <span class="title class_">Serializer</span>.ClassCodec()).create();</span><br><span class="line">                <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> gson.toJson(object);</span><br><span class="line">                <span class="keyword">return</span> json.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ClassCodec</span> <span class="keyword">implements</span> <span class="title class_">JsonSerializer</span>&lt;Class&lt;?&gt;&gt;, JsonDeserializer&lt;Class&lt;?&gt;&gt; &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) <span class="keyword">throws</span> JsonParseException &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> json.getAsString();</span><br><span class="line">                <span class="keyword">return</span> Class.forName(str);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JsonParseException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span>             <span class="comment">//   String.class</span></span><br><span class="line">        <span class="keyword">public</span> JsonElement <span class="title function_">serialize</span><span class="params">(Class&lt;?&gt; src, Type typeOfSrc, JsonSerializationContext context)</span> &#123;</span><br><span class="line">            <span class="comment">// class -&gt; json</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonPrimitive</span>(src.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参数调优"><a href="#参数调优" class="headerlink" title="参数调优"></a>参数调优</h3><ol>
<li><p><code>CONNECT_TIMEOUT_MILLIS</code></p>
<ul>
<li><p>属于 <code>SocketChannal</code> 参数</p>
</li>
<li><p>用在<code>客户端</code>建立连接时，如果在指定毫秒内无法连接，会抛出 <code>timeout</code> 异常</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Boostrap</span>().option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="number">300</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：<ul>
<li><code>客户端</code>： 通过<code>.option()</code>方法配置参数 给 <code>SocketChannel</code> 配置参数 (因为对于客户端来说就一个<code>Socket</code>)</li>
<li><code>服务端</code><br><code>new ServerBootstrap().option()</code>       // 给 <code>ServerSocketChannel</code> 配置参数<br><code>new ServerBootstrap().childHandler()</code> // 给 <code>SocketChannel</code> 配置参数</li>
</ul>
</li>
</ul>
</blockquote>
<ol>
<li><code>SO_BACKLOG</code><ul>
<li>属于 <code>ServerSocketChannal</code> 参数</li>
<li><code>SO_TIMEOUT</code>主要用在<code>阻塞 IO</code>，阻塞 IO 中 <code>accept</code>，<code>read</code> 等都是无限等待的，如果<code>不希望永远阻塞</code>，使用它<code>调整超时时间</code></li>
</ul>
</li>
</ol>
<blockquote>
<p>TCP的是<code>三次握手</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line"></span><br><span class="line">participant c as client</span><br><span class="line">participant s as server</span><br><span class="line">participant sq as syns queue&lt;半连接队列&gt;</span><br><span class="line">participant aq as accept queue&lt;全连接队列&gt;</span><br><span class="line"></span><br><span class="line">s -&gt;&gt; s : bind()</span><br><span class="line">s -&gt;&gt; s : listen()</span><br><span class="line">c -&gt;&gt; c : connect()</span><br><span class="line">c -&gt;&gt; s : 1. SYN</span><br><span class="line">Note left of c : SYN_SEND</span><br><span class="line">s -&gt;&gt; sq : put</span><br><span class="line">Note right of s : SYN_RCVD</span><br><span class="line">s -&gt;&gt; c : 2. SYN + ACK</span><br><span class="line">Note left of c : ESTABLISHED</span><br><span class="line">c -&gt;&gt; s : 3. ACK</span><br><span class="line">sq -&gt;&gt; aq : put</span><br><span class="line">Note right of s : ESTABLISHED</span><br><span class="line">aq --&gt;&gt; s : </span><br><span class="line">s -&gt;&gt; s : accept()</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>三次握手</code>详解</p>
<ol>
<li>第一次握手，client 发送 SYN 到 server，状态修改为 SYN_SEND，server 收到，状态改变为 SYN_REVD，并将该请求放入 sync queue 队列</li>
<li>第二次握手，server 回复 SYN + ACK 给 client，client 收到，状态改变为 ESTABLISHED，并发送 ACK 给 server</li>
<li>第三次握手，server 收到 ACK，状态改变为 ESTABLISHED，将该请求从 sync queue 放入 accept queue</li>
</ol>
<p>其中</p>
<ul>
<li><p>在 <code>linux 2.2</code> 之前，<code>backlog</code> 大小包括了<code>两个队列的大小</code>，在 <code>2.2 之后</code>，分别用下面<code>两个参数来控制</code></p>
</li>
<li><p><code>sync queue</code> - 半连接队列</p>
<ul>
<li>大小通过<code>/proc/sys/net/ipv4/tcp_max_syn_backlog</code> 指定，在 <code>syncookies</code> 启用的情况下，逻辑上没有最大值限制，这个设置便被忽略</li>
</ul>
</li>
<li><code>accept queue</code>- 全连接队列<ul>
<li>其大小通过<code>/proc/sys/net/core/somaxconn</code>指定，在使用 listen 函数时，内核会根据传入的 <code>backlog</code> 参数【程序中】与<code>系统参数</code>【配置文件】，取二者的较小值</li>
<li>如果 <code>accpet queue</code>队列满了，<code>server</code> 将发送一个拒绝连接的错误信息到 <code>client</code></li>
</ul>
</li>
</ul>
<p><code>Netty</code> :  可以通过  <code>option(ChannelOption.SO_BACKLOG, 值)</code>来设置大小</p>
</blockquote>
<ol>
<li><code>ulimit -n</code><ul>
<li>属于操作系统参数</li>
</ul>
</li>
</ol>
<ol>
<li><code>TCP_NODELAY</code><ul>
<li>属于 <code>SocketChannal</code> 参数</li>
<li>设置为<code>false</code> 表示开启了<code>Nagle</code>算法，建议设为<code>true</code></li>
</ul>
</li>
</ol>
<ol>
<li><p><code>SO_SNDBUF &amp; SO_RCVBUF</code>&lt;是发送缓冲区 &amp; 接受缓冲区，间接的影响到滑动窗口的大小；现在的<code>OS</code>会自动根据发送接收的双方设置大小&gt;</p>
<ul>
<li><p><code>SO_SNDBUF</code> 属于 <code>SocketChannal</code> 参数</p>
</li>
<li><p><code>SO_RCVBUF</code> 既可用于 <code>SocketChannal</code> 参数，也可以用于 <code>ServerSocketChannal</code> 参数（建议设置到 <code>ServerSocketChannal</code> 上）</p>
</li>
</ul>
</li>
</ol>
<ol>
<li><p><code>ALLOCATOR</code>==(<code>涉及源码</code>)==</p>
<ul>
<li><p>属于 <code>SocketChannal</code> 参数</p>
</li>
<li><p>用来分配 <code>ByteBuf， ctx.alloc()</code></p>
</li>
<li><code>alloc 创建的buf</code> 是一个池化的直接内存的，可以在<code>VM option</code>中进行设置<code>是否池化</code>，是否<code>直接内存还是堆内存</code></li>
</ul>
</li>
</ol>
<ol>
<li><p><code>RCVBUF_ALLOCATOR</code>==(<code>涉及源码</code>)==</p>
<ul>
<li><p>属于 <code>SocketChannal</code> 参数1</p>
</li>
<li><p>可以用来控制 <code>netty</code> 接收缓冲区大小</p>
</li>
<li><p>负责入站数据的分配，决定入站缓冲区的大小（并可动态调整），统一采用 direct 直接内存，具体池化还是非池化由 allocator 决定</p>
</li>
</ul>
</li>
</ol>
<h2 id="基于聊天的RPC"><a href="#基于聊天的RPC" class="headerlink" title="基于聊天的RPC"></a>基于聊天的RPC</h2><h4 id="实现消息通信的思路"><a href="#实现消息通信的思路" class="headerlink" title="实现消息通信的思路"></a>实现消息通信的思路</h4><p><strong>客户端</strong></p>
<ul>
<li><font color="blue">1.</font>向<code>pipline</code>中加上<code>粘包半包，日志，消息解码编码,RpcRequestMessageHandler</code>的处理器，随后建立与<code>服务端</code>的连接</li>
<li><font color="blue">2.</font>向服务端发送请求消息，该请求消息找到<code>pipline</code> 的所有出站处理器（<code>下-&gt; 上</code>），并发送数据<ul>
<li>使用<code>异步的回调方法  addListener()</code>处理发送失败的消息</li>
</ul>
</li>
<li><font color="blue">6.</font> 将 1.2. 步骤进行疯转，然后将<code>channel.closeFuture().sync();</code> 修改为<code>异步</code>的<code>channel.closeFuture().addListener(future -&gt; &#123;&#125;)</code></li>
<li><font color="blue">7.</font>获取唯一的 <code>channel</code> 对象，此处是要进行<code>双重检查锁</code>的单例模式的方式创建获取</li>
<li><p><font color="blue">8.</font> 创建代理类<code>getProxyService</code>，将发送的消息格式进行简化</p>
<ul>
<li><strong>发送消息：</strong>将方法调用转换为 <code>消息对象</code> 随后在再将消息对象<code>发送出去</code></li>
<li><font color="blue">10.</font><strong>接收消息：</strong> 准备一个空 <code>Promise</code> 对象，来异步的接收结果  ；调用<code>await()</code>等待 <code>promise</code> 结果<ul>
<li>接收成功：获取成功，拿到结果<code>getNow</code>，并返回</li>
<li>接受失败：抛出异常</li>
</ul>
</li>
</ul>
</li>
<li><p><font color="blue">9.</font> 在<code>RpcResponseMessageHandler</code>中定义接收结果的<code>promise</code>对象集合<code>ConcurrentHashMap&lt;&gt;()</code></p>
<ul>
<li>进行保护性编程：拿到 空的 <code>promise</code>，之后 随机进行销毁，减少集合中的<code>promise</code>对象</li>
<li><p><code>promise</code> 非空就表示获取到，否则抛出异常</p>
<ul>
<li><p>判断获取到的对象是否有值</p>
<ul>
<li>有：获取成功并取得该值</li>
<li>无 ：获取失败</li>
</ul>
</li>
<li><p>最后让上述<code>await()</code>结束等待</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>服务端</strong></p>
<ul>
<li><font color="blue">3.</font>同样的也要向<code>pipline</code>中加上<code>粘包半包，日志，消息解码编码,RpcResponseMessageHandler</code>的处理器</li>
<li><font color="blue">4.</font>随后拿到客户端传来的消息之后需要对接收的消息进行<code>入站的处理（就是上面的入站处理器）</code>（<code>上-&gt; 下</code></li>
<li><font color="blue">5.</font>最后交给请求的<code>Handler</code> ——<code>RpcRequestMessageHandler</code><ul>
<li><code>RpcRequestMessageHandler</code> 中的处理是;<code>远程调用方法主要是通过反射实现的</code><ul>
<li>拿到<code>rpc请求消息</code>之后，根据消息的接口得到真正调用的实现对象，找到要调用的方法，反射进行调用</li>
<li>将结果（<code>无论成功还是异常</code>）都将封装成<code>response</code>的对象，并通过<code>ctx</code> 进行返回,若有<strong>异常需要捕获，并放入响应消息中</strong></li>
<li>随后响应消息经过服务器端的<code>pipline</code> 的所有出站处理器（<code>下-&gt; 上</code>），并发送数据,最后交给客户端的<code>RPCHandler</code>——<code>RpcResponseMessageHandler</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://rycan.top">Ryang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://rycan.top/post/7d3cd9cc.html">http://rycan.top/post/7d3cd9cc.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://rycan.top" target="_blank">RyCanの学习手记</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Netty/">Netty</a></div><div class="post_share"><div class="social-share" data-image="/./img/5.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><!--.post-reward--><!--  .reward-button--><!--    i.fas.fa-qrcode--><!--    = ' ' + _p('donate')--><!--  .reward-main--><!--    ul.reward-all--><!--      each item in theme.reward.QR_code--><!--        - var clickTo = item.link ? item.link : item.img--><!--        li.reward-item--><!--          a(href=url_for(clickTo) target='_blank')--><!--            img.post-qr-code-img(src=url_for(item.img) alt=item.text)--><!--          .post-qr-code-desc=item.text--><link rel="stylesheet" href="/" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">打赏</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></button></div><audio id="coinAudio" src="https://npm.elemecdn.com/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer="defer" src="/"></script><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/2da05edf.html" title="JUC 学习合集"><img class="cover" src="/./img/6.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JUC 学习合集</div></div></a></div><div class="next-post pull-right"><a href="/post/4f46b5ba.html" title="Netty 学习(尚硅谷)"><img class="cover" src="/./img/6.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Netty 学习(尚硅谷)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/6d654720.html" title="Netty 学习(未学的源码)"><img class="cover" src="/./img/15.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-03</div><div class="title">Netty 学习(未学的源码)</div></div></a></div><div><a href="/post/4f46b5ba.html" title="Netty 学习(尚硅谷)"><img class="cover" src="/./img/6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-03</div><div class="title">Netty 学习(尚硅谷)</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Livere</span><span class="switch-btn"></span><span class="second-comment">Valine</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81ODY2MC8zNTEyMg=="></div></div><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#NIO"><span class="toc-number">1.</span> <span class="toc-text">NIO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6"><span class="toc-number">1.1.</span> <span class="toc-text">三大组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Channel"><span class="toc-number">1.1.1.</span> <span class="toc-text">1. Channel</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">文件编程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#FileChannel"><span class="toc-number">1.1.1.1.1.</span> <span class="toc-text">FileChannel</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Path"><span class="toc-number">1.1.1.1.2.</span> <span class="toc-text">Path</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Files"><span class="toc-number">1.1.1.1.3.</span> <span class="toc-text">Files</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Buffer"><span class="toc-number">1.1.2.</span> <span class="toc-text">2. Buffer</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ByteBuffer"><span class="toc-number">1.1.2.0.1.</span> <span class="toc-text">ByteBuffer</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Selector"><span class="toc-number">1.1.3.</span> <span class="toc-text">3. Selector</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%89%88%E6%9C%AC"><span class="toc-number">1.1.3.0.1.</span> <span class="toc-text">3.1 多线程版本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%89%88%E6%9C%AC"><span class="toc-number">1.1.3.0.2.</span> <span class="toc-text">3.2线程池版本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-Selector%E7%89%88%E6%9C%AC"><span class="toc-number">1.1.3.0.3.</span> <span class="toc-text">3.2 Selector版本</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-number">1.2.1.</span> <span class="toc-text">阻塞与非阻塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">多路复用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86-accept-%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.2.3.</span> <span class="toc-text">处理 accept 事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86-read-%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.2.4.</span> <span class="toc-text">处理 read 事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86-write-%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.2.5.</span> <span class="toc-text">处理 write 事件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E6%AC%A1%E6%80%A7%E6%97%A0%E6%B3%95%E5%86%99%E5%AE%8C%E4%BE%8B%E5%AD%90"><span class="toc-number">1.2.5.0.1.</span> <span class="toc-text">一次性无法写完例子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.2.6.</span> <span class="toc-text">多线程的优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP"><span class="toc-number">1.2.7.</span> <span class="toc-text">UDP</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#NIO-VS-BIO"><span class="toc-number">2.</span> <span class="toc-text">NIO VS BIO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Stream-VS-channel"><span class="toc-number">2.0.1.</span> <span class="toc-text">Stream VS channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.0.2.</span> <span class="toc-text">IO模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.0.3.</span> <span class="toc-text">零拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9FIO%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">2.0.3.0.1.</span> <span class="toc-text">传统IO的流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NIO%E4%BC%98%E5%8C%96%E4%B8%80"><span class="toc-number">2.0.3.0.2.</span> <span class="toc-text">NIO优化一</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NIO%E4%BC%98%E5%8C%96%E4%BA%8C"><span class="toc-number">2.0.3.0.3.</span> <span class="toc-text">NIO优化二</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NIO%E4%BC%98%E5%8C%96%E4%B8%89"><span class="toc-number">2.0.3.0.4.</span> <span class="toc-text">NIO优化三</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AIO"><span class="toc-number">3.</span> <span class="toc-text">AIO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6AIO"><span class="toc-number">3.0.0.1.</span> <span class="toc-text">文件AIO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9CAIO"><span class="toc-number">3.0.0.2.</span> <span class="toc-text">网络AIO</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Netty"><span class="toc-number">4.</span> <span class="toc-text">Netty</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A5%E9%97%A8"><span class="toc-number">4.1.</span> <span class="toc-text">入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">4.1.1.</span> <span class="toc-text">使用案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6"><span class="toc-number">4.1.2.</span> <span class="toc-text">组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#EventLoop"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">EventLoop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EventLoopGroup"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">EventLoopGroup</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#NioEventLoop-%E5%A4%84%E7%90%86-io-%E4%BA%8B%E4%BB%B6"><span class="toc-number">4.1.2.2.1.</span> <span class="toc-text">NioEventLoop 处理 io 事件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9B%B4%E6%8D%A2%E4%B8%8D%E5%90%8C%E7%9A%84handler"><span class="toc-number">4.1.2.2.2.</span> <span class="toc-text">更换不同的handler</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NioEventLoop%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1"><span class="toc-number">4.1.2.2.3.</span> <span class="toc-text">NioEventLoop处理任务</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Channel"><span class="toc-number">4.1.2.3.</span> <span class="toc-text">Channel</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ChannelFuture"><span class="toc-number">4.1.2.3.1.</span> <span class="toc-text">ChannelFuture</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CloseFuture"><span class="toc-number">4.1.2.3.2.</span> <span class="toc-text">CloseFuture</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%8F%90%E5%8D%87%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">4.1.2.3.3.</span> <span class="toc-text">异步提升的是什么</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Future-amp-Promise"><span class="toc-number">4.1.2.4.</span> <span class="toc-text">Future &amp; Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#JDK-FUTURE"><span class="toc-number">4.1.2.4.1.</span> <span class="toc-text">JDK FUTURE</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NETTY-FUTURE"><span class="toc-number">4.1.2.4.2.</span> <span class="toc-text">NETTY FUTURE</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NETTY-PROMISE"><span class="toc-number">4.1.2.4.3.</span> <span class="toc-text">NETTY PROMISE</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Handler-amp-Pipeline"><span class="toc-number">4.1.2.5.</span> <span class="toc-text">Handler &amp; Pipeline</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EmbeddedChannel"><span class="toc-number">4.1.2.6.</span> <span class="toc-text">EmbeddedChannel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ByteBuf"><span class="toc-number">4.1.2.7.</span> <span class="toc-text">ByteBuf</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-number">4.1.2.7.1.</span> <span class="toc-text">创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98-vs-%E5%A0%86%E5%86%85%E5%AD%98"><span class="toc-number">4.1.2.7.2.</span> <span class="toc-text">直接内存 vs 堆内存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B1%A0%E5%8C%96-vs-%E9%9D%9E%E6%B1%A0%E5%8C%96"><span class="toc-number">4.1.2.7.3.</span> <span class="toc-text">池化 vs 非池化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E6%88%90"><span class="toc-number">4.1.2.7.4.</span> <span class="toc-text">组成</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.2.7.5.</span> <span class="toc-text">方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ByteBuf-%E4%BC%98%E5%8A%BF"><span class="toc-number">4.1.2.8.</span> <span class="toc-text">ByteBuf 优势</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%80%9A%E4%BF%A1"><span class="toc-number">4.1.3.</span> <span class="toc-text">双向通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6"><span class="toc-number">4.2.</span> <span class="toc-text">进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%8F%E5%8C%85%E5%8D%8A%E5%8C%85"><span class="toc-number">4.2.1.</span> <span class="toc-text">黏包半包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%B0%E8%B1%A1%E5%A4%8D%E7%8E%B0"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">现象复现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B2%98%E5%8C%85"><span class="toc-number">4.2.1.1.1.</span> <span class="toc-text">粘包</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%8A%E5%8C%85"><span class="toc-number">4.2.1.1.2.</span> <span class="toc-text">半包</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%B0%E8%B1%A1%E5%88%86%E6%9E%90"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">现象分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">4.2.1.3.</span> <span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%A7%A3%E6%9E%90"><span class="toc-number">4.2.2.</span> <span class="toc-text">协议设计与解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">Redis协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Http%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.2.2.3.</span> <span class="toc-text">Http协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.2.2.4.</span> <span class="toc-text">自定义协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E5%8A%A0-Sharable"><span class="toc-number">4.2.2.5.</span> <span class="toc-text">什么时候可以加 @Sharable</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E5%8C%96"><span class="toc-number">4.3.</span> <span class="toc-text">强化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%8A%E5%A4%A9%E5%AE%A4"><span class="toc-number">4.3.1.</span> <span class="toc-text">聊天室</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">思路：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%81%87%E6%AD%BB"><span class="toc-number">4.3.1.2.</span> <span class="toc-text">连接假死</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-number">4.4.</span> <span class="toc-text">优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E7%AE%97%E6%B3%95"><span class="toc-number">4.4.1.</span> <span class="toc-text">序列化算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98"><span class="toc-number">4.4.2.</span> <span class="toc-text">参数调优</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%81%8A%E5%A4%A9%E7%9A%84RPC"><span class="toc-number">4.5.</span> <span class="toc-text">基于聊天的RPC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="toc-number">4.5.0.1.</span> <span class="toc-text">实现消息通信的思路</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By Ryang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><!--button#darkmode(type="button" title=_p('rightside.night_mode_title'))--><!--  i.fas.fa-adjust--><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"></svg><use id="modeicon" xlink:href="#icon-moon"></use></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();" rel="external nofollow noreferrer"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();" rel="external nofollow noreferrer"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();" rel="external nofollow noreferrer"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();" rel="external nofollow noreferrer"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();" rel="external nofollow noreferrer"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();" rel="external nofollow noreferrer"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();" rel="external nofollow noreferrer"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()" rel="external nofollow noreferrer"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()" rel="external nofollow noreferrer"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()" rel="external nofollow noreferrer"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()" rel="external nofollow noreferrer"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()" rel="external nofollow noreferrer"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()" rel="external nofollow noreferrer"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()" rel="external nofollow noreferrer"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()" rel="external nofollow noreferrer"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()" rel="external nofollow noreferrer"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();" rel="external nofollow noreferrer"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();" rel="external nofollow noreferrer"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();" rel="external nofollow noreferrer"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();" rel="external nofollow noreferrer"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.19/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !true) {
  if (true) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'Adx946D8MgrhiaHCsXZfLp1L-gzGzoHsz',
      appKey: 'rvkGzSypPhV7c8TIk5TAM8iy',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: {"2020":"dc709fac0d361370bcf0d36d32adb97df7c95824.png","tv_白眼":"c1d59f439e379ee50eef488bcb5e5378e5044ea4.png","tv_doge":"6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png","tv_坏笑":"1f0b87f731a671079842116e0991c91c2c88645a.png","tv_难过":"87f46748d3f142ebc6586ff58860d0e2fc8263ba.png","tv_生气":"26702dcafdab5e8225b43ffd23c94ac1ff932654.png","tv_委屈":"d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png","tv_斜眼笑":"911f987aa8bc1bee12d52aafe62bc41ef4474e6c.png","tv_呆":"fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png","tv_发怒":"34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png","tv_惊吓":"0d15c7e2ee58e935adc6a7193ee042388adc22af.png","tv_呕吐":"9f996894a39e282ccf5e66856af49483f81870f3.png","tv_思考":"90cf159733e558137ed20aa04d09964436f618a1.png","tv_微笑":"70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png","tv_疑问":"0793d949b18d7be716078349c202c15ff166f314.png","tv_大哭":"23269aeb35f99daee28dda129676f6e9ea87934f.png","tv_鼓掌":"1d21793f96ef4e6f48b23e53e3b9e42da833a0f6.png","tv_抠鼻":"c666f55e88d471e51bbd9fab9bb308110824a6eb.png","tv_亲亲":"a8111ad55953ef5e3be3327ef94eb4a39d535d06.png","tv_调皮":"b9c41de8e82dd7a8515ae5e3cb63e898bf245186.png","tv_笑哭":"1abc628f6d4f4caf9d0e7800878f4697abbc8273.png","tv_晕":"5443c22b4d07fb1907ccc610c8e6db254f2461b7.png","tv_点赞":"f85c354995bd99e28fc76c869bfe42ba6438eff4.png","tv_害羞":"a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png","tv_睡着":"8b196675b53af58264f383c50ad0945048290b33.png","tv_色":"61822c7e9aae5da76475e7892534545336b23a6f.png","tv_吐血":"09dd16a7aa59b77baa1155d47484409624470c77.png","tv_无奈":"ea8ed89ee9878f2fece2dda0ea8a5dbfe21b5751.png","tv_再见":"180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png","tv_流汗":"cead1c351ab8d79e9f369605beb90148db0fbed3.png","tv_偷笑":"bb690d4107620f1c15cff29509db529a73aee261.png","tv_抓狂":"fe31c08edad661d63762b04e17b8d5ae3c71a757.png","tv_黑人问号":"45821a01f51bc867da9edbaa2e070410819a95b2.png","tv_困":"241ee304e44c0af029adceb294399391e4737ef2.png","tv_打脸":"56ab10b624063e966bfcb76ea5dc4794d87dfd47.png","tv_闭嘴":"c9e990da7f6e93975e25fd8b70e2e290aa4086ef.png","tv_鄙视":"6e72339f346a692a495b123174b49e4e8e781303.png","tv_腼腆":"89712c0d4af73e67f89e35cbc518420380a7f6f4.png","tv_馋":"fc7e829b845c43c623c8b490ee3602b7f0e76a31.png","tv_可爱":"9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png","tv_发财":"34db290afd2963723c6eb3c4560667db7253a21a.png","tv_生病":"8b0ec90e6b86771092a498c54f09fc94621c1900.png","tv_流鼻血":"c32d39db2737f89b904ca32700d140a9241b0767.png","tv_尴尬":"7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png","tv_大佬":"093c1e2c490161aca397afc45573c877cdead616.png","tv_流泪":"7e71cde7858f0cd50d74b0264aa26db612a8a167.png","tv_冷漠":"b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png","tv_皱眉":"72ccad6679fea0d14cce648b4d818e09b8ffea2d.png","tv_鬼脸":"0ffbbddf8a94d124ca2f54b360bbc04feb6bbfea.png","tv_调侃":"4bc022533ef31544ca0d72c12c808cf4a1cce3e3.png","tv_目瞪口呆":"0b8cb81a68de5d5365212c99375e7ace3e7891b7.png","2233娘_大笑":"16b8794be990cefa6caeba4d901b934a227ee3b8.png","2233娘_疑问":"0b41f509351958dbb63d472fec0132d1bd03bd14.png","2233娘_吃惊":"d1628c43d35b1530c0504a643ff80b6189fa0a43.png","2233娘_汗":"247cd9df8cdf84b18368c21e3b2dd374e84c0927.png","2233娘_大哭":"476a2a60f6e337b8c0697a592e0aa82781f6b33b.png","2233娘_困惑":"714eeb4eae0d0933b4ff08b7df788b1982f6b940.png","2233娘_耶":"d7178e258a0efc969b65ccc2b1322fb235f5dff4.png","2233娘_怒":"f31953119c51b9748016440ac0b632f779929b37.png","2233娘_卖萌":"ea893aa25355de95ab4f03c2dad3f0c58d0c159e.png","2233娘_委屈":"d9d0bf9d358af8d5761093ec66d4e3f60d963a63.png","2233娘_郁闷":"485203fe7100f2c8fc40b2800a18fe20b35f2f1a.png","2233娘_第一":"3754ee6e5985bd0bd7dfb668981f2a8733398ebd.png","2233娘_喝水":"695bf5429472049b52c1e0de586f8a2511195a23.png","2233娘_吐魂":"e999af499edf38a91ca68b1a9d2f97042c1d6734.png","2233娘_无言":"fdb5870f32cfaf7949e0f88a13f6feba4a48b719.png","热词系列_增加":"142409b595982b8210b2958f3d340f3b47942645.png","热词系列_泪目":"bba3703ab90b7d16fe9dbcb85ed949db687f8331.png","热词系列_保护":"55f8f6445ca7c3170cdfc5b16036abf639ce9b57.png","热词系列_害怕":"d77e2de26da143249f0c0ad7a608c27152c985bf.png","热词系列_爱了爱了":"2a165b555ba20391316366c664ed7891883dc5aa.png","热词系列_问号":"c1d1e76c12180adc8558f47006fe0e7ded4154bb.png","热词系列_吹爆":"b528220f9c37256ed6a37f05bf118e44b08b81e5.png","热词系列_三连":"21f15fe11b7a84d2f2121c16dec50a4e4556f865.png","热词系列_可以":"e08543c71202b36c590094417fcfbb80c3506cd8.png","热词系列_打卡":"a9cf77c78e1b9b40aa3ed4862402fba008ee2f51.png","热词系列_妙啊":"0e98299d7decf5eaffad854977946075c3e91cb8.png","热词系列_这次一定":"a01ca28923daa7cc896c42f27deb4914e20dd572.png","热词系列_AWSL":"c37f88cf799f9badf9d84b7671dc3dd98c0fc0c2.png","热词系列_递话筒":"98e6950e39fbb4dd1c576042063ca632074070ba.png","热词系列_你细品":"535e00658e7e47966f154d3a167fa2365ebc4321.png","热词系列_咕咕":"d8065c2e7ce48c929317a94553499a46fecc262a.png","热词系列_标准结局":"3de98174b510cf7dc5fd1bd08c5d881065e79137.png","热词系列_危":"5cc6c3357c4df544dd8de9d5c5c0cec97c7c9a56.png","热词系列_张三":"255a938f39cea625032b6650036b31aa26c50a3c.png","热词系列_害":"cbe798a194612958537c5282fcca7c3bcd2aa15c.png","热词系列_我裂开了":"29bd57ec4e8952880fea6c9e47aee924e91f10c4.png","热词系列_有内味了":"7ca61680a905b5b6e2e335c630e725b648b03b4d.png","热词系列_猛男必看":"c97064450528a0e45c7e7c365a15fbb13fd61d8c.png","热词系列_奥力给":"c9b8683827ec6c00fea5327c9bec14f581cef2aa.png","热词系列_我哭了":"9e0b3877d649aaf6538fbdd3f937e240a9d808e4.png","热词系列_高产":"9db817cba4a7f4a42398f3b2ec7c0a8e0c247c42.png","热词系列_我酸了":"a8cbf3f6b8cd9377eeb15b9172f3cd683b2e4650.png","热词系列_真香":"e68497c775feaac1c3b1a6cd63a50cfb11b767c4.png","热词系列_我全都要":"d424d1ad8d14c1c9b8367842bc68c658b9229bc1.png","热词系列_神仙UP":"a49e0d0db1e7d35a0f7411be13208951ab448f03.png","热词系列_你币有了":"84820c2b147a8ca02f3c4006b63f76c6313cbfa0.png","热词系列_不愧是你":"9ff2e356797c57ee3b1675ade0883d2d2247be9b.png","热词系列_锤":"35668cc12ae25b9545420e4a85bf21a0bfc03e5d.png","热词系列_秀":"50782fbf5d9b7f48f9467b5c53932981e321eedc.png","热词系列_爷关更":"faad40c56447f1f8abcb4045c17ce159d113d1fd.png","热词系列_有生之年":"f41fdafe2d0fbb8e8bc1598d2cf37e355560103a.png","热词系列_镇站之宝":"24e7a6a6e6383c987215fb905e3ee070aca259b5.png","热词系列_我太男了":"a523f3e4c63e4db1232365765d0ec452f83be97e.png","热词系列_完结撒花":"ea9db62ff5bca8e069cd70c4233353a802835422.png","热词系列_大师球":"f30089248dd137c568edabcb07cf67e0f6e98cf3.png","热词系列_知识盲区":"ccc94600b321a28116081e49ecedaa4ee8728312.png","热词系列_“狼火”":"33ccd3617bfa89e9d1498b13b7542b63f163e5de.png","加油武汉":"eb966aaa5b690d3f9308a9f936f5b5a72a7f956b.png","口罩":"3ad2f66b151496d2a5fb0a8ea75f32265d778dd3.png","鸡腿":"c7860392815d345fa69c4f00ef18d67dccfbd574.png","微笑":"685612eadc33f6bc233776c6241813385844f182.png","笑":"81edf17314cea3b48674312b4364df44d5c01f17.png","呲牙":"b5a5898491944a4268360f2e7a84623149672eb6.png","OK":"4683fd9ffc925fa6423110979d7dcac5eda297f4.png","星星眼":"63c9d1a31c0da745b61cdb35e0ecb28635675db2.png","哦呼":"362bded07ea5434886271d23fa25f5d85d8af06c.png","嫌弃":"de4c0783aaa60ec03de0a2b90858927bfad7154b.png","喜欢":"8a10a4d73a89f665feff3d46ca56e83dc68f9eb8.png","酸了":"92b1c8cbceea3ae0e8e32253ea414783e8ba7806.png","大哭":"2caafee2e5db4db72104650d87810cc2c123fc86.png","害羞":"9d2ec4e1fbd6cb1b4d12d2bbbdd124ccb83ddfda.png","无语":"44667b7d9349957e903b1b62cb91fb9b13720f04.png","疑惑":"b7840db4b1f9f4726b7cb23c0972720c1698d661.png","调皮":"8290b7308325e3179d2154327c85640af1528617.png","喜极而泣":"485a7e0c01c2d70707daae53bee4a9e2e31ef1ed.png","奸笑":"bb84906573472f0a84cebad1e9000eb6164a6f5a.png","偷笑":"6c49d226e76c42cd8002abc47b3112bc5a92f66a.png","大笑":"ca94ad1c7e6dac895eb5b33b7836b634c614d1c0.png","阴险":"ba8d5f8e7d136d59aab52c40fd3b8a43419eb03c.png","捂脸":"6921bb43f0c634870b92f4a8ad41dada94a5296d.png","囧":"12e41d357a9807cc80ef1e1ed258127fcc791424.png","呆":"33ad6000d9f9f168a0976bc60937786f239e5d8c.png","抠鼻":"cb89184c97e3f6d50acfd7961c313ce50360d70f.png","惊喜":"0afecaf3a3499479af946f29749e1a6c285b6f65.png","惊讶":"f8e9a59cad52ae1a19622805696a35f0a0d853f3.png","笑哭":"c3043ba94babf824dea03ce500d0e73763bf4f40.png","妙啊":"b4cb77159d58614a9b787b91b1cd22a81f383535.png","doge":"bba7c12aa51fed0199c241465560dfc2714c593e.png","滑稽":"d15121545a99ac46774f1f4465b895fe2d1411c3.png","吃瓜":"4191ce3c44c2b3df8fd97c33f85d3ab15f4f3c84.png","打call":"431432c43da3ee5aab5b0e4f8931953e649e9975.png","点赞":"1a67265993913f4c35d15a6028a30724e83e7d35.png","鼓掌":"895d1fc616b4b6c830cf96012880818c0e1de00d.png","尴尬":"cb321684ed5ce6eacdc2699092ab8fe7679e4fda.png","冷":"cb0ebbd0668640f07ebfc0e03f7a18a8cd00b4ed.png","灵魂出窍":"43d3db7d97343c01b47e22cfabeca84b4251f35a.png","委屈":"d2f26cbdd6c96960320af03f5514c5b524990840.png","傲娇":"010540d0f61220a0db4922e4a679a1d8eca94f4e.png","疼":"905fd9a99ec316e353b9bd4ecd49a5f0a301eabf.png","吓":"9c10c5ebc7bef27ec641b8a1877674e0c65fea5d.png","生病":"0f25ce04ae1d7baf98650986454c634f6612cb76.png","吐":"06946bfe71ac48a6078a0b662181bb5cad09decc.png","嘘声":"e64af664d20716e090f10411496998095f62f844.png","捂眼":"c5c6d6982e1e53e478daae554b239f2b227b172b.png","思考":"cfa9b7e89e4bfe04bbcd34ccb1b0df37f4fa905c.png","再见":"fc510306bae26c9aec7e287cdf201ded27b065b9.png","翻白眼":"eba54707c7168925b18f6f8b1f48d532fe08c2b1.png","哈欠":"888d877729cbec444ddbd1cf4c9af155a7a06086.png","奋斗":"bb2060c15dba7d3fd731c35079d1617f1afe3376.png","墨镜":"3a03aebfc06339d86a68c2d893303b46f4b85771.png","撇嘴":"531863568e5668c5ac181d395508a0eeb1f0cda4.png","难过":"a651db36701610aa70a781fa98c07c9789b11543.png","抓狂":"4c87afff88c22439c45b79e9d2035d21d5622eba.png","生气":"3195714219c4b582a4fb02033dd1519913d0246d.png","干杯":"8da12d5f55a2c7e9778dcc05b40571979fe208e6.png","爱心":"ed04066ea7124106d17ffcaf75600700e5442f5c.png","锦鲤":"643d6c19c8164ffd89e3e9cdf093cf5d773d979c.png","胜利":"b49fa9f4b1e7c3477918153b82c60b114d87347c.png","加油":"c7aaeacb21e107292d3bb053e5abde4a4459ed30.png","保佑":"fafe8d3de0dc139ebe995491d2dac458a865fb30.png","抱拳":"89516218158dbea18ab78e8873060bf95d33bbbe.png","响指":"1b5c53cf14336903e1d2ae3527ca380a1256a077.png","支持":"3c210366a5585706c09d4c686a9d942b39feeb50.png","拥抱":"41780a4254750cdaaccb20735730a36044e98ef3.png","怪我咯":"07cc6077f7f7d75b8d2c722dd9d9828a9fb9e46d.png","跪了":"f2b3aee7e521de7799d4e3aa379b01be032698ac.png","黑洞":"e90ec4c799010f25391179118ccd9f66b3b279ba.png","老鼠":"8e6fb491eb1bb0d5862e7ec8ccf9a3da12b6c155.png","福到了":"5de5373d354c373cf1617b6b836f3a8d53c5a655.png"},
      path: window.location.pathname,
      // master: '8a517fba7c520dddace09b926c0775c3',   //博主邮箱md5加密32位小写
      // tagMeta: ["博主", "小伙伴", "访客"],     //标识字段名
      // friends: [],  //小伙伴邮箱Md5
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdnjs.cloudflare.com/ajax/libs/valine/1.5.1/Valine.min.js').then(initValine)
}

if ('Livere' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="/js/sun_moon.js" async></script><script async src="/js/charts.js"></script><script async src="//at.alicdn.com/t/c/font_4146777_2b7ofuf0dew.js"></script><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/cat.js"></script><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async data-pjax src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.6.0/jquery.min.js" type="application/javascript"></script><script src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><script src="/js/newYear.js"></script><script async data-pjax src="/js/newYear.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script defer src="/js/lunar.js"></script><script defer src="/js/day.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><div id="fps"></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><div class="aplayer no-destroy" data-id="3136179094" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/gh/xiabo2/CDN@latest/fishes.js"></script><script defer src="https://cdn.jsdelivr.net/combine/npm/jquery@latest/dist/jquery.min.js,gh/weilining/jsdelivr/jquery/circlemagic/circlemagic.min.js,gh/weilining/jsdelivr@latest/jquery/circlemagic/butterflycirclemagic.js"></script><script src="https://cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script><div><canvas id="snow" style="position:fixed;top:0;left:0;width:100%;height:100%;z-index:99999;pointer-events:none"></canvas></div><script>const notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));</script><script async type="text/javascript" src="https://cdn.jsdelivr.net/gh/Candinya/Kratos-Rebirth@latest/source/js/snow.min.js"></script><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/rightMenu.js"></script><script defer src="https://rmt.dogedoge.com/fetch/~/source/jsdelivr/npm/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="https://cdn.jsdelivr.net/gh/sirxemic/jquery.ripples/dist/jquery.ripples.js"></script><script defer data-pjax src="/js/ripples.js"></script><script src="/js/yinghua.js"></script><script src="/js/fengye.js"></script><script src="/js/emoji.js"></script><script defer src="https://cdn.jsdelivr.net/gh/graingert/wow@1.3.0/dist/wow.min.js"></script><script defer data-pjax src="/js/wow_init.js"></script><script async src="/js/title.js"></script><script src="/js/visitor.js"></script><script src="/js/random.js"></script><script src="https://npm.elemecdn.com/vue@2.6.11"></script><script async src="/js/fps.js"></script><script src="https://unpkg.com/swiper/swiper-bundle.min.js"></script><script src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/js/main.js"></script><script src="/js/random.js"></script><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async data-pjax src="/js/txmap.js"></script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script src="/js/weather.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/canvas-nest.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"> <!--文章容器--> <div id="catalog_magnet">  <!--挂载容器--> <div class="magnet_item"><div style="display:flex;padding: 20px;font-size:16px;"><span style="font-weight:500;flex:1">中间件 (7)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></div><div class="magnet_item"><div style="display:flex;padding: 20px;font-size:16px;"><span style="font-weight:500;flex:1">框架 (12)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></div><div class="magnet_item"><div style="display:flex;padding: 20px;font-size:16px;"><span style="font-weight:500;flex:1">Java (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></div><div class="magnet_item"><div style="display:flex;padding: 20px;font-size:16px;"><span style="font-weight:500;flex:1">MySQL (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></div><div class="magnet_item"><div style="display:flex;padding: 20px;font-size:16px;"><span style="font-weight:500;flex:1">redis (8)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></div><div class="magnet_item"><div style="display:flex;padding: 20px;font-size:16px;"><span style="font-weight:500;flex:1">Future (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></div><div class="magnet_item"><div style="display:flex;padding: 20px;font-size:16px;"><span style="font-weight:500;flex:1">SpringCloud (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></div><div class="magnet_item" style="visibility: hidden"></div><a class="magnet_link_more"  href="http://rycan.top/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a> </div> </div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #5faee3;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #48c9b0}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>function history_calendar_injector_config(){
                var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
                var item_html = '<div class="card-widget card-history"><div class="card-content"><div class="item-headline"><i class="fas fa-clock fa-spin"></i><span>那年今日</span></div><div id="history-baidu" style="height: 100px;overflow: hidden"><div class="history_swiper-container" id="history-container" style="width: 100%;height: 100%"><div class="swiper-wrapper" id="history_container_wrapper" style="height:20px"></div></div></div></div>';
                console.log('已挂载history_calendar')
                // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
            }if( document.getElementsByClassName('sticky_layout')[0] && (location.pathname ==='/'|| '/' ==='all')){

            history_calendar_injector_config()
        } </script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/js/main.js"></script><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://img2.baidu.com/it/u=3745692040,3005247474&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=500);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/中间件/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">中间件</a><span class="categoryBar-list-count">7</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://img1.baidu.com/it/u=1341754829,1132645464&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=400&amp;h=400);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/框架/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">框架</a><span class="categoryBar-list-count">12</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://img0.baidu.com/it/u=2484535052,376615361&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=503&amp;h=500);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Java/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">Java</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://img0.baidu.com/it/u=3312661278,78172823&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=554);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/MySQL/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">MySQL</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://img2.baidu.com/it/u=1036154364,590128025&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=502);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/redis/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">redis</a><span class="categoryBar-list-count">8</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://img2.baidu.com/it/u=3063786176,3698143304&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=500);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Future/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">Future</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://img1.baidu.com/it/u=2409457391,176527849&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=500);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/SpringCloud/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">SpringCloud</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = 'e2b04289e870b005374ee030148d64fd&s=rsv3';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '112.982279,28.19409';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/c4fc293b.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt=""><img width="48" height="48" src="./img/10.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-07-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/c4fc293b.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt="">网站还没做的功能</a><div class="blog-slider__text">有空再说~</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/c4fc293b.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/16107.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt=""><img width="48" height="48" src="./img/1.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-06-21</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/16107.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt="">Hello World</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/16107.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/57317.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt=""><img width="48" height="48" src="./img/4.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-06-21</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/57317.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt="">b-草稿</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/57317.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '2');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 280px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/charts/'|| '/charts/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("https://gitcalendar.fomal.cc/api?YangruiY",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'YangruiY')
    }
  </script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>