<!-- - var pageType = is_post() ? 'post' : 'page'--><!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><div id="myscoll"></div><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java-语法 | 杨睿的学习手记</title><meta name="author" content="Ryang"><meta name="copyright" content="Ryang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="语法值得注意的点介绍">
<meta property="og:type" content="article">
<meta property="og:title" content="Java-语法">
<meta property="og:url" content="http://rycan.top/post/554bb3d.html">
<meta property="og:site_name" content="杨睿的学习手记">
<meta property="og:description" content="语法值得注意的点介绍">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://rycan.top/img/47.jpg">
<meta property="article:published_time" content="2023-07-03T12:49:36.000Z">
<meta property="article:modified_time" content="2023-07-04T12:38:10.300Z">
<meta property="article:author" content="Ryang">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://rycan.top/img/47.jpg"><link rel="shortcut icon" href="/img/"><link rel="canonical" href="http://rycan.top/post/554bb3d.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.19/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?https://hm.baidu.com/hm.js?d8e3a0b8a30b7b4c269ee5f0b81bda2d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"该文章创建于","messageNext":"前，请以最新文章为主"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Ryang","link":"链接: ","source":"来源: 杨睿的学习手记","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java-语法',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2023-07-04 20:38:10'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="//at.alicdn.com/t/font_2264842_b004iy0kk2b.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><script type="text/javascript" src="https://cdn1.tianlelectric_clock:i0.top/npm/jquery@latest/dist/jquery.min.js"></script><script type="text/javascript" src="/js/rightmenu.js"></script><span id="fps"></span><script type="text/javascript" src="https://unpkg.zhimg.com/jquery@latest/dist/jquery.min.js"></script><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><script src="https://npm.elemecdn.com/echarts@4.9.0/map/js/china.js"></script><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><link rel="stylesheet" href="/css/car.css"><link rel="stylesheet" href="/css/emoji.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/mainColor/heoMainColor.css"><link rel="stylesheet" type="text/css" href="/css/404.css"><script async src="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/categoryBar/categoryBar.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/categoryBar/categoryBar.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/mainColor/heoMainColor.css"><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="https://unpkg.com/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><link rel="stylesheet" href="/css/collections.css"><link rel="stylesheet" href="/css/modify.css"><link rel="stylesheet" href="/css/style.css"><script src="http://cdn.bootcss.com/pace/1.0.2/pace.min.js" async></script><link rel="stylesheet" href="/css/duotone.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhheo/JS-Heo@master/mainColor/heoMainColor.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhheo/JS-Heo@main/tag-link/tag-link.css"><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"></div><div class="carplay"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/13.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">76</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">46</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><hr class="custom-hr"/><!--if theme.menu--><!--  .menus_items--><!--    each value, label in theme.menu--><!--      if typeof value !== 'object'--><!--        .menus_item--><!--          - const valueArray = value.split('||')--><!--          a.site-page(href=url_for(trim(valueArray[0])))--><!--            if valueArray[1]--><!--              i.fa-fw(class=trim(valueArray[1]))--><!--            span=' '+label--><!--      else--><!--        .menus_item--><!--          - const labelArray = label.split('||')--><!--          - const hideClass = labelArray[2] && trim(labelArray[2]) === 'hide' ? 'hide' : ''--><!--          a.site-page.group(class=`${hideClass}` href='javascript:void(0);')--><!--            if labelArray[1]--><!--              i.fa-fw(class=trim(labelArray[1]))--><!--            span=' '+ trim(labelArray[0])--><!--            i.fas.fa-chevron-down--><!--          ul.menus_item_child--><!--            each val,lab in value--><!--              - const valArray = val.split('||')--><!--              li--><!--                a.site-page.child(href=url_for(trim(valArray[0])))--><!--                  if valArray[1]--><!--                    i.fa-fw(class=trim(valArray[1]))--><!--                  span=' '+ lab--><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-shouye"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shouye"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-shijianzhou"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shijianzhou"></use></svg><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover" href="javascript:void(0);" rel="external nofollow noreferrer"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shu"></use></svg><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-biaoqian"></use></svg><span> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenlei"></use></svg><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:randomPost();" rel="external nofollow noreferrer"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-suiji"></use></svg><span> 随机文章</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/MessageBoard/"><i class="fa-fw icon-liuyanzhi"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-liuyanzhi"></use></svg><span> 给我留言</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover" href="javascript:void(0);" rel="external nofollow noreferrer"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-yu"></use></svg><span> 摸鱼</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.4399.com/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youxi"></use></svg><span> 4399</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.bilibili.com/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili"></use></svg><span> B站</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener external nofollow noreferrer" href="https://y.qq.com/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-mianxingerji"></use></svg><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/camera/"><i class="fa-fw icon-tupian1"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-tupian1"></use></svg><span> 图床</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/charts/"><i class="fa-fw icon-tongjifenxi"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-tongjifenxi"></use></svg><span> 统计</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover" href="javascript:void(0);" rel="external nofollow noreferrer"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lianjie"></use></svg><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-pengyoufill"></use></svg><span> 友情链接</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guanyuwo"></use></svg><span> 关于我</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/47.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="杨睿的学习手记"></a></span><div id="he-plugin-simple"></div><div id="none_space"><span class="site-name">杨睿的学习手记</span></div><div id="menus"><div id="search-button"><!--a.site-page.social-icon.search(href="javascript:void(0);")--><!--  i.fas.fa-search.fa-fw--><a class="search faa-parent animated-hover" title="检索站内任何你想要的信息"><svg class="faa-tada icon" style="height:24px;width:24px;fill:currentColor;position:relative;top:6px" aria-hidden="true"><use xlink:href="#icon-sousuo"></use></svg><span> 搜索</span></a></div><!--if theme.menu--><!--  .menus_items--><!--    each value, label in theme.menu--><!--      if typeof value !== 'object'--><!--        .menus_item--><!--          - const valueArray = value.split('||')--><!--          a.site-page(href=url_for(trim(valueArray[0])))--><!--            if valueArray[1]--><!--              i.fa-fw(class=trim(valueArray[1]))--><!--            span=' '+label--><!--      else--><!--        .menus_item--><!--          - const labelArray = label.split('||')--><!--          - const hideClass = labelArray[2] && trim(labelArray[2]) === 'hide' ? 'hide' : ''--><!--          a.site-page.group(class=`${hideClass}` href='javascript:void(0);')--><!--            if labelArray[1]--><!--              i.fa-fw(class=trim(labelArray[1]))--><!--            span=' '+ trim(labelArray[0])--><!--            i.fas.fa-chevron-down--><!--          ul.menus_item_child--><!--            each val,lab in value--><!--              - const valArray = val.split('||')--><!--              li--><!--                a.site-page.child(href=url_for(trim(valArray[0])))--><!--                  if valArray[1]--><!--                    i.fa-fw(class=trim(valArray[1]))--><!--                  span=' '+ lab--><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-shouye"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shouye"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-shijianzhou"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shijianzhou"></use></svg><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover" href="javascript:void(0);" rel="external nofollow noreferrer"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shu"></use></svg><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-biaoqian"></use></svg><span> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenlei"></use></svg><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:randomPost();" rel="external nofollow noreferrer"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-suiji"></use></svg><span> 随机文章</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/MessageBoard/"><i class="fa-fw icon-liuyanzhi"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-liuyanzhi"></use></svg><span> 给我留言</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover" href="javascript:void(0);" rel="external nofollow noreferrer"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-yu"></use></svg><span> 摸鱼</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.4399.com/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youxi"></use></svg><span> 4399</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.bilibili.com/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili"></use></svg><span> B站</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener external nofollow noreferrer" href="https://y.qq.com/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-mianxingerji"></use></svg><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/camera/"><i class="fa-fw icon-tupian1"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-tupian1"></use></svg><span> 图床</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/charts/"><i class="fa-fw icon-tongjifenxi"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-tongjifenxi"></use></svg><span> 统计</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover" href="javascript:void(0);" rel="external nofollow noreferrer"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lianjie"></use></svg><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-pengyoufill"></use></svg><span> 友情链接</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guanyuwo"></use></svg><span> 关于我</span></a></li></ul></div></div><a class="sun_moon faa-parent animated-hover" onclick="switchNightMode()" title="浅色和深色模式转换" id="nightmode-button"><svg class="faa-tada" style="height:25px;width:25px;fill:currentColor;position:relative;top:7px" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div><!--#randomPost--><!--  a.site-page.social-icon.search(href="javascript:;" onclick="randomPost()" title="随机访问一篇文章")--><!--    i.fas.fa-circle-notch.fa-fw--></nav><div id="post-info"><h1 class="post-title">Java-语法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-03T12:49:36.000Z" title="发表于 2023-07-03 20:49:36">2023-07-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-04T12:38:10.300Z" title="更新于 2023-07-04 20:38:10">2023-07-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.1w</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>200分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java-语法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div><!----><!--span.post-qrcode--><!--  span.post-meta__separator |--><!--  i.fa.fa-qrcode.post-meta__icon.fa-fw(aria-hidden="true")--><!--  a(href="javasvript:;" onmouseover='document.getElementById("post-qrcode").style.display="block"' onmouseout='document.getElementById("post-qrcode").style.display="none"')='二维码'--><!--  div#post-qrcode.post-qrcode-img--><!--    img#post-img(src=qrcode(page.permalink))--></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><div class="top-img gist" style="background-image: url(/img/47.jpg)"></div><article class="post-content" id="article-container"><meta name="referrer" content="no-referrer">
<h2 id="Java基础">Java基础</h2>
<h4 id="转义字符">转义字符:</h4>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;\t :一个制表位，实现对齐的功能</span><br><span class="line">&gt;\n :换行符</span><br><span class="line">&gt;\\ :一个\</span><br><span class="line">&gt;\<span class="string">&quot; :一个&quot;</span></span><br><span class="line">&gt;\<span class="string">&#x27; :一个&#x27;</span></span><br><span class="line">&gt;\r :一个回车</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="数据类型">数据类型</h4>
<blockquote>
<p><strong>1. java</strong> 数据类型分为两大类 基本数据类型， 引用类型</p>
<p><strong>2.</strong> 基本数据类型有 <strong>8</strong> 中 数值型 <strong>[byte 1  , short 2, int 4, long 8, float 4 ,double 8] char 2 , boolean 1</strong></p>
<p>**3.引用类型 **[<strong>类，接口， 数组]</strong></p>
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304082346428.png" alt="image-20230408234631382" style="zoom: 33%;">
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304082348068.png" alt="image-20230408234853026" style="zoom:33%;">
<p>bit 最小的存储<code>单位 </code>       byte 最基本的存储<code>单元</code>     1Byte = 8bit</p>
<p>浮点数常量的两种表示形式：</p>
<ul>
<li>十进制数形式:如:5.12      	512.0f 		.512(必须有小数点)</li>
<li>科学计数法形式:如:5.12e2 [5.12 * 10 的 2 次方 ]        5.12E-2 [5.12/10 的 2 次方]</li>
</ul>
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304082355713.png" alt="image-20230408235553668" style="zoom:33%;">
<p><strong>自动类型转换</strong></p>
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304082357928.png" alt="image-20230408235717884" style="zoom:33%;">
<ul>
<li><code>byte  char   short </code>  不会进行互相转换  但是可以计算，先转为 int 再计算</li>
</ul>
<p><strong>强制类型转换</strong></p>
<ul>
<li>
<p>将容量大的数据类型转换为容量小的数据类型</p>
</li>
<li>
<p>使用时要加上强制转换符 ( )，但可能造成精度降低或溢出</p>
</li>
<li>
<p>使用 基本数据类型对应的包装类，的相应方法，得到基本数据类型</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> Integer.parseInt(s5);</span><br><span class="line"><span class="type">double</span> <span class="variable">num2</span> <span class="operator">=</span> Double.parseDouble(s5);</span><br><span class="line"><span class="type">float</span> <span class="variable">num3</span> <span class="operator">=</span> Float.parseFloat(s5);</span><br><span class="line"><span class="type">long</span> <span class="variable">num4</span> <span class="operator">=</span> Long.parseLong(s5);</span><br><span class="line"><span class="type">byte</span> <span class="variable">num5</span> <span class="operator">=</span> Byte.parseByte(s5);</span><br><span class="line"><span class="type">short</span> <span class="variable">num6</span> <span class="operator">=</span> Short.parseShort(s5);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> Boolean.parseBoolean(<span class="string">&quot;true&quot;</span>); </span><br><span class="line"></span><br><span class="line">System.out.println(num1);<span class="comment">//123 </span></span><br><span class="line">System.out.println(num2);<span class="comment">//123.0 </span></span><br><span class="line">System.out.println(num3);<span class="comment">//123.0 </span></span><br><span class="line">System.out.println(num4);<span class="comment">//123 </span></span><br><span class="line">System.out.println(num5);<span class="comment">//123 </span></span><br><span class="line">System.out.println(num6);<span class="comment">//123 </span></span><br><span class="line">System.out.println(b);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="运算符">运算符</h4>
<blockquote>
<p><strong>算术运算符</strong></p>
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304090003738.png" alt="image-20230409000336554" style="zoom:33%;">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&gt;i++;<span class="comment">//自增等价 i=i+1;=&gt;i=11</span></span><br><span class="line">&gt;System.out.println(<span class="string">&quot;i=&quot;</span> + i); <span class="comment">//11</span></span><br><span class="line">&gt;++i;<span class="comment">//自增等价于 i=i+1;=&gt;i=12</span></span><br><span class="line">&gt;System.out.println(<span class="string">&quot;i=&quot;</span> + i);<span class="comment">//12</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">&gt;<span class="comment">//int k = ++j; //等价 j=j+1;k=j;</span></span><br><span class="line">&gt;<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> j++; <span class="comment">// 等价 k =j;j=j+1; </span></span><br><span class="line">&gt;System.out.println(<span class="string">&quot;k=&quot;</span> + k + <span class="string">&quot;j=&quot;</span> + j);<span class="comment">//8    9</span></span><br></pre></td></tr></table></figure>
<p>**关系运算符 **   最终的结果是一个 boolean 值。</p>
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304090008665.png" alt="image-20230409000818545" style="zoom: 33%;">
<p><strong>逻辑运算符</strong>   最终的结果是一个 boolean 值</p>
<ul>
<li>短路与 &amp;&amp;，短路或||，取反 !</li>
<li>逻辑与 &amp;，逻辑或 |，^ 逻辑异或</li>
</ul>
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304090009424.png" alt="image-20230409000930305" style="zoom: 33%;">
<ul>
<li>&amp;&amp; 和 &amp; 区别：</li>
<li>对于&amp;&amp;短路与而言，如果第一个条件为 false ,后面的条件不再判断；效率高</li>
<li>对于&amp;逻辑与而言，如果第一个条件为 false ,后面的条件仍然会判断；效率低</li>
<li>||短路或 和 |逻辑或  同理</li>
</ul>
<p><strong>赋值运算符</strong></p>
<ul>
<li>基本赋值运算符  =</li>
<li>复合赋值运算符  += ，-= ，*= ， /= ，%=</li>
</ul>
<p><strong>三元运算符</strong></p>
<ul>
<li>条件表达式 ? 表达式 1: 表达式 2;<br>
运算规则:  如果条件表达式为 true，运算后的结果是表达式 1; 如果条件表达式为 false，运算后的结果是表达式 2;</li>
</ul>
<p><strong>运算符优先级</strong></p>
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304090016272.png" alt="image-20230409001618152" style="zoom:33%;">
</blockquote>
<h4 id="标识符">标识符</h4>
<blockquote>
<ul>
<li>只能  _ 、 $  、0-9 、 a-z-A-Z  组成</li>
<li>数字不能开头</li>
<li>不能使用关键字 保留字</li>
<li>不能有空格</li>
</ul>
</blockquote>
<h4 id="进制">进制</h4>
<blockquote>
<ul>
<li>二进制:0,1 ，满2进1.以0b或0B开头。</li>
<li>十进制:0-9 ，满 10 进 1。</li>
<li>八进制:0-7 ，满 8 进 1. 以数字 0 开头表示。</li>
<li>十六进制:0-9 及 A(10)-F(15)，满 16 进 1. 以 <strong>0x</strong> 或 <strong>0X</strong> 开头表示。此处的 A-F 不区分大小写。</li>
<li>二进制转换成八进制         规则:从低位开始,将二进制数每三位一组，转成对应的八进制数即可。</li>
<li>八进制转换成二进制         规则:将八进制数每 1 位，转成对应的一个 3 位的二进制数即可。</li>
<li>二进制转换成十六进制     规则:从低位开始，将二进制数每四位一组，转成对应的十六进制数即可</li>
<li>十六进制转换成二进制      规则:将十六进制数每 1 位，转成对应的 4 位的一个二进制数即可。</li>
</ul>
</blockquote>
<h4 id="位运算符">位运算符</h4>
<blockquote>
<ul>
<li>&gt;&gt;     算术右移                  低位溢出,符号位不变,并用符号位补溢出的高位     int  o =   1&gt;&gt;2   本质   1 / 2 / 2 =0</li>
<li>&lt;&lt;     算术左移                  符号位不变,低位补 0                                         int  o =   1&lt;&lt;2   本质   1 *2 * 2 =4</li>
<li>&gt;&gt;&gt;   无符号右移               低位溢出，高位补 0</li>
<li>~       按位取反</li>
<li>&amp;      按位与</li>
<li>|       按位或</li>
<li>^ 按位异或</li>
</ul>
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304090029636.png" alt="image-20230409002903592" style="zoom:33%;">
</blockquote>
<h4 id="原码-反码-补码">原码 反码 补码</h4>
<blockquote>
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304090027305.png" alt="image-20230409002719110" style="zoom: 33%;">
</blockquote>
<h4 id="控制结构">控制结构</h4>
<blockquote>
<ul>
<li>
<p>顺序控制</p>
</li>
<li>
<p>分支控制</p>
</li>
<li>
<p>if-…-else</p>
</li>
<li>
<p>switch (表达式)</p>
<ul>
<li>表达式只能是： <code>byte short int char enum string</code></li>
<li>表达式数据类型，应和case后的常量类型一致，或者是<code>可以自动转成</code>可以相互比较的类型，比如输入的是字符，而常量是 int</li>
</ul>
</li>
<li>
<p>循环控制</p>
</li>
<li>
<p>for</p>
</li>
</ul>
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304090853207.png" alt="image-20230409085337157" style="zoom:33%;">
<ul>
<li>while</li>
</ul>
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304090856386.png" alt="image-20230409085642257" style="zoom:25%;">
<ul>
<li>do…while
<ul>
<li>至少执行一次，哪怕循环条件不成立</li>
</ul>
</li>
</ul>
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304090859610.png" alt="image-20230409085916561" style="zoom:25%;">
</blockquote>
<h4 id="跳出控制语句">跳出控制语句</h4>
<blockquote>
<ul>
<li>
<p>break———退出 最近的 循环体</p>
</li>
<li>
<p>可以和标签一起使用：label1、label2、……</p>
</li>
<li>
<p>continue———<strong>continue</strong> 语句用于结束本次循环，继续执行下一次循环。</p>
</li>
<li>
<p>通过标签指明要跳过的是哪一层循环</p>
</li>
<li>
<p>return———跳出所在的方法</p>
</li>
</ul>
</blockquote>
<h4 id="数组">数组</h4>
<blockquote>
<h6 id="一维数组">一维数组</h6>
<p><strong>定义：</strong>  <code>数据类型  数组名[]  =  new  数据类型[大小]</code></p>
<p><strong>初始化：</strong></p>
<ul>
<li>动态初始化：</li>
<li>方式一：数据类型 数组名[]; 也可以 数据类型[] 数组名;    +  数组名=new 数据类型[大小];   <code>int a[]; 或者 int[] a;    a=new int[10]; </code></li>
<li>方式二：<code>double scores[] = new double[5]</code></li>
<li>静态初始化：</li>
<li>数据类型数组名[]= {元素值,元素值…}    <code>int a[]=&#123;2,5,6,7,8,89,90,34,56&#125;</code></li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>数组创建后，如果没有赋值，有默认值<code>int 0，short 0, byte 0, long 0, float 0.0,double 0.0，	char \u0000，boolean false，String null</code></li>
<li>数组属引用类型，数组型数据是对象(object)</li>
</ul>
<p><strong>数组赋值机制</strong></p>
<ul>
<li>
<p>基本数据类型赋值就是具体的数据，而且相互不影响</p>
</li>
<li>
<p>但是 <code>数组</code> 在默认情况下是引用传递，赋的值是地址</p>
</li>
</ul>
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304090920854.png" alt="image-20230409092034725" style="zoom:33%;">
<h6 id="二维数组">二维数组</h6>
<p><strong>声明方式</strong></p>
<p>​	<code>int[][] y 或者 int[] y[] 或者 int y[][] </code></p>
<p><strong>初始化</strong></p>
<ul>
<li>动态初始化</li>
<li><code>类型[][] 数组名=new 类型[大小][大小] </code>    <code>int a[][]=new int[2][3]</code></li>
<li><code>类型 数组名[][]; 数组名 = new 类型[大小][大小]     int a[][];arr = new int[2][3]; </code></li>
<li>列数不确定: <code>int[][] arr = new int[3][]; </code></li>
<li>静态初始化</li>
<li><code>类型 数组名[][] = &#123;&#123;值 1,值 2..&#125;,&#123;值 1,值 2..&#125;,&#123;值 1,值 2..&#125;&#125;       int[][] arr = &#123;&#123;1,1,1&#125;, &#123;8,8,9&#125;, &#123;100&#125;&#125;;</code></li>
</ul>
</blockquote>
<h4 id="排序">排序</h4>
<blockquote>
<h6 id="冒泡">冒泡</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">for</span>( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">  <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line"> 	 	temp = arr[j]; </span><br><span class="line">      arr[j] = arr[j+<span class="number">1</span>]; </span><br><span class="line">      arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">  &#125; </span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="OOP">OOP</h4>
<blockquote>
<p><strong>对象在内存中存在形式</strong></p>
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304090937946.png" alt="image-20230409093709824" style="zoom:33%;">
<ul>
<li>属性如果不赋值，有默认值，规则和数组一致。具体说:<code> int 0，short 0, byte 0, long 0, 			float 0.0,double 0.0，char \u0000， boolean false，String null</code></li>
</ul>
<p><strong>类和对象的内存分配机制</strong>   <code>Person p2 =p1;</code>   赋值的是地址</p>
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304090940261.png" alt="image-20230409094038229" style="zoom:33%;">
<ul>
<li>栈:一般存放基本数据类型(局部变量)</li>
<li>堆:存放对象(Catcat,数组等)</li>
<li>方法区:常量池(常量，比如字符串)，类加载信息</li>
</ul>
<p><strong>Java创建对象的流程简单分析</strong></p>
<ul>
<li>先加载Person类信息(属性和方法信息,只会加载一次)</li>
<li>在堆中分配空间, 进行默认初始化</li>
<li>把地址赋给p,p就指向对象</li>
<li>进行指定初始化   <code>p.name =”jack” p.age = 10</code></li>
</ul>
<p><strong>方法的调用机制原理</strong></p>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304090945088.png" alt="image-20230409094529955" style="zoom:35%;"> <img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304090945345.png" alt="image-20230409094548309" style="zoom:33%;"><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304090946615.png" alt="image-20230409094608582" style="zoom: 33%;"></p>
<p><strong>成员方法传参机制</strong></p>
<ul>
<li>基本数据类型的传参机制    值    形参的任何改变不会影响实参</li>
<li>引用数据类型的传参机制  地址(传递也是值，但是值是地址)，可以通过形参影响实参</li>
</ul>
<p><strong>递归</strong></p>
<p>注意：</p>
<ul>
<li>执行一个方法时，就创建一个新的受保护的独立空间(栈空间)</li>
<li>方法的局部变量是独立的，不会相互影响，比如n变量</li>
<li>如果方法中使用的是引用类型变量(比如数组，对象)，就会共享该引用类型的数据.</li>
<li>递归必须向退出递归的条件逼近，否则就是无限递归,出现StackOverflowError,死龟了:)</li>
<li>当一个方法执行完毕，或者遇到return,就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。</li>
</ul>
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304090956551.png" alt="image-20230409095627461" style="zoom:33%;">
<p><strong>方法重载</strong></p>
<ul>
<li>方法名:必须相同</li>
<li>形参列表:必须不同(形参类型、个数、顺序，至少有一样不同，参数名无要求)</li>
<li>返回类型:无要求</li>
</ul>
<p><strong>可变参数</strong></p>
<p>java 允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法。 就可以通过可变参数实现</p>
<ul>
<li>可变参数的实参可以为0个或任意多个</li>
<li>可变参数的实参可以为数组 如：int[] arr = {1, 2, 3};t1.f1(arr)</li>
<li>可变参数的本质就是数组</li>
<li>可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后  如：<code>public void f2(String str, double... nums)</code></li>
<li>一个形参列表中只能出现一个可变参数 <code>f3(int... nums1, double... nums2) &#123;&#125;是 错的</code></li>
</ul>
<p><strong>作用域</strong></p>
<ul>
<li>全局变量:也就是属性，作用域为整个类体</li>
<li>局部变量:也就是除了属性之外的其他变量，作用域为定义它的代码块中!</li>
<li>PS：</li>
<li>全局变量(属性)可以不赋值，直接使用，因为有默认值，<code>局部变量必须赋值</code>后才能使用，因为没有默认值</li>
<li>属性和局部变量可以重名，访问时遵循就近原则</li>
<li>在同一个作用域中，比如在同一个成员方法中，两个局部变量，不能重名。</li>
<li>全局变量生命周期较长，伴随着对象的创建而创建，伴随着对象的销毁而销毁。</li>
<li>局部变量，生命周期较短，伴随着它的代码块的执行而创建，伴随着代码块的结束而销毁。</li>
<li>即在一次方法调用过程中。 作用域范围不同</li>
<li>全局变量/属性:可以被本类使用，或其他类使用(通过对象调用)</li>
<li>局部变量:只能在本类中对应的方法中使用</li>
<li>修饰符不同</li>
<li>全局变量/属性可以加修饰符</li>
<li>局部变量不可以加修饰符</li>
</ul>
<p><strong>构造方法/构造器</strong></p>
<ul>
<li>构造器的修饰符可以默认，也可以是 public protected private</li>
<li>构造器没有返回值,也不能写 void</li>
<li>方法名 和类名字必须一样且参数列表 和 成员方法  也要一样</li>
<li>构造器的调用, 由系统完成</li>
<li>一个类可以定义多个不同的构造器，即构造器重载</li>
<li>构造器是完成对象的初始化，并不是创建对象</li>
<li>在创建对象时,系统自动的调用该类的构造方法</li>
<li>如果程序员没有定义构造器，系统会自动给类生成一个默认无参构造器(也叫默认构造器)，可以使用javap指令反编译看看</li>
<li>一旦定义了自己的构造器,默认的构造器就覆盖了，就不能再使用默认的无参构造器，除非显式的定义一下</li>
</ul>
<p><strong>this</strong></p>
<ul>
<li>this 关键字可以用来访问本类的属性、方法、构造器</li>
<li>this 用于区分当前类的属性和局部变量</li>
<li>访问成员方法的语法：this.方法名(参数列表);</li>
<li>访问构造器语法：this(参数列表); 注意只能在构造器中使用(即只能在构造中访问另外一个构造器, <strong>必须放在第一条语句</strong>)</li>
<li>this 不能在类定义的外部使用，只能在类定义的方法中使用。</li>
</ul>
<p><strong>包</strong></p>
<ul>
<li>命名规则:只能包含数字、字母、下划线、小圆点.但不能用数字开头，不能是关键字或保留字</li>
<li>import指令位置放在package的下面，在类定义前面,可以有多句且没有顺序要求。</li>
</ul>
<p><strong>访问修饰符</strong></p>
<ul>
<li>公开级别:用 public 修饰,对外公开</li>
<li>受保护级别:用 protected 修饰,对子类和同一个包中的类公开</li>
<li>默认级别:没有修饰符号,向同一个包的类公开</li>
<li>私有级别:用 private 修饰,只有类本身可以访问,不对外公开</li>
</ul>
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304091014671.png" alt="image-20230409101410577" style="zoom:33%;">
<ul>
<li>ps:</li>
<li>修饰符可以用来修饰类中的属性，成员方法以及类</li>
<li>只有默认的和public才能修饰类 ,并且遵循上述访问权限的特点</li>
<li>成员方法的访问规则和属性完全一样</li>
</ul>
<p><strong>封装</strong></p>
<ul>
<li>封装(encapsulation)就是把抽象出的数据[属性]和对数据的操作[方法]封装在一起,数据被保护在内部,程序的其它部分只有通过被授权的操作[方法],才能对数据进行操作。</li>
<li>优点：</li>
<li>隐藏实现细节:方法(连接数据库) &lt; --调用(传入参数…)</li>
<li>可以对数据进行验证，保证安全合理</li>
<li></li>
<li>实现步骤</li>
<li>将属性进行私有化private  [不能直接修改属性]</li>
<li>提供一个公共的(public)set方法， 用于对属性判断并赋值</li>
<li>提供一个公共的(public)get方法， 用于获取属性的值</li>
</ul>
<p><strong>继承</strong></p>
<ul>
<li>子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问, 但是私有属性和方法不能在子类直接访问，要通过父类提供公共的方法去访问</li>
<li>子类必须调用父类的构造器，完成父类的初始化</li>
<li>当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用 super 去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过</li>
<li>如果希望指定去调用父类的某个构造器，则显式调用一下 : super(参数列表)</li>
<li>super 在使用时，必须放在构造器第一行(super 只能在构造器中使用)</li>
<li>super() 和 this() 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器</li>
<li>java 所有类都是 Object 类的子类, Object 是所有类的基类.</li>
<li>父类构造器的调用不限于直接父类！将一直往上追溯直到 Object 类(顶级父类)</li>
<li>子类最多只能继承一个父类(指直接继承)，即 java 中是单继承机制。</li>
<li>不能滥用继承，子类和父类之间必须满足 is-a 的逻辑关系</li>
</ul>
<p><strong>子类创建的内存布局</strong></p>
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304091022742.png" alt="image-20230409102246648" style="zoom:25%;">
<p><strong>super 关键字</strong></p>
<ul>
<li>访问父类的属性,但不能访问父类的private属性  super.属性名;</li>
<li>访问父类的方法，不能访问父类的private方法  super.方法名(参数列表);</li>
<li>访问父类的构造器: super(参数列表);只能放在构造器的第一句且只能出现一次!</li>
<li>PS:</li>
<li>调用父类的构造器的好处 (父类属性由父类初始化，子类的属性由子类初始化)</li>
<li>当子类中有和父类中的成员(属性和方法)重名时，为了访问父类的成员，必须通过super。如果没有重名，使用super、 this、 直接访问是一样的效果!</li>
<li>super的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员;如果多个基类(上级类)中都有同名的成员，使用super访问遵循就近原则。A-&gt;B-&gt;C,当然也需要遵守访问权限的相关规则</li>
</ul>
<p><strong>super 和 this 的比较</strong></p>
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304091026057.png" alt="image-20230409102604962" style="zoom:33%;">
<p><strong>方法重写/覆盖(override)</strong></p>
<ul>
<li>父子类只有方法体不同</li>
<li>细节：</li>
<li>子类方法的返回类型和父类方法返回类型一样，或者是父类返回类型的子类</li>
<li>子类方法不能缩小父类方法的访问权限  public &gt; protected &gt;默认&gt; private</li>
<li>属性没有重写之说！属性的值看编译类型（左），方法的值看运行类型（右）</li>
</ul>
<p><strong>比较重写和重载</strong></p>
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304091028051.png" alt="image-20230409102829956" style="zoom:33%;">
<p><strong>多态</strong></p>
<ul>
<li>具体体现</li>
<li>方法的多态     重写和重载就体现多态</li>
<li>对象的多态</li>
<li>一个对象的编译类型和运行类型可以不一致</li>
<li>编译类型在定义对象时，就确定了，不能改变</li>
<li>运行类型是可以变化的.</li>
<li>编译类型看定义时=号的左边，运行类型看=号的右边</li>
<li>多态的前提是：两个对象(类)存在继承关系</li>
<li>向上转型      <strong>不能调用子类中特有成员</strong></li>
<li>父类的引用指向了子类的对象</li>
<li>语法:<code>父类类型 引用名= new 子类类型();  Animal animal = new Cat(); </code></li>
<li>可以调用父类中的所有成员(需遵守访问权限)，<strong>不能调用子类中特有成员</strong>   因为在编译阶段，能调用哪些成员,是由编译类型来决定的</li>
<li>最终运行效果看子类的具体实现</li>
<li>向下转型<code> [instanceOf ]</code>   <strong>能调用子类中特有成员</strong></li>
<li>语法:<code>子类类型  引用名= (子类类型) 父类引用 ; Cat cat = (Cat) animal;</code>   cat 的编译类型 Cat,运行类型是 Cat</li>
<li>只能强转父类的引用，不能强转父类的对象</li>
<li>要求父类的引用必须指向的是当前目标类型的对象</li>
<li>当向下转型后，可以调用子类类型中所有的成员</li>
<li><code>XX  instanceOf YY</code>    比较操作符，用于判断<code>对象(XX)</code>的【运行】类型是否为 <code>YY类型</code>或 <code>YY 类型的子类型</code></li>
<li>属性没有重写之说!属性的值看<code>编译类型</code>   <code>左编译  右运行</code></li>
</ul>
<p><strong>java 的动态绑定机制</strong></p>
<ul>
<li>当调用对象方法的时候，该方法会和该对象的<code>内存地址/运行类型</code>绑定   [ 方法看运行（右）/看方法的所在类 ]</li>
<li>当调用对象属性时，没有动态绑定机制，哪里声明，那里使用[  属性看编译（左）/本类 ]</li>
</ul>
<p><strong>对象数组</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 2 个 Student 对象和 2 个 Teacher 对象, 统一放在数组中，并调用每个对象 say 方法</span></span><br><span class="line">&gt;Person[] persons = <span class="keyword">new</span> <span class="title class_">Person</span>[<span class="number">5</span>];</span><br><span class="line">&gt;persons[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;jack&quot;</span>, <span class="number">20</span>); </span><br><span class="line">&gt;persons[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;mary&quot;</span>, <span class="number">18</span>, <span class="number">100</span>);</span><br><span class="line">&gt;persons[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;smith&quot;</span>, <span class="number">19</span>, <span class="number">30.1</span>);</span><br><span class="line">&gt;persons[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;scott&quot;</span>, <span class="number">30</span>, <span class="number">20000</span>);</span><br><span class="line">&gt;persons[<span class="number">4</span>] = <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;king&quot;</span>, <span class="number">50</span>, <span class="number">25000</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//循环遍历多态数组，调用 say</span></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; persons.length; i++) &#123;</span><br><span class="line">&gt;<span class="comment">//person[i] 编译类型是 Person ,运行类型是是根据实际情况有 JVM 来判断 </span></span><br><span class="line">System.out.println(persons[i].say());<span class="comment">//动态绑定机制</span></span><br><span class="line">&gt;<span class="comment">//使用 类型判断 + 向下转型.</span></span><br><span class="line"><span class="keyword">if</span>(persons[i] <span class="keyword">instanceof</span> Student) &#123;<span class="comment">//判断 person[i] 的运行类型是不是 Student</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student)persons[i];<span class="comment">//向下转型 </span></span><br><span class="line">    student.study(); <span class="comment">//小也可以使用一条语句   ((Student)persons[i]).study();</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(persons[i] <span class="keyword">instanceof</span> Teacher) &#123; </span><br><span class="line">    <span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> (Teacher)persons[i]; </span><br><span class="line">    teacher.teach();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(persons[i] <span class="keyword">instanceof</span> Person)&#123; </span><br><span class="line">    System.out.println(<span class="string">&quot;你的类型有误, 请自己检查...&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;你的类型有误, 请自己检查...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Object</strong></p>
<h6 id="和-equals-的对比">==和 equals 的对比</h6>
<ul>
<li>== :<code>既可以</code>判断基本类型，<code>又可以</code>判断引用类型</li>
<li>==:如果判断<code>基本类型</code>，判断的是<code>值</code>是否相等</li>
<li>== :如果判断<code>引用类型</code>，判断的是<code>地址</code>是否相等，即判定是不是同一个对象</li>
<li>equals:是Object类中的方法，<code>只能判断引用类型</code></li>
<li><code>默认</code>判断的是<code>地址是否相等</code>，也就是判断两个对象是不是同一个对象</li>
<li>子类中往往<code>重写</code>该方法，用于判断<code>内容(值)</code>是否相等</li>
</ul>
<h6 id="hashCode">hashCode</h6>
<ul>
<li>两个引用，如果指向的是<code>同一个对象</code>，则哈希值肯定是<code>一样</code>的</li>
<li>两个引用，如果指向的是<code>不同对象</code>，则哈希值是<code>不一样</code>的</li>
<li>哈希值主要根据<code>地址号</code>来的     <code>不能完全</code>将哈希值<code>等价于</code>地址。</li>
</ul>
<h6 id="toString-方法">toString 方法</h6>
<ul>
<li>默认返回：全类名+@+哈希值的十六进制，子类往往重写 toString 方法，用于返回对象的属性信息</li>
<li>重写 toString 方法，打印对象或拼接对象时，都会自动调用该对象的 toString 形式.</li>
<li>当直接输出一个对象时，toString 方法会被默认的调用, 比如 System.out.println(monster)； 就会默认调用 monster.toString()</li>
</ul>
<h6 id="finalize-方法">finalize 方法</h6>
<ul>
<li>当对象被回收时，系统自动调用该对象的 finalize 方法。子类可以重写该方法，做一些释放资源的操作</li>
<li>什么时候被回收：当某个对象<code>没有任何引用</code>时，则 jvm 就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，<code>在销毁该对象前</code>，会先调用 finalize 方法。</li>
<li>垃圾回收机制的调用，是由系统来决定(即有自己的 GC 算法), 也可以通过 <code>System.gc() 主动触发垃圾回收机制</code></li>
<li>程序员可以在 finalize 中，写自己的业务逻辑代码 如果程序员不重写 finalize,那么就会调用 Object 类的 finalize, 即默认处理</li>
</ul>
<p><strong>类变量</strong></p>
<ul>
<li>static变量是同一个类所有对象共享</li>
<li>static类变量，在类加载的时候就生成了</li>
<li>类变量也叫静态变量/静态属性，是该类的所有对象共享的变量,任何一个该类的对象去访问它时,取到的都是相同的值，同样任何一个该类的对象去修改它时,修改的也是同一个变量。</li>
</ul>
<p>定义：<code>访问修饰符 static 数据类型 变量名; [推荐]   ||    static 访问修饰符 数据类型 变量名; [推荐]  </code></p>
<p>访问：</p>
<ul>
<li>类名.类变量名	[推荐使用;使用前提：满足访问修饰符的访问权限和范围]</li>
<li>对象名.类变量名 [静态变量的访问修饰符的访问权限和范围和普通属性是一样的。]</li>
</ul>
<p>PS：</p>
<ul>
<li>什么时候需要用类变量：当我们需要让某个类的所有对象都共享一个变量时，就可以考虑使用类变量(静态变量):</li>
<li>类变量与实例变量(普通属性)区别： <code>类变量</code>是该类的<code>所有对象共享</code>的，而<code>实例变量</code>是<code>每个对象独享</code>的。</li>
<li>加上static称为类变量或静态变量，否则称为  普通属性/普通成员变量/非静态属性/非静态成员变量/实例变量</li>
<li>实例变量<code>不能</code>通过<code>类名.类变量</code>名方式访问。</li>
<li>类变量是在类加载时就初始化了，也就是说，即使你没有创建对象，<code>只要类加载了，就可以使用类变量了</code>。</li>
<li>类变量的生命周期是随类的加载开始，随着类消亡而销毁。</li>
</ul>
<p><strong>类方法</strong></p>
<ul>
<li>类方法也叫静态方法;静态方法 可以访问 静态属性/变量</li>
<li>定义:<code>访问修饰符static数据返回类型方法名()&#123; &#125; [推荐]  static访问修饰符数据返回类型方法名()&#123; &#125;</code></li>
<li>调用方式: <code>类名:类方法名 或者 对象名.类方法名</code> [前提是满足访问修饰符的访问权限和和范围]</li>
<li>PS:</li>
<li>类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区:类方法中无this的参数,普通方法中隐含着this的参数</li>
<li>类方法可以通过类名调用，也可以通过对象名调用。</li>
<li>普通方法和对象有关，要通过对象名调用，比如对象名.方法名(参数)，不能通过类名调用。</li>
<li>类方法中不允许使用和对象有关的关键字，比如this和super。 普通方法(成员方法)可以。</li>
<li>类方法(静态方法)中只能访问静态变量或静态方法。</li>
<li>普通成员方法（非静态的方法），既可以访问非静态成员，也可以访问静态成员。</li>
</ul>
<p><strong>main 方法语法</strong></p>
<p>main方法的形式的解释 : <code>public static void main(String[] args)&#123;&#125;</code></p>
<ul>
<li>java虚拟机需要调用类的main()方法，所以该方法的<code>访问权限必须是public</code></li>
<li>java虚拟机在执行main()方法时不必创建对象，所以该方法<code>必须是static</code></li>
<li>该方法接收String类型的数组参数，该<code>数组中</code>保存执行java命令时传递给所运行的类的参数</li>
</ul>
<p>PS:</p>
<ul>
<li>在 main()方法中，我们可以直接调用 main 方法所在类的静态方法或静态属性。</li>
<li>不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员</li>
</ul>
<p><strong>代码块</strong></p>
<ul>
<li>代码化块又称为初始化块,属于类中的成员[即是类的一部分]，类似于方法，将逻辑语包封装在方法体中，通过{}包围起来。</li>
<li>但和方法不同，没有方法名，没有返回，没有参数只有方法体，而且不用通过对象或类显式调用，而是加载类时，或创建对象时隐式调用。</li>
</ul>
<p>语法：<code>[修饰符]&#123;   代码  &#125;;</code></p>
<p>PS:</p>
<ul>
<li>修饰符可选，要写的话，<code>也只能是 static</code></li>
<li>代码块分为两类，使用static修饰的叫静态代码块，没有static修饰的， 叫普通代码块/非静态代码块。</li>
<li>逻辑语句可以为任何逻辑语句(输入、输出、方法调用、循环、判断等)</li>
<li>; 号可以写上，也可以省略。</li>
</ul>
<p>PS:</p>
<ul>
<li>
<p>static代码块也叫静态代码块，<code>作用就是对类进行初始化</code>，而且它随着类的加载而执行，<code>并且只会执行一次</code>。 如果是普通代码块，每创建一个对象，就执行。</p>
</li>
<li>
<p>类什么时候被加载</p>
</li>
<li>
<p>①创建对象实例时(new)</p>
</li>
<li>
<p>②创建子类对象实例，父类也会被加载  而且 父类先被加载，子类后被加载</p>
</li>
<li>
<p>③使用类的静态成员时(静态属性，静态方法)</p>
</li>
<li>
<p>普通的代码块，在创建对象实例时，会被隐式的调用。被创建一次，就会调用次。如果只是使用类的静态成员时，普通代码块并不会执行。</p>
</li>
<li>
<p>创建一个对象时，在一个类调用顺序是:(点，难点 ) :</p>
</li>
<li>
<p>调用静态代码块和静态属性初始化(注意:静态代码块和静态属性初始化调用的优先级一样，按他们定义的顺序调用)</p>
</li>
<li>
<p>调用普通代码块和普通属性的初始化(注意:普通代码块和普通属性初始化调用的优先级一样，按定义顺序调用)、</p>
</li>
<li>
<p>调用构造方法</p>
</li>
<li>
<p>构造器的最前面其实隐含了super()；super()是优先于构造器和普通代码块执行的。</p>
</li>
<li>
<p>创建一个子类对象时(继承关系)， 他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序如下:</p>
</li>
<li>
<p>父类的静态代码块和静态属性(优先级一样，按定义顺序执行)</p>
</li>
<li>
<p>子类的静态代码块和静态属性(优先级一样，按定义顺序执行)</p>
</li>
<li>
<p>父类的普通代码块和普通属性初始化(优先级一样，按定义顺序执行)</p>
</li>
<li>
<p>父类的构造方法</p>
</li>
<li>
<p>子类的普通代码块和普通属性初始化(优先级一样，按定义顺序执行)</p>
</li>
<li>
<p>子类的构造方法</p>
</li>
<li>
<p>静态代码块只能直接调用静态成员(静态属性和静态方法)，普通代码块可以调用任意成员。</p>
</li>
</ul>
<p><strong>final 关键字</strong></p>
<ul>
<li>
<p>final可以修饰类、属性、方法和局部变量</p>
</li>
<li>
<p>使用场景：</p>
</li>
<li>
<p>当不希望类被继承时，可以用final修饰.</p>
</li>
<li>
<p>当不希望父类的某个方法被子类覆盖/重写(override)时，可以用final关键字修饰。<code>访问修饰符 final 返回类型 方法名 </code></p>
</li>
<li>
<p>当不希望类的的某个属性的值被修改，可以用final修饰.   <code>public final double TAX RATE=0.08</code></p>
</li>
<li>
<p>当不希望某个局部变量被修改，可以使用final修饰    <code>final double TAX RATE=0.08</code></p>
</li>
<li>
<p>PS:</p>
</li>
<li>
<p>final修饰的属性又叫常量，一般用XX_XX_XX来命名</p>
</li>
<li>
<p>final修饰的属性在定义时，必须赋初值，并且以后不能再修改，赋值可以在如下位置之一 :</p>
</li>
<li>
<p>在定义时:如public final double TAX_ RATE=0.08;</p>
</li>
<li>
<p>在构造器中</p>
</li>
<li>
<p>在代码块中</p>
</li>
<li>
<p>如果final修饰的属性是静态的，则初始化的位置只能是</p>
</li>
<li>
<p>定义时</p>
</li>
<li>
<p>在静态代码块,不能在构造器中赋值。</p>
</li>
<li>
<p>final类不能继承，但是可以实例化对象。</p>
</li>
<li>
<p>如果类不是final类， 但是含有final方法，则该方法虽然不能重写，但是可以被继承。</p>
</li>
<li>
<p>一般来说，如果一个类已经是final类了,就没有必要再将方法修饰成final方法。</p>
</li>
<li>
<p>final不能修饰构造方法(即构造器)</p>
</li>
<li>
<p>final和static往往搭配使用，效率更高，不会导致类加载.底层编译器做了优化处理。</p>
</li>
<li>
<p>包装类(Integer,Double,Float, Boolean等都是 final 类),String也是 final 类。</p>
</li>
</ul>
<p>**抽象类 **</p>
<ul>
<li>
<p>小结: 当父类的某些方法，需要声明，但是又不确定如何实现时，可以将其声明为抽象方法(用abstract关键字来修饰该方法)，那么这个类(用abstract来修饰的类)	就是抽象类</p>
</li>
<li>
<p>用abstract关键字来修饰一个类时,这个类就叫抽象类   <code>访问修饰符abstract类名&#123;&#125;</code></p>
</li>
<li>
<p>用abstract关键字来修饰一个方法时，这个方法就是抽象方法 <code>访问修饰符 abstract 返回类型方法名(参数列表);</code> //没有方法体</p>
</li>
</ul>
<p>PS:</p>
<ul>
<li>
<p>抽象类不能被实例化</p>
</li>
<li>
<p>抽象类不一定要包含abstract方法。也就是说，抽象类可以没有abstract方法</p>
</li>
<li>
<p>一旦类包含了abstract方法则这个类必须声明为abstract</p>
</li>
<li>
<p>abstract只能修饰类和方法，不能修饰属性和其它的</p>
</li>
<li>
<p>抽象类可以有<code>任意成员[抽象类本质还是类]</code> ,比如:非抽象方法、构造器、静态属性等</p>
</li>
<li>
<p>抽象方法不能有主体，即不能实现.  abstract void aaa(); 后面不能加{ }</p>
</li>
<li>
<p>如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类。</p>
</li>
<li>
<p>抽象方法<code>不能</code>使用private、 final和static来修饰， 这些适合重写相违背的。</p>
</li>
</ul>
<p><strong>接口</strong></p>
<ul>
<li>接口就是给出一些没有实现的方法,封装到一起，在某个类要使用的时候，根据具体情况把这些方法写出来</li>
<li>接口体现了程序设计的多态和高内聚低偶合的设计思想。</li>
<li>特别说明: Jdk8.0后接口类可以有静态方法，默认方法，也就是说接口中可以有方法的具体实现</li>
<li>接口不能被实例化</li>
<li>接口中所有的方法是public方法， 接口中抽象方法，可以不用abstract修饰 <code> 如 void aaa();  实际上是abstract void aa();</code></li>
<li>一个普通类实现接口,就必须将该接口的所有方法都实现。</li>
<li>抽象类实现接口，可以不用实现接口的方法。</li>
<li>一个类同时可以实现多个接口</li>
<li>接口中的属性，只能是final的，而且是public static final修饰符。<code>比如: int a=1;实际上是public static final int a= 1; (必须初始化)</code></li>
<li>接口中属性的访问形式: 			<code>接口名.属性名       IB.n1 = 30;</code></li>
<li>接口不能继承其它的类,但是可以继承多个其他接口    <code>interface A extends B,C&#123;&#125;</code></li>
<li>接口的修饰符只能是public和默认，这点和类的修饰符是一样的。</li>
<li><code>实现接口是对 java 单继承机制的一种补充</code></li>
</ul>
<p><strong>接口的多态特性</strong></p>
<ul>
<li>多态参数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//接口的多态体现</span></span><br><span class="line">&gt;<span class="comment">//接口类型的变量 if01 可以指向 实现了 IF 接口类的对象实例 </span></span><br><span class="line">&gt;<span class="type">IF</span> <span class="variable">if01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Monster</span>();</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">interface</span> <span class="title class_">IF</span> &#123;&#125;</span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Monster</span> <span class="keyword">implements</span> <span class="title class_">IF</span>&#123;&#125; </span><br></pre></td></tr></table></figure>
<ul>
<li>多态数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//多态数组 -&gt; 接口类型数组 </span></span><br><span class="line">&gt;Usb[] usbs = <span class="keyword">new</span> <span class="title class_">Usb</span>[<span class="number">2</span>]; </span><br><span class="line">&gt;usbs[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Phone_</span>();</span><br><span class="line">&gt;usbs[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Camera_</span>();</span><br><span class="line">&gt;<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; usbs.length; i++) &#123;</span><br><span class="line">usbs[i].work();<span class="comment">//动态绑定.. //和前面一样，我们仍然需要进行类型的向下转型 </span></span><br><span class="line"><span class="keyword">if</span>(usbs[i] <span class="keyword">instanceof</span> Phone_) &#123;<span class="comment">//判断他的运行类型是 Phone_</span></span><br><span class="line">    ((Phone_) usbs[i]).call(); </span><br><span class="line">&#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">interface</span> <span class="title class_">Usb</span>&#123; <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Phone_</span> <span class="keyword">implements</span> <span class="title class_">Usb</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123; </span><br><span class="line">    System.out.println(<span class="string">&quot;手机可以打电话...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;手机工作中...&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Camera_</span> <span class="keyword">implements</span> <span class="title class_">Usb</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123; </span><br><span class="line">    System.out.println(<span class="string">&quot;相机工作中...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>多态传递</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//如果 IG 继承了 IH 接口，而 Teacher 类实现了 IG 接口 那么，实际上就相当于 Teacher 类也实现了 IH 接口. </span></span><br><span class="line">&gt;<span class="comment">//这就是所谓的 接口多态传递现象.</span></span><br><span class="line">&gt;<span class="type">IG</span> <span class="variable">ig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">&gt;<span class="type">IH</span> <span class="variable">ih</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">interface</span> <span class="title class_">IH</span> &#123; <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">interface</span> <span class="title class_">IG</span> <span class="keyword">extends</span> <span class="title class_">IH</span>&#123; &#125; </span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">implements</span> <span class="title class_">IG</span> &#123;</span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123; </span><br><span class="line">&#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>内部类</strong></p>
<ul>
<li>
<p>分类</p>
</li>
<li>
<p>如果定义类在局部位置(方法中/代码块) :</p>
</li>
<li>
<p>局部内部类</p>
</li>
<li>
<p>匿名内部类</p>
</li>
<li>
<p>定义在成员位置</p>
</li>
<li>
<p>成员内部类</p>
</li>
<li>
<p>静态内部类</p>
</li>
<li>
<p>一个类的内部又完整的嵌套了另一个类结构。被嵌套的类称为内部类(inner class),嵌套其他类的类称为外部类(outer class)。是我们<code>类的第五大成员[属性、方法、构	造器、代码块、内部类]</code>，内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系。</p>
</li>
<li>
<p>局部内部类</p>
</li>
<li>
<p>位置：<code>外部类的局部位置</code>，常为在<code>方法中</code>，并且<code>有类名</code>。</p>
</li>
<li>
<p>可以直接访问外部类的所有成员，包含私有的</p>
</li>
<li>
<p>不能添加访问修饰符，因为它的地位就是一个局部变量。</p>
</li>
<li>
<p>局部变量是不能使用修饰符的。但是可以使用final修饰 <code>final class Inner02 &#123;...&#125;</code></p>
</li>
<li>
<p>作用域:仅仅在定义它的方法或代码块中。</p>
</li>
<li>
<p>局部内部类可以<code>直接访向</code>外部类的成员</p>
</li>
<li>
<p>外部类可以<code>访向</code>局部内部类的成员   <code>访问方式:先创建对象，再访问(注意:必须在作用域内)    Inner02 inner02 = new Inner02(); 	inner02.f1();  </code></p>
</li>
<li>
<p>外部其他类----<code>不能访问</code>----&gt;局部内部类(因为局部内部类地位是一个局部变量)</p>
</li>
<li>
<p>如果外部类和局部内部类的成员<code>重名</code>时，默认遵循<code>就近原则</code>，如果想访问外部类的成员，则可以使用(<code>外部类名.this.成员</code>) 去访问 <code>System. out.println(”外部类的n2=”+外部类名.this.n2);</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Outer02</span> &#123;<span class="comment">//外部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Inner02</span> &#123;<span class="comment">//局部内部类(本质仍然是一个类)</span></span><br><span class="line">                    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">800</span>; </span><br><span class="line">                   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">                       System.out.println(<span class="string">&quot;n1=&quot;</span> + n1 + <span class="string">&quot; 外部类的 n1=&quot;</span> + Outer02.<span class="built_in">this</span>.n1);</span><br><span class="line">                       System.out.println(<span class="string">&quot;Outer02.this hashcode=&quot;</span> + Outer02.<span class="built_in">this</span>);</span><br><span class="line">                       m2();</span><br><span class="line">                   &#125; </span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">Inner02</span> <span class="variable">inner02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner02</span>();</span><br><span class="line">        inner02.f1();</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>匿名内部类</li>
<li>匿名内部类本质是类，一个内部类，该类没有名字，匿名内部类同时还是一个对象</li>
<li>位置:匿名内部类是定义在<code>外部类的局部位置</code>，<code>比如方法中</code>，并且<code>没有类名</code></li>
<li>不能添加访问修饰符，因为它的地位就是一个局部变量。</li>
<li>作用域:仅仅在定义它的方法或代码块中。</li>
<li>匿名内部类<code>直接访问</code>外部类成员,包含私有的[访问方式:直接访问]</li>
<li>外部其他类—<code>不能访问</code>-----&gt;匿名内部类(因为匿名内部类地位是一个局部变量)</li>
<li>如果外部类和匿名内部类的<code>成员重名</code>时，匿名内部类访问的话，默认遵循<code>就近原则</code>，如果想访问外部类的成员，则可以使用(<code>外部类名.this.成员 </code>)去访问</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Outer05</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//匿名内部类</span></span><br><span class="line">       <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>()&#123;</span><br><span class="line">          <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">88</span>; <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;Outer05.this hashcode=&quot;</span> + Outer05.<span class="built_in">this</span>);</span><br><span class="line">               &#125; </span><br><span class="line">       &#125;;</span><br><span class="line">       p.hi();</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//当做实参直接传递，简洁高效 </span></span><br><span class="line">  f1(<span class="keyword">new</span> <span class="title class_">IL</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;这是一副名画~~...&quot;</span>); </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//传统方法 </span></span><br><span class="line">  f1(<span class="keyword">new</span> <span class="title class_">Picture</span>());</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>成员内部类</p>
</li>
<li>
<p>位置:成员内部类是定义在<code>外部类的成员位置</code>，并且<code>没有static修饰</code>。</p>
</li>
<li>
<p>可以<code>直接访问</code>外部类的所有成员，包含私有的</p>
</li>
<li>
<p>可以<code>添加任意访问修饰符</code>(public、protected 、默认、private),因为其地位就是一个成员。</p>
</li>
<li>
<p>作用域和外部类的其他成员一样，为整个类体</p>
</li>
<li>
<p>成员内部类<code>直接访问</code>外部类成员</p>
</li>
<li>
<p>外部类可以<code>访问</code>成员内部类       <code>访问方式:创建对象， 再访问</code></p>
</li>
<li>
<p>外部其他类<code>可以访问</code>成员内部类</p>
<ul>
<li>方式一   outer08.new Inner08(); 相当于把 new Inner08()当做是 outer08 成员  <code>Outer08.Inner08 inner08 = outer08.new Inner08(); inner08.say();</code></li>
<li>方式二	在外部类中，编写一个方法，可以返回 Inner08 对象   <code> Outer08.Inner08 inner08Instance = outer08.getInner08Instance(); inner08Instance.say();</code></li>
</ul>
</li>
<li>
<p>如果外部类和内部类的<code>成员重名</code>时，内部类访问的话，默认遵循<code>就近原则</code>，如果想访问外部类的成员，则可以使用(<code>外部类名.this.成员</code>) 去访问</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">           <span class="type">Outer08</span> <span class="variable">outer08</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer08</span>(); </span><br><span class="line">           outer08.t1();</span><br><span class="line">           <span class="comment">//外部其他类，使用成员内部类的三种方式</span></span><br><span class="line">           <span class="comment">// 第一种方式 </span></span><br><span class="line">           <span class="comment">// outer08.new Inner08(); 相当于把 new Inner08()当做是 outer08 成员 </span></span><br><span class="line">           Outer08.<span class="type">Inner08</span> <span class="variable">inner08</span> <span class="operator">=</span> outer08.<span class="keyword">new</span> <span class="title class_">Inner08</span>();</span><br><span class="line">           inner08.say();</span><br><span class="line">           <span class="comment">// 第二方式 在外部类中，编写一个方法，可以返回 Inner08 对象 </span></span><br><span class="line">           Outer08.<span class="type">Inner08</span> <span class="variable">inner08Instance</span> <span class="operator">=</span> outer08.getInner08Instance(); </span><br><span class="line">           inner08Instance.say();</span><br><span class="line">       &#125; </span><br><span class="line">      <span class="keyword">class</span> <span class="title class_">Outer08</span> &#123; <span class="comment">//外部类 </span></span><br><span class="line">          <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">          <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123; </span><br><span class="line">              System.out.println(<span class="string">&quot;hi()方法...&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line"><span class="comment">//成员内部类</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner08</span> &#123;</span><br><span class="line">          <span class="keyword">private</span> <span class="type">double</span> <span class="variable">sal</span> <span class="operator">=</span> <span class="number">99.8</span>; </span><br><span class="line">          <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">66</span>; </span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;n1 = &quot;</span> + n1 + <span class="string">&quot; name = &quot;</span> + name + <span class="string">&quot; 外部类的 n1=&quot;</span> + Outer08.<span class="built_in">this</span>.n1);</span><br><span class="line">              hi();</span><br><span class="line">          &#125; </span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> Inner08 <span class="title function_">getInner08Instance</span><span class="params">()</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner08</span>(); </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">t1</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="type">Inner08</span> <span class="variable">inner08</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner08</span>();</span><br><span class="line">           inner08.say();</span><br><span class="line">           System.out.println(inner08.sal); </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>静态内部类</p>
</li>
<li>
<p>位置:静态内部类是定义在<code>外部类的成员位置</code>，并且<code>有static修饰</code></p>
</li>
<li>
<p>可以<code>直接访问</code>外部类的所有静态成员，包含私有的，但不能直接访问非静态成员</p>
</li>
<li>
<p>可以<code>添加任意访问修饰符</code>(public protected、 默认、private),因为其地位就是一个成员。</p>
</li>
<li>
<p>作用域:同其他的成员，为整个类体</p>
</li>
<li>
<p>静态内部类<code>直接访问</code>外部类(此如:静态属性) [可直接访问所有静态成员]</p>
</li>
<li>
<p>外部类<code>可访问</code>静态内部类       <code>访问方式:创建对象，再访问</code></p>
</li>
<li>
<p>外部其他类<code>可以访问</code>静态内部类</p>
</li>
<li>
<p><code>方式一</code>：因为静态内部类，是可以通过类名直接访问(前提是满足访问权限</p>
</li>
<li>
<p><code>方式二</code>：编写一个方法，可以返回静态内部类的对象实例</p>
</li>
<li>
<p>如果外部类和静态内部类的<code>成员重名</code>时，静态内部类访问的时，默认遵循<code>就近原则</code>，如果想访问外部类的成员，则可以使用(<code>外部类名.成员</code>) 去访问</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Outer10</span> <span class="variable">outer10</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer10</span>(); </span><br><span class="line">   outer10.m1();</span><br><span class="line">  <span class="comment">//方式 1</span></span><br><span class="line">  Outer10.<span class="type">Inner10</span> <span class="variable">inner10</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer10</span>.Inner10();</span><br><span class="line">  inner10.say();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//方式 2</span></span><br><span class="line">   Outer10.<span class="type">Inner10</span> <span class="variable">inner101</span> <span class="operator">=</span> outer10.getInner10();</span><br><span class="line">   inner101.say();</span><br><span class="line">&gt;&#125; </span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Outer10</span> &#123; </span><br><span class="line">   <span class="comment">//外部类 </span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//Inner10 就是静态内部类</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner10</span> &#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;李四&quot;</span>; </span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">           System.out.println(name + <span class="string">&quot; 外部类 name= &quot;</span> + Outer10.name);</span><br><span class="line">           cry();</span><br><span class="line">       &#125; </span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123; <span class="comment">//外部类---访问------&gt;静态内部类 访问方式:创建对象，再访问 </span></span><br><span class="line">       <span class="type">Inner10</span> <span class="variable">inner10</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner10</span>();</span><br><span class="line">       inner10.say();</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">public</span> Inner10 <span class="title function_">getInner10</span><span class="params">()</span> &#123; </span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner10</span>();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Inner10 <span class="title function_">getInner10_</span><span class="params">()</span> &#123; </span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner10</span>();</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Java中阶">Java中阶</h2>
<h3 id="枚举">枚举</h3>
<blockquote>
<p>两种实现的方式：</p>
<ul>
<li>
<p>自定义类实现枚举</p>
</li>
<li>
<p>不需要提供setXxx方法，因为枚举对象值通常为只读，并将构造器私有化,目的防止直接 new</p>
</li>
<li>
<p>对枚举对象/属性使用final + static 共同修饰，实现底层优化.</p>
</li>
<li>
<p>枚举对象名通常使用全部大写，常量的命名规范.</p>
</li>
<li>
<p>枚举对象根据需要，也可以有多个属性</p>
</li>
<li>
<p>小结：进行自定义类实现枚举，有如下特点：</p>
</li>
<li>
<p>构造器私有化</p>
</li>
<li>
<p>本类内部创建一组对象</p>
</li>
<li>
<p>对外暴露对象（通过为对象添加 <code>public final static</code> 修饰符）</p>
</li>
<li>
<p>可以提供 get 方法，但是不要提供 set</p>
</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span> &#123;<span class="comment">//类	</span></span><br><span class="line">    <span class="keyword">private</span> String name; </span><br><span class="line">    <span class="keyword">private</span> String desc;<span class="comment">//描述</span></span><br><span class="line">	<span class="comment">//定义了四个对象, 固定.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;温暖&quot;</span>); </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;寒冷&quot;</span>); </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;凉爽&quot;</span>); </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;炎热&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name, String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>使用enum关键字实现枚举</p>
</li>
<li>
<p>使用关键字 enum 替代 class</p>
</li>
<li>
<p><code>public static final Season SPRING = new Season(&quot;春天&quot;, &quot;温暖&quot;) </code>直接改为  <code>SPRING(&quot;春天&quot;, &quot;温暖&quot;) </code>  即   <code>常量名(实参列表) </code></p>
</li>
<li>
<p>如果有多个常量(对象)， 使用 ,号间隔即可</p>
</li>
<li>
<p>如果使用 enum 来实现枚举，要求将定义常量对象写在前面</p>
</li>
<li>
<p>如果我们使用的是无参构造器，创建常量对象，则可以省略 ()</p>
</li>
<li>
<p>PS：</p>
</li>
<li>
<p>当我们使用 enum 关键字开发一个枚举类时，默认会继承 Enum 类, 而且是一个 final 类</p>
</li>
<li>
<p>传统的 public static final Season2 SPRING = new Season2(“春天”, “温暖”); 简化成 SPRING(“春天”, “温暖”)， 这里必须知道，它调用的是哪个构造器.</p>
</li>
<li>
<p>如果使用无参构造器 创建 枚举对象，则实参列表和小括号都可以省略</p>
</li>
<li>
<p>当有多个枚举对象时，使用,间隔，最后有一个分号结尾</p>
</li>
<li>
<p>枚举对象必须放在枚举类的行首</p>
</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Season2</span> &#123;<span class="comment">//类</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;温暖&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;寒冷&quot;</span>), </span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;凉爽&quot;</span>), </span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;炎热&quot;</span>)<span class="comment">/*, What()*/</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc;<span class="comment">//描述</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season2</span><span class="params">()</span> &#123;<span class="comment">//无参构造器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season2</span><span class="params">(String name, String desc)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>枚举的常用方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="number">1</span>) toString:Enum 类已经重写过了，返回的是当前对象 名,子类可以重写该方法，用于返回对象的属性信息</span><br><span class="line"></span><br><span class="line">&gt;<span class="number">2</span>) name:返回当前对象名(常量名)，子类中不能重写</span><br><span class="line"></span><br><span class="line">&gt;<span class="number">3</span>) ordinal:返回当前对象的位置号，默认从 <span class="number">0</span> 开始</span><br><span class="line"></span><br><span class="line">&gt;<span class="number">4</span>) values:返回当前枚举类中所有的常量</span><br><span class="line"></span><br><span class="line">&gt;<span class="number">5</span>) valueOf:将字符串转换成枚举对象，要求字符串必须为已有的常量名，否则报异常</span><br><span class="line"></span><br><span class="line">&gt;<span class="number">6</span>) compareTo:比较两个枚举常量，比较的就是编号</span><br></pre></td></tr></table></figure>
<p><strong>enum 实现接口</strong></p>
<ul>
<li>
<p>使用enum关键字后，就不能再继承其它类了，因为enum会隐式继承Enum，而Java是单继承机制。</p>
</li>
<li>
<p>枚举类和普通类一样，可以实现接口，因为enum 实现的枚举类，仍然是一个类，所以还是可以实现接口的.形式为：</p>
</li>
</ul>
<p><code>enum 类名 implements 接口 1，接口 2&#123; &#125; </code></p>
</blockquote>
<h3 id="注解">注解</h3>
<blockquote>
<p>注解(Annotation)也被称为元数据(Metadata)，用于修饰解释包、类、方法、属性、构造器、局部变量等数据信息</p>
<p>**三个基本的 Annotation: **</p>
<ul>
<li>
<p>@Override: 限定某个方法，是重写父类方法, 该注解只能用于方法</p>
</li>
<li>
<p>@Deprecated: 用于表示某个程序元素(类, 方法等)已过时</p>
</li>
<li>
<p>@Target(value= {CONSTRUCTOR, FIELD, LOCAL VARIABLE, METHOD,PACKAGE,PARAMETER, TYPE})</p>
</li>
<li>
<p>@SuppressWarnings: 抑制编译器警告</p>
</li>
</ul>
<p><strong>元注解</strong></p>
<ol>
<li>Retention        指定注解的作用范围，三种 SOURCE,CLASS,RUNTIME</li>
<li>Target            指定注解可以在哪些地方使用</li>
<li>Documented  指定该注解是否会在 javadoc 体现</li>
<li>Inherited        子类会继承父类注解</li>
</ol>
</blockquote>
<h3 id="异常">异常</h3>
<blockquote>
<ul>
<li>
<p>异常分为两大类，运行时异常和编译时异常.</p>
</li>
<li>
<p>编译异常是指在编译期间，就必须处理的异常，否则代码不能通过编译。</p>
</li>
<li>
<p>运行时异常，编译器检查不出来。一般是指编程时的逻辑错误</p>
</li>
<li>
<p>异常处理</p>
</li>
<li>
<p>try-catch-finally</p>
</li>
<li>
<p>如果异常发生了， 则异常发生后面的代码不会执行，直接进入到catch块</p>
</li>
<li>
<p>如果异常没有发生，则顺序执行try的代码块，不会进入到catch.</p>
</li>
<li>
<p>如果希望<code>不管是否发生异常</code>，都执行某段代码(比如关闭连接，释放资源等)则使用finally {}</p>
</li>
<li>
<p>可以有多个catch语句，捕获不同的异常(进行不同的业务处理)，要求父类异常在后，子类异常在前，比如(Exception 在后，NullPointerException 在前)，如果发生异常，只会	匹配一个catch</p>
</li>
<li>
<p>可以进行 try-finally配合使用，但是这种用法相当于没有捕获异常， 因此程序会直接崩掉/退出。应用场景，就是执行一段代码，不管是否发生异常，都必须执行某个业务逻辑</p>
</li>
<li>
<p><strong>不要在 finally 语句块中使用 return!</strong> 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</p>
</li>
<li>
<p>throws</p>
</li>
<li>
<p>如果个方法(中的语句执行时)可能生成某种异常  但是并不能确定如何处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。</p>
</li>
<li>
<p>在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。</p>
</li>
<li>
<p>对于编译异常，程序中必须处理，比如try-catch或者throws</p>
</li>
<li>
<p>对于运行时异常，程序中如果没有处理，默认就是throws的方式处理</p>
</li>
<li>
<p>子类重写父类的方法时，对抛出异常的<code>规定</code>:子类重写的方法，所抛出的异常型要么和父类抛出的异常一致， 要么为父类抛出的异常的类型的子类型</p>
</li>
<li>
<p>在throws过程中，如果有方法try-catch，就相当于处理异常，就可以不必throws</p>
</li>
<li>
<p>自定义异常</p>
</li>
<li>
<p>当程序中出现了某些&quot;错误”,但该错误信息并没有在Throwable子类中描述处理，这个时候可以自己设计异常类，用于描述该错误信息。</p>
</li>
<li>
<p>步骤：</p>
<ul>
<li>定义类:自定义异常类名(程序员自己写)继承Exception或RuntimeException</li>
<li>如果继承Exception,属于编译异常</li>
<li>如果继承RuntimeException,属于运行异常(一般都是继承RuntimeException)</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">throw</span> 和 <span class="keyword">throws</span> 的区别<span class="keyword">class</span> <span class="title class_">AgeException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123; </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">AgeException</span><span class="params">(String message)</span> &#123;<span class="comment">//构造器</span></span><br><span class="line">       <span class="built_in">super</span>(message); </span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">if</span>(!(age &gt;= <span class="number">18</span> &amp;&amp; age &lt;= <span class="number">120</span>)) &#123;</span><br><span class="line">   <span class="comment">//这里我们可以通过构造器，设置信息</span></span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeException</span>(<span class="string">&quot;年龄需要在 18~120 之间&quot;</span>);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>throw 和 throws 的区别</strong></p>
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304091500359.png" alt="image-20230409150018185" style="zoom: 33%;">
</blockquote>
<h2 id="Java高阶">Java高阶</h2>
<h3 id="常用类">常用类</h3>
<h5 id="String"><code>String</code></h5>
<blockquote>
<p>String 有属性 private final char value[]; 用于存放字符串内容<br>
一定要注意:value 是一个 final 类型， 不可以修改:即 value 不能指向新的地址，但是单个字符内容是可以变化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">final</span> <span class="type">char</span>[] value = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">&gt;<span class="type">char</span>[] v2 = &#123;<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;m&#x27;</span>&#125;;</span><br><span class="line">&gt;value[<span class="number">0</span>] = <span class="string">&#x27;H&#x27;</span>;</span><br><span class="line">&gt;<span class="comment">//value = v2; 不可以修改 value 地址</span></span><br></pre></td></tr></table></figure>
<ul>
<li>创建：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot; &quot;</span>;</span><br><span class="line">&gt;<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sting</span>(<span class="string">&quot; &quot;</span>);</span><br></pre></td></tr></table></figure>
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304080013744.png" alt="image-20230408001304669" style="zoom:25%;">
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304080015501.png" alt="image-20230408001500427" style="zoom:33%;">
<ul>
<li>equals   比较内容是否相同，区分大小写</li>
<li>equalsIgnoreCase 忽略大小写的判断内容是否相等</li>
<li>length 获取字符的个数，字符串的长度</li>
<li>indexOf 获取字符在字符串对象中第一次出现的索引，索引从 0 开始，如果找不到，返回-1</li>
<li>lastIndexOf 获取字符在字符串中最后一次出现的索引，索引从 0 开始，如果找不到，返回-1</li>
<li>substring 截取指定范围的子串<code>name.substring(6);//截取索引 [6开始的 后面的字符</code>    <code>name.substring(0,5)表示从索引 0 开始截取，截取到索引 5-1=4 位置</code></li>
<li>toUpperCase 转换成大写</li>
<li>toLowerCase 转换成小写</li>
<li>concat 拼接字符串</li>
<li>replace 替换字符串中的字符     s11=s1.replace() 方法执行后，返回的结果(s11)才是替换过的.      注意对 s1 没有任何影响</li>
<li>split 分割字符串, 对于某些分割字符，我们需要 转义比如 | \等   在对字符串进行分割时，如果有特殊字符，需要加入 转义符 \</li>
<li>toCharArray 转换成字符数组</li>
<li>compareTo比较两个字符串的大小，如果前者大，则返回正数，后者大，则返回负数，如果相等，返回0</li>
<li>(1)如果长度相同，并且每个字符也相同，就返回0</li>
<li>(2)如果长度相同或者不相同，但是在进行比较时，可以区分大小就返回<code>if(c1!=c2)&#123;return c1-c2;&#125;</code><br>
如果前面的部分都相同，就返回<code>strl.len-str2.len</code></li>
<li>format 格式字符串<code>占位符有:%s 字符串 %c 字符 %d 整型 %.2f 浮点型</code></li>
</ul>
</blockquote>
<h5 id="StringBuffer"><code>StringBuffer</code></h5>
<blockquote>
<p>StringBuffer 是一个 final 类，不能被继承<br>
因为 StringBuffer 字符内容是存在 char[] value, 所有的变化(增加/删除)都不用每次更换地址(即不是每次创建新对象)， 所以效率高于 String</p>
<p><strong>对比String</strong></p>
<p>1)String保存的是字符串常量，里面的值不能更改，每次String类的更新实际上就是更改地址，效率较低/private final char value[I:<br>
2)StringBuffer保存的是字符串变量，里面的值可以更改，每次StringBuffer的更新实际上可以更新内容，不用每次更新地址，效率较高<br>
char[value];这个放在堆.</p>
<p><strong>与String的相互转化</strong></p>
<p>1、String——&gt;StringBuffer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//方式 1 使用构造器</span></span><br><span class="line">&gt;<span class="comment">//注意: 返回的是 StringBuffer 对象，对 str 本身没有影响 </span></span><br><span class="line">&gt;<span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str);</span><br><span class="line">&gt;<span class="comment">//方式 2 使用的是 append 方法</span></span><br><span class="line">&gt;<span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">&gt;stringBuffer1 = stringBuffer.append(str);</span><br></pre></td></tr></table></figure>
<p>2、StringBuffer -&gt;String</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;韩顺平教育&quot;</span>); </span><br><span class="line">&gt;<span class="comment">//方式 1 使用 StringBuffer 提供的 toString 方法</span></span><br><span class="line">&gt;<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stringBuffer.toString();</span><br><span class="line">&gt;<span class="comment">//方式 2: 使用构造器来搞定</span></span><br><span class="line">&gt;<span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(stringBuffer);</span><br></pre></td></tr></table></figure>
<p><strong>常用方法</strong></p>
<p>append()      追加元素</p>
<p>delete()        删除元素：删除索引为&gt;=start &amp;&amp; &lt;end 处的字符</p>
<p>replace()      替换元素 索引[ start ,end)</p>
<p>indexOf()      查找指定的子串在字符串第一次出现的索引</p>
<p>insert()         在指定索引的位置插入 指定元素</p>
</blockquote>
<h5 id="StringBuilder"><code>StringBuilder </code></h5>
<blockquote>
<p>1)一个可变的字符序列。此类提供一个与StringBuffer兼容的API,但不保证同步(StringBuilder不是线程安全)。该类被设计用作StringBuffer的一个简易<br>
替换，用在字符串缓冲区被单个线程使用的时候。如果可能，建议优先采用该类因为在大多数实现中，它比StringBuffer要快。<br>
2)在StringBuilder上的主要操作是append和insert方法，可重载这些方法，以接受任意类型的数据。</p>
</blockquote>
<p><strong>String、StringBuffer 和 StringBuilder 的比较</strong></p>
<blockquote>
<p>1)StringBuilder和StringBuffer非常类似，均代表可变的字符序列，而且方法也一样<br>
2)String:不可变字符序列，效率低，线程安全<br>
3)StringBuffer:可变字符序列、效率较高（增删）、有同步锁线程安全，<br>
4)StringBuilder:可变字符序列、效率最高、无同步锁，线程不安全<br>
5)String使用注意说明：<br>
string s=“a”      创建了一个字符串<br>
s+=“b”   实际上原来的&quot;a&quot;字符串对象已经丢弃了，现在又产生了一个字符串s+“b”(也就是&quot;ab”)。如果多次执行这些改变串内容的操作，会导致大量副<br>
本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能</p>
<p>=&gt;结论：如果我们对String做大量修改，不要使用String</p>
</blockquote>
<p><strong>String、StringBuffer 和 StringBuilder 的选择</strong></p>
<blockquote>
<p>使用的原则，结论：<br>
1.如果字符串存在大量的修改操作，一般使用StringBuffer或String Builder<br>
2.如果字符串存在大量的修改操作，并在单线程的情况，使用StringBuilder<br>
3.如果字符串存在大量的修改操作，并在多线程的情况，使用StringBuffer<br>
4.如果我们字符串很少修改，被多个对象引用，使用String,比如配置信息等</p>
</blockquote>
<h5 id="Math"><code>Math</code></h5>
<blockquote>
<p>abs 绝对值</p>
<p>pow 求幂</p>
<p>ceil 向上取整,返回&gt;=该参数的最小整数(转成 double);  3.9   就是 4</p>
<p>floor 向下取整，返回&lt;=该参数的最大整数(转成 double)</p>
<p>round 四舍五入 Math.floor(该参数+0.5)</p>
<p>sqrt 求开方</p>
<p>random 求随机数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;获取 a-b 之间的一个随机整数,a,b 均为整数        (<span class="type">int</span>)(a + Math.random() * (b-a +<span class="number">1</span>) )</span><br><span class="line">&gt;<span class="comment">//Math.random() * (b-a) 返回的就是 0 &lt;= 数 &lt;= b-a</span></span><br><span class="line"></span><br><span class="line">&gt;(<span class="type">int</span>)(a) &lt;= x &lt;= (<span class="type">int</span>)(a + Math.random() * (b-a +<span class="number">1</span>) )</span><br><span class="line">&gt;&gt;    Math.random()*<span class="number">6</span> 返回的是 <span class="number">0</span> &lt;= x &lt; <span class="number">6</span> 小数</span><br><span class="line">&gt;<span class="number">2</span> + Math.random()*<span class="number">6</span> 返回的就是 <span class="number">2</span>&lt;= x &lt; <span class="number">8</span> 小数</span><br><span class="line">&gt;&gt;(<span class="type">int</span>)(<span class="number">2</span> + Math.random()*<span class="number">6</span>) = <span class="number">2</span> &lt;= x &lt;= <span class="number">7</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="Arrays"><code>Arrays</code></h5>
<blockquote>
<p>toString()   将数组转换为字符串类型</p>
<p>sort()         进行排序</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;定制排序</span><br><span class="line">&gt;&gt;Arrays.sort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123; <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123; </span><br><span class="line">      <span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> (Integer) o1;</span><br><span class="line">      <span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> (Integer) o2;</span><br><span class="line">      <span class="keyword">return</span> i2 - i1;</span><br><span class="line">  &#125; </span><br><span class="line">&gt;&gt;&#125;);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>binarySerach()   对排好序的数组进行二分查找     如果数组中不存在该元素，就返回 return -(low + 1);</p>
<p>copyof()      数组元素的复制</p>
<blockquote>
<ul>
<li>如果拷贝的长度 &gt; arr.length 就在新数组的后面 增加 null</li>
</ul>
<blockquote>
<ul>
<li>如果拷贝长度 &lt; 0 就抛出异常 NegativeArraySizeException</li>
</ul>
</blockquote>
</blockquote>
<p>fill()            数组元素的填充</p>
<p>equals()      比较两个元素内容是不是完全一致的</p>
<p>asList()       将一组值转换为  List 集合   <code>List asList = Arrays.asList(2,3,4,5,6,1);</code></p>
</blockquote>
<h5 id="System"><code>System</code></h5>
<blockquote>
<p>exit(0) 表示程序退出     0 表示一个状态 , 正常的状态</p>
<p>arraycopy :复制数组元素，比较适合底层调用， 一般使用 Arrays.copyOf 完成复制数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">System.arraycopy(src, <span class="number">0</span>, dest, <span class="number">0</span>, src.length);</span><br><span class="line"></span><br><span class="line">	src 源数组   	 </span><br><span class="line"> srcPos  从源数组的哪个索引位置开始拷贝     </span><br><span class="line"> dest 目标数组，即把源数组的数据拷贝到哪个数组</span><br><span class="line"> destPos: 把源数组的数据拷贝到 目标数组的哪个索引        	 </span><br><span class="line"> length: 从源数组拷贝多少个数据到目标数组</span><br></pre></td></tr></table></figure>
<p>currentTimeMillens:      返回当前时间距离 1970-1-1 的毫秒数</p>
<p>gc:    运行垃圾回收机制     System.gc()</p>
</blockquote>
<p><code>BigInteger BigDecimal </code></p>
<blockquote>
<p>add           加</p>
<p>substract   减</p>
<p>multiply     乘</p>
<p>divide        除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">BigInteger</span> <span class="variable">bigInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;23788888899999999999999999999&quot;</span>);</span><br><span class="line">&gt;<span class="type">BigInteger</span> <span class="variable">bigInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;23788888899999999999999999999999999&quot;</span>);</span><br><span class="line">&gt;&gt;<span class="type">BigInteger</span> <span class="variable">add</span> <span class="operator">=</span> bigInteger.add(bigInteger2);</span><br><span class="line">&gt;<span class="type">BigInteger</span> <span class="variable">subtract</span> <span class="operator">=</span> bigInteger.subtract(bigInteger2);</span><br><span class="line">&gt;<span class="type">BigInteger</span> <span class="variable">multiply</span> <span class="operator">=</span> bigInteger.multiply(bigInteger2);</span><br><span class="line">&gt;<span class="type">BigInteger</span> <span class="variable">divide</span> <span class="operator">=</span> bigInteger.divide(bigInteger2);</span><br><span class="line">&gt;<span class="comment">//System.out.println(bigDecimal.divide(bigDecimal2));</span></span><br><span class="line">&gt;<span class="comment">//可能抛出异常 ArithmeticException </span></span><br><span class="line">&gt;&gt;<span class="comment">//在调用 divide 方法时，指定精度即可. BigDecimal.ROUND_CEILING </span></span><br><span class="line">&gt;<span class="comment">//如果有无限循环小数，就会保留 分子 的精度 System.out.println(bigDecimal.divide(bigDecimal2, BigDecimal.ROUND_CEILING));</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="Date"><code>Date</code></h5>
<blockquote>
<p><strong>第一代</strong></p>
<p>1)Date:精确到毫秒，代表特定的瞬间<br>
2)SimpleDateFormat:格式和解析日期的类 SimpleDateFormat格式化和解析日期的具体类。它允许进行格式化（日期-&gt;文本）解析（文本-&gt;日期）和规范化.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//创建 SimpleDateFormat 对象，可以指定相应的格式</span></span><br><span class="line">&gt;<span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy 年 MM 月 dd 日 hh:mm:ss E&quot;</span>); </span><br><span class="line">&gt;<span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> sdf.format(d1); </span><br><span class="line">&gt;<span class="comment">// format:将日期转换成指定格式的字符串 System.out.println(&quot;当前日期=&quot; + format);</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//可以把一个格式化的 String 转成对应的 Date</span></span><br><span class="line">&gt;<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;1996 年 01 月 01 日 10:20:30 星期一&quot;</span>;</span><br><span class="line">&gt;<span class="type">Date</span> <span class="variable">parse</span> <span class="operator">=</span> sdf.parse(s);</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>第二代</strong></p>
<p>Calendar 是一个抽象类， 并且构造器是 private</p>
<p>可以通过 getInstance() 来获取实例</p>
<p>如果我们需要按照 24 小时进制来获取时间， Calendar.HOUR ==改成=&gt; Calendar.HOUR_OF_DAY</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance(); <span class="comment">//创建日历类对象//比较简单，自由</span></span><br><span class="line">&gt;<span class="comment">//2.获取日历对象的某个日历字段</span></span><br><span class="line">&gt;System.out.println(<span class="string">&quot;年:&quot;</span> + c.get(Calendar.YEAR));</span><br><span class="line">&gt;System.out.println(<span class="string">&quot;月:&quot;</span> + (c.get(Calendar.MONTH) + <span class="number">1</span>));<span class="comment">// 这里为什么要 + 1, 因为 Calendar 返回月时候，是按照 0 开始编号</span></span><br><span class="line">&gt;System.out.println(<span class="string">&quot;日:&quot;</span> + c.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">&gt;System.out.println(<span class="string">&quot;小时:&quot;</span> + c.get(Calendar.HOUR));</span><br><span class="line">&gt;System.out.println(<span class="string">&quot;分钟:&quot;</span> + c.get(Calendar.MINUTE));</span><br><span class="line">&gt;System.out.println(<span class="string">&quot;秒:&quot;</span> + c.get(Calendar.SECOND));</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>第三代</strong></p>
<p>LocalDatel只包含日期，可以获取日期字段<br>
LocalTime.只包含时间，可以获取时间字段<br>
LocalDateTime包含日期+时间，可以获取日期和时间字段</p>
<p>Instant 时间戳</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//1. 使用 now() 返回表示当前日期时间的 对象</span></span><br><span class="line">&gt;<span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now(); <span class="comment">//LocalDate.now(); 可以获取年月日    //LocalTime.now() 获取到时分秒</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//2. 使用 DateTimeFormatter 对象来进行格式化</span></span><br><span class="line">&gt;<span class="comment">// 创建 DateTimeFormatter 对象</span></span><br><span class="line">&gt;<span class="type">DateTimeFormatter</span> <span class="variable">dateTimeFormatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>); <span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> dateTimeFormatter.format(ldt);</span><br><span class="line">&gt;System.out.println(<span class="string">&quot;年=&quot;</span> + ldt.getYear()); </span><br><span class="line">&gt;System.out.println(<span class="string">&quot;月=&quot;</span> + ldt.getMonth());</span><br><span class="line">&gt;System.out.println(<span class="string">&quot;月=&quot;</span> + ldt.getMonthValue()); </span><br><span class="line">&gt;System.out.println(<span class="string">&quot;日=&quot;</span> + ldt.getDayOfMonth());</span><br><span class="line">&gt;System.out.println(<span class="string">&quot;时=&quot;</span> + ldt.getHour()); </span><br><span class="line">&gt;System.out.println(<span class="string">&quot;分=&quot;</span> + ldt.getMinute());</span><br><span class="line">&gt;System.out.println(<span class="string">&quot;秒=&quot;</span> + ldt.getSecond());</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//看看 890 天后，是什么时候 把 年月日-时分秒</span></span><br><span class="line">&gt;<span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> ldt.plusDays(<span class="number">890</span>);</span><br><span class="line">&gt;<span class="comment">//看看在 3456 分钟前是什么时候，把 年月日-时分秒输出</span></span><br><span class="line">&gt;<span class="type">LocalDateTime</span> <span class="variable">localDateTime2</span> <span class="operator">=</span> ldt.minusMinutes(<span class="number">3456</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//1.通过 静态方法 now() 获取表示当前时间戳的对象 </span></span><br><span class="line">&gt;<span class="type">Instant</span> <span class="variable">now</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">&gt;<span class="comment">//2. 通过 from 可以把 Instant 转成 Date</span></span><br><span class="line">&gt;<span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> Date.from(now);</span><br><span class="line">&gt;<span class="comment">//3. 通过 date 的 toInstant() 可以把 date 转成 Instant 对象 </span></span><br><span class="line">&gt;<span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> date.toInstant();</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="包装类">包装类</h5>
<blockquote>
<p>装箱： 基本数据类型———&gt; 包装类型</p>
</blockquote>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//jdk5 前是手动装箱和拆箱 </span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//手动装箱 int-&gt;Integer</span></span><br><span class="line">&gt;<span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">&gt;<span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(n1); </span><br><span class="line">&gt;<span class="type">Integer</span> <span class="variable">integer1</span> <span class="operator">=</span> Integer.valueOf(n1);</span><br><span class="line">&gt;<span class="comment">//手动拆箱</span></span><br><span class="line">&gt;<span class="comment">//Integer -&gt; int</span></span><br><span class="line">&gt;<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> integer.intValue();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//jdk5 后，就可以自动装箱和自动拆箱</span></span><br><span class="line">&gt;<span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">&gt;<span class="comment">//自动装箱 int-&gt;Integer</span></span><br><span class="line">&gt;<span class="type">Integer</span> <span class="variable">integer2</span> <span class="operator">=</span> n2; <span class="comment">//底层使用的是 Integer.valueOf(n2) </span></span><br><span class="line">&gt;<span class="comment">//自动拆箱 Integer-&gt;int</span></span><br><span class="line">&gt;<span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> integer2; <span class="comment">//底层仍然使用的是 intValue()方法</span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>包装类型和 String 类型的相互转换</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//包装类(Integer)-&gt;String </span></span><br><span class="line">&gt;<span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">//自动装箱</span></span><br><span class="line">&gt;<span class="comment">//方式 1</span></span><br><span class="line">&gt;<span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">&gt;<span class="comment">//方式 2</span></span><br><span class="line">&gt;<span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> i.toString(); </span><br><span class="line">&gt;<span class="comment">//方式 3</span></span><br><span class="line">&gt;<span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//String -&gt; 包装类(Integer)</span></span><br><span class="line">&gt;<span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;12345&quot;</span>;</span><br><span class="line">&gt;<span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> Integer.parseInt(str4);<span class="comment">//使用到自动装箱 </span></span><br><span class="line">&gt;<span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(str4);<span class="comment">//构造器</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="集合">集合</h3>
<h5 id="ArrayList"><code>ArrayList</code>:</h5>
<blockquote>
<p>add:添加单个元素                <code>list.add(&quot;jack&quot;);</code></p>
<p>remove:删除指定元素           <code>list.remove(true)</code>   指定元素</p>
<p>contains:查找元素是否存在   <code>list.contains(&quot;jack&quot;)</code></p>
<p>size:获取元素个数                <code>list.size()</code></p>
<p>isEmpty:判断是否为空</p>
<p>clear:清空</p>
<p>addAll:添加多个元素</p>
<p>containsAll:查找多个元素是否都存在</p>
<p>removeAll:删除多个元素</p>
</blockquote>
<blockquote>
<p><strong>底层结构和源码分析</strong></p>
<p>1)ArrayListr中维护了一个Object类型的数组elementData.<br>
transient Object[]elementData;//transient:表示瞬间，短暂的，表示该属性不会被序列号<br>
2)当创建ArrayList对象时，如果使用的是无参构造器，则初始elementData容量为0，第1次添加，则扩容elementData为10，如需要再次扩容，则扩容elementData为1.5倍。<br>
3)如果使用的是指定大小的构造器，则初始elementData容量为指定大小，如果需要扩容，则直接扩容elementData为1.5倍。</p>
<p>但是 vector是扩容2倍</p>
</blockquote>
<h5 id="list"><code>list</code></h5>
<blockquote>
<ul>
<li>void add(int index, Object ele):在 index 位置插入 ele 元素</li>
<li>boolean addAll(int index, Collection eles):从 index 位置开始将 eles 中的所有元素添加进来</li>
<li>Object get(int index):获取指定 index 位置的元素</li>
<li>int indexOf(Object obj):返回 obj 在集合中首次出现的位置</li>
<li>int lastIndexOf(Object obj):返回 obj 在当前集合中末次出现的位置</li>
<li>Object remove(int index):移除指定 index 位置的元素，并返回此元素</li>
<li>Object set(int index, Object ele):设置指定 index 位置的元素为 ele , 相当于是替换.</li>
<li>List subList(int fromIndex, int toIndex):返回从 fromIndex 到 toIndex 位置的子集合    <code>[  )</code>     =&gt;     fromIndex &lt;= subList &lt; toIndex</li>
</ul>
</blockquote>
<h5 id="LinkedList"><code>LinkedList</code></h5>
<blockquote>
<p>1)LinkedList底层维护了一个双向链表.<br>
2)LinkedList中维护了两个属性first和last分别指向首节点和尾节点<br>
3)每个节点(Node对象)，里面又维护了prev、next、item三个属性，其中通过prev指向前一个，通过next指向后一个节点。最终实现双向链表.<br>
4)所以LinkedList的元素的添加和删除，不是通过数组完成的，相对来说效率较高。</p>
</blockquote>
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304072339888.png" alt="image-20230407233906818" style="zoom:33%;">
<h5 id="Set"><code>Set</code></h5>
<p><code>HashSet</code></p>
<blockquote>
<p><strong>添加元素的底层实现</strong></p>
<p>1.HashSet底层是HashMap<br>
2.添加一个元素时，先得到hash值会转成-&gt;索引值<br>
3.找到存储数据表table,看这个索引位置是否已经存放的有元素<br>
4.如果没有，直接加入<br>
5.如果有，调用equals比较，如果相同，就放弃添加，如果不相同，则添加到最后<br>
6.在Java8中，如果一条链表的元素个数到达TREEIFY THRESHOLD(默认是8)，并且tablel的大小&gt;=MIN TREEIFY CAPACITY(默认64)，就会进行树化（红黑树）</p>
</blockquote>
<blockquote>
<p><strong>扩容</strong></p>
<p>1.HashSet底层是HashMap,第一次添加时，table数组扩容到16，临界值(threshold)是16*加载因子(loadFactor)0.75=12<br>
2.如果table数组使用到了临界值12，就会扩容到16*2=32，新的临界值就是32*0.75=24,依次类推<br>
3.在Java8中，如果一条链表的元素个数到达TREEIFY THRESHOLD(默认是8)，并且tablel的大小&gt;=MIN_TREEIFY_CAPACITY(默认64)，就会进行树化（红黑树），否则仍然采用数组扩容机制</p>
</blockquote>
<h5 id="LinkedHashSet"><code>LinkedHashSet</code></h5>
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304072352343.png" alt="image-20230407235257276" style="zoom:33%;">
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304072354996.png" style="zoom:33%;">
<h5 id="Map"><code>Map</code></h5>
<blockquote>
<ul>
<li>
<p>put：添加/修改 键值对</p>
</li>
<li>
<p>remove:根据键删除映射关系</p>
</li>
<li>
<p>get:根据键获取值</p>
</li>
<li>
<p>size:获取元素个数</p>
</li>
<li>
<p>clear:清除 k-v</p>
</li>
<li>
<p>containsKey:查找键是否存在</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>扩容机制：</p>
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304080001252.png" alt="image-20230408000100181" style="zoom: 50%;">
</blockquote>
<p><code>HashTable</code></p>
<blockquote>
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304080003684.png" alt="image-20230408000347617" style="zoom: 50%;">
</blockquote>
<blockquote>
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304080004912.png" alt="image-20230408000453841" style="zoom: 60%;">
</blockquote>
<h3 id="泛型">泛型</h3>
<blockquote>
<p>泛型：参数化类型，只要 类声明 或者实例化的时候 会顶号具体的类型就可以 ——解决数据类型的安全性问题</p>
<p>​			保证在编译时没有异常  不会有  ClassCastEception 异常</p>
<p>​			类声明的时候 通过一个 标识 标识类中 某个 属性的类型 或者方法的返回值类型  或者参数类型</p>
<p>注：</p>
<ul>
<li>
<p>E 具体的数据类型在定义 Person 对象的时候指定,即在编译期间，就确定 E 是什么类型</p>
</li>
<li>
<p>泛型的声明<br>
<code>interface接口&lt;T&gt;&#123;&#125;</code>和<code>class类&lt;K,V&gt;&#123;&#125;</code></p>
</li>
<li>
<p>T,K,V不代表值，而是表示类型</p>
</li>
<li>
<p>任意字母都可以。常用T表示，是Type的缩写</p>
</li>
<li>
<p>泛型的实例化</p>
</li>
<li>
<p><code>List&lt;String&gt;strList = new ArrayList&lt;String&gt;();</code></p>
</li>
<li>
<p><code>Iterator&lt;Customer&gt;iterator = customers.iterator();</code></p>
</li>
<li>
<p><code>interface List&lt;T&gt;(),public class HashSet&lt;E&gt;&#123;&#125;</code><br>
说明：T,E只能是引用类型<br>
<code>List&lt;Integer&gt;list = new ArrayList&lt;Integer&gt;();//OK List&lt;int&gt;list2 = new ArrayList&lt;int&gt;()://错误</code><br>
2.在给泛型指定具体类型后，可以传入该类型或者其子类类型<br>
3.泛型使用形式<br>
<code>List&lt;Integer&gt;list1=new ArrayList&lt;Integer&gt;(); List&lt;Integer&gt;list2=new ArrayList&lt;&gt;();</code><br>
如果我们这样写<code>List list3=new ArrayList();</code>默认给它的泛型是<code>[&lt;E&gt;E就是Object]</code></p>
</li>
</ul>
<h6 id="自定义泛型：">自定义泛型：</h6>
<p><strong>泛型类</strong></p>
<p><code>Class 类名  &lt;T,R...&gt;&#123; 成员 &#125;</code></p>
<p>注意:</p>
<p>​	1)泛型标识符可以有多个;普通成员可以使用泛型（属性、方法）<br>
​	2)使用泛型的数组，不能初始化<br>
​	3)静态方法中不能使用类的泛型</p>
<blockquote>
<p>因为  静态方法/ 属性  是和类相关的，在类加载时，对象还没有创建 所以，如果静态方法和静态属性使用了泛型，JVM 就无法完成初始化</p>
</blockquote>
<p>​	4)泛型类的类型，是在创建对象时确定的（因为创建对象时，需要指定确定类型)<br>
​	5)如果在创建对象时，没有指定类型，默认为Object</p>
<p><strong>泛型接口</strong></p>
<p><code>interface 接口名 &lt;T,R...&gt;&#123;&#125;</code></p>
<p>注意：</p>
<p>​	1)接口中，静态成员也不能使用泛型（这个和泛型类规定一样）</p>
<p>​	2)泛型接口的类型，在继承接口或者实现接口时确定</p>
<p>​	3)没有指定类型，默认为Object</p>
<p><strong>泛型方法</strong><br>
<code>修饰符&lt;T,R.&gt;返回类型方法名（参数列表）&#123;&#125;</code><br>
注意:<br>
1.泛型方法，可以定义在普通类中，也可以定义在泛型类<br>
2.当泛型方法被调用时，类型会确定<br>
3.<code>public void eat(E e),</code>修饰符后没有 <code>&lt;T,R.&gt;  ea</code>  方法不是泛型方法，而是使用了泛型<br>
<strong>泛型的继承和通配符</strong></p>
<p>1)泛型不具备继承性<br>
2)<?>:支持任意泛型类型    `List<?> c <code>可以接受任意的泛型类型 3)&lt;? extends A&gt;:支持A类以及A类的子类，规定了泛型的上限   </code>List&lt;? extends AA&gt; c:<code> 表示 上限，可以接受 AA 或者 AA 子类 4)&lt;? super A&gt;:支持A类以及A类的父类，不限于直接父类，规定了泛型的下限</code>  List&lt;? super AA&gt; c`: 支持 AA 类以及 AA 类的父类，不限于直接父类</p>
</blockquote>
<h3 id="线程">线程</h3>
<blockquote>
<p>进程： 运行的程序，是程序的一次执行过程  或者  正在运行的程序 是一个动态的过程  有自身的 产生 、消亡、存在过程</p>
<p>线程： 由进程创建、进程的实体</p>
<p>单线程：同一时刻只允许一个进程执行</p>
<p>多线程： 同一时刻只允许多个进程执行—— 如：多窗口聊天 、多下载任务</p>
<p>并发：同一时刻，多任务交替执行，“是貌似同时”，单核cpu 实现的多任务就是并发</p>
<p>并行：同一时刻，多任务同时执行，多核cpu 可以实现并行</p>
</blockquote>
<h5 id="使用：">使用：</h5>
<blockquote>
<p>​	方式一：<strong>继承 Thread 类，重写 run 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;cat.start();<span class="comment">//启动线程-&gt; 最终会执行 cat 的 run 方法</span></span><br><span class="line">&gt;start() 源码会调用 start0() 该线程不会立刻执行   只是将线程 变成了可以运行状态，具体的执行时间取决于CPU  由CPU统一调度</span><br><span class="line">  start0()是本地方法，是 JVM 调用, 底层是 c/c++实现 ；真正实现多线程的效果， 是 start0(), 而不是 run</span><br><span class="line"></span><br><span class="line">&gt;cat.run();</span><br><span class="line">&gt;run 方法就是一个普通的方法, 没有真正的启动一个线程，就会把 run 方法执行完毕，才向下执行 ；</span><br><span class="line">  当 main 线程启动一个子线程 Thread-<span class="number">0</span>, 主线程不会阻塞, 会继续执行   这时 主线程和子线程是交替执行..</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">&gt;......</span><br><span class="line">&gt;<span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;<span class="comment">//重写 run 方法，写上自己的业务逻辑</span></span><br><span class="line">  ...</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>​	方式二：<strong>实现Runnable接口，重写 run 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123; <span class="comment">//通过实现 Runnable 接口，开发线程 int count = 0;</span></span><br><span class="line">&gt;...</span><br><span class="line">&gt;<span class="meta">@Override</span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; <span class="comment">//普通方法</span></span><br><span class="line">  ...</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>继承Thread vs实现Runnable的区别：</strong></p>
<p>1、从java的设计来看，本质上没有区别<br>
2、实现Runnable接口方式更加适合多个线程共享一个资源的情况，并且避免了单继承的限制，建议使用Runnable</p>
</blockquote>
<h5 id="模拟多线程">模拟多线程</h5>
<blockquote>
<p>创建两个线程，一个线程每隔1秒输出&quot;helo,world”,输出10次，退出，一个线程每隔1秒输出&quot;hi”,输出5次退出.</p>
</blockquote>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread03</span> &#123;</span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">T1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T1</span>();</span><br><span class="line">  <span class="type">T2</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T2</span>();</span><br><span class="line">  <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t1); </span><br><span class="line">  <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t2); </span><br><span class="line">  thread1.start();<span class="comment">//启动第 1 个线程 </span></span><br><span class="line">  thread2.start();<span class="comment">//启动第 2 个线程 //...</span></span><br><span class="line">&gt;&#125; </span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">T1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123; <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&gt;<span class="meta">@Override</span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">//每隔 1 秒输出 “hello,world”,输出 10 次 </span></span><br><span class="line">      System.out.println(<span class="string">&quot;hello,world &quot;</span> + (++count));</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace(); </span><br><span class="line">      &#125;</span><br><span class="line">          <span class="keyword">if</span>(count == <span class="number">60</span>) &#123; </span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">              &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&gt;&#125; </span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">T2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123; </span><br><span class="line">&gt;<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&gt;<span class="meta">@Override</span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">&gt;<span class="comment">//每隔 1 秒输出 “hi”,输出 5 次 </span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;hi &quot;</span> + (++count)); </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace(); </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(count == <span class="number">50</span>) &#123; </span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&gt;&#125; </span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&gt;使用多线程，模拟三个窗口同时售票 <span class="number">100</span> 张</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="comment">//测试</span></span><br><span class="line">  <span class="comment">//System.out.println(&quot;===使用继承的方式来售票=====&quot;); </span></span><br><span class="line">  <span class="comment">// SellTicket01 sellTicket01 = new SellTicket01();</span></span><br><span class="line">  <span class="comment">// SellTicket01 sellTicket02 = new SellTicket01();</span></span><br><span class="line">  <span class="comment">// SellTicket01 sellTicket03 = new SellTicket01(); //</span></span><br><span class="line">  <span class="comment">// //这里我们会出现超卖..</span></span><br><span class="line">  <span class="comment">// sellTicket01.start();//启动售票线程</span></span><br><span class="line">  <span class="comment">// sellTicket02.start();//启动售票线程</span></span><br><span class="line">  <span class="comment">// sellTicket03.start();//启动售票线程</span></span><br><span class="line"></span><br><span class="line">  	System.out.println(<span class="string">&quot;===使用实现接口的方式来售票=====&quot;</span>); </span><br><span class="line">      <span class="type">SellTicket02</span> <span class="variable">sellTicket02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket02</span>();</span><br><span class="line">  	<span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket02).start();<span class="comment">//第 1 个线程-窗口 </span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket02).start();<span class="comment">//第 2 个线程-窗口</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket02).start();<span class="comment">//第 3 个线程-窗口</span></span><br><span class="line">  &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">SellTicket01</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">&gt;<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ticketNum</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">//让多个线程共享 ticketNum</span></span><br><span class="line">&gt;<span class="meta">@Override</span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ticketNum &lt;= <span class="number">0</span>) &#123; </span><br><span class="line">          System.out.println(<span class="string">&quot;售票结束...&quot;</span>); </span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//休眠 50 毫秒, 模拟 </span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">50</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace(); </span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;窗口 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 售出一张票&quot;</span> + <span class="string">&quot; 剩余票数=&quot;</span> + (--ticketNum));</span><br><span class="line">  &#125; </span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">SellTicket02</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">&gt;<span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticketNum</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">//让多个线程共享 ticketNum</span></span><br><span class="line">&gt;<span class="meta">@Override</span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ticketNum &lt;= <span class="number">0</span>) &#123; </span><br><span class="line">          System.out.println(<span class="string">&quot;售票结束...&quot;</span>); </span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//休眠 50 毫秒, 模拟 </span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">50</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace(); </span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;窗口 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 售出一张票&quot;</span> + <span class="string">&quot; 剩余票数=&quot;</span> + (--ticketNum));</span><br><span class="line">  &#125; </span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="终止线程">终止线程</h5>
<blockquote>
<p>1.当线程完成任务后，会自动退出。<br>
2.还可以通过使用变量来控制 run方法 退出的方式停止线程，即通知方式</p>
</blockquote>
<h5 id="常用方法">常用方法:</h5>
<blockquote>
<ol>
<li>setName()//设置线程名称，使之与参数name相同</li>
<li>getName() //返回该线程的名称</li>
<li>start() //使该线程开始执行; Java虚拟机底层调用该线程的start()方法</li>
<li>run() //调用线程对象run方法;</li>
<li>setPriority() //更改线程的优先级</li>
<li>getPriority() //获取线程的优先级</li>
<li>sleep() //在指定的毫秒数内让当前正在执行的线程休眠(暂停执行)</li>
<li>interrupt() //中断线程</li>
<li>yield:线程的礼让。让出cpu,让其他线程执行，但礼让的时间不确定，所以也不一定礼让成功。</li>
<li>join:线程的插队。插队的线程一旦插队成功，则肯定先执行完插入的线程所有的任务</li>
</ol>
<p>注意：</p>
<ul>
<li>start底层会创建新的线程，调用run, run就是一个简单的方法调用，不会启动新线程</li>
<li>线程优先级的范围</li>
<li>interrupt,中断线程，但并没有真正的结束线程。所以一般用于中断正在休眠的线程</li>
<li>sleep:线程的静态方法，使当前线程休眠</li>
</ul>
<p><strong>用户线程 &amp; 守护线程</strong></p>
<ol>
<li>用户线程: 也叫工作线程，当线程的任务执行完或通知方式结束</li>
<li>守护线程:一般是为工作线程服务的，当所有的用户线程结束，守护线程自动结束     //  setDaemon(true)   设置为守护线程</li>
<li>常见的守护线程: 垃圾回收机制</li>
</ol>
</blockquote>
<h5 id="线程的生命周期">线程的生命周期</h5>
<blockquote>
<p>线程状态类型:</p>
<ul>
<li>
<p>NEW  尚未启动的线程处于此状态。</p>
</li>
<li>
<p>RUNNABLE 在Java虚拟机中执行的线程处于此状态。</p>
</li>
<li>
<p>BLOCKED 被阻塞等待监视器锁定的线程处于此状态。</p>
</li>
<li>
<p>WAITING 正在等待另一个线程执行特定动作的线程处于此状态。</p>
</li>
<li>
<p>TIMED WAITING 正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。</p>
</li>
<li>
<p>TERMINATED己退出的线程处于此状态。</p>
</li>
</ul>
</blockquote>
<h5 id="线程同步">线程同步</h5>
<blockquote>
<p><strong>定义</strong>:当有一个线程在对内存进行操作时， 其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作</p>
<p><strong>同步具体的方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>同步代码块</span><br><span class="line"><span class="keyword">synchronized</span> (对象) &#123; <span class="comment">// 得到对象的锁，才能操作同步代码</span></span><br><span class="line"><span class="comment">//需要被同步代码;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> <span class="keyword">synchronized</span>还可以放在方法声明中， 表示整个方法为同步方法</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m</span> <span class="params">(String name)</span>&#123;</span><br><span class="line"><span class="comment">//需要被同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="互斥锁">互斥锁</h5>
<blockquote>
<p>每个对象都有一个可称为“互斥锁”的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。</p>
<p>关键字synchronized来与对象的互斥锁联系。当某个对象用synchronized修饰时，表明该对象在任一时刻只能由一个线程访问。</p>
<ul>
<li>同步的局限性:导致程序的执行效率要降低。</li>
<li>同步方法(非静态的)的锁可以是在 this 对象,也可以是其他对象(要求是同一个对象)。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;①<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123; </span><br><span class="line"><span class="comment">//同步方法, 在同一时刻， 只能有一个线程来执行 sell 方法 </span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;②也可以在代码块上写 synchronize ,同步代码块, 互斥锁还是在 <span class="built_in">this</span> 对象 </span><br><span class="line">&gt;<span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">......</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="comment">/*this*/</span> object) &#123; </span><br><span class="line">  ....</span><br><span class="line">  &#125;	</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>同步方法（静态的）的锁为当前类本身</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">SellTicket03</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123; </span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123; 	</span><br><span class="line">  	<span class="comment">//此方法的锁是加在 SellTicket03.class上面的</span></span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">  &#125;</span><br><span class="line">  如果在静态方法中，实现一个同步代码块则为</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123; </span><br><span class="line">      <span class="keyword">synchronized</span> (SellTicket03.class) &#123; </span><br><span class="line">      System.out.println(<span class="string">&quot;m2&quot;</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong></p>
<blockquote>
<ul>
<li>1.同步方法如果没有使用static修饰:默认锁对象为this</li>
<li>2.如果方法使用static修饰，默认锁对象:当前类.class</li>
<li>3.实现的落地步骤:</li>
<li>需要先分析上锁的代码</li>
<li>选择同步代码块或同步方法</li>
<li>要求多个线程的锁对象为同一个即可!</li>
</ul>
</blockquote>
<p><strong>解决收票问题</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">&gt;使用多线程，模拟三个窗口同时售票 <span class="number">100</span> 张</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="comment">//测试</span></span><br><span class="line">      <span class="comment">//System.out.println(&quot;===使用继承的方式来售票=====&quot;); </span></span><br><span class="line">      <span class="comment">// SellTicket01 sellTicket01 = new SellTicket01();</span></span><br><span class="line">      <span class="comment">// SellTicket01 sellTicket02 = new SellTicket01();</span></span><br><span class="line">      <span class="comment">// SellTicket01 sellTicket03 = new SellTicket01(); //</span></span><br><span class="line">      <span class="comment">// //这里我们会出现超卖..</span></span><br><span class="line">      <span class="comment">// sellTicket01.start();//启动售票线程</span></span><br><span class="line">      <span class="comment">// sellTicket02.start();//启动售票线程</span></span><br><span class="line">      <span class="comment">// sellTicket03.start();//启动售票线程</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//sellTicket02.start();//启动售票线程 </span></span><br><span class="line">           	<span class="comment">//sellTicket03.start();//启动售票线程</span></span><br><span class="line">			<span class="comment">//System.out.println(&quot;===使用实现接口方式来售票=====&quot;); </span></span><br><span class="line">           	<span class="comment">//SellTicket02 sellTicket02 = new SellTicket02();</span></span><br><span class="line">			<span class="comment">//new Thread(sellTicket02).start();//第 1 个线程-窗口 </span></span><br><span class="line">           	<span class="comment">//new Thread(sellTicket02).start();//第 2 个线程-窗口 </span></span><br><span class="line">          	<span class="comment">//new Thread(sellTicket02).start();//第 3 个线程-窗口</span></span><br><span class="line">          <span class="comment">// 使用锁 解决超卖</span></span><br><span class="line">		<span class="type">SellTicket03</span> <span class="variable">sellTicket03</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket03</span>(); </span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket03).start();<span class="comment">//第 1 个线程-窗口</span></span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket03).start();<span class="comment">//第 2 个线程-窗口 </span></span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket03).start();<span class="comment">//第 3 个线程-窗口</span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 使用锁机制    1、使用 Thread 方式</span></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">SellTicket01</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ticketNum</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">//让多个线程共享 ticketNum</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123; </span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;hello&quot;</span>); </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (ticketNum &lt;= <span class="number">0</span>) &#123; </span><br><span class="line">              System.out.println(<span class="string">&quot;售票结束...&quot;</span>); </span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//休眠 50 毫秒, 模拟 </span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">50</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace(); </span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(<span class="string">&quot;窗口 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 售出一张票&quot;</span> + <span class="string">&quot; 剩余票数=&quot;</span> + (--ticketNum));</span><br><span class="line">      &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">SellTicket02</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticketNum</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">//让多个线程共享 ticketNum</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (ticketNum &lt;= <span class="number">0</span>) &#123; </span><br><span class="line">              System.out.println(<span class="string">&quot;售票结束...&quot;</span>); </span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//休眠 50 毫秒, 模拟 </span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">50</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace(); </span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(<span class="string">&quot;窗口 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 售出一张票&quot;</span> + <span class="string">&quot; 剩余票数=&quot;</span> + (--ticketNum));</span><br><span class="line">      &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//使用锁机制</span></span><br><span class="line">&gt;<span class="comment">//2、实现接口方式, 使用 synchronized 实现线程同步 </span></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">SellTicket03</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticketNum</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">//让多个线程共享 ticketNum </span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//控制 run 方法变量</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  <span class="comment">//同步方法(静态的)的锁为当前类本身</span></span><br><span class="line">  <span class="keyword">public</span> <span class="comment">/*synchronized*/</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123; <span class="comment">//同步方法, 在同一时刻， 只能有一个线程来执行 sell 方法</span></span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="comment">/*this*/</span> object) &#123; </span><br><span class="line">          <span class="keyword">if</span> (ticketNum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;售票结束...&quot;</span>); </span><br><span class="line">              loop = <span class="literal">false</span>;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"><span class="comment">//休眠 50 毫秒, 模拟 </span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              Thread.sleep(<span class="number">50</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace(); </span><br><span class="line">          &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;窗口 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 售出一张票&quot;</span>+ <span class="string">&quot; 剩余票数=&quot;</span> + (--ticketNum));</span><br><span class="line">      &#125; </span><br><span class="line">  &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">              sell();<span class="comment">//sell 方法是一共同步方法 </span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="死锁">死锁</h5>
<blockquote>
<p>多个线程都占用了对方的锁资源，但不肯相让，导致了死锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;死锁演示：</span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; </span><br><span class="line">  <span class="comment">//下面业务逻辑的分析 </span></span><br><span class="line">  <span class="comment">//1. 如果 flag 为 T, 线程 A 就会先得到/持有 o1 对象锁, 然后尝试去获取 o2 对象锁 </span></span><br><span class="line">  <span class="comment">//2. 如果线程 A 得不到 o2 对象锁，就会 Blocked </span></span><br><span class="line">  <span class="comment">//3. 如果 flag 为 F, 线程 B 就会先得到/持有 o2 对象锁, 然后尝试去获取 o1 对象锁 </span></span><br><span class="line">  <span class="comment">//4. 如果线程 B 得不到 o1 对象锁，就会 Blocked </span></span><br><span class="line">  <span class="keyword">if</span> (flag) &#123; </span><br><span class="line">      <span class="keyword">synchronized</span> (o1) &#123;<span class="comment">//对象互斥锁, 下面就是同步代码 </span></span><br><span class="line">  		System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 进入 1&quot;</span>); </span><br><span class="line">          <span class="keyword">synchronized</span> (o2) &#123; <span class="comment">// 这里获得 li 对象的监视权</span></span><br><span class="line">              System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 进入 2&quot;</span>); </span><br><span class="line">          &#125; </span><br><span class="line">      &#125; </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="keyword">synchronized</span> (o2) &#123; </span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 进入 3&quot;</span>); </span><br><span class="line">          <span class="keyword">synchronized</span> (o1) &#123; <span class="comment">// 这里获得 li 对象的监视权 </span></span><br><span class="line">          System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 进入 4&quot;</span>); </span><br><span class="line">          &#125; </span><br><span class="line">      &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="释放锁">释放锁</h5>
<blockquote>
<p><strong>会释放锁</strong></p>
<p>当前线程的同步方法、同步代码块+</p>
<p>1.执行结束</p>
<p>2.遇到break、 return.</p>
<p>3.出现了未处理的Error或Exception,导致异常结束</p>
<p>4.执行了线程对象wait()方法,当前线程暂停,并释放锁。</p>
<p><strong>不会释放锁</strong></p>
<p>1.线程执行同步代码块或同步方法时，程序调用Thread.sleep()、 Thread.yield()方法暂停当前线程的执行，不会释放锁</p>
<p>2.线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁。</p>
<p>​	PS:应尽量避免使用suspend()和resume()来控制线程</p>
</blockquote>
<h3 id="IO流">IO流</h3>
<blockquote>
<p>流：数据在数据源(文件)和程序(内存)之间经历的路径</p>
<p>输入流:数据从数据源(文件)到程序(内存)的路径</p>
<p>输出流:数据从程序(内存)到数据源(文件)的路径</p>
</blockquote>
<h4 id="文件">文件</h4>
<blockquote>
<p><strong>创建文件对象相关构造器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;①<span class="keyword">new</span> <span class="title class_">File</span>(String pathname) <span class="comment">//根据路径构建一个File对象</span></span><br><span class="line">&gt;<span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\news1.txt&quot;</span>; </span><br><span class="line">&gt;<span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath);</span><br><span class="line"></span><br><span class="line">&gt;②<span class="keyword">new</span> <span class="title class_">File</span>(File parent,String child) <span class="comment">//根据父目录文件+子路径构建</span></span><br><span class="line">&gt;<span class="type">File</span> <span class="variable">parentFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;e:\\&quot;</span>); <span class="comment">//在 java 中file 对象只是一个对象 </span></span><br><span class="line">&gt;<span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;news2.txt&quot;</span>;<span class="comment">//只有执行createNewFile 方法，才会在磁盘创建该文件 </span></span><br><span class="line">&gt;<span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parentFile, fileName); </span><br><span class="line"></span><br><span class="line">&gt;③<span class="keyword">new</span> <span class="title class_">File</span>(String parent,String child) <span class="comment">//根据父目录+子路径构建</span></span><br><span class="line">&gt;<span class="type">String</span> <span class="variable">parentPath</span> <span class="operator">=</span> <span class="string">&quot;e:\\&quot;</span>; </span><br><span class="line">&gt;<span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;news4.txt&quot;</span>; </span><br><span class="line">&gt;<span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parentPath, fileName);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>创建文件对象相关方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;e:\\news1.txt&quot;</span>); </span><br><span class="line"></span><br><span class="line">&gt;文件名字=<span class="string">&quot; + file.getName()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&gt;文件绝对路径=&quot;</span> + file.getAbsolutePath()</span><br><span class="line"></span><br><span class="line">&gt;文件父级目录=<span class="string">&quot; + file.getParent()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&gt;文件大小(字节)=&quot;</span> + file.length()</span><br><span class="line"></span><br><span class="line">&gt;文件是否存在=<span class="string">&quot; + file.exists()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&gt;是不是一个文件=&quot;</span> + file.isFile()</span><br><span class="line"></span><br><span class="line">&gt;是不是一个目录=<span class="string">&quot; + file.isDirectory()</span></span><br></pre></td></tr></table></figure>
<p><strong>目录的操作和文件删除</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;mkdir创建一 级目录、mkdirs创建多级目录、delete删除空目录或文件</span><br><span class="line"></span><br><span class="line">&gt;<span class="type">boolean</span> <span class="title function_">mkdir</span><span class="params">()</span>	</span><br><span class="line"></span><br><span class="line">&gt;<span class="type">boolean</span>	<span class="title function_">mkdirs</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="IO-流">IO 流</h4>
<blockquote>
<p>Java程序中，对于数据的输入/输出操作以&quot;流(stream)&quot;的方式进行。</p>
<ul>
<li>
<p>输入input:读取外部数据—&gt;程序(内存)中。</p>
</li>
<li>
<p>输出output:将程序(内存)数据输出到  —&gt;磁盘、光盘等存储设备中</p>
</li>
</ul>
</blockquote>
<h5 id="InputStream（字节输入流）"><code>InputStream</code>（字节输入流）</h5>
<blockquote>
<p><code>InputStream</code> 常用方法 ：</p>
<ul>
<li><code>read()</code> ：返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。如果未读取任何字节，则代码返回 <code>-1</code> ，表示文件结束。</li>
<li><code>read(byte b[ ])</code> : 从输入流中读取一些字节存储到数组 <code>b</code> 中。如果数组 <code>b</code> 的长度为零，则不读取。如果没有可用字节读取，返回 <code>-1</code>。如果有可用字节读取，则最多读取的字节数最多等于 <code>b.length</code> ， 返回读取的字节数。这个方法等价于 <code>read(b, 0, b.length)</code>。</li>
<li><code>read(byte b[], int off, int len)</code> ：在<code>read(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li>
<li><code>skip(long n)</code> ：忽略输入流中的 n 个字节 ,返回实际忽略的字节数。</li>
<li><code>available()</code> ：返回输入流中可以读取的字节数。</li>
<li><code>close()</code> ：关闭输入流释放相关的系统资源。</li>
</ul>
<p>从 Java 9 开始，<code>InputStream</code> 新增加了多个实用的方法：</p>
<ul>
<li><code>readAllBytes()</code> ：读取输入流中的所有字节，返回字节数组。</li>
<li><code>readNBytes(byte[] b, int off, int len)</code> ：阻塞直到读取 <code>len</code> 个字节。</li>
<li><code>transferTo(OutputStream out)</code> ： 将所有字节从一个输入流传递到一个输出流。</li>
</ul>
<p><code>FileInputStream</code> 是一个比较常用的字节输入流对象，可直接指定文件路径，可以直接读取单字节数据，也可以读取至字节数组中。</p>
</blockquote>
<h5 id="OutputStream（字节输出流）"><code>OutputStream</code>（字节输出流）</h5>
<blockquote>
<p><code>OutputStream</code> 常用方法 ：</p>
<ul>
<li><code>write(int b)</code> ：将特定字节写入输出流。</li>
<li><code>write(byte b[ ])</code> : 将数组<code>b</code> 写入到输出流，等价于 <code>write(b, 0, b.length)</code> 。</li>
<li><code>write(byte[] b, int off, int len)</code> : 在<code>write(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li>
<li><code>flush()</code> ：刷新此输出流并强制写出所有缓冲的输出字节。</li>
<li><code>close()</code> ：关闭输出流释放相关的系统资源。</li>
</ul>
<p><code>FileOutputStream</code> 是最常用的字节输出流对象，可直接指定文件路径，可以直接输出单字节数据，也可以输出指定的字节数组。</p>
</blockquote>
<h5 id="Reader（字符输入流）"><code>Reader</code>（字符输入流）</h5>
<blockquote>
<p><code>Reader</code> 用于读取文本， <code>InputStream</code> 用于读取原始字节。</p>
<p><code>Reader</code> 常用方法 ：</p>
<ul>
<li><code>read()</code> : 从输入流读取一个字符。</li>
<li><code>read(char[] cbuf)</code> : 从输入流中读取一些字符，并将它们存储到字符数组 <code>cbuf</code>中，等价于 <code>read(cbuf, 0, cbuf.length)</code> 。</li>
<li><code>read(char[] cbuf, int off, int len)</code> ：在<code>read(char[] cbuf)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</li>
<li><code>skip(long n)</code> ：忽略输入流中的 n 个字符 ,返回实际忽略的字符数。</li>
<li><code>close()</code> : 关闭输入流并释放相关的系统资源。</li>
</ul>
<p><code>InputStreamReader</code> 是字节流转换为字符流的桥梁，其子类 <code>FileReader</code> 是基于该基础上的封装，可以直接操作字符文件。</p>
</blockquote>
<h5 id="Writer（字符输出流）"><code>Writer</code>（字符输出流）</h5>
<blockquote>
<p><code>Writer</code>用于将数据（字符信息）写入到目的地（通常是文件），<code>java.io.Writer</code>抽象类是所有字符输出流的父类。</p>
<p><code>Writer</code> 常用方法 ：</p>
<ul>
<li><code>write(int c)</code> : 写入单个字符。</li>
<li><code>write(char[] cbuf)</code> ：写入字符数组 <code>cbuf</code>，等价于<code>write(cbuf, 0, cbuf.length)</code>。</li>
<li><code>write(char[] cbuf, int off, int len)</code> ：在<code>write(char[] cbuf)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</li>
<li><code>write(String str)</code> ：写入字符串，等价于 <code>write(str, 0, str.length())</code> 。</li>
<li><code>write(String str, int off, int len)</code> ：在<code>write(String str)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</li>
<li><code>append(CharSequence csq)</code> ：将指定的字符序列附加到指定的 <code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</li>
<li><code>append(char c)</code> ：将指定的字符附加到指定的 <code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</li>
<li><code>flush()</code> ：刷新此输出流并强制写出所有缓冲的输出字符。</li>
<li><code>close()</code>:关闭输出流释放相关的系统资源。</li>
</ul>
<p><code>OutputStreamWriter</code> 是字符流转换为字节流的桥梁，其子类 <code>FileWriter</code> 是基于该基础上的封装，可以直接将字符写入到文件。</p>
</blockquote>
<h5 id="FileInputStream">FileInputStream</h5>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\hello.txt&quot;</span>;</span><br><span class="line">&gt;--- <span class="number">1</span> .单个字节的读取 </span><br><span class="line">&gt;<span class="type">int</span> <span class="variable">readData</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">&gt;<span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">  fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath); <span class="comment">//创建 FileInputStream对象,用于读取文件 </span></span><br><span class="line">  <span class="comment">//从该输入流读取一个字节的数据,如果没有输入可用,此方法将阻止,如果返回-1 , 表示读取完毕 </span></span><br><span class="line">  <span class="keyword">while</span> ((readData = fileInputStream.read()) != -<span class="number">1</span>) &#123; </span><br><span class="line">      System.out.print((<span class="type">char</span>)readData);<span class="comment">//转成 char 显示 </span></span><br><span class="line">  &#125; </span><br><span class="line">&gt;&#125;<span class="keyword">catch</span>(Exceotion e)&#123;</span><br><span class="line"> e.printStackTrace(); </span><br><span class="line">&gt;&#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">&gt;<span class="comment">//关闭文件流，释放资源</span></span><br><span class="line">  <span class="keyword">try</span> &#123; </span><br><span class="line">  	fileInputStream.close(); </span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123; </span><br><span class="line">  	e.printStackTrace(); </span><br><span class="line">  &#125; </span><br><span class="line">&gt;&#125; </span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;---<span class="number">2.</span> 使用 read(<span class="type">byte</span>[] b)读取 </span><br><span class="line">&gt;<span class="type">byte</span>[] buf =<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>]; <span class="comment">//一次读取 8 个字节/字节数组</span></span><br><span class="line">&gt;<span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">&gt;<span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">&gt;<span class="keyword">try</span> &#123; </span><br><span class="line">  fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath); <span class="comment">//创建 FileInputStream 对象，用于读取文件 </span></span><br><span class="line">  <span class="comment">//从该输入流读取最多 b.length字节的数据到字节数组。此方法将阻塞，直到某些输入可用。如果返回-1 , 表示读取完毕; 如果读取正常, 返回实际读取的字节数 </span></span><br><span class="line">  <span class="keyword">while</span> ((readLen = fileInputStream.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">      System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="number">0</span>, readLen));<span class="comment">//显示 </span></span><br><span class="line">  &#125; </span><br><span class="line">&gt;&#125;<span class="keyword">catch</span>(......)&#123;</span><br><span class="line">&gt;......</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="DataInputStream"><code>DataInputStream</code></h5>
<p>用于读取指定类型数据，不能单独使用，必须结合 <code>FileInputStream</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>);</span><br><span class="line"><span class="comment">//必须将fileInputStream作为构造参数才能使用</span></span><br><span class="line"><span class="type">DataInputStream</span> <span class="variable">dataInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(fileInputStream);</span><br><span class="line"><span class="comment">//可以读取任意具体的类型数据</span></span><br><span class="line">dataInputStream.readBoolean();</span><br><span class="line">dataInputStream.readInt();</span><br><span class="line">dataInputStream.readUTF();</span><br></pre></td></tr></table></figure>
<h5 id="FileOutputStream">FileOutputStream</h5>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&gt;数据写到文件中, 如果该文件不存在，则创建该文件</span><br><span class="line"></span><br><span class="line">&gt;<span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\a.txt&quot;</span>; </span><br><span class="line">&gt;<span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//创建 FileOutputStream 对象 </span></span><br><span class="line">&gt;<span class="keyword">try</span> &#123; </span><br><span class="line">&gt;<span class="comment">//1. new FileOutputStream(filePath) 创建方式，当写入内容是，会覆盖原来的内容</span></span><br><span class="line"><span class="comment">//2. new FileOutputStream(filePath, true) 创建方式，当写入内容是，是追加到文件后面 </span></span><br><span class="line">  fileOutputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filePath, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">//写入一个字节</span></span><br><span class="line"><span class="comment">//fileOutputStream.write(&#x27;H&#x27;);//</span></span><br><span class="line"><span class="comment">//写入字符串</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hsp,world!&quot;</span>;</span><br><span class="line"><span class="comment">//str.getBytes() 可以把 字符串-&gt; 字节数组</span></span><br><span class="line"><span class="comment">//fileOutputStream.write(str.getBytes());</span></span><br><span class="line">&gt;<span class="comment">/*</span></span><br><span class="line"><span class="comment">&gt;write(byte[] b, int off, int len) 将 len 字节从位于偏移量 off 的指定字节数组写入此文件输出流</span></span><br><span class="line"><span class="comment">&gt;*/</span></span><br><span class="line">fileOutputStream.write(str.getBytes(), <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">&gt;&#125; <span class="keyword">catch</span> (IOException e) &#123; </span><br><span class="line">&gt;......</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;编程完成 图片/音乐 的拷贝</span><br><span class="line">&gt;<span class="comment">//1. 创建文件的输入流 , 将文件读入到程序</span></span><br><span class="line"><span class="comment">//2. 创建文件的输出流， 将读取到的文件数据，写入到指定的文件. String srcFilePath = &quot;e:\\Koala.jpg&quot;;</span></span><br><span class="line">&gt;<span class="type">String</span> <span class="variable">destFilePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\Koala3.jpg&quot;</span>;</span><br><span class="line">&gt;<span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">&gt;<span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">&gt;<span class="keyword">try</span> &#123;</span><br><span class="line">	fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFilePath); </span><br><span class="line">  fileOutputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFilePath); <span class="comment">//定义一个字节数组,提高读取效果</span></span><br><span class="line">  <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">  <span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ((readLen = fileInputStream.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">//读取到后，就写入到文件 通过 fileOutputStream //即，是一边读，一边写</span></span><br><span class="line">  	fileOutputStream.write(buf, <span class="number">0</span>, readLen);<span class="comment">//一定要使用这个方法</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;拷贝 ok~&quot;</span>);</span><br><span class="line">&gt;&#125; <span class="keyword">catch</span> (IOException e) &#123; </span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&gt;&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123; <span class="comment">//关闭输入流和输出流，释放资源</span></span><br><span class="line">      <span class="keyword">if</span> (fileInputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">          fileInputStream.close(); </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (fileOutputStream != <span class="literal">null</span>) &#123; </span><br><span class="line">          fileOutputStream.close();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace(); </span><br><span class="line">  &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125; </span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="DataOutputStream"><code>DataOutputStream</code></h5>
<p>用于写入指定类型数据，不能单独使用，必须结合 <code>FileOutputStream</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出流</span></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out.txt&quot;</span>);</span><br><span class="line"><span class="type">DataOutputStream</span> <span class="variable">dataOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(fileOutputStream);</span><br><span class="line"><span class="comment">// 输出任意数据类型</span></span><br><span class="line">dataOutputStream.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">dataOutputStream.writeByte(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h5 id="节点流">节点流</h5>
<h6 id="FileReader"><code>FileReader</code></h6>
<blockquote>
<p><strong>常用方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;--- 公共部分</span><br><span class="line"></span><br><span class="line">&gt;<span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\story.txt&quot;</span>;</span><br><span class="line">&gt;<span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line">&gt;...</span><br><span class="line">&gt;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">&gt;e.printStackTrace();</span><br><span class="line">&gt;&#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">&gt;<span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (fileReader != <span class="literal">null</span>) &#123; </span><br><span class="line">    fileReader.close();</span><br><span class="line">&#125;</span><br><span class="line">&gt;&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace(); </span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125; </span><br></pre></td></tr></table></figure>
<ul>
<li>new FileReader(File/String)      创建 FileReader 对象</li>
<li>read:每次读取单个字符，返回该字符，如果到文件末尾返回-1</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;---- 单个字符读取文件</span><br><span class="line">&gt;<span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&gt;<span class="comment">//1. 创建 FileReader 对象</span></span><br><span class="line">&gt;<span class="keyword">try</span> &#123;</span><br><span class="line">   fileReader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(filePath); </span><br><span class="line">   <span class="comment">//循环读取 使用 read, 单个字符读取 </span></span><br><span class="line">   <span class="keyword">while</span> ((data = fileReader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">       System.out.print((<span class="type">char</span>) data); </span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>read(char[]):批量读取多个字符到数组，返回读取到的字符数，如果到文件末尾返回-1</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;----字符数组读取文件</span><br><span class="line">&gt;<span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&gt;<span class="type">char</span>[] buf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">8</span>]; <span class="comment">//1. 创建 FileReader 对象</span></span><br><span class="line">&gt;<span class="keyword">try</span> &#123;</span><br><span class="line"> fileReader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(filePath);</span><br><span class="line"> <span class="comment">//循环读取 使用 read(buf), 返回的是实际读取到的字符数 //如果返回-1, 说明到文件结束</span></span><br><span class="line">  <span class="keyword">while</span> ((readLen = fileReader.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">  System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="number">0</span>, readLen)); </span><br><span class="line">  &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>API:</p>
<ul>
<li>new String(char[]):将char[]转换成String</li>
<li>new String(charl[],off,Ien):将char[]的指定部分转换成String</li>
</ul>
</blockquote>
<h6 id="FileWriter"><code>FileWriter</code></h6>
<blockquote>
<p><strong>常用方法</strong></p>
<ul>
<li>
<p>new FileWriter(File/String): 覆盖模式，相当于流的指针在首端</p>
</li>
<li>
<p>new FileWriter(File/String,true): 追加模式，相当于流的指针在尾端</p>
</li>
<li>
<p>write(int):写入单个字符		fileWriter.write(‘H’);</p>
</li>
<li>
<p>write(char[]):写入指定数组     fileWriter.write(chars);</p>
</li>
<li>
<p>write(char[],off,len):写入指定数组的指定部分          fileWriter.write(“南京北京”.toCharArray(), 0, 3);</p>
</li>
<li>
<p>write (string) :写入整个字符串            fileWriter.write(“风雨之后，定见彩虹”);</p>
</li>
<li>
<p>write(string,off,len):写入字符串的指定部分         fileWriter.write(“上海天津”, 0, 2);</p>
</li>
</ul>
<p>相关APl:</p>
<ul>
<li>String类: toCharArray:将String转换成char[]</li>
</ul>
<p>注意:   FileWriter使用后，必须要关闭(close)或刷新(flush)，否则写入不到指定的文件!</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\note.txt&quot;</span>; </span><br><span class="line">&gt;<span class="comment">//创建 FileWriter 对象 FileWriter </span></span><br><span class="line">&gt;fileWriter = <span class="literal">null</span>; </span><br><span class="line">&gt;<span class="type">char</span>[] chars = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">&gt;<span class="keyword">try</span> &#123;</span><br><span class="line">  fileWriter = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(filePath);<span class="comment">//默认是覆盖写入 </span></span><br><span class="line">  <span class="comment">//3) write(int):写入单个字符 </span></span><br><span class="line">  fileWriter.write(<span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">  <span class="comment">//4) write(char[]):写入指定数组 </span></span><br><span class="line">  fileWriter.write(chars);</span><br><span class="line">  <span class="comment">//5) write(char[],off,len):写入指定数组的指定部分 </span></span><br><span class="line">  fileWriter.write(<span class="string">&quot;韩顺平教育&quot;</span>.toCharArray(), <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="comment">//6) write(string):写入整个字符串 </span></span><br><span class="line">  fileWriter.write(<span class="string">&quot;风雨之后，定见彩虹&quot;</span>);</span><br><span class="line">  <span class="comment">//7) write(string,off,len):写入字符串的指定部分 </span></span><br><span class="line">  fileWriter.write(<span class="string">&quot;上海天津&quot;</span>, <span class="number">0</span>, <span class="number">2</span>); </span><br><span class="line">  <span class="comment">//在数据量大的情况下，可以使用循环操作.</span></span><br><span class="line">&gt;&#125; <span class="keyword">catch</span> (IOException e) &#123; </span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&gt;&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//关闭文件流，等价 flush() + 关闭 </span></span><br><span class="line">      fileWriter.close();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123; </span><br><span class="line">      e.printStackTrace();</span><br><span class="line">  &#125; </span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;System.out.println(<span class="string">&quot;程序结束...&quot;</span>);</span><br><span class="line">&gt;&#125; </span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="节点流和处理流">节点流和处理流</h5>
<blockquote>
<p><strong>节点流</strong>：可以从一个特定的数据源读写数据    <code>FileReader、 FileWriter </code></p>
<p><strong>处理流</strong>：(也叫包装流)是“连接&quot;在已存在的流(节点流或处理流)之上，为程序提供更为强大的读写功能         <code>Buffer...</code></p>
<p><strong>节点流和处理流的区别和联系</strong></p>
<p>1.节点流是底层流/低级流，直接跟数据源相接。</p>
<p>2.处理流(包装流)包装节点流，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出。</p>
<p>3.处理流(也叫包装流)对节点流进行包装，使用了修饰器设计模式，不会直接与数据源相连</p>
</blockquote>
<h5 id="处理流">处理流</h5>
<h6 id="BufferedReader"><code>BufferedReader</code></h6>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\a.java&quot;</span>;</span><br><span class="line">&gt;<span class="comment">//创建 bufferedReader</span></span><br><span class="line">&gt;<span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(filePath));</span><br><span class="line">&gt;String line; <span class="comment">//按行读取, 效率高</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//bufferedReader.readLine() 是按行读取文件  当返回 null 时，表示文件读取完毕</span></span><br><span class="line">&gt;<span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">&gt;System.out.println(line); </span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//关闭流, 这里注意，只需要关闭 BufferedReader ，因为底层会自动的去关闭 节点流</span></span><br><span class="line">&gt;bufferedReader.close();</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="BufferedWriter"><code>BufferedWriter</code></h6>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//创建 BufferedWriter</span></span><br><span class="line">&gt;<span class="comment">//1. new FileWriter(filePath, true) 表示以追加的方式写入 </span></span><br><span class="line">&gt;<span class="comment">//2. new FileWriter(filePath) , 表示以覆盖的方式写入</span></span><br><span class="line">&gt;<span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\ok.txt&quot;</span>;</span><br><span class="line">&gt;<span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(filePath));</span><br><span class="line">&gt;bufferedWriter.write(<span class="string">&quot;hello, 韩顺平教育!&quot;</span>);</span><br><span class="line">&gt;<span class="comment">//插入一个和系统相关的换行 </span></span><br><span class="line">&gt;bufferedWriter.newLine();</span><br><span class="line">&gt;<span class="comment">//说明:关闭外层流即可 ， 传入的 new FileWriter(filePath) ,会在底层关闭 </span></span><br><span class="line">&gt;bufferedWriter.close();</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>综合使用BufferedWriter和BufferedReader — 二者也是字符流</strong></p>
<blockquote>
<p>综合使用完成<strong>文本文件</strong>的拷贝</p>
</blockquote>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//BufferedReader 和 BufferedWriter 是安装字符操作不要去操作 二进制文件[声音，视频，doc, pdf ], 可能造成文件损坏 </span></span><br><span class="line"></span><br><span class="line">&gt;<span class="type">String</span> <span class="variable">srcFilePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\a.java&quot;</span>;</span><br><span class="line">&gt;<span class="type">String</span> <span class="variable">destFilePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\a2.java&quot;</span>;</span><br><span class="line">&gt;<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">&gt;<span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">&gt;String line;</span><br><span class="line">&gt;<span class="keyword">try</span> &#123;</span><br><span class="line">&gt;br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(srcFilePath)); </span><br><span class="line">&gt;bw = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(destFilePath));</span><br><span class="line">&gt;<span class="comment">//说明: readLine 读取一行内容，但是没有换行 </span></span><br><span class="line">&gt;<span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">	<span class="comment">//每读取一行，就写入 </span></span><br><span class="line">  bw.write(line); </span><br><span class="line">  <span class="comment">//插入一个换行 </span></span><br><span class="line">  bw.newLine();</span><br><span class="line">  &#125; </span><br><span class="line">&gt;System.out.println(<span class="string">&quot;拷贝完毕...&quot;</span>);</span><br><span class="line">&gt;&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">&gt;e.printStackTrace();</span><br><span class="line">&gt;&#125; <span class="keyword">finally</span> &#123; <span class="comment">//关闭流</span></span><br><span class="line">&gt;<span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(br != <span class="literal">null</span>) &#123;</span><br><span class="line">      br.close(); &#125;</span><br><span class="line">  <span class="keyword">if</span>(bw != <span class="literal">null</span>) &#123; </span><br><span class="line">      bw.close();</span><br><span class="line">  &#125;</span><br><span class="line">&gt;&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">  e.printStackTrace(); </span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="BufferedInputStream-和-BufferedOutputStream-也是字节流"><strong><code>BufferedInputStream 和 BufferedOutputStream</code>  也是字节流</strong></h6>
<blockquote>
<p><code>BufferedInputStream</code>   创建时，会创建一个内部缓冲区数组.</p>
<p><code>BufferedOutputStream</code>  事故实现缓冲的输出流，可以将多个字节写入底层输出流中，不必对每次字节写入都调用底层系统</p>
<ul>
<li><strong>字节流可以操作二进制文件，也可以操作文本文件</strong></li>
</ul>
</blockquote>
<p><code>BufferedInputStream 和 BufferedOutputStream</code>   综合使用案例</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">String</span> <span class="variable">srcFilePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\a.java&quot;</span>; </span><br><span class="line">&gt;<span class="type">String</span> <span class="variable">destFilePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\a3.java&quot;</span>;</span><br><span class="line">&gt;<span class="comment">//创建 BufferedOutputStream 对象 BufferedInputStream 对象 BufferedInputStream bis = null;</span></span><br><span class="line">&gt;<span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">&gt;<span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//因为 FileInputStream 是 InputStream 子类</span></span><br><span class="line">&gt;bis = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFilePath));</span><br><span class="line">&gt;bos = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFilePath));</span><br><span class="line">&gt;<span class="comment">//循环的读取文件，并写入到 destFilePath </span></span><br><span class="line">&gt;<span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">&gt;<span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&gt;<span class="comment">//当返回 -1 时，就表示文件读取完毕 </span></span><br><span class="line">&gt;<span class="keyword">while</span> ((readLen = bis.read(buff)) != -<span class="number">1</span>) &#123;</span><br><span class="line">  bos.write(buff, <span class="number">0</span>, readLen); </span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;System.out.println(<span class="string">&quot;文件拷贝完毕~~~&quot;</span>);</span><br><span class="line">&gt;&#125; <span class="keyword">catch</span> (IOException e) &#123; </span><br><span class="line">&gt;e.printStackTrace();</span><br><span class="line">&gt;&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">&gt;<span class="comment">//关闭流 , 关闭外层的处理流即可，底层会去关闭节点流 </span></span><br><span class="line">&gt;<span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(bis != <span class="literal">null</span>) &#123; </span><br><span class="line">      bis.close();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(bos != <span class="literal">null</span>) &#123;</span><br><span class="line">      bos.close(); </span><br><span class="line">  &#125;</span><br><span class="line">&gt;&#125;<span class="keyword">catch</span> (IOException e) &#123; </span><br><span class="line">&gt;e.printStackTrace();</span><br><span class="line">&gt;&#125; </span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="对象流">对象流</h5>
<h6 id="序列化和反序列化">序列化和反序列化</h6>
<blockquote>
<p>1.序列化就是在保存数据时，保存 数据的值 和 数据类型       将数据结构或对象转换成二进制字节流的过程</p>
<p>2.反序列化就是在恢复数据时，恢复数据的值和数据类型       将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</p>
<p>3.需要让某个对象支持序列化机制，则必须让其类是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一:</p>
<p>​	Serializable // 这是个标记接口，没有方法需要实现  [推荐]</p>
<p>​	Externalizable //该接口有方法需要实现，因此我们一般实现上面的Serializable接口</p>
<ul>
<li>ObjectOutputStream 提供 序列化功能</li>
<li>ObjectInputStream 提供 反序列化功能</li>
</ul>
<p>4、序列化协议<strong>在TCP/IP 4 层模型中的   应用层 更细点 是表示层</strong></p>
</blockquote>
<h6 id="ObjectInputStream"><code>ObjectInputStream</code></h6>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;------完成数据的序列化</span><br><span class="line">&gt;<span class="comment">//序列化后，保存的文件格式，不是存文本，而是按照他的格式来保存 </span></span><br><span class="line">&gt;<span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\data.dat&quot;</span>;</span><br><span class="line">&gt;<span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filePath));</span><br><span class="line">&gt;<span class="comment">//序列化数据到 e:\data.dat</span></span><br><span class="line">&gt;oos.writeInt(<span class="number">100</span>);<span class="comment">// int -&gt; Integer (实现了 Serializable) </span></span><br><span class="line">&gt;oos.writeBoolean(<span class="literal">true</span>);<span class="comment">// boolean -&gt; Boolean (实现了 Serializable) </span></span><br><span class="line">&gt;oos.writeChar(<span class="string">&#x27;a&#x27;</span>);<span class="comment">// char -&gt; Character (实现了 Serializable) </span></span><br><span class="line">&gt;oos.writeDouble(<span class="number">9.5</span>);<span class="comment">// double -&gt; Double (实现了 Serializable) </span></span><br><span class="line">&gt;oos.writeUTF(<span class="string">&quot;韩顺平教育&quot;</span>);<span class="comment">//String</span></span><br><span class="line">&gt;<span class="comment">//保存一个 dog 对象</span></span><br><span class="line">&gt;oos.writeObject(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;旺财&quot;</span>, <span class="number">10</span>, <span class="string">&quot;日本&quot;</span>, <span class="string">&quot;白色&quot;</span>)); </span><br><span class="line">&gt;oos.close();</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="ObjectOutputStream"><code>ObjectOutputStream</code></h6>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;------读取上述文件并进行反序列化</span><br><span class="line">&gt;<span class="comment">// 1.创建流对象</span></span><br><span class="line">&gt;<span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\data.dat&quot;</span>)); </span><br><span class="line">&gt;<span class="comment">// 2.读取， 注意顺序</span></span><br><span class="line">&gt;System.out.println(ois.readInt());</span><br><span class="line">&gt;System.out.println(ois.readBoolean());</span><br><span class="line">&gt;System.out.println(ois.readChar());</span><br><span class="line">&gt;System.out.println(ois.readDouble());</span><br><span class="line">&gt;System.out.println(ois.readUTF());</span><br><span class="line">&gt;System.out.println(ois.readObject());</span><br><span class="line">&gt;System.out.println(ois.readObject());</span><br><span class="line">&gt;System.out.println(ois.readObject());</span><br><span class="line">&gt;<span class="comment">// 3.关闭</span></span><br><span class="line">&gt;ois.close();</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>PS:注意事项和细节说明</strong></p>
<p>1)读写顺序要一致</p>
<p>2)用于序列化和反序列化的类必须实现 <code>Serializable</code> 接口</p>
<p>3)序列化的类中建议添加SerialVersionUID,为了提高版本的兼容性</p>
<p>4)序列化对象时，默认将里面所有属性都进行序列化，但除了static或transient修饰的成员</p>
<p>5)序列化对象时，要求里面属性的类型也需要实现序列化接口</p>
<p>6)序列化具备可继承性，也就是如果某类已经实现了序列化，则它的所有子类也已经默认实现了序列化</p>
</blockquote>
<h5 id="标准输入输出流">标准输入输出流</h5>
<blockquote>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="http://System.in">System.in</a>         标准输入流               InputStream                 键  盘</p>
<p>System.out       标准输出流               PrintStream                 显示器</p>
<ul>
<li>System.out.println(…)为使用out对象将数据输出到显示器;Scanner是由标准输入从键盘接收数据</li>
</ul>
</blockquote>
<h5 id="转换流">转换流</h5>
<blockquote>
<ol>
<li>
<p>InputStreamReader:Reader的子类可以将InputStream(字节流)包装成(转换)Reader(字符流)</p>
</li>
<li>
<p>OutputStreamWriter:Writer的子类实现将OutputStream(字节流)包装成Writer(字符流)</p>
</li>
<li>
<p>当处理纯文本数据时，如果使用字符流效率更高，并且可以有效解决中文问题，建议将字节流转换成字符流</p>
</li>
<li>
<p>可以在使用时指定编码格式(比如utf-8, gbk,gb2312, IS08859-1等)</p>
</li>
</ol>
</blockquote>
<h6 id="InputStreamReader"><code>InputStreamReader </code></h6>
<blockquote>
<p><code>InputStreamReader </code>转换流解决中文乱码问题</p>
<blockquote>
<p>即：<code>将字节流FilelnputStream包装成(转换成)字符流InputStreamReader,后对文件进行读取(按照utf-8/gbk格式)，进而在包装成BufferedReader</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\a.txt&quot;</span>;</span><br><span class="line">&gt;<span class="comment">//1. 把 FileInputStream 转成 InputStreamReader</span></span><br><span class="line">&gt;<span class="comment">//2. 指定编码 gbk</span></span><br><span class="line">&gt;<span class="comment">//InputStreamReader isr = new InputStreamReader(new FileInputStream(filePath), &quot;gbk&quot;); </span></span><br><span class="line">&gt;<span class="comment">//3. 把 InputStreamReader 传入 BufferedReader</span></span><br><span class="line">&gt;<span class="comment">//BufferedReader br = new BufferedReader(isr);</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//将2 和 3 合在一起</span></span><br><span class="line">&gt;<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath), <span class="string">&quot;gbk&quot;</span>));</span><br><span class="line">&gt;<span class="comment">//4. 读取</span></span><br><span class="line">&gt;<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> br.readLine(); </span><br><span class="line">&gt;System.out.println(<span class="string">&quot;读取内容=&quot;</span> + s); </span><br><span class="line">&gt;<span class="comment">//5. 关闭外层流</span></span><br><span class="line">&gt;br.close();</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="OutputStreamWriter"><code>OutputStreamWriter</code></h6>
<blockquote>
<blockquote>
<p>将字节流FileOutputStream包装成(转换成)字符流OutputStreamReader,后对文件进行读取(按照utf-8/gbk格式)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 1.创建流对象</span></span><br><span class="line">&gt;<span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;d:\\a.txt&quot;</span>), <span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">&gt;<span class="comment">// 2.写入 </span></span><br><span class="line">&gt;osw.write(<span class="string">&quot;hello,韩顺平教育~&quot;</span>); </span><br><span class="line">&gt;<span class="comment">// 3.关闭</span></span><br><span class="line">&gt;osw.close(); </span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="打印流">打印流</h5>
<blockquote>
<p><code>System.out</code> 实际是用于获取一个 <code>PrintStream</code> 对象，<code>print</code>方法实际调用的是 <code>PrintStream</code> 对象的 <code>write</code> 方法。</p>
<p><code>PrintStream</code> 属于字节打印流，与之对应的是 <code>PrintWriter</code> （字符打印流）。</p>
<p><code>PrintStream</code> 是 <code>OutputStream</code> 的子类，<code>PrintWriter</code> 是 <code>Writer</code> 的子类。</p>
</blockquote>
<h6 id="PrintStream"><code>PrintStream </code></h6>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">PrintWriter</span> <span class="variable">printWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;e:\\f2.txt&quot;</span>));</span><br><span class="line">&gt;printWriter.print(<span class="string">&quot;hi, 南京你好&quot;</span>);  <span class="comment">//将 &quot;hi, 南京你好&quot; 写到e:\\f2.txt</span></span><br><span class="line">&gt;printWriter.close();		<span class="comment">//flush + 关闭流, 才会将数据写入到文件..</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="PrintWriter"><code> PrintWriter</code></h6>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">PrintStream</span> <span class="variable">out</span> <span class="operator">=</span> System.out; </span><br><span class="line">&gt;<span class="comment">//在默认情况下，PrintStream 输出数据的位置是 标准输出，即显示器 </span></span><br><span class="line">&gt;out.print(<span class="string">&quot;南京,你好);   //在控制台打印南京,你好</span></span><br><span class="line"><span class="string">&gt;//因为 print 底层使用的是 write , 所以我们可以直接调用 write 进行打印/输出 </span></span><br><span class="line"><span class="string">&gt;out.write(&quot;</span>南京,你好<span class="string">&quot;.getBytes());  //在控制台打印 南京,你好</span></span><br><span class="line"><span class="string">&gt;out.close(); </span></span><br><span class="line"><span class="string">&gt;System.setOut(new PrintStream(&quot;</span>e:\\f1.txt<span class="string">&quot;));   //输出修改成到 &quot;</span>e:\\f1.txt<span class="string">&quot;   &quot;</span>南京,你好<span class="string">&quot;  就会写到&quot;</span>e:\\f1.txt<span class="string">&quot;文件中</span></span><br><span class="line"><span class="string">&gt;System.out.println(&quot;</span>南京,你好<span class="string">&quot;); </span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="随机访问流">随机访问流</h5>
<blockquote>
<p>指的是支持随意跳转到文件的任意位置进行读写的 <code>RandomAccessFile</code> ;<code>RandomAccessFile</code> 比较常见的一个应用就是实现大文件的 <strong>断点续传</strong> 。</p>
<p><code>RandomAccessFile</code> 的实现依赖于 <code>FileDescriptor</code> (文件描述符) 和 <code>FileChannel</code> （内存映射文件）。</p>
<p><strong>断点续传</strong></p>
<p>​	简单来说就是上传文件中途暂停或失败（比如遇到网络问题）之后，不需要重新上传，只需要上传那些未成功上传的文件分片即可。分片（先将文件切分成多个文件分片）上传是断点续传的基础。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// openAndDelete 参数默认为 false 表示打开文件并且这个文件不会被删除</span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="title function_">RandomAccessFile</span><span class="params">(File file, String mode)</span></span><br><span class="line">&gt;<span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">&gt;<span class="built_in">this</span>(file, mode, <span class="literal">false</span>);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// 私有方法</span></span><br><span class="line">&gt;<span class="keyword">private</span> <span class="title function_">RandomAccessFile</span><span class="params">(File file, String mode, <span class="type">boolean</span> openAndDelete)</span>  <span class="keyword">throws</span> FileNotFoundException&#123;</span><br><span class="line">&gt;<span class="comment">// 省略大部分代码</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以指定 <code>mode</code>（读写模式）</p>
<ul>
<li><code>r</code> : 只读模式。</li>
<li><code>rw</code>: 读写模式</li>
<li><code>rws</code>: 相对于 <code>rw</code>，<code>rws</code> 同步更新对“文件内容”或“元数据”的修改到外部存储设备。</li>
<li><code>rwd</code> : 相对于 <code>rw</code>，<code>rwd</code> 同步更新对“文件内容”的修改到外部存储设备。</li>
</ul>
<p>文件内容指的是文件中实际<code>保存的数据</code>，</p>
<p>元数据则是用来<code>描述文件属性</code>比如文件的大小信息、创建和修改时间。</p>
<p><code>RandomAccessFile</code> 中有一个文件指针用来表示下一个将要被写入或者读取的字节所处的位置。可以使用<code>seek(long pos)</code> 方法来设置文件指针的偏移量（距文件开头 <code>pos</code> 个字节处）。</p>
<p>​		如果想要获取文件指针当前的位置的话，可以使用 <code>getFilePointer()</code> 方法。</p>
<p><code>write</code> 方法在写入对象的时候如果对应的位置已经有数据的话，会将其覆盖掉。</p>
</blockquote>
<h3 id="反射">反射</h3>
<h4 id="问题引入">问题引入</h4>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt;创建对象 , 传统的方法，行不通 --&gt; <span class="keyword">new</span> <span class="title class_">classfullpath</span>(); --&gt; ×</span><br><span class="line"></span><br><span class="line">&gt;使用反射机制解决,加载类, 返回 Class 类型的对象 cls </span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//将配置文件的  classfullpath 字段转化为字符串类型</span></span><br><span class="line">&gt;<span class="type">String</span> <span class="variable">classfullpath</span> <span class="operator">=</span> properties.get(<span class="string">&quot;classfullpath&quot;</span>).toString();<span class="comment">//&quot;com.hspedu.Cat&quot; </span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//(1) 加载类, 返回 Class 类型的对象 cls</span></span><br><span class="line">&gt;<span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(classfullpath);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//(2) 通过 cls 得到 加载的类 com.hspedu.Cat 的对象实例</span></span><br><span class="line">&gt;<span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line">&gt;System.out.println(<span class="string">&quot;o 的运行类型=&quot;</span> + o.getClass()); <span class="comment">//运行类型</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//(3) 通过 cls 得到你加载的类 com.hspedu.Cat 的 methodName&quot;hi&quot; 的方法对象  即:在反射中，可以把方法视为对象(万物皆对象)</span></span><br><span class="line">&gt;<span class="type">Method</span> <span class="variable">method1</span> <span class="operator">=</span> cls.getMethod(methodName);</span><br><span class="line">&gt;<span class="comment">//(4) 通过 method1 调用方法: 即通过方法对象来实现调用方法 </span></span><br><span class="line">&gt;method1.invoke(o); </span><br><span class="line">&gt;------传统方法 对象.方法() ,  反射:方法.invoke(对象实例)</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//得到 name 字段</span></span><br><span class="line">&gt;<span class="comment">//getField 不能得到私有的属性</span></span><br><span class="line">&gt;------传统写法 对象.成员变量 ,    反射 : 成员变量对象.get(对象)</span><br><span class="line">&gt;<span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> cls.getField(<span class="string">&quot;age&quot;</span>); </span><br><span class="line"></span><br><span class="line">&gt;<span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> cls.getConstructor(); <span class="comment">//()中可以指定构造器参数类型, 返回无参构造器</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>Object o = Class.forName(&quot;com.hspedu.Cat&quot;).newInstance();           ------得到加载类的实例对象</code></p>
</blockquote>
<blockquote>
<p><code>Method method1 = cls.getMethod(methodName);   method1.invoke(o);     --------实现调用方法</code></p>
</blockquote>
<blockquote>
<p><code>Field nameField = cls.getField(&quot;age&quot;);                             -----得到指定字段的值</code></p>
</blockquote>
<blockquote>
<p><code>Constructor constructor = cls.getConstructor();                     ------------指定构造器参数类型</code></p>
</blockquote>
</blockquote>
<h4 id="核心">核心</h4>
<blockquote>
<p>**反射：**允许程序在执行期借助于   反射的API  取得  类的内部信息；加载完类之后，在堆中就产生了一个Class类型的对象,这个对象包含了类的完整结构信息。通过这个对象就能得到类的结构。</p>
<p><strong>原理介绍：</strong></p>
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304082012697.png" alt="image-20230408201240971" style="zoom:33%;">
<p><strong>Java 反射机制可以完成</strong></p>
<blockquote>
<ul>
<li>在运行时<code>判断</code>任意一个对象所属的类</li>
<li>在运行时<code>构造</code>任意一个类的对象</li>
<li>在运行时<code>得到</code>任意一个类所具有的成员变量和方法</li>
<li>在运行时<code>调用</code>任意一个对象的成员变量和方法</li>
<li><code>生成</code>动态代理</li>
</ul>
</blockquote>
<p><strong>反射的优化</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;<span class="comment">//传统方法来调用 hi</span></span><br><span class="line">&gt;&gt;cat.hi();</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;```java</span><br><span class="line">&gt;&gt;//反射机制调用方法 hi</span><br><span class="line">&gt;&gt;Class cls = Class.forName(&quot;com.hspedu.Cat&quot;); </span><br><span class="line">&gt;&gt;Object o = cls.newInstance();</span><br><span class="line">&gt;&gt;Method hi = cls.getMethod(&quot;hi&quot;);</span><br><span class="line">&gt;&gt;&gt;hi.invoke(o);//反射调用方法</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;```java</span><br><span class="line">&gt;&gt;//反射调用优化 + 关闭访问检查</span><br><span class="line">&gt;&gt;Class cls = Class.forName(&quot;com.hspedu.Cat&quot;);</span><br><span class="line">&gt;&gt;Object o = cls.newInstance();</span><br><span class="line">&gt;&gt;Method hi = cls.getMethod(&quot;hi&quot;); </span><br><span class="line">&gt;&gt;------hi.setAccessible(true);//在反射调用方法时，取消访问检查</span><br><span class="line">&gt;&gt;hi.invoke(o);//反射调用方法</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;**反射调用优化-关闭访问检查**</span><br><span class="line"></span><br><span class="line">&gt;&gt;- Method和Field、Constructor对象都有setAccessible()方法</span><br><span class="line"></span><br><span class="line">&gt;- setAccessible作用是启动和禁用访问安全检查的开关</span><br><span class="line"></span><br><span class="line">&gt;&gt;- 参数值为true表示反射的对象在使用时取消访问检查，提高反射的效率。参数值为false则表示反射的对象执行访问检查</span><br><span class="line"></span><br><span class="line">#### Class 类</span><br><span class="line"></span><br><span class="line">&gt;- Class也是类，因此也`继承Object类 `</span><br><span class="line">&gt;- Class类对象不是new出来的，而是`系统创建`的</span><br><span class="line">&gt;- 对于某个类的Class类对象，在`内存中只有一份`， 因为类只加载一次    ——&gt; 所以  hashCode() 值是一样的</span><br><span class="line">&gt;- 每个`类的实例`都会`知道`自己是由`哪个Class实例所生成`</span><br><span class="line">&gt;- 通过Class对象可以通过一系列API 完整地得到一个`类的完整结构`，</span><br><span class="line">&gt;- `Class对象`是存放在`堆的`</span><br><span class="line">&gt;- 类的`字节码`二进制数据，是放在`方法区`的，有的地方称为类的元数据(包括方法代码，变量名，方法名，访问权限等)</span><br><span class="line"></span><br><span class="line">&gt;**常用方法**</span><br><span class="line"></span><br><span class="line">&gt;`static Class forName(String name)`			返回(获得)指定类名的Class对象</span><br><span class="line"></span><br><span class="line">&gt;`getPackage()	`					                 	       得到包名</span><br><span class="line"></span><br><span class="line">&gt;`Object newInstance()	` 			   			     调用缺省构造函数，返回该Class对象的一个实例</span><br><span class="line"></span><br><span class="line">&gt;`getName()	` 												         返回此Class对象所表示的实体(类、接口、数组类、基本类型等)名称</span><br><span class="line"></span><br><span class="line">&gt;`Class [] getInterfaces()	`							获取当前Class对象的接口</span><br><span class="line"></span><br><span class="line">&gt;`ClassLoader getClassLoader()`					返回该类的类加载器</span><br><span class="line"></span><br><span class="line">&gt;`Class getSuperclass()`								  返回表示此Class所表示的实体的超类的Class</span><br><span class="line"></span><br><span class="line">&gt;`Constructor[] getConstructors()`				返回一个包含某些Constructor对象的数组</span><br><span class="line"></span><br><span class="line">&gt;`Field[] getDeclaredFields()	`					 返回Field对象的一个数组</span><br><span class="line"></span><br><span class="line">&gt;`Method getMethod(String name.Class ... paramTypes) `    返回一个Method对象，此对象的形参类型为paramType</span><br><span class="line"></span><br><span class="line">&gt;```java</span><br><span class="line">&gt;String classAllPath = &quot;com.hspedu.Car&quot;;</span><br><span class="line"></span><br><span class="line">&gt;//1 . 获取到 Car 类 对应的 Class 对象       &lt;?&gt; 表示不确定的 Java 类型</span><br><span class="line">&gt;Class&lt;?&gt; cls = Class.forName(classAllPath); </span><br><span class="line"></span><br><span class="line">&gt;//2. 输出 cls</span><br><span class="line">&gt;System.out.println(cls); //com.hspedu.Car       显示 cls 对象, 是哪个类的 Class 对象  </span><br><span class="line">&gt;System.out.println(cls.getClass());//java.lang.Class         输出 cls 运行类型 </span><br><span class="line"></span><br><span class="line">&gt;//3. 得到包名</span><br><span class="line">&gt;System.out.println(cls.getPackage().getName());//包名</span><br><span class="line"></span><br><span class="line">&gt;//4. 得到全类名</span><br><span class="line">&gt;System.out.println(cls.getName());</span><br><span class="line"></span><br><span class="line">&gt;//5. 通过 cls 创建对象实例</span><br><span class="line">&gt;Car car = (Car) cls.newInstance(); </span><br><span class="line">&gt;System.out.println(car);//car.toString()</span><br><span class="line"></span><br><span class="line">&gt;//6. 通过反射获取属性 brand</span><br><span class="line">&gt;Field brand = cls.getField(&quot;brand&quot;); </span><br><span class="line">&gt;System.out.println(brand.get(car));//宝马</span><br><span class="line"></span><br><span class="line">&gt;//7. 通过反射给属性赋值</span><br><span class="line">&gt;brand.set(car, &quot;奔驰&quot;); </span><br><span class="line">&gt;System.out.println(brand.get(car));//奔驰</span><br><span class="line"></span><br><span class="line">&gt;//8 我希望大家可以得到所有的属性(字段)</span><br><span class="line">&gt;Field[] fields = cls.getFields();</span><br><span class="line">&gt;for (Field f : fields) &#123;</span><br><span class="line">System.out.println(f.getName());//名称 </span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<blockquote>
<p><strong>获取Class类对象</strong></p>
<p>1、前提:<strong>已知一个类的全类名，且该类在类路径下</strong>，可通过Class类的静态方法   forName()	获取，可能抛出ClassNotFoundException,<br>
实例: <code>Class cls1 =Class.forName( &quot;java.lang.Cat&quot; );</code><br>
应用场景:多用于配置文件，读取类全路径，加载类.</p>
<p>2、前提:<strong>若已知具体的类</strong>，通过类的class获取，该方式最为安全可靠，程序性能最高==(优先于1)==<br>
实例: <code>Class cls2 = Cat.class;</code><br>
应用场景:多用于参数传递，比如通过反射得到对应构造器对象.<br>
3、前提:<strong>已知某个类的实例</strong>，调用该实例的getClass()方法获取Class对象，<br>
实例:<code>Class cla =对象.getClass();</code>//运行类型<br>
应用场景:通过创建好的对象，获取Class对象.<br>
4、<strong>其他方式：类加载器</strong><br>
<code>ClassLoader cls = 对象.getClass().getClassLoader(); Class cla = cls.loadClass(” 类的全类名”);</code><br>
5、<strong>8个基本数据</strong>按如下方式得到Class类对象<br>
<code>Class cls =基本数据类型.class</code><br>
6、基本数据类型对应的<strong>包装类</strong>，可以通过.TYPE得到Class类对象<br>
<code>Class cls =包装类.TYPE</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//1. Class.forName</span></span><br><span class="line">&gt;<span class="type">String</span> <span class="variable">classAllPath</span> <span class="operator">=</span> <span class="string">&quot;com.hspedu.Car&quot;</span>; <span class="comment">//通过读取配置文件获取 </span></span><br><span class="line">&gt;Class&lt;?&gt; cls1 = Class.forName(classAllPath); </span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//2. 类名.class , 应用场景: 用于参数传递 </span></span><br><span class="line">&gt;<span class="type">Class</span> <span class="variable">cls2</span> <span class="operator">=</span> Car.class; </span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//3. 对象.getClass(), 应用场景，有对象实例 </span></span><br><span class="line">&gt;<span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">&gt;<span class="type">Class</span> <span class="variable">cls3</span> <span class="operator">=</span> car.getClass(); </span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//4. 通过类加载器【4 种】来获取到类的 Class 对象 </span></span><br><span class="line">&gt;<span class="comment">//(1)先得到 car 的类加载器 </span></span><br><span class="line">&gt;<span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> car.getClass().getClassLoader(); </span><br><span class="line">&gt;<span class="comment">//(2)通过类加载器得到 Class 对象</span></span><br><span class="line">&gt;<span class="type">Class</span> <span class="variable">cls4</span> <span class="operator">=</span> classLoader.loadClass(classAllPath);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//5. 基本数据(int, char,boolean,float,double,byte,long,short) 按如下方式得到 Class 类对象 </span></span><br><span class="line">&gt;Class&lt;Integer&gt; integerClass = <span class="type">int</span>.class;</span><br><span class="line">&gt;Class&lt;Character&gt; characterClass = <span class="type">char</span>.class;</span><br><span class="line">&gt;Class&lt;Boolean&gt; booleanClass = <span class="type">boolean</span>.class;</span><br><span class="line">&gt;System.out.println(integerClass);<span class="comment">//int</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//6. 基本数据类型对应的包装类，可以通过 .TYPE 得到 Class 类对象</span></span><br><span class="line">&gt;Class&lt;Integer&gt; type1 = Integer.TYPE;</span><br><span class="line">&gt;Class&lt;Character&gt; type2 = Character.TYPE; <span class="comment">//其它包装类 BOOLEAN, DOUBLE, LONG,BYTE 等</span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>哪些类型有 Class 对象&lt;?&gt;      ? 可以填的内容：</strong></p>
<ul>
<li>外部类，成员内部类，静态内部类，局部内部类，匿名内部类</li>
<li>interface : 接口</li>
<li>数组</li>
<li>enum :枚举</li>
<li>annotation :注解</li>
<li>基本数据类型，</li>
<li>void</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   Class&lt;String&gt; stringClass = String.class;  <span class="comment">//外部类</span></span><br><span class="line">Class&lt;Serializable&gt; serializableClass = Serializable.class;  <span class="comment">//接口</span></span><br><span class="line">Class&lt;Integer[]&gt; aClass4 = Integer[].class;   <span class="comment">// 数组</span></span><br><span class="line">Class&lt;<span class="type">float</span>[][]&gt; aClass5 = <span class="type">float</span>[][].class;   <span class="comment">// 二维数组</span></span><br><span class="line">Class&lt;Deprecated&gt; deprecatedClass = Deprecated.class;<span class="comment">//注解</span></span><br><span class="line">Class&lt;Enum&gt; enumClass = Enum.class;<span class="comment">//枚举</span></span><br><span class="line">Class&lt;Thread.State&gt; stateClass = Thread.State.class;   <span class="comment">//枚举</span></span><br><span class="line">Class&lt;Long&gt; longClass = <span class="type">long</span>.class;  <span class="comment">//基本数据类型</span></span><br><span class="line">Class&lt;Void&gt; voidClass = <span class="keyword">void</span>.class; <span class="comment">// void数据类型</span></span><br><span class="line">Class&lt;Class&gt; classClass = Class.class;  <span class="comment">// Class</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="类加载">类加载</h4>
<blockquote>
<ul>
<li>
<p><strong>静态加载:编译时</strong>加载相关的类，如果没有  则报错，依赖性太强</p>
</li>
<li>
<p><strong>动态加载:运行时</strong>加载需要的类，如果运行时不用该类，即使不存在该类，也不报错，降低了依赖性</p>
</li>
</ul>
<p><strong>类加载时机</strong></p>
<ul>
<li>当创建对象时(new)                      //静态加载</li>
<li>当子类被加载时，父类也加载        //静态加载</li>
<li>调用类中的静态成员时                 //静态加载</li>
<li>通过反射                                    <a target="_blank" rel="noopener" href="//xn--Class-e86hzbv53p4x8g.forName">//动态加载Class.forName</a>(&quot; com.test.Cat&quot;):</li>
</ul>
<p><strong>加载过程</strong></p>
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304082056439.png" style="zoom:25%;">
<p><strong>加载阶段</strong></p>
<p>JVM在该阶段的主要目的是将字节码从不同的数据源转化为二进制字节流加载到内存中，并生成一个代表该类的java.lang.Class对象</p>
<p><strong>连接阶段验证</strong></p>
<p>为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<p>验证包括:文件格式验证(是否以魔数oxcafebabe开头)、元数据验证、字节码验证和符号引用验证</p>
<p>可以考虑使用-Xverify:none参数来关闭大部分的类验证措施，缩短虚拟机类加载的时间。</p>
<p><strong>连接阶段准备</strong></p>
<p>JVM会在该阶段对静态变量，分配内存并默认初始化。这些变量所使用的内存都将在方法区中进行分配</p>
<blockquote>
<ul>
<li>n1 是实例属性, 不是静态变量，因此在准备阶段，是不会分配内存</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>n2 是静态变量，分配内存 n2 是默认初始化 0 ,而不是 20</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>n3 是 static final 是常量, 他和静态变量不一样, 因为一旦赋值就不变 n3 = 30</li>
</ul>
</blockquote>
<blockquote>
<p><code>public int n1 = 10;</code><br>
<code>public static int n2 = 20;  public static final int n3 = 30;</code></p>
</blockquote>
<p><strong>连接阶段-解析</strong><br>
虚拟机将常量池内的符号引用   替换为  直接引用的过程。<br>
<strong>Initialization (初始化)</strong></p>
<p>执行&lt;clinit&gt;()方法；</p>
<p><clinit> ()方法作用是：由编译器按语句在源文件中出现的顺序，依次自动收集类中所有静态变量的赋值动作和静态代码块中的语句并进行合并。</clinit></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;代码:</span><br><span class="line">&gt;&gt;<span class="keyword">class</span> <span class="title class_">B</span>&#123;		</span><br><span class="line">&gt;&gt;<span class="keyword">static</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">  num = <span class="number">300</span>;	</span><br><span class="line">&gt;&gt;&#125;</span><br><span class="line">&gt;&gt;<span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span><span class="number">100</span>;</span><br><span class="line">&gt;&gt;<span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;B() 构造器被执行&quot;</span>);	</span><br><span class="line">&gt;&gt;&#125;	</span><br><span class="line">&gt;&gt;&#125;</span><br><span class="line">&gt;&gt;clinit的执行转换过程：</span><br><span class="line">&gt;&gt;<span class="comment">//1、加载B类,并生成B的Class对象	连接 num = 0;	初始化阶段</span></span><br><span class="line">&gt;&gt;<span class="comment">//2、依次执行自动收集类中的所有静态变量的赋值动作和静态代码块中的语句 并进行合并</span></span><br><span class="line">&gt;&gt;<span class="comment">/* clinit()&#123;	</span></span><br><span class="line"><span class="comment">System.out.println(&quot;hi&quot;);	</span></span><br><span class="line"><span class="comment">  num = 300;	</span></span><br><span class="line"><span class="comment">  num = 100;	 </span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  合并即为	</span></span><br><span class="line"><span class="comment">  num = 100</span></span><br><span class="line"><span class="comment">&gt;&gt;*/</span></span><br><span class="line">&gt;&gt;<span class="comment">//3、执行构造器new B();	</span></span><br><span class="line">&gt;&gt;System.out.println(<span class="keyword">new</span> <span class="title class_">B</span>().num);  <span class="comment">// 100,如果直接使用类的静态属性，也会导致类的加载 </span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>虚拟机 会保证一个类的&lt; clinit&gt; ()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类， 那么只会有一个线程去执行这个类的          &lt; clinit&gt;()方法，其他线程都需要阻塞等待，直到活动线程执行&lt; clinit&gt; ()方法完毕。</p>
</blockquote>
<h4 id="通过反射获取类的结构信息">通过反射获取类的结构信息</h4>
<blockquote>
<p><strong>前置</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">&gt;<span class="keyword">public</span> String hobby;</span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">&gt;<span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">&gt;<span class="keyword">public</span> <span class="title function_">A</span><span class="params">(String name)</span> &#123;&#125; </span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">interface</span> <span class="title class_">IA</span> &#123; &#125;</span><br><span class="line">&gt;<span class="keyword">interface</span> <span class="title class_">IB</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="meta">@Deprecated</span></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">IA</span>, IB &#123;</span><br><span class="line"><span class="comment">//属性</span></span><br><span class="line">&gt;<span class="keyword">public</span> String name;</span><br><span class="line">&gt;<span class="keyword">protected</span> <span class="keyword">static</span> <span class="type">int</span> age; <span class="comment">// 4 + 8 = 12 String job;</span></span><br><span class="line">&gt;<span class="keyword">private</span> <span class="type">double</span> sal;</span><br><span class="line">&gt;<span class="comment">//构造器</span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">&gt;<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123; &#125;</span><br><span class="line">&gt;<span class="comment">//私有构造器</span></span><br><span class="line">&gt;<span class="keyword">private</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">//方法</span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">double</span> sal)</span> &#123;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">protected</span> String <span class="title function_">m2</span><span class="params">()</span> &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> &#123;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="java-lang-Class-类">java.lang.Class 类</h5>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//得到 Class 对象</span></span><br><span class="line">&gt;Class&lt;?&gt; personCls = Class.forName(<span class="string">&quot;com.hspedu.reflection.Person&quot;</span>); </span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//getName:获取全类名</span></span><br><span class="line">&gt;System.out.println(personCls.getName());<span class="comment">//com.hspedu.reflection.Person </span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//getSimpleName:获取简单类名 </span></span><br><span class="line">&gt;System.out.println(personCls.getSimpleName());<span class="comment">//Person </span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//getFields:获取所有 public 修饰的属性，包含本类以及父类的 </span></span><br><span class="line">&gt;Field[] fields = personCls.getFields();</span><br><span class="line">&gt;<span class="keyword">for</span> (Field field : fields) &#123;<span class="comment">//增强 for</span></span><br><span class="line">System.out.println(<span class="string">&quot;本类以及父类的属性=&quot;</span> + field.getName()); </span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//getDeclaredFields:获取本类中所有属性</span></span><br><span class="line">&gt;Field[] declaredFields = personCls.getDeclaredFields();</span><br><span class="line">&gt;<span class="keyword">for</span> (Field declaredField : declaredFields) &#123; </span><br><span class="line">&gt;System.out.println(<span class="string">&quot;本类中所有属性=&quot;</span> + declaredField.getName());</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//getMethods:获取所有 public 修饰的方法，包含本类以及父类的 Method[] methods = personCls.getMethods();</span></span><br><span class="line">&gt;<span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">&gt;System.out.println(<span class="string">&quot;本类以及父类的方法=&quot;</span> + method.getName()); </span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//getDeclaredMethods:获取本类中所有方法</span></span><br><span class="line">&gt;Method[] declaredMethods = personCls.getDeclaredMethods(); </span><br><span class="line">&gt;<span class="keyword">for</span> (Method declaredMethod : declaredMethods) &#123;</span><br><span class="line">&gt;System.out.println(<span class="string">&quot;本类中所有方法=&quot;</span> + declaredMethod.getName()); </span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//getConstructors: 获取所有 public 修饰的构造器，包含本类 </span></span><br><span class="line">&gt;Constructor&lt;?&gt;[] constructors = personCls.getConstructors(); </span><br><span class="line">&gt;<span class="keyword">for</span> (Constructor&lt;?&gt; constructor : constructors) &#123;</span><br><span class="line">&gt;System.out.println(<span class="string">&quot;本类的构造器=&quot;</span> + constructor.getName()); </span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//getDeclaredConstructors:获取本类中所有构造器</span></span><br><span class="line">&gt;Constructor&lt;?&gt;[] declaredConstructors = personCls.getDeclaredConstructors(); </span><br><span class="line">&gt;<span class="keyword">for</span> (Constructor&lt;?&gt; declaredConstructor : declaredConstructors) &#123;</span><br><span class="line">&gt;System.out.println(<span class="string">&quot;本类中所有构造器=&quot;</span> + declaredConstructor.getName());<span class="comment">//只是输出名 </span></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//getPackage:以 Package 形式返回 包信息 </span></span><br><span class="line">&gt;System.out.println(personCls.getPackage());<span class="comment">//com.hspedu.reflection </span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//getSuperClass:以 Class 形式返回父类信息</span></span><br><span class="line">&gt;Class&lt;?&gt; superclass = personCls.getSuperclass(); </span><br><span class="line">&gt;System.out.println(<span class="string">&quot;父类的 class 对象=&quot;</span> + superclass);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//getInterfaces:以 Class[]形式返回接口信息</span></span><br><span class="line">&gt;Class&lt;?&gt;[] interfaces = personCls.getInterfaces();</span><br><span class="line">&gt;<span class="keyword">for</span> (Class&lt;?&gt; anInterface : interfaces) &#123; </span><br><span class="line">&gt;System.out.println(<span class="string">&quot;接口信息=&quot;</span> + anInterface);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//getAnnotations:以 Annotation[] 形式返回注解信息 </span></span><br><span class="line">&gt;Annotation[] annotations = personCls.getAnnotations(); </span><br><span class="line">&gt;<span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">&gt;System.out.println(<span class="string">&quot;注解信息=&quot;</span> + annotation);<span class="comment">//注解 &#125;</span></span><br><span class="line">&gt;&#125; </span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="java-lang-reflect-Field-类">java.lang.reflect.Field 类</h5>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//得到 Class 对象</span></span><br><span class="line">&gt;Class&lt;?&gt; personCls = Class.forName(<span class="string">&quot;com.hspedu.reflection.Person&quot;</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//getDeclaredFields:获取本类中所有属性</span></span><br><span class="line">&gt;<span class="comment">//规定 说明: 默认修饰符 是0 ， public 是1 ，private 是 2 ，protected 是 4 , static 是 8 ，final 是 16 </span></span><br><span class="line">&gt;Field[] declaredFields = personCls.getDeclaredFields();</span><br><span class="line">&gt;<span class="keyword">for</span> (Field declaredField : declaredFields) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;本类中所有属性=&quot;</span> + declaredField.getName()+ </span><br><span class="line">                 <span class="string">&quot; 该属性的修饰符值=&quot;</span> + declaredField.getModifiers() + </span><br><span class="line">                 <span class="string">&quot; 该属性的类型=&quot;</span> + declaredField.getType());</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="java-lang-reflect-Method-类">java.lang.reflect.Method 类</h5>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//getDeclaredMethods:获取本类中所有方法</span></span><br><span class="line">&gt;Method[] declaredMethods = personCls.getDeclaredMethods(); </span><br><span class="line">&gt;<span class="keyword">for</span> (Method declaredMethod : declaredMethods) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;本类中所有方法=&quot;</span> + declaredMethod.getName()</span><br><span class="line">                     + <span class="string">&quot; 该方法的访问修饰符值=&quot;</span> + declaredMethod.getModifiers() </span><br><span class="line">                     + <span class="string">&quot; 该方法返回类型&quot;</span> + declaredMethod.getReturnType());</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//输出当前这个方法的形参数组情况</span></span><br><span class="line">&gt;Class&lt;?&gt;[] parameterTypes = declaredMethod.getParameterTypes(); </span><br><span class="line">  <span class="keyword">for</span> (Class&lt;?&gt; parameterType : parameterTypes) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;该方法的形参类型=&quot;</span> + parameterType); &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="java-lang-reflect-Constructor-类">java.lang.reflect.Constructor 类</h5>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//getDeclaredConstructors:获取本类中所有构造器</span></span><br><span class="line">&gt;Constructor&lt;?&gt;[] declaredConstructors = personCls.getDeclaredConstructors(); </span><br><span class="line">&gt;<span class="keyword">for</span> (Constructor&lt;?&gt; declaredConstructor : declaredConstructors) &#123;</span><br><span class="line">&gt;System.out.println(<span class="string">&quot;本类中所有构造器=&quot;</span> + declaredConstructor.getName());</span><br><span class="line"></span><br><span class="line">&gt;Class&lt;?&gt;[] parameterTypes = declaredConstructor.getParameterTypes(); </span><br><span class="line">&gt;<span class="keyword">for</span> (Class&lt;?&gt; parameterType : parameterTypes) &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;该构造器的形参类型=&quot;</span> + parameterType); </span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125; </span><br><span class="line"></span><br><span class="line">&gt;------ getModifiers   以 <span class="type">int</span> 形式返回修饰符   （和Method 一样）</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="通过反射创建对象">通过反射创建对象</h4>
<blockquote>
<blockquote>
<ul>
<li>方式一:调用类中的public修饰的无参构造器</li>
<li>方式二:调用类中的指定构造器</li>
<li>Class类相关方法</li>
<li>newInstance :调用类中的无参构造器，获取<code>对应类</code>的对象</li>
<li>getConstructor(Class…clazz):根据参数列表，获取对应的<code>public构造器</code>对象</li>
<li>getDecalaredConstructor(Class…clazz):根据参数列表，获取<code>对应的所有构造器</code>对象</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>Constructor类相关方法</li>
<li>setAccessible:暴破</li>
<li>newlnstance(objet…obj):调用构造器</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&gt;------ 通过反射创建某类的对象，要求该类中必须有 <span class="keyword">public</span> 的无参构造</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//1. 先获取到 User 类的 Class 对象 </span></span><br><span class="line">&gt;Class&lt;?&gt; userClass = Class.forName(<span class="string">&quot;com.ry.reflect.User&quot;</span>); </span><br><span class="line">&gt;<span class="comment">//2. 通过 public 的无参构造器创建实例 </span></span><br><span class="line">&gt;<span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> userClass.newInstance(); </span><br><span class="line">&gt;System.out.println(o);   <span class="comment">//User [age=10, name=小明]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//3. 通过 public 的有参构造器创建实例 </span></span><br><span class="line">&gt;<span class="comment">/* constructor 对象就是User中的有参构造器 </span></span><br><span class="line"><span class="comment">  public User(String name) &#123;//public 的有参构造器 </span></span><br><span class="line"><span class="comment">  this.name = name;</span></span><br><span class="line"><span class="comment">  &#125; </span></span><br><span class="line"><span class="comment">&gt;*/</span> </span><br><span class="line">&gt;<span class="comment">//3.1 先得到对应构造器</span></span><br><span class="line">&gt;Constructor&lt;?&gt; constructor = userClass.getConstructor(String.class); </span><br><span class="line">&gt;<span class="comment">//3.2 创建实例，并传入实参   实质类似于  Person dog = new Person();</span></span><br><span class="line">&gt;Object dog= constructor.newInstance(<span class="string">&quot;dog&quot;</span>); </span><br><span class="line">&gt;System.out.println(dog);  <span class="comment">//User [age=10, name=小明]  </span></span><br><span class="line">&gt;<span class="comment">//如果没有User中没有赋值并且没有重写toString()方法 返回的就是：com.ry.reflect.User@... (地址)   就是下面的 Student中的例子</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;------------通过调用某个特定构造器的方式，实现创建某类的对象</span><br><span class="line">&gt;<span class="comment">//4. 通过非 public 的有参构造器创建实例 </span></span><br><span class="line">&gt;<span class="comment">//4.1 得到 private 的构造器对象    实质类似于  Person user2 = new Person(age,name);</span></span><br><span class="line">&gt;Constructor&lt;?&gt; constructor1 = userClass.getDeclaredConstructor(<span class="type">int</span>.class, String.class); </span><br><span class="line">&gt;<span class="comment">//4.2 创建实例;暴破【暴力破解】 , 使用反射可以访问 private 构造器/方法/属性, </span></span><br><span class="line">&gt;constructor1.setAccessible(<span class="literal">true</span>); </span><br><span class="line">&gt;<span class="type">Object</span> <span class="variable">user2</span> <span class="operator">=</span> constructor1.newInstance(<span class="number">100</span>, <span class="string">&quot;张三丰&quot;</span>); </span><br><span class="line">&gt;System.out.println(<span class="string">&quot;user2=&quot;</span> + user2);  <span class="comment">//user2=User [age=10, name=张三丰]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">User</span> &#123; <span class="comment">//User 类</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;&#125;<span class="comment">//无参 public </span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name)</span> &#123;&#125;<span class="comment">//public 的有参构造器 this.name = name;</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;<span class="comment">//private 有参构造器 this.age = age;</span></span><br><span class="line"><span class="built_in">this</span>.name = name; </span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="string">&quot;User [age=&quot;</span> + age + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">  &#125; </span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="通过反射访问类中的成员">通过反射访问类中的成员</h4>
<h5 id="访问属性"><strong>访问属性</strong></h5>
<blockquote>
<p>1.根据属性名获取Field对象		Field f = clazz对象.getDeclaredField(属性名);</p>
<p>2.暴破: 	f.setAccessible(true); //f是Field的对象</p>
<p>3.访问		f.set(o,值); //o 表示对象		System.out.println(f.get(o));//o表示对象</p>
<p>4.注意:	如果是静态属性，则set和get中的参数o,可以写成null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//1. 得到 Student 类对应的 Class 对象</span></span><br><span class="line">&gt;Class&lt;?&gt; stuClass = Class.forName(<span class="string">&quot;com.ry.reflect.Student&quot;</span>); </span><br><span class="line">&gt;<span class="comment">//2. 创建对象</span></span><br><span class="line">&gt;<span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> stuClass.newInstance();<span class="comment">//o 的运行类型就是 Student </span></span><br><span class="line">&gt;System.out.println(o.getClass());<span class="comment">//class com.ry.reflect.Student</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//3. 使用反射得到 age 属性对象</span></span><br><span class="line">&gt;<span class="type">Field</span> <span class="variable">age</span> <span class="operator">=</span> stuClass.getField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">&gt;age.set(o, <span class="number">88</span>);<span class="comment">//通过反射来操作属性 </span></span><br><span class="line">&gt;System.out.println(o);<span class="comment">//Student [age=88, name=null]</span></span><br><span class="line">&gt;System.out.println(age.get(o));<span class="comment">//88    返回 age 属性的值</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//4. 使用反射操作 name 属性</span></span><br><span class="line">&gt;<span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> stuClass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">&gt;<span class="comment">//对 name 进行暴破, 可以操作 private 属性</span></span><br><span class="line">&gt;name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">&gt;name.set(<span class="literal">null</span>, <span class="string">&quot;老韩~&quot;</span>);<span class="comment">//因为 name 是 static 属性，因此 o 也可以写出 null </span></span><br><span class="line">&gt;<span class="comment">//name.set(o, &quot;老韩&quot;);</span></span><br><span class="line">&gt;<span class="comment">//System.out.println(o);</span></span><br><span class="line">&gt;<span class="comment">//System.out.println(name.get(o)); //获取属性值 </span></span><br><span class="line">&gt;System.out.println(name.get(<span class="literal">null</span>));<span class="comment">//老韩~   获取属性值, 要求 name 是 static</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Student</span> &#123;<span class="comment">//类 </span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;&#125;<span class="comment">//构造器 </span></span><br><span class="line">&gt;<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Student [age=&quot;</span> + age + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&gt;&#125; </span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="访问方法">访问方法</h5>
<blockquote>
<p>1.根据方法名和参数列表获取Method方法对象:   Method m =clazz.getDeclaredMethod(方法名，XX.class); //得到本类的所有方法</p>
<p>2.获取对象: Object o= clazz.newlnstance();</p>
<p>3.暴破: m.setAccessible(true);</p>
<p>4.访问: Object returnValue = m.invoke(o,实参列表);//o就是对象</p>
<p>5.注意:如果是静态方法，则invoke的参数o,可以写成null!</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&gt;Class&lt;?&gt; bossCls = Class.forName(<span class="string">&quot;com.Reflection.Boss&quot;</span>); </span><br><span class="line">&gt;<span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> bossCls.newInstance(); </span><br><span class="line">&gt;System.out.println(o);<span class="comment">//com.ry.reflect.Boss@61bbe9ba</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//3. 调用 public 的 hi 方法 </span></span><br><span class="line">&gt;<span class="comment">//Method hi = bossCls.getMethod(&quot;hi&quot;, String.class);//OK </span></span><br><span class="line">&gt;<span class="comment">//3.1 得到 hi 方法对象 </span></span><br><span class="line">&gt;<span class="type">Method</span> <span class="variable">hi</span> <span class="operator">=</span> bossCls.getDeclaredMethod(<span class="string">&quot;hi&quot;</span>, String.class);<span class="comment">//OK </span></span><br><span class="line">&gt;<span class="comment">//3.2 调用 hi（）方法</span></span><br><span class="line">&gt;hi.invoke(o, <span class="string">&quot;南京你好~&quot;</span>);  <span class="comment">//hi 南京你好~</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//4. 调用 private static 方法 </span></span><br><span class="line">&gt;<span class="comment">//4.1 得到 say 方法对象 </span></span><br><span class="line">&gt;<span class="type">Method</span> <span class="variable">say</span> <span class="operator">=</span> bossCls.getDeclaredMethod(<span class="string">&quot;say&quot;</span>, <span class="type">int</span>.class, String.class, <span class="type">char</span>.class); </span><br><span class="line">&gt;<span class="comment">//4.2 因为 say 方法是 private, 所以需要暴破，原理和前面讲的构造器和属性一样 </span></span><br><span class="line">&gt;say.setAccessible(<span class="literal">true</span>); </span><br><span class="line">&gt;System.out.println(say.invoke(o, <span class="number">100</span>, <span class="string">&quot;张三&quot;</span>, <span class="string">&#x27;男&#x27;</span>));    <span class="comment">//100 张三 男</span></span><br><span class="line">&gt;<span class="comment">//4.3 因为 say 方法是 static 的，还可以这样调用 ，可以传入 null </span></span><br><span class="line">&gt;System.out.println(say.invoke(<span class="literal">null</span>, <span class="number">200</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&#x27;女&#x27;</span>)); <span class="comment">//200 李四 女</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//5. 在反射中，如果方法有返回值，统一返回Object , 但是他运行类型和方法定义的返回类型一致 </span></span><br><span class="line">&gt;<span class="type">Object</span> <span class="variable">reVal</span> <span class="operator">=</span> say.invoke(<span class="literal">null</span>, <span class="number">300</span>, <span class="string">&quot;王五&quot;</span>, <span class="string">&#x27;男&#x27;</span>); </span><br><span class="line">&gt;System.out.println(<span class="string">&quot;reVal 的运行类型=&quot;</span> + reVal.getClass());<span class="comment">//reVal 的运行类型=class java.lang.String</span></span><br><span class="line">&gt;<span class="type">Method</span> <span class="variable">m1</span> <span class="operator">=</span> bossCls.getDeclaredMethod(<span class="string">&quot;m1&quot;</span>); </span><br><span class="line">&gt;<span class="type">Object</span> <span class="variable">reVal1</span> <span class="operator">=</span> m1.invoke(o); </span><br><span class="line">&gt;System.out.println(<span class="string">&quot;reVal1的运行类型=&quot;</span> + reVal1.getClass());<span class="comment">//reVal1的运行类型=class com.ry.reflect.Monster</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Monster</span> &#123;&#125; </span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Boss</span> &#123;</span><br><span class="line">&gt;<span class="keyword">public</span> <span class="type">int</span> age; </span><br><span class="line">&gt;<span class="keyword">private</span> <span class="keyword">static</span> String name; </span><br><span class="line">&gt;<span class="keyword">public</span> <span class="title function_">Boss</span><span class="params">()</span> &#123;	&#125;<span class="comment">//构造器 </span></span><br><span class="line">&gt;<span class="keyword">public</span> Monster <span class="title function_">m1</span><span class="params">()</span> &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Monster</span>(); </span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">say</span><span class="params">(<span class="type">int</span> n, String s, <span class="type">char</span> c)</span> &#123;<span class="comment">//静态方法 </span></span><br><span class="line"><span class="keyword">return</span> n + <span class="string">&quot; &quot;</span> + s + <span class="string">&quot; &quot;</span> + c; </span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">(String s)</span> &#123;<span class="comment">//普通 public 方法</span></span><br><span class="line">&gt;System.out.println(<span class="string">&quot;hi &quot;</span> + s); </span><br><span class="line">&gt;&#125; </span><br><span class="line">&gt;&#125; </span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="网络编程">网络编程</h3>
<h5 id="InetAddress-类">InetAddress 类</h5>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//获取本机 InetAddress 对象 getLocalHost </span></span><br><span class="line">&gt;<span class="type">InetAddress</span> <span class="variable">localHost</span> <span class="operator">=</span> InetAddress.getLocalHost(); </span><br><span class="line">&gt;<span class="comment">//根据指定主机名/域名获取 ip 地址对象 getByName </span></span><br><span class="line">&gt;<span class="type">InetAddress</span> <span class="variable">host2</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;ThinkPad-PC&quot;</span>); </span><br><span class="line">&gt;<span class="type">InetAddress</span> <span class="variable">host3</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.baidui.com&quot;</span>); </span><br><span class="line">&gt;<span class="comment">//获取 InetAddress 对象的主机名 getHostName </span></span><br><span class="line">&gt;<span class="type">String</span> <span class="variable">host3Name</span> <span class="operator">=</span> host3.getHostName(); </span><br><span class="line">&gt;<span class="comment">//获取 InetAddress 对象的地址 getHostAddress </span></span><br><span class="line">&gt;<span class="type">String</span> <span class="variable">host3Address</span> <span class="operator">=</span> host3.getHostAddress(); </span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="Socket">Socket</h5>
<blockquote>
<ul>
<li>通信的两端都要有Socket,是两台机器间通信的端点</li>
</ul>
<blockquote>
<ul>
<li>网络通信其实就是Socket间的通信。</li>
</ul>
</blockquote>
<ul>
<li>Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输。</li>
</ul>
<blockquote>
<ul>
<li>一般主动发起通信的应用程序属客户端，等待通信请求的为服务端</li>
</ul>
</blockquote>
</blockquote>
<h5 id="TCP网络通信编程">TCP网络通信编程</h5>
<blockquote>
<p><strong>基本介绍</strong></p>
<ul>
<li>基于客户端和服务端的网络通信</li>
<li>底层使用的是TCP/IP协议</li>
<li>应用场景举例:客户端发送数据，服务端接受并显示控制台</li>
<li>基于Socket的TCP编程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="number">1</span>使用字节流，编写一个服务器端,和一个客户端;</span><br><span class="line">&gt;<span class="number">2</span>服务器端在 <span class="number">9999</span>端口监听</span><br><span class="line">&gt;<span class="number">3</span>客户端连接到服务器端， 发送<span class="string">&quot;hello, server&quot;</span>，</span><br><span class="line">&gt;<span class="number">4</span>然后退出，后服务器端接收到 客户端发送的信息，输出并退出</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;------Server端</span><br><span class="line">&gt;<span class="comment">//1. 在本机 的 9999 端口监听, 等待连接 </span></span><br><span class="line">&gt;<span class="comment">//细节: </span></span><br><span class="line">&gt;<span class="comment">//1要求在本机没有其它服务在监听 9999</span></span><br><span class="line">&gt;<span class="comment">//2这个 ServerSocket 可以通过 accept() 返回多个 Socket [多个客户端连接服务器的并发] </span></span><br><span class="line">&gt;<span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//2. 当没有客户端连接 9999 端口时，程序会阻塞, 等待连接,如果有客户端连接，则会返回 Socket 对象，程序继续 </span></span><br><span class="line">&gt;<span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept(); </span><br><span class="line">&gt;System.out.println(<span class="string">&quot;服务端 socket =&quot;</span> + socket.getClass()); </span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//3. 通过 socket.getInputStream() 读取客户端写入 在数据通道中的数据, 并显示 </span></span><br><span class="line">&gt;<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream(); </span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//4. IO 读取 </span></span><br><span class="line">&gt;<span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]; </span><br><span class="line">&gt;<span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">&gt;<span class="keyword">while</span> ((readLen = inputStream.read(buf)) != -<span class="number">1</span>) &#123; </span><br><span class="line">&gt;System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="number">0</span>, readLen));<span class="comment">//根据读取到的实际长度，显示内容. </span></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//5.关闭流和 socket </span></span><br><span class="line">&gt;inputStream.close(); </span><br><span class="line">&gt;socket.close(); </span><br><span class="line">&gt;serverSocket.close();<span class="comment">//关闭</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;------Client端</span><br><span class="line">&gt;<span class="comment">//1. 连接服务端 (ip , 端口） 连接本机的 9999 端口, 如果连接成功，返回 Socket 对象 </span></span><br><span class="line">&gt;<span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLocalHost(), <span class="number">9999</span>); </span><br><span class="line">&gt;System.out.println(<span class="string">&quot;客户端 socket 返回=&quot;</span> + socket.getClass()); </span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//2. 连接上后，生成 Socket, 通过 socket.getOutputStream() 得到 和 socket 对象关联的输出流对象 </span></span><br><span class="line">&gt;<span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream(); </span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//3. 通过输出流，写入数据到 数据通道 </span></span><br><span class="line">&gt;outputStream.write(<span class="string">&quot;hello, server&quot;</span>.getBytes()); </span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//4. 关闭流对象和 socket, 必须关闭 </span></span><br><span class="line">&gt;outputStream.close(); </span><br><span class="line">&gt;socket.close();</span><br><span class="line">&gt;System.out.println(<span class="string">&quot;客户端退出.....&quot;</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="number">1</span>使用字节流，编写一个服务器端,和一个客户端;</span><br><span class="line">&gt;<span class="number">2</span>服务器端在 <span class="number">9999</span>端口监听</span><br><span class="line">&gt;<span class="number">3</span>客户端连接到服务器端， 发送<span class="string">&quot;hello, server&quot;</span>，并接收服务器端回发的<span class="string">&quot;hello,client&quot;</span>,再退出</span><br><span class="line">&gt;<span class="number">4</span>然后退出，后服务器端接收到 客户端发送的信息，输出并发送<span class="string">&quot;hello, client&quot;</span>再退出</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// Server端</span></span><br><span class="line">&gt;<span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">&gt;System.out.println(<span class="string">&quot;服务端，在 9999 端口监听，等待连接..&quot;</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept(); </span><br><span class="line">&gt;System.out.println(<span class="string">&quot;服务端 socket =&quot;</span> + socket.getClass()); </span><br><span class="line"></span><br><span class="line">&gt;<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream(); </span><br><span class="line"></span><br><span class="line">&gt;<span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]; </span><br><span class="line">&gt;<span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">&gt;<span class="keyword">while</span> ((readLen = inputStream.read(buf)) != -<span class="number">1</span>) &#123; </span><br><span class="line">&gt;System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="number">0</span>, readLen));</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">//	获取 socket 相关联的输出流 </span></span><br><span class="line">&gt;<span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream(); </span><br><span class="line">&gt;outputStream.write(<span class="string">&quot;hello, client&quot;</span>.getBytes()); </span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//	设置结束标记 </span></span><br><span class="line">&gt;socket.shutdownOutput();</span><br><span class="line">&gt;outputStream.close(); </span><br><span class="line">&gt;inputStream.close(); </span><br><span class="line">&gt;socket.close(); </span><br><span class="line">&gt;serverSocket.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;------Client端</span><br><span class="line">&gt;<span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLocalHost(), <span class="number">9999</span>); </span><br><span class="line">&gt;System.out.println(<span class="string">&quot;客户端 socket 返回=&quot;</span> + socket.getClass()); </span><br><span class="line"></span><br><span class="line">&gt;<span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream(); </span><br><span class="line">&gt;outputStream.write(<span class="string">&quot;hello, server&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 设置结束标记 </span></span><br><span class="line">&gt;socket.shutdownOutput(); </span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 获取和 socket 关联的输入流. 读取数据(字节)，并显示 </span></span><br><span class="line">&gt;<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream(); </span><br><span class="line">&gt;<span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]; </span><br><span class="line">&gt;<span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">&gt;<span class="keyword">while</span> ((readLen = inputStream.read(buf)) != -<span class="number">1</span>) &#123; </span><br><span class="line">&gt;System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="number">0</span>, readLen)); </span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;inputStream.close(); </span><br><span class="line">&gt;outputStream.close(); </span><br><span class="line">&gt;socket.close(); </span><br><span class="line">&gt;System.out.println(<span class="string">&quot;客户端退出.....&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="number">1</span>使用字符流，编写一个服务器端,和一个客户端;</span><br><span class="line">&gt;<span class="number">2</span>服务器端在 <span class="number">9999</span>端口监听</span><br><span class="line">&gt;<span class="number">3</span>客户端连接到服务器端， 发送<span class="string">&quot;hello, server&quot;</span>，并接收服务器端回发的<span class="string">&quot;hello,client&quot;</span>,再退出</span><br><span class="line">&gt;<span class="number">4</span>然后退出，后服务器端接收到 客户端发送的信息，输出并发送<span class="string">&quot;hello, client&quot;</span>再退出</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;----------Server端</span><br><span class="line">&gt;<span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept(); </span><br><span class="line">&gt;System.out.println(<span class="string">&quot;服务端 socket =&quot;</span> + socket.getClass()); </span><br><span class="line"></span><br><span class="line">&gt;<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream(); </span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//IO 读取, 使用字符流, 使用 InputStreamReader 将 inputStream 转成字符流 </span></span><br><span class="line">&gt;<span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream)); </span><br><span class="line"></span><br><span class="line">&gt;<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> bufferedReader.readLine(); </span><br><span class="line">&gt;System.out.println(s);<span class="comment">//输出</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream(); </span><br><span class="line">&gt;<span class="comment">// 使用字符输出流的方式回复信息 </span></span><br><span class="line">&gt;<span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream)); </span><br><span class="line">&gt;bufferedWriter.write(<span class="string">&quot;hello client 字符流&quot;</span>); </span><br><span class="line">&gt;bufferedWriter.newLine();<span class="comment">// 插入一个换行符，表示回复内容的结束 </span></span><br><span class="line">&gt;bufferedWriter.flush();<span class="comment">//注意需要手动的 flush</span></span><br><span class="line"></span><br><span class="line">&gt;bufferedWriter.close(); </span><br><span class="line">&gt;bufferedReader.close();</span><br><span class="line">&gt;socket.close(); </span><br><span class="line">&gt;serverSocket.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;----------Client端</span><br><span class="line">&gt;<span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLocalHost(), <span class="number">9999</span>); </span><br><span class="line">&gt;System.out.println(<span class="string">&quot;客户端 socket 返回=&quot;</span> + socket.getClass());</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 通过输出流，写入数据到 数据通道, 使用字符流 </span></span><br><span class="line">&gt;<span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream(); </span><br><span class="line">&gt;<span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream)); </span><br><span class="line">&gt;bufferedWriter.write(<span class="string">&quot;hello, server 字符流&quot;</span>); </span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//插入一个换行符，表示写入的内容结束, 注意，要求对方使用readLine()! 		</span></span><br><span class="line">&gt;bufferedWriter.newLine();</span><br><span class="line">&gt;bufferedWriter.flush();<span class="comment">//如果使用的字符流,要手动刷新,否则数据不会写入数据通道 </span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//获取和 socket 关联的输入流. 读取数据(字符)，并显示 </span></span><br><span class="line">&gt;<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream(); </span><br><span class="line">&gt;<span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream)); </span><br><span class="line"></span><br><span class="line">&gt;<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> bufferedReader.readLine(); </span><br><span class="line">&gt;System.out.println(s)</span><br><span class="line"></span><br><span class="line">&gt;bufferedReader.close();</span><br><span class="line">&gt;bufferedWriter.close();</span><br><span class="line">&gt;socket.close(); </span><br><span class="line">&gt;System.out.println(<span class="string">&quot;客户端退出.....&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="number">1.</span> 编写一个服务端和一个客户端,服务器端在 <span class="number">8888</span>端口监听</span><br><span class="line">&gt;<span class="number">2.</span> 客户端连接到服务端，发送一张图片e:\qie.png </span><br><span class="line">&gt;<span class="number">3.</span> 服务器端接收到 客户端发送的图片，保存到src下，发送<span class="string">&quot;收到图片&quot;</span>再退出</span><br><span class="line">&gt;<span class="number">4.</span> 客户端接收到服务端发送的<span class="string">&quot;收到图片&quot;</span>，再退出[会使用到事先做好的工具类]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;----------Server</span><br><span class="line">&gt;<span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>); </span><br><span class="line">&gt;System.out.println(<span class="string">&quot;服务端在 8888 端口监听....&quot;</span>); </span><br><span class="line"></span><br><span class="line">&gt;<span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept(); </span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 通过 Socket 得到输入流 </span></span><br><span class="line">&gt;<span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(socket.getInputStream()); </span><br><span class="line">&gt;<span class="type">byte</span>[] bytes = StreamUtils.streamToByteArray(bis);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//将得到 bytes 数组，写入到指定的路径，就得到一个文件了 </span></span><br><span class="line">&gt;<span class="type">String</span> <span class="variable">destFilePath</span> <span class="operator">=</span> <span class="string">&quot;src\\abc.mp4&quot;</span>; </span><br><span class="line">&gt;<span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFilePath)); </span><br><span class="line">&gt;bos.write(bytes); </span><br><span class="line">&gt;bos.close(); </span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 向客户端回复 &quot;收到图片&quot;,并通过 socket 获取到输出流(字符) </span></span><br><span class="line">&gt;<span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(socket.getOutputStream())); </span><br><span class="line">&gt;writer.write(<span class="string">&quot;收到图片&quot;</span>); </span><br><span class="line">&gt;writer.flush();<span class="comment">//把内容刷新到数据通道 </span></span><br><span class="line">&gt;socket.shutdownOutput();<span class="comment">//设置写入结束标记 </span></span><br><span class="line"></span><br><span class="line">&gt;writer.close(); </span><br><span class="line">&gt;bis.close(); </span><br><span class="line">&gt;socket.close(); </span><br><span class="line">&gt;serverSocket.close(); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;----------Client</span><br><span class="line"></span><br><span class="line">&gt;<span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLocalHost(), <span class="number">8888</span>); </span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//创建读取磁盘文件的输入流 </span></span><br><span class="line">&gt;<span class="comment">//String filePath = &quot;e:\\qie.png&quot;; </span></span><br><span class="line">&gt;<span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\abc.mp4&quot;</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath)); </span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//bytes 就是 filePath 对应的字节数组 </span></span><br><span class="line">&gt;<span class="type">byte</span>[] bytes = StreamUtils.streamToByteArray(bis); </span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//通过 socket 获取到输出流, 将 bytes 数据发送给服务端 </span></span><br><span class="line">&gt;<span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(socket.getOutputStream()); </span><br><span class="line">&gt;bos.write(bytes);<span class="comment">//将文件对应的字节数组的内容，写入到数据通道 </span></span><br><span class="line">&gt;bis.close(); </span><br><span class="line">&gt;socket.shutdownOutput();<span class="comment">//设置写入数据的结束标记 </span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//=====接收从服务端回复的消息===== </span></span><br><span class="line">&gt;<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream(); </span><br><span class="line">&gt;<span class="comment">//使用 StreamUtils 的方法，直接将 inputStream 读取到的内容 转成字符串 </span></span><br><span class="line">&gt;<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> StreamUtils.streamToString(inputStream); </span><br><span class="line">&gt;System.out.println(s);</span><br><span class="line"></span><br><span class="line">&gt;inputStream.close(); </span><br><span class="line">&gt;bos.close(); </span><br><span class="line">&gt;socket.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;----------工具类</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamUtils</span> &#123; </span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 功能:将输入流转换成 byte[] </span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] streamToByteArray(InputStream is) <span class="keyword">throws</span> Exception&#123; </span><br><span class="line">          <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();<span class="comment">//创建输出流对象 </span></span><br><span class="line">          <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">          <span class="type">int</span> len;</span><br><span class="line">          <span class="keyword">while</span>((len=is.read(b))!=-<span class="number">1</span>)&#123;</span><br><span class="line">              bos.write(b, <span class="number">0</span>, len); </span><br><span class="line">          &#125;</span><br><span class="line">          <span class="type">byte</span>[] array = bos.toByteArray(); bos.close();</span><br><span class="line">          <span class="keyword">return</span> array;</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 功能:将 InputStream 转换成 String </span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">streamToString</span><span class="params">(InputStream is)</span> <span class="keyword">throws</span> Exception&#123; </span><br><span class="line">          <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is)); </span><br><span class="line">          StringBuilder builder= <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">          String line;</span><br><span class="line">          <span class="keyword">while</span>((line=reader.readLine())!=<span class="literal">null</span>)&#123; <span class="comment">//当读取到 null 时，就表示结束 </span></span><br><span class="line">              builder.append(line+<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> builder.toString();</span><br><span class="line">          &#125; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="netstat-指令">netstat 指令</h5>
<blockquote>
<p>netstat -an可以查看当前主机网络情况，包括端口监听情况和网络连接情况</p>
<p>netstat -an| more 可以分页显示</p>
</blockquote>
<h5 id="UDP-网络通信编程">UDP 网络通信编程</h5>
<blockquote>
<p><strong>基本介绍</strong></p>
<ul>
<li>类<code>DatagramSocket</code>和<code>DatagramPacket</code>[数据包/数据报]实现了基于UDP协议网络程序。</li>
<li>UDP数据报通过数据报套接字<code>DatagramSocket</code>发送和接收，系统不保证UDP数据报一定能够安全送到目的地，也不能确定什么时候可以抵达。</li>
<li>DatagramPacket 对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号。</li>
<li>UDP协议中每个数据报都给出完整的地址信息，因此无须建立发送方和接收方的连接</li>
</ul>
<p><strong>基本流程</strong></p>
<ul>
<li>核心的两个类/对象<code>DatagramSocket</code>与<code>DatagramPacket</code></li>
<li>建立发送端，接收端(没有服务端和客户端概念)</li>
<li>发送数据前，建立数据包/报DatagramPacket对象</li>
<li>调用DatagramSocket的发送、接收方法</li>
<li>关闭DatagramSocket</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="number">1.</span>编写一个接收端A,和一个发送端B</span><br><span class="line">&gt;<span class="number">2.</span>接收端A在<span class="number">9999</span>端口等待接收数据(receive)</span><br><span class="line">&gt;<span class="number">3.</span>发送端B向接收端A发送数据<span class="string">&quot;hello ,明天吃火锅~&quot;</span></span><br><span class="line">&gt;<span class="number">4.</span>接收端A接收到发送端B发送的数据，回复<span class="string">&quot;好的，明天见&quot;</span>，再退出</span><br><span class="line">&gt;<span class="number">5.</span>发送端接收回复的数据，再退出</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;---------------Receiver</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//创建一个 DatagramSocket 对象，准备在 9999 接收数据 </span></span><br><span class="line">&gt;<span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//构建一个 DatagramPacket 对象，准备接收数据 </span></span><br><span class="line">&gt;<span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]; </span><br><span class="line">&gt;<span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buf, buf.length); </span><br><span class="line">&gt;<span class="comment">//调用接收方法, 将通过网络传输的 DatagramPacket对象填充到packet对象 </span></span><br><span class="line">&gt;<span class="comment">//当有数据包发送到 本机的 9999 端口时，就会接收到数据 </span></span><br><span class="line">&gt;<span class="comment">//如果没有数据包发送到 本机的 9999 端口, 就会阻塞等待。</span></span><br><span class="line">&gt;System.out.println(<span class="string">&quot;接收端 A 等待接收数据..&quot;</span>); </span><br><span class="line">&gt;socket.receive(packet);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//可以把 packet 进行拆包，取出数据，并显示. </span></span><br><span class="line">&gt;<span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> packet.getLength();<span class="comment">//实际接收到的数据字节长度 </span></span><br><span class="line">&gt;<span class="type">byte</span>[] data = packet.getData();<span class="comment">//接收到数据 </span></span><br><span class="line">&gt;<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(data, <span class="number">0</span>, length); </span><br><span class="line">&gt;System.out.println(s); </span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//===回复信息给 B 端 </span></span><br><span class="line">&gt;<span class="comment">//将需要发送的数据，封装到 DatagramPacket 对象 </span></span><br><span class="line">&gt;data = <span class="string">&quot;好的, 明天见&quot;</span>.getBytes(); </span><br><span class="line">&gt;<span class="comment">//说明: 封装的DatagramPacket 对象data内容字节数组 , data.length主机(IP) ,端口 </span></span><br><span class="line">&gt;packet = <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data, data.length, InetAddress.getByName(<span class="string">&quot;192.168.12.1&quot;</span>), <span class="number">9998</span>); </span><br><span class="line">&gt;socket.send(packet);<span class="comment">//发送 </span></span><br><span class="line"></span><br><span class="line">&gt;socket.close(); </span><br><span class="line">&gt;System.out.println(<span class="string">&quot;A 端退出...&quot;</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;----------------------Sender</span><br><span class="line">&gt;<span class="comment">//创建 DatagramSocket 对象，准备在 9998 端口 接收数据 </span></span><br><span class="line">&gt;<span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9998</span>); </span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//将要发送的数据，封装到 DatagramPacket 对象 </span></span><br><span class="line">&gt;<span class="type">byte</span>[] data = <span class="string">&quot;hello 明天吃火锅~&quot;</span>.getBytes(); </span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//说明: 封装的 DatagramPacket 对象 data 内容字节数组 , data.length , 主机(IP) , 端口 </span></span><br><span class="line">&gt;<span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data, data.length, InetAddress.getByName(<span class="string">&quot;192.168.12.1&quot;</span>), <span class="number">9999</span>); </span><br><span class="line">&gt;socket.send(packet); </span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//接收从 A 端回复的信息,构建一个 DatagramPacket 对象，准备接收数据</span></span><br><span class="line">&gt;<span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]; </span><br><span class="line">&gt;packet = <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buf, buf.length); </span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//调用 接收方法, 将通过网络传输的 DatagramPacket 对象,填充到 packet 对象 </span></span><br><span class="line">&gt;<span class="comment">//当有数据包发送到 本机的 9998 端口时，就会接收到数据 </span></span><br><span class="line">&gt;<span class="comment">//如果没有数据包发送到 本机的 9998 端口, 就会阻塞等待. </span></span><br><span class="line">&gt;socket.receive(packet); </span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//可以把 packet 进行拆包，取出数据，并显示. </span></span><br><span class="line">&gt;<span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> packet.getLength();<span class="comment">//实际接收到的数据字节长度 </span></span><br><span class="line">&gt;data = packet.getData();<span class="comment">//接收到数据 </span></span><br><span class="line">&gt;<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(data, <span class="number">0</span>, length); </span><br><span class="line">&gt;System.out.println(s); </span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//关闭资源 </span></span><br><span class="line">&gt;socket.close(); </span><br><span class="line">&gt;System.out.println(<span class="string">&quot;B 端退出&quot;</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="JDBC">JDBC</h3>
<h5 id="JDBC-的相关-API-小结">JDBC 的相关 API 小结</h5>
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304091508201.png" alt="image-20230409150812071" style="zoom:33%;">
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304091508200.png" alt="image-20230409150824079" style="zoom:33%;">
<h2 id="Java8新特性">Java8新特性</h2>
<h3 id="Lambda">Lambda</h3>
<h4 id="语法">语法</h4>
<blockquote>
<p>Lambda 表达式：在Java 8 语言中引入的一种新的语法元素和操作符。这个操作符为 “<strong>-&gt;</strong>” ， 该操作符被称为 <strong>Lambda</strong> <strong>操作符或箭头操作符</strong>。</p>
<p>它将 Lambda 分为两个部分：</p>
<p><strong>左侧：<strong>指定了 Lambda 表达式需要的</strong>参数列表</strong></p>
<p>**右侧：**指定了 <strong>Lambda</strong> <strong>体</strong>，是抽象方法的实现逻辑，也即Lambda 表达式要执行的功能。</p>
</blockquote>
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304091556367.png" alt="image-20230303231532143" style="zoom:33%;">
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202303032318941.png" alt="image-20230303231832864" style="zoom:33%;">
<h4 id="类型推断"><strong>类型推断</strong></h4>
<p>即：Lambda 表达式中的参数类型都是由编译器推断得出的。Lambda 表达式中无需指定类型，程序依然可以编译，这是因为 javac 根据程序的上下文，在后台推断出了参数的类型。Lambda 表达式的类型依赖于上下文环境，由编译器推断出来的。</p>
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202303032328811.png" alt="image-20230303232854741" style="zoom:33%;">
<h4 id="Lambda使用">Lambda使用</h4>
<blockquote>
<p>1、举例   (o1,o2) -&gt; Integer.compare(o1,o2);</p>
<p>2、格式：</p>
<p>​		-&gt;: Lambda 称为操作符或者叫箭头操作符</p>
<p>​		-&gt;左边: Lambda形参列表(其实就是接口中的抽象方法的形参列表)</p>
<p>​		-&gt;右边：lambda体(其实就是重写的的抽象方法的方法体)</p>
<p>​		Lambda左边：形参列表类型可以省略(类型推断):如果lambda形参列表只有一个参数，其一对小括号也可以省略</p>
<p>​		Lambda右边：lambda体应该用一对{}包含，如果lambda体只有一条执行语句,{}和{return…} 可以省</p>
<p>3、Lambda 表达式的使用(6种方法)<br>
4、Lambda 表达式的本质 ：作为接口的实例</p>
</blockquote>
<h4 id="Lambda使用举例">Lambda使用举例</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lambda_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 语法格式一: 无参，无返回值</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;nju&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        runnable.run();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//lambda 表达式  -&gt;</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;nju&quot;</span>);</span><br><span class="line">        runnable.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 语法格式二:Lambda 需要一个参数，但是没有返回值</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">        Consumer&lt;String&gt; con = <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        con.accept(<span class="string">&quot;南京&quot;</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">//lambda 表达式  -&gt;</span></span><br><span class="line">        Consumer&lt;String&gt; con = (String s) -&gt; &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;;</span><br><span class="line">        con.accept(<span class="string">&quot;南京&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 语法格式三：数据类型可以省略，因为可由编译器推断得出，称为“类型推断” [方式二的简化]</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span>&#123;</span><br><span class="line">        Consumer&lt;String&gt; con = <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        con.accept(<span class="string">&quot;南京&quot;</span>);</span><br><span class="line">        </span><br><span class="line"> 		<span class="comment">//lambda 表达式  -&gt;</span></span><br><span class="line">        Consumer&lt;String&gt; con = (s) -&gt; &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;;</span><br><span class="line">        con.accept(<span class="string">&quot;南京&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 语法格式四：Lambda 若只需要一个参数时，参数的小括号可以省略 [方式二、三的简化]</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span>&#123;</span><br><span class="line">        Consumer&lt;String&gt; con = <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        con.accept(<span class="string">&quot;南京&quot;</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">//lambda 表达式  -&gt;</span></span><br><span class="line">        Consumer&lt;String&gt; con = s -&gt; &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;;</span><br><span class="line">        con.accept(<span class="string">&quot;南京&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 语法格式五：Lambda 需要两个或以上的参数，多条执行语句，并且可以有返回值</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">m5</span><span class="params">()</span> &#123;</span><br><span class="line">        Comparator&lt;Integer&gt; com1 = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">                System.out.println(o1);</span><br><span class="line">                System.out.println(o2);</span><br><span class="line">                <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">compare1</span> <span class="operator">=</span> com1.compare(<span class="number">12</span>, <span class="number">21</span>);</span><br><span class="line">        System.out.println(compare1);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">         <span class="comment">//lambda 表达式  -&gt;</span></span><br><span class="line">        Comparator&lt;Integer&gt; com1 = (o1, o2) -&gt; &#123;</span><br><span class="line">            System.out.println(o1);</span><br><span class="line">            System.out.println(o2);</span><br><span class="line">            <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">compare1</span> <span class="operator">=</span> com1.compare(<span class="number">21</span>, <span class="number">21</span>);</span><br><span class="line">        System.out.println(compare1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 语法格式六：当 Lambda 体只有一条语句时，return 与大括号若有，都可以省略[方式五的简化]</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">m6</span><span class="params">()</span> &#123;</span><br><span class="line">        Comparator&lt;Integer&gt; com1 = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">compare1</span> <span class="operator">=</span> com1.compare(<span class="number">12</span>, <span class="number">21</span>);</span><br><span class="line">        System.out.println(compare1);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">         <span class="comment">//lambda 表达式  -&gt;</span></span><br><span class="line">        Comparator&lt;Integer&gt; com1 = (o1, o2) -&gt;  o1.compareTo(o2);</span><br><span class="line">        <span class="type">int</span> <span class="variable">compare1</span> <span class="operator">=</span> com1.compare(<span class="number">12</span>, <span class="number">21</span>);</span><br><span class="line">        System.out.println(compare1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法引用与构造器引用">方法引用与构造器引用</h3>
<h4 id="方法引用-Method-References">方法引用(Method References)</h4>
<blockquote>
<p>1、当要传递给Lambda体的操作，如果方法体中只有一个方法的调用的话（包括构造方法）,我们可以用方法引用进一步简化代码。</p>
<p>2、方法引用可以看做是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖。</p>
<p>3、要求：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致！</p>
<p>4、格式：使用操作符 “<strong>::</strong>” 将类(或对象) 与 方法名分隔开来。</p>
<p>5、如下三种主要使用情况：</p>
<p>​			1、<strong>对象::实例方法名</strong></p>
<p>​			2、<strong>类::静态方法名</strong></p>
<p>​			3、<strong>类::实例方法名</strong></p>
</blockquote>
<h4 id="方法引用举例">方法引用举例</h4>
<h5 id="引用类的静态方法">引用类的静态方法</h5>
<blockquote>
<p>如果我们在重写方法的时候，方法体中<strong>只有一行代码</strong>，并且这行代码是调用了某个类的<strong>静态方法</strong>，并且我们把要  重写的<strong>抽象方法中所有的参数都按照顺序传入了这个静态方法</strong>中，这个时候我们就可以引用类的静态方法。</p>
<p><code>类名::方法名</code></p>
<p>例如：</p>
<p>如下代码就可以用方法引用进行简化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"></span><br><span class="line">Stream&lt;Author&gt; authorStream = authors.stream();</span><br><span class="line"></span><br><span class="line">authorStream.map(author -&gt; author.getAge())</span><br><span class="line">        .map(age-&gt;String.valueOf(age));</span><br></pre></td></tr></table></figure>
<p>注意，如果我们所重写的方法是没有参数的，调用的方法也是没有参数的也相当于符合以上规则。</p>
<p>优化后如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"></span><br><span class="line">Stream&lt;Author&gt; authorStream = authors.stream();</span><br><span class="line"></span><br><span class="line">authorStream.map(author -&gt; author.getAge())</span><br><span class="line">        .map(String::valueOf);</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="引用对象的实例方法">引用对象的实例方法</h5>
<blockquote>
<p>​	如果我们在重写方法的时候，方法体中<strong>只有一行代码</strong>，并且这行代码是调用了某个对象的<strong>成员方法</strong>，并且我们把要重写的<strong>抽象方法中所有的参数都按照顺序传入了这个成员方法中</strong>，这个时候我们就可以引用对象的实例方法</p>
<p><code>对象名::方法名</code></p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"></span><br><span class="line">Stream&lt;Author&gt; authorStream = authors.stream();</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">authorStream.map(author -&gt; author.getName())</span><br><span class="line">        .forEach(name-&gt;sb.append(name));</span><br></pre></td></tr></table></figure>
<p>优化后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"></span><br><span class="line">Stream&lt;Author&gt; authorStream = authors.stream();</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">authorStream.map(author -&gt; author.getName())</span><br><span class="line">        .forEach(sb::append);</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="引用类的实例方法">引用类的实例方法</h5>
<blockquote>
<p>如果我们在重写方法的时候，方法体中<strong>只有一行代码</strong>，并且这行代码是调用了第一个参数的<strong>成员方法</strong>，并且我们把要<strong>重写的抽象方法中</strong><code>剩余的所有的参数</code><strong>都按照顺序传入了这个成员方法中</strong>，这个时候我们就可以引用类的实例方法。</p>
<p><code>类名::方法名</code></p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">interface</span> <span class="title class_">UseString</span>&#123;</span><br><span class="line">  String <span class="title function_">use</span><span class="params">(String str,<span class="type">int</span> start,<span class="type">int</span> length)</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">subAuthorName</span><span class="params">(String str, UseString useString)</span>&#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> useString.use(str,start,length);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">  subAuthorName(<span class="string">&quot;三更草堂&quot;</span>, <span class="keyword">new</span> <span class="title class_">UseString</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">use</span><span class="params">(String str, <span class="type">int</span> start, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> str.substring(start,length);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化后如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">  subAuthorName(<span class="string">&quot;三更草堂&quot;</span>, String::substring);</span><br><span class="line"></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法引用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Method_References</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 使用情景 ：当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用</span></span><br><span class="line"><span class="comment">   * 方法引用 : 本质就是Lambda 表达式，而Lambda 表达式的本质 ：作为接口的实例</span></span><br><span class="line"><span class="comment">   * 所以： 方法引用也是函数接口的实例</span></span><br><span class="line"><span class="comment">   * 3 使用格式：</span></span><br><span class="line"><span class="comment">   *  （类）对象::实例方法名</span></span><br><span class="line"><span class="comment">   *      情况一 :  对象::实例方法名(非静态方法)</span></span><br><span class="line"><span class="comment">   *      情况二 :  类::静态方法名</span></span><br><span class="line"><span class="comment">   *      情况三 :  类::实例方法名</span></span><br><span class="line"><span class="comment">   * 4 方法引用使用的要求：</span></span><br><span class="line"><span class="comment">   *          接口中的抽象方法的形参列表和返回值类型与方法引用的方法的形参列表和返回值类型相同(针对情况一 、二)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="comment">//情况一 : 对象::实例方法名(非静态方法)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Consumer 中的 void accept(T t)</span></span><br><span class="line"><span class="comment">             PrintStream 中的 void println(T t)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.print(<span class="string">&quot;lambda 表达式:&quot;</span>);</span><br><span class="line">        Consumer&lt;String&gt; con1 = str -&gt; System.out.println(str);</span><br><span class="line">        con1.accept(<span class="string">&quot;南京&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;方法引用:&quot;</span>);</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">out</span> <span class="operator">=</span> System.out;</span><br><span class="line">        Consumer&lt;String&gt; con2 = out::println;</span><br><span class="line">        con2.accept(<span class="string">&quot;金陵&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Supplier 中的T get()</span></span><br><span class="line"><span class="comment">        Employee 中的String getName()   ----见Employee.java</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1001</span>,<span class="string">&quot;tom&quot;</span>,<span class="number">23</span>,<span class="number">20000</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;lambda 表达式:&quot;</span>);</span><br><span class="line">        Supplier&lt;String&gt; sup1 = () -&gt;employee.getName();</span><br><span class="line">        System.out.println(sup1.get());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法引用</span></span><br><span class="line">        System.out.print(<span class="string">&quot;方法引用:&quot;</span>);</span><br><span class="line">        Supplier&lt;String&gt; sup2 = employee ::getName;</span><br><span class="line">        System.out.println(sup2.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//情况二 :  类::静态方法名</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Comparator 中的int compare(T t1,T t2)</span></span><br><span class="line"><span class="comment">            Integer 中的 int compare(T t1,T t2)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> &#123;</span><br><span class="line">        Comparator&lt;Integer&gt; com = (t1, t2) -&gt; Integer.compare(t1, t2);</span><br><span class="line">        <span class="type">int</span> <span class="variable">compare</span> <span class="operator">=</span> com.compare(<span class="number">5</span>, <span class="number">9</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;lambda 表达式:&quot;</span>);</span><br><span class="line">        System.out.println(compare);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;方法引用:&quot;</span>);</span><br><span class="line">        Comparator&lt;Integer&gt; com1 = Integer::compare;</span><br><span class="line">        System.out.println(com1.compare(<span class="number">8</span>, <span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Function 中的 R apply(T t)</span></span><br><span class="line"><span class="comment">        Math 中的 Long round(T t)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;lambda 表达式:&quot;</span>);</span><br><span class="line">        Function&lt;Double,Long&gt; fun = d -&gt; Math.round(d);</span><br><span class="line">        System.out.println(fun.apply(<span class="number">12.5</span>));</span><br><span class="line">        System.out.print(<span class="string">&quot;方法引用:&quot;</span>);</span><br><span class="line">        Function&lt;Double,Long&gt; fun1 = Math::round;</span><br><span class="line">        System.out.println(fun1.apply(<span class="number">22.3</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//情况三 :  类::实例方法名</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Comparator 中的int compare (T t1, T t2)</span></span><br><span class="line"><span class="comment">        String 中的int compare (T t2)   [实际上是 t1.compare(t2) 所以 t1 可以省略]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m5</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;lambda 表达式:&quot;</span>);</span><br><span class="line">        Comparator&lt;String&gt; com1 = (o1, o2) -&gt; o1.compareTo(o2);</span><br><span class="line">        System.out.println(com1.compare(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abf&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;方法引用:&quot;</span>);</span><br><span class="line">        Comparator&lt;String&gt; com2 = String::compareTo;</span><br><span class="line">        System.out.println(com2.compare(<span class="string">&quot;acd&quot;</span>, <span class="string">&quot;acf&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        BiPredicate 中的boolean test (T t1, T t2)</span></span><br><span class="line"><span class="comment">        String 中的boolean equal(T t2)   [实际上是 t1.equal(t2) 所以 t1 可以省略]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m6</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;lambda 表达式:&quot;</span>);</span><br><span class="line">        BiPredicate&lt;String,String&gt; biPredicate =(o1,o2) -&gt; o1.equals(o2);</span><br><span class="line">        System.out.println(biPredicate.test(<span class="string">&quot;123&quot;</span>, <span class="string">&quot;124&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;方法引用:&quot;</span>);</span><br><span class="line">        BiPredicate&lt;String,String&gt; biPredicate1 = String::equals;</span><br><span class="line">        System.out.println(biPredicate1.test(<span class="string">&quot;123&quot;</span>, <span class="string">&quot;123&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Function 中的 R apply (T t)</span></span><br><span class="line"><span class="comment">        Employee 中的 String getAge()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m7</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;lambda 表达式:&quot;</span>);</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">employ</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">0000</span>, <span class="string">&quot;jack&quot;</span>, <span class="number">23</span>, <span class="number">5000</span>);</span><br><span class="line">        Function&lt;Employee,Integer&gt; fun = employee -&gt; employee.getAge();</span><br><span class="line">        System.out.println(fun.apply(employ));</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;方法引用:&quot;</span>);</span><br><span class="line">        Function&lt;Employee,Integer&gt; fun1 = Employee::getAge;</span><br><span class="line">        System.out.println(fun1.apply(employ));</span><br><span class="line">    &#125;		</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="构造器引用">构造器引用</h4>
<blockquote>
<p><strong>格式：</strong> <strong>类名::new</strong></p>
<p>如果方法体中的<strong>一行代码</strong>是构造器的话就可以使用构造器引用。</p>
<p>可以把构造器引用赋值给定义的方法，要求构造器参数列表要与接口中抽象方法的参数列表一致！且方法的返回值即为构造器对应类的对象。</p>
<h5 id="使用前提">使用前提</h5>
<p>​	如果我们在重写方法的时候，方法体中<strong>只有一行代码</strong>，并且这行代码是<strong>调用了某个类的构造方法</strong>，并且我们把<strong>要重写的抽象方法中的所有的参数都按照顺序传入了这个构造方法中</strong>，这个时候我们就可以引用构造器。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">authors.stream()</span><br><span class="line">        .map(author -&gt; author.getName())</span><br><span class="line">        .map(name-&gt;<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(name))-------------------------</span><br><span class="line">        .map(sb-&gt;sb.append(<span class="string">&quot;-三更&quot;</span>).toString())</span><br><span class="line">        .forEach(str-&gt; System.out.println(str));</span><br></pre></td></tr></table></figure>
<p>优化后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">authors.stream()</span><br><span class="line">        .map(author -&gt; author.getName())</span><br><span class="line">        .map(StringBuilder::<span class="keyword">new</span>)-------------------------</span><br><span class="line">        .map(sb-&gt;sb.append(<span class="string">&quot;-三更&quot;</span>).toString())</span><br><span class="line">        .forEach(str-&gt; System.out.println(str));</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器引用</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一、构造器引用</span></span><br><span class="line"><span class="comment"> * 格式： ClassName::new</span></span><br><span class="line"><span class="comment"> * 注意： 其与方法引用类似，函数式接口中抽象方法的形参列表和构造器的形参列表一致，抽象方法返回值类型即为构造器所属的类的类型</span></span><br><span class="line"><span class="comment"> * 二、构造器引用之：数组引用</span></span><br><span class="line"><span class="comment"> * 格式： type[] :: new</span></span><br><span class="line"><span class="comment"> * 注意： 将数组也视为一种类，那么写法与构造器引用一样</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constructor_Reference</span> &#123;</span><br><span class="line">   <span class="comment">//构造器引用</span></span><br><span class="line">    <span class="comment">//Supplier 中的为T get()</span></span><br><span class="line">    <span class="comment">//Employee 中的为Employee()</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//原始的oop</span></span><br><span class="line">        Supplier&lt;Employee&gt; sup = <span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;Employee&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Employee <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.print(<span class="string">&quot;原始的为:&quot;</span>);</span><br><span class="line">        System.out.println(sup.get());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// lambda 表达式</span></span><br><span class="line">        Supplier&lt;Employee&gt; sup1 = () -&gt; <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">        System.out.print(<span class="string">&quot;lambda 表达式:&quot;</span>);</span><br><span class="line">        System.out.println(sup1.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造器引用</span></span><br><span class="line">        Supplier&lt;Employee&gt; sup2 = Employee::<span class="keyword">new</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;方法引用:&quot;</span>);</span><br><span class="line">        System.out.println(sup2.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//Function 中的 R apply(T t)</span></span><br><span class="line">    <span class="comment">//Employee 中的为 Employee(int id)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">employee1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">        <span class="comment">//原始的oop</span></span><br><span class="line">        Function&lt;Integer,Employee&gt; fun =<span class="keyword">new</span> <span class="title class_">Function</span>&lt;Integer, Employee&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Employee <span class="title function_">apply</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.print(<span class="string">&quot;原始的为:&quot;</span>);</span><br><span class="line">        System.out.println(fun.apply(<span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// lambda 表达式</span></span><br><span class="line">        Function&lt;Integer,Employee&gt; fun1 = id -&gt; <span class="keyword">new</span> <span class="title class_">Employee</span>(id);</span><br><span class="line">        System.out.print(<span class="string">&quot;lambda 表达式:&quot;</span>);</span><br><span class="line">        System.out.println(fun1.apply(<span class="number">1001</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造器引用</span></span><br><span class="line">        Function&lt;Integer,Employee&gt; fun2 =Employee::<span class="keyword">new</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;方法引用:&quot;</span>);</span><br><span class="line">        System.out.println(fun2.apply(<span class="number">1002</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//BiFunction中的R apply(T t,U u)</span></span><br><span class="line">    <span class="comment">//Employee 中的为 (int id, String name)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">        <span class="comment">//原始的oop</span></span><br><span class="line">        BiFunction&lt;Integer,String,Employee&gt; biFunction = <span class="keyword">new</span> <span class="title class_">BiFunction</span>&lt; Integer, String,Employee&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Employee <span class="title function_">apply</span><span class="params">( Integer id,String name)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span>  <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">10000</span>,<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.print(<span class="string">&quot;原始的为:&quot;</span>);</span><br><span class="line">        System.out.println(biFunction.apply(<span class="number">10000</span>,<span class="string">&quot;jack&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// lambda 表达式</span></span><br><span class="line">        BiFunction&lt;Integer,String,Employee&gt; biFunction1 = (id,name) -&gt; <span class="keyword">new</span> <span class="title class_">Employee</span>(id,name);</span><br><span class="line">        System.out.print(<span class="string">&quot;lambda 表达式:&quot;</span>);</span><br><span class="line">        System.out.println(biFunction1.apply(<span class="number">10001</span>,<span class="string">&quot;john&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造器引用</span></span><br><span class="line">        BiFunction&lt;Integer,String,Employee&gt; biFunction2 =Employee::<span class="keyword">new</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;方法引用:&quot;</span>);</span><br><span class="line">        System.out.println(biFunction2.apply(<span class="number">10002</span>,<span class="string">&quot;joke&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//数组引用</span></span><br><span class="line">    <span class="comment">//Function中的R apply(T t)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;lambda 表达式&quot;</span>);</span><br><span class="line">        Function&lt;Integer,String[]&gt; fun1 = length -&gt; <span class="keyword">new</span> <span class="title class_">String</span>[length];</span><br><span class="line">        String[] apply = fun1.apply(<span class="number">5</span>);</span><br><span class="line">        System.out.println(Arrays.toString(apply));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;数组引用&quot;</span>);</span><br><span class="line">        Function&lt;Integer,String[]&gt; fun2 = String[] ::<span class="keyword">new</span>;</span><br><span class="line">        String[] apply1 = fun1.apply(<span class="number">3</span>);</span><br><span class="line">        System.out.println(Arrays.toString(apply1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">其中两者引用公用可能涉及的类：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line"><span class="comment">//以及对应的setter getter toString 构造器等方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeData</span> &#123;  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Employee&gt; <span class="title function_">getEmployees</span><span class="params">()</span>&#123;</span><br><span class="line">      List&lt;Employee&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      list.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1001</span>, <span class="string">&quot;马化腾&quot;</span>, <span class="number">34</span>, <span class="number">6000.38</span>));</span><br><span class="line">      list.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1002</span>, <span class="string">&quot;马云&quot;</span>, <span class="number">12</span>, <span class="number">9876.12</span>));</span><br><span class="line">      list.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1003</span>, <span class="string">&quot;刘强东&quot;</span>, <span class="number">33</span>, <span class="number">3000.82</span>));</span><br><span class="line">      list.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1004</span>, <span class="string">&quot;雷军&quot;</span>, <span class="number">26</span>, <span class="number">7657.37</span>));</span><br><span class="line">      list.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1005</span>, <span class="string">&quot;李彦宏&quot;</span>, <span class="number">65</span>, <span class="number">5555.32</span>));</span><br><span class="line">      list.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1006</span>, <span class="string">&quot;比尔盖茨&quot;</span>, <span class="number">42</span>, <span class="number">9500.43</span>));</span><br><span class="line">      list.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1007</span>, <span class="string">&quot;任正非&quot;</span>, <span class="number">26</span>, <span class="number">4333.32</span>));</span><br><span class="line">      list.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1008</span>, <span class="string">&quot;扎克伯格&quot;</span>, <span class="number">35</span>, <span class="number">2500.32</span>));</span><br><span class="line">	<span class="keyword">return</span> list; </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Stream流">==Stream流==</h3>
<h4 id="前置准备">前置准备</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;<span class="number">1.18</span><span class="number">.16</span>&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">   &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span><span class="comment">//用于后期的去重使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Author</span> &#123;</span><br><span class="line">    <span class="comment">//id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//年龄</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">//简介</span></span><br><span class="line">    <span class="keyword">private</span> String intro;</span><br><span class="line">    <span class="comment">//作品</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Book&gt; books;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span><span class="comment">//用于后期的去重使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="comment">//id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="comment">//书名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分类</span></span><br><span class="line">    <span class="keyword">private</span> String category;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//评分</span></span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//简介</span></span><br><span class="line">    <span class="keyword">private</span> String intro;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Author&gt; <span class="title function_">getAuthors</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//数据初始化</span></span><br><span class="line">        <span class="type">Author</span> <span class="variable">author</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Author</span>(<span class="number">1L</span>,<span class="string">&quot;蒙多&quot;</span>,<span class="number">33</span>,<span class="string">&quot;一个从菜刀中明悟哲理的祖安人&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="type">Author</span> <span class="variable">author2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Author</span>(<span class="number">2L</span>,<span class="string">&quot;亚拉索&quot;</span>,<span class="number">15</span>,<span class="string">&quot;狂风也追逐不上他的思考速度&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="type">Author</span> <span class="variable">author3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Author</span>(<span class="number">3L</span>,<span class="string">&quot;易&quot;</span>,<span class="number">14</span>,<span class="string">&quot;是这个世界在限制他的思维&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="type">Author</span> <span class="variable">author4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Author</span>(<span class="number">3L</span>,<span class="string">&quot;易&quot;</span>,<span class="number">14</span>,<span class="string">&quot;是这个世界在限制他的思维&quot;</span>,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//书籍列表</span></span><br><span class="line">        List&lt;Book&gt; books1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Book&gt; books2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Book&gt; books3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        books1.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="number">1L</span>,<span class="string">&quot;刀的两侧是光明与黑暗&quot;</span>,<span class="string">&quot;哲学,爱情&quot;</span>,<span class="number">88</span>,<span class="string">&quot;用一把刀划分了爱恨&quot;</span>));</span><br><span class="line">        books1.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="number">2L</span>,<span class="string">&quot;一个人不能死在同一把刀下&quot;</span>,<span class="string">&quot;个人成长,爱情&quot;</span>,<span class="number">99</span>,<span class="string">&quot;讲述如何从失败中明悟真理&quot;</span>));</span><br><span class="line"></span><br><span class="line">        books2.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="number">3L</span>,<span class="string">&quot;那风吹不到的地方&quot;</span>,<span class="string">&quot;哲学&quot;</span>,<span class="number">85</span>,<span class="string">&quot;带你用思维去领略世界的尽头&quot;</span>));</span><br><span class="line">        books2.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="number">3L</span>,<span class="string">&quot;那风吹不到的地方&quot;</span>,<span class="string">&quot;哲学&quot;</span>,<span class="number">85</span>,<span class="string">&quot;带你用思维去领略世界的尽头&quot;</span>));</span><br><span class="line">        books2.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="number">4L</span>,<span class="string">&quot;吹或不吹&quot;</span>,<span class="string">&quot;爱情,个人传记&quot;</span>,<span class="number">56</span>,<span class="string">&quot;一个哲学家的恋爱观注定很难把他所在的时代理解&quot;</span>));</span><br><span class="line"></span><br><span class="line">        books3.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="number">5L</span>,<span class="string">&quot;你的剑就是我的剑&quot;</span>,<span class="string">&quot;爱情&quot;</span>,<span class="number">56</span>,<span class="string">&quot;无法想象一个武者能对他的伴侣这么的宽容&quot;</span>));</span><br><span class="line">        books3.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="number">6L</span>,<span class="string">&quot;风与剑&quot;</span>,<span class="string">&quot;个人传记&quot;</span>,<span class="number">100</span>,<span class="string">&quot;两个哲学家灵魂和肉体的碰撞会激起怎么样的火花呢？&quot;</span>));</span><br><span class="line">        books3.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="number">6L</span>,<span class="string">&quot;风与剑&quot;</span>,<span class="string">&quot;个人传记&quot;</span>,<span class="number">100</span>,<span class="string">&quot;两个哲学家灵魂和肉体的碰撞会激起怎么样的火花呢？&quot;</span>));</span><br><span class="line"></span><br><span class="line">        author.setBooks(books1);</span><br><span class="line">        author2.setBooks(books2);</span><br><span class="line">        author3.setBooks(books3);</span><br><span class="line">        author4.setBooks(books3);</span><br><span class="line"></span><br><span class="line">        List&lt;Author&gt; authorList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(author,author2,author3,author4));</span><br><span class="line">        <span class="keyword">return</span> authorList;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="常用操作">常用操作</h4>
<h5 id="1-创建流">1 创建流</h5>
<blockquote>
<p>单列集合： <code>集合对象.stream()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">Stream&lt;Author&gt; stream = authors.stream();</span><br></pre></td></tr></table></figure>
<p>数组：<code>Arrays.stream(数组) </code>或者使用<code>Stream.of</code>来创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">Stream&lt;Integer&gt; stream = Arrays.stream(arr);</span><br><span class="line">Stream&lt;Integer&gt; stream2 = Stream.of(arr);</span><br></pre></td></tr></table></figure>
<p>双列集合：转换成单列集合后再创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;蜡笔小新&quot;</span>,<span class="number">19</span>);</span><br><span class="line">map.put(<span class="string">&quot;黑子&quot;</span>,<span class="number">17</span>);</span><br><span class="line">map.put(<span class="string">&quot;日向翔阳&quot;</span>,<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">Stream&lt;Map.Entry&lt;String, Integer&gt;&gt; stream = map.entrySet().stream();</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="2-中间操作">2 中间操作</h5>
<h6 id="filter">filter</h6>
<blockquote>
<p>​	可以对流中的元素进行<code>条件过滤</code>，符合过滤条件的才能继续留在流中。</p>
<p>例如：</p>
<p>​	打印所有姓名长度大于1的作家的姓名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">authors.stream()</span><br><span class="line">        .filter(author -&gt; author.getName().length()&gt;<span class="number">1</span>)</span><br><span class="line">        .forEach(author -&gt; System.out.println(author.getName()));</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="map">map</h6>
<blockquote>
<p>​	可以把对流中的元素进行<code>计算或转换</code>。</p>
<p>例如：</p>
<p>​	打印所有作家的<code>姓名</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"></span><br><span class="line">authors</span><br><span class="line">        .stream()</span><br><span class="line">        .map(author -&gt; author.getName())</span><br><span class="line">        .forEach(name-&gt;System.out.println(name));</span><br></pre></td></tr></table></figure>
<p>打印所有作家 <code>年龄+10</code> 的结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"></span><br><span class="line">authors.stream()</span><br><span class="line">        .map(author -&gt; author.getAge())</span><br><span class="line">        .map(age-&gt;age+<span class="number">10</span>)</span><br><span class="line">        .forEach(age-&gt; System.out.println(age));</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="distinct">distinct</h6>
<blockquote>
<p>​	可以<code>去除</code>流中的<code>重复元素</code></p>
<p>例如：</p>
<p>​	打印所有作家的姓名，并且要求其中不能有重复元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">authors.stream()</span><br><span class="line">        .distinct()</span><br><span class="line">        .forEach(author -&gt; System.out.println(author.getName()));</span><br></pre></td></tr></table></figure>
<p><strong>注意：distinct方法是依赖Object的equals方法来判断是否是相同对象的。所以需要注意重写equals方法。</strong></p>
</blockquote>
<h6 id="sorted">sorted</h6>
<blockquote>
<p>​	可以对流中的元素进行<code>排序</code>。</p>
<p>例如：</p>
<p>​	对流中的元素按照年龄进行<code>降序排序</code>，并且要求<code>不能有重复</code>的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">&gt;<span class="comment">//        对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素。</span></span><br><span class="line">  authors.stream()</span><br><span class="line">          .distinct()</span><br><span class="line">          .sorted()</span><br><span class="line">          .forEach(author -&gt; System.out.println(author.getAge()));</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">&gt;<span class="comment">//        对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素。</span></span><br><span class="line">  authors.stream()</span><br><span class="line">          .distinct()</span><br><span class="line">          .sorted((o1, o2) -&gt; o2.getAge()-o1.getAge())</span><br><span class="line">          .forEach(author -&gt; System.out.println(author.getAge()));</span><br></pre></td></tr></table></figure>
<p><strong>注意：如果调用空参的sorted()方法，需要流中的元素是实现了Comparable。</strong></p>
<p>​</p>
</blockquote>
<h6 id="limit">limit</h6>
<blockquote>
<p>​	可以设置流的<code>最大长度</code>，<code>超出的部分将被抛弃</code>。</p>
<p>例如：</p>
<p>​	对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素,然后打印其中年龄最大的两个作家的姓名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">authors.stream()</span><br><span class="line">        .distinct()</span><br><span class="line">        .sorted()</span><br><span class="line">        .limit(<span class="number">2</span>)</span><br><span class="line">        .forEach(author -&gt; System.out.println(author.getName()));</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="skip">skip</h6>
<blockquote>
<p>​	<code>跳过流中的前n个元素，返回剩下的元素</code></p>
<p>例如：</p>
<p>​	打印除了年龄最大的作家外的其他作家，要求不能有重复元素，并且按照年龄降序排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//        打印除了年龄最大的作家外的其他作家，要求不能有重复元素，并且按照年龄降序排序。</span></span><br><span class="line">  List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">  authors.stream()</span><br><span class="line">          .distinct()</span><br><span class="line">          .sorted()</span><br><span class="line">          .skip(<span class="number">1</span>)</span><br><span class="line">          .forEach(author -&gt; System.out.println(author.getName()));</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="flatMap">flatMap</h6>
<blockquote>
<p>​	map只能把<code>一个对象转换成另一个对象</code>来作为流中的元素。</p>
<p>​    而flatMap可以把<code>一个对象转换成多个对象</code>作为流中的元素。</p>
<p>例一：</p>
<p>​	打印所有书籍的名字。要求对重复的元素进行去重。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//        打印所有书籍的名字。要求对重复的元素进行去重。</span></span><br><span class="line">  List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"></span><br><span class="line">  authors.stream()</span><br><span class="line">          .flatMap(author -&gt; author.getBooks().stream())</span><br><span class="line">          .distinct()</span><br><span class="line">          .forEach(book -&gt; System.out.println(book.getName()));</span><br></pre></td></tr></table></figure>
<p>例二：</p>
<p>​	打印现有数据的所有分类。要求对分类进行去重。不能出现这种格式：哲学,爱情</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//        打印现有数据的所有分类。要求对分类进行去重。不能出现这种格式：哲学,爱情     爱情</span></span><br><span class="line">  List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">  authors.stream()</span><br><span class="line">          .flatMap(book -&gt; Arrays.stream(book.getCategory().split(<span class="string">&quot;,&quot;</span>)))</span><br><span class="line">          .distinct()</span><br><span class="line">          .forEach(category-&gt; System.out.println(category));</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="3-终结操作">3 终结操作</h5>
<h6 id="forEach">forEach</h6>
<blockquote>
<p>​	对流中的元素进行<code>遍历操作</code>，我们通过传入的参数去指定对遍历到的元素进行什么具体操作。</p>
<p>例子：</p>
<p>​	输出所有作家的名字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//        输出所有作家的名字</span></span><br><span class="line">  List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"></span><br><span class="line">  authors.stream()</span><br><span class="line">          .map(author -&gt; author.getName())</span><br><span class="line">          .distinct()</span><br><span class="line">          .forEach(name-&gt; System.out.println(name));</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="count">count</h6>
<blockquote>
<p>​		可以用来获取当前流中<code>元素的个数</code>。</p>
<p>例子：</p>
<p>​	打印这些作家的所出书籍的数目，注意删除重复元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//        打印这些作家的所出书籍的数目，注意删除重复元素。</span></span><br><span class="line">  List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">  <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> authors.stream()</span><br><span class="line">          .flatMap(author -&gt; author.getBooks().stream())</span><br><span class="line">          .distinct()</span><br><span class="line">          .count();</span><br><span class="line">  System.out.println(count);</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="max-min">max&amp;min</h6>
<blockquote>
<p>​	可以用来或者流中的<code>最值</code>。</p>
<p>例子：</p>
<p>​	分别获取这些作家的所出书籍的最高分和最低分并打印。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//        分别获取这些作家的所出书籍的最高分和最低分并打印。</span></span><br><span class="line">  <span class="comment">//Stream&lt;Author&gt;  -&gt; Stream&lt;Book&gt; -&gt;Stream&lt;Integer&gt;  -&gt;求值</span></span><br><span class="line"></span><br><span class="line">  List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">  Optional&lt;Integer&gt; max = authors.stream()</span><br><span class="line">          .flatMap(author -&gt; author.getBooks().stream())</span><br><span class="line">          .map(book -&gt; book.getScore())</span><br><span class="line">          .max((score1, score2) -&gt; score1 - score2);</span><br><span class="line"> System.out.println(max.get());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Optional&lt;Integer&gt; min = authors.stream()</span><br><span class="line">          .flatMap(author -&gt; author.getBooks().stream())</span><br><span class="line">          .map(book -&gt; book.getScore())</span><br><span class="line">          .min((score1, score2) -&gt; score1 - score2);</span><br><span class="line">  System.out.println(min.get());</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="collect">collect</h6>
<blockquote>
<p>​	把当前流<code>转换成一个集合</code>。</p>
<p>例子：</p>
<p>​	获取一个存放所有作者名字的<code>List集合</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//        获取一个存放所有作者名字的List集合。</span></span><br><span class="line">  List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">	List&lt;String&gt; nameList = authors.stream()</span><br><span class="line">                                 .map(author -&gt; author.getName())</span><br><span class="line">                                 .collect(Collectors.toList());</span><br><span class="line">  System.out.println(nameList);</span><br></pre></td></tr></table></figure>
<p>​	获取一个所有书名的<code>Set集合</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//        获取一个所有书名的Set集合。</span></span><br><span class="line">  List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">  Set&lt;Book&gt; books = authors.stream()</span><br><span class="line">                           .flatMap(author -&gt; author.getBooks().stream())</span><br><span class="line">                           .collect(Collectors.toSet());</span><br><span class="line"></span><br><span class="line">  System.out.println(books);</span><br></pre></td></tr></table></figure>
<p>​	获取一个Map集合，map的key为作者名，value为<code>List&lt;Book&gt;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//        获取一个Map集合，map的key为作者名，value为List&lt;Book&gt;</span></span><br><span class="line">  List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"></span><br><span class="line">  Map&lt;String, List&lt;Book&gt;&gt; map = authors.stream()</span><br><span class="line">          .distinct()</span><br><span class="line">          .collect(Collectors.toMap(author -&gt; author.getName(), author -&gt; author.getBooks()));</span><br><span class="line"></span><br><span class="line">  System.out.println(map);</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="查找与匹配">查找与匹配</h6>
<blockquote>
<h6 id="anyMatch">anyMatch</h6>
<p>​	可以用来<code>判断</code>是否有<code>任意</code>符合匹配条件的元素，结果为boolean类型。</p>
<p>例子：</p>
<p>​	判断是否有年龄在29以上的作家</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//        判断是否有年龄在29以上的作家</span></span><br><span class="line">  List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> authors.stream()</span><br><span class="line">          .anyMatch(author -&gt; author.getAge() &gt; <span class="number">29</span>);</span><br><span class="line">  System.out.println(flag);</span><br></pre></td></tr></table></figure>
<h6 id="allMatch">allMatch</h6>
<p>​	可以用来<code>判断</code>是否<code>都</code>符合匹配条件，结果为boolean类型。如果都符合结果为true，否则结果为false。</p>
<p>例子：</p>
<p>​	判断是否所有的作家都是成年人</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//        判断是否所有的作家都是成年人</span></span><br><span class="line">  List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> authors.stream()</span><br><span class="line">          .allMatch(author -&gt; author.getAge() &gt;= <span class="number">18</span>);</span><br><span class="line">  System.out.println(flag);</span><br></pre></td></tr></table></figure>
<h6 id="noneMatch">noneMatch</h6>
<p>​	可以<code>判断</code>流中的元素是否<code>都不</code>符合匹配条件。如果都不符合结果为true，否则结果为false</p>
<p>例子：</p>
<p>​	判断作家是否都没有超过100岁的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//        判断作家是否都没有超过100岁的。</span></span><br><span class="line">  List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"></span><br><span class="line">  <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> authors.stream()</span><br><span class="line">          .noneMatch(author -&gt; author.getAge() &gt; <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  System.out.println(b);</span><br></pre></td></tr></table></figure>
<h6 id="findAny">findAny</h6>
<p>​	<code>获取</code>流中的<code>任意一个</code>元素。该方法没有办法保证获取的一定是流中的第一个元素。</p>
<p>例子：</p>
<p>​	获取任意一个年龄大于18的作家，如果存在就输出他的名字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//        获取任意一个年龄大于18的作家，如果存在就输出他的名字</span></span><br><span class="line">  List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">  Optional&lt;Author&gt; optionalAuthor = authors.stream()</span><br><span class="line">          .filter(author -&gt; author.getAge()&gt;<span class="number">18</span>)</span><br><span class="line">          .findAny();</span><br><span class="line"></span><br><span class="line">  optionalAuthor.ifPresent(author -&gt; System.out.println(author.getName()));</span><br></pre></td></tr></table></figure>
<h6 id="findFirst">findFirst</h6>
<p>​	<code>获取</code>流中的<code>第一个</code>元素。</p>
<p>例子：</p>
<p>​	获取一个年龄最小的作家，并输出他的姓名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//        获取一个年龄最小的作家，并输出他的姓名。</span></span><br><span class="line">  List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">  Optional&lt;Author&gt; first = authors.stream()</span><br><span class="line">          .sorted((o1, o2) -&gt; o1.getAge() - o2.getAge())</span><br><span class="line">          .findFirst();</span><br><span class="line"></span><br><span class="line">  first.ifPresent(author -&gt; System.out.println(author.getName()));</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="reduce归并">reduce归并</h6>
<blockquote>
<p>​	对流中的数据按照<code>你指定的计算方式计算出一个结果</code>。（<code>缩减操作</code>）</p>
<p>​	reduce的作用是把<code>stream中的元素给组合起来</code>，我们可以传入一个初始值，它会按照<code>给定的计算方式</code>依次拿流中的元素和初始化值进行计算，计算结果再和后面的元素计算。</p>
<p>​	reduce<code>两个参数</code>的重载形式内部的计算方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> identity;</span><br><span class="line">&gt;<span class="keyword">for</span> (T element : <span class="built_in">this</span> stream)</span><br><span class="line">result = accumulator.apply(result, element)</span><br><span class="line">&gt;<span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
<p>​	其中identity就是我们可以通过方法参数传入的初始值，accumulator的apply具体进行什么计算也是我们通过方法参数来确定的。</p>
<p>例子：</p>
<p>​	使用reduce求所有作者年龄的<code>和</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//        使用reduce求所有作者年龄的和</span></span><br><span class="line">  List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> authors.stream()</span><br><span class="line">          .distinct()</span><br><span class="line">          .map(author -&gt; author.getAge())</span><br><span class="line">          .reduce(<span class="number">0</span>, (result, element) -&gt; result + element);</span><br><span class="line">  System.out.println(sum);</span><br></pre></td></tr></table></figure>
<p>​	使用reduce求所有作者中年龄的<code>最大值</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//        使用reduce求所有作者中年龄的最大值</span></span><br><span class="line">  List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">max</span> <span class="operator">=</span> authors.stream()</span><br><span class="line">          .map(author -&gt; author.getAge())</span><br><span class="line">          .reduce(Integer.MIN_VALUE, (result, element) -&gt; result &lt; element ? element : result);</span><br><span class="line"></span><br><span class="line">  System.out.println(max);</span><br></pre></td></tr></table></figure>
<p>​	使用reduce求所有作者中年龄的<code>最小值</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//        使用reduce求所有作者中年龄的最小值</span></span><br><span class="line">  List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">min</span> <span class="operator">=</span> authors.stream()</span><br><span class="line">          .map(author -&gt; author.getAge())</span><br><span class="line">          .reduce(Integer.MAX_VALUE, (result, element) -&gt; result &gt; element ? element : result);</span><br><span class="line">  System.out.println(min);</span><br></pre></td></tr></table></figure>
<p>​	reduce<code>一个参数</code>的重载形式内部的计算</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">boolean</span> <span class="variable">foundAny</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">&gt;<span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">&gt;<span class="keyword">for</span> (T element : <span class="built_in">this</span> stream) &#123;</span><br><span class="line">   <span class="keyword">if</span> (!foundAny) &#123;</span><br><span class="line">       foundAny = <span class="literal">true</span>;</span><br><span class="line">       result = element;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">       result = accumulator.apply(result, element);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">return</span> foundAny ? Optional.of(result) : Optional.empty();</span><br></pre></td></tr></table></figure>
<p>​	如果用一个参数的重载方法去求<code>最小值</code>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        使用reduce求所有作者中年龄的最小值</span></span><br><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">Optional&lt;Integer&gt; minOptional = authors.stream()</span><br><span class="line">        .map(author -&gt; author.getAge())</span><br><span class="line">        .reduce((result, element) -&gt; result &gt; element ? element : result);</span><br><span class="line">minOptional.ifPresent(age-&gt; System.out.println(age));</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="注意">注意</h4>
<blockquote>
<ul>
<li>惰性求值（如果没有终结操作，没有中间操作是不会得到执行的）</li>
<li>流是一次性的（一旦一个流对象经过一个终结操作后。这个流就不能再被使用）</li>
<li>不会影响原数据（我们在流中可以多数据做很多处理。但是正常情况下是不会影响原来集合中的元素的。这往往也是我们期望的）</li>
</ul>
</blockquote>
<h4 id="什么是Stream">什么是Stream</h4>
<blockquote>
<p><strong>Stream到底是什么呢？</strong></p>
<p>是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。</p>
<p><strong>“集合讲的是数据，Stream讲的是计算！”</strong></p>
<p><strong>注意：</strong></p>
<p>​		①Stream 自己不会存储元素。</p>
<p>​		②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</p>
<p>​		③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</p>
</blockquote>
<h4 id="Stream的操作三个步骤">Stream的操作三个步骤</h4>
<blockquote>
<p>1- 创建 Stream(即实例化)</p>
<p>​		一个数据源（如：集合、数组），获取一个流</p>
<p>2- 中间操作(一系列的过滤、映射…)</p>
<p>​		一个中间操作链，对数据源的数据进行处理</p>
<p>3- 终止操作(终端操作)</p>
<p>​		一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用</p>
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202303040017238.png" alt="image-20230304001717059" style="zoom: 25%;">
</blockquote>
<h5 id="创建-Stream方式">创建 Stream方式</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">创建 Stream方式一：通过集合</span><br><span class="line">	Java8 中的 Collection 接口被扩展，提供了两个获取流的方法：  </span><br><span class="line">    	<span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">stream</span><span class="params">()</span> : 返回一个顺序流</span><br><span class="line">    	<span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">parallelStream</span><span class="params">()</span> : 返回一个并行流</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">创建 Stream方式二：通过数组</span><br><span class="line">    Java8 中的 Arrays 的静态方法 stream() 可以获取数组流：</span><br><span class="line">        <span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title function_">stream</span><span class="params">(T[] array)</span>: 返回一个流</span><br><span class="line">    以重载形式，能够处理对应基本类型的数组：</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> IntStream <span class="title function_">stream</span><span class="params">(<span class="type">int</span>[] array)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> LongStream <span class="title function_">stream</span><span class="params">(<span class="type">long</span>[] array)</span></span><br><span class="line">    	<span class="keyword">public</span> <span class="keyword">static</span> DoubleStream <span class="title function_">stream</span><span class="params">(<span class="type">double</span>[] array)</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">创建 Stream方式三：通过Stream的of()</span><br><span class="line">	可以调用Stream类静态方法 of(), 通过显示值创建一个流。它可以接收任意数量的参数。</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">of</span><span class="params">(T... values)</span> : 返回一个流</span><br><span class="line">    </span><br><span class="line">创建 Stream方式四：创建无限流</span><br><span class="line">	可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。</span><br><span class="line">		迭代</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">iterate</span><span class="params">(<span class="keyword">final</span> T seed, <span class="keyword">final</span> UnaryOperator&lt;T&gt; f)</span> </span><br><span class="line">		生成</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">generate</span><span class="params">(Supplier&lt;T&gt; s)</span>  </span><br><span class="line">    		<span class="comment">// 方式四：创建无限流</span></span><br><span class="line">                <span class="meta">@Test</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">                <span class="comment">// 迭代</span></span><br><span class="line">                <span class="comment">// public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final</span></span><br><span class="line">                <span class="comment">// UnaryOperator&lt;T&gt; f)</span></span><br><span class="line">                Stream&lt;Integer&gt; stream = Stream.iterate(<span class="number">0</span>, x -&gt; x + <span class="number">2</span>);</span><br><span class="line">                stream.limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">    </span><br><span class="line">                <span class="comment">// 生成</span></span><br><span class="line">                <span class="comment">// public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</span></span><br><span class="line">                Stream&lt;Double&gt; stream1 = Stream.generate(Math::random);</span><br><span class="line">                stream1.limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>
<h5 id="Stream的中间操作"><strong>Stream的中间操作</strong></h5>
<blockquote>
<p>多个<strong>中间操作</strong>可以连接起来形成一个<strong>流水线</strong>，除非流水线上触发终止操作，否则<strong>中间操作不会执行任何的处理</strong>！而在<strong>终止操作时一次性全部处理，称为“惰性求值”</strong>。</p>
</blockquote>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202303040021035.png" alt="image-20230304002156910" style="zoom:18%;"><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202303040022122.png" alt="image-20230304002243581" style="zoom:18%;"><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202303040023968.png" alt="image-20230304002316901" style="zoom:18%;"></p>
<h5 id="Stream-的终止操作"><strong>Stream</strong> <strong>的终止操作</strong></h5>
<blockquote>
<p>终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是 void 。</p>
<p>流进行了终止操作后，不能再次使用。</p>
</blockquote>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202303040024924.png" alt="image-20230304002408853" style="zoom:18%;"><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202303040025340.png" alt="image-20230304002500152" style="zoom:18%;"></p>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304091556835.png" alt="image-20230304002435218" style="zoom:18%;"><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202303040025483.png" alt="image-20230304002523423" style="zoom:18%;"></p>
<h5 id="Collectors"><strong>Collectors</strong></h5>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202303040025200.png" alt="image-20230304002550138" style="zoom: 25%;"><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304091556891.png" alt="image-20230304002603515" style="zoom: 25%;"></p>
<h5 id="基本数据类型优化">基本数据类型优化</h5>
<blockquote>
<p>装箱和拆箱肯定是要消耗时间的;Stream还提供了很多专门针对基本数据类型的方法。例如：mapToInt,mapToLong,mapToDouble,flatMapToInt,flatMapToDouble等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//如：</span></span><br><span class="line">&gt;<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test27</span><span class="params">()</span> &#123;</span><br><span class="line">  List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">  authors.stream()</span><br><span class="line">          .map(author -&gt; author.getAge())</span><br><span class="line">          .map(age -&gt; age + <span class="number">10</span>)</span><br><span class="line">          .filter(age-&gt;age&gt;<span class="number">18</span>)</span><br><span class="line">          .map(age-&gt;age+<span class="number">2</span>)</span><br><span class="line">          .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">  authors.stream()</span><br><span class="line">          .mapToInt(author -&gt; author.getAge())</span><br><span class="line">          .map(age -&gt; age + <span class="number">10</span>)</span><br><span class="line">          .filter(age-&gt;age&gt;<span class="number">18</span>)</span><br><span class="line">          .map(age-&gt;age+<span class="number">2</span>)</span><br><span class="line">          .forEach(System.out::println);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="并行流优化">并行流优化</h5>
<blockquote>
<p>​	当流中有大量元素时，我们可以使用并行流去提高操作的效率，其实并行流就是把任务分配给多个线程去完全。而如果我们使用Stream的话，我们只需要修改一个方法的调用就可以使用并行流来帮我们实现。</p>
<p>​	<code>parallel</code>方法可以把<code>串行流转换成并行流</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test28</span><span class="params">()</span> &#123;</span><br><span class="line">  Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> stream.parallel()</span><br><span class="line">          .peek(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Integer&gt;() &#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Integer num)</span> &#123;</span><br><span class="line">                  System.out.println(num+Thread.currentThread().getName());</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">          .filter(num -&gt; num &gt; <span class="number">5</span>)</span><br><span class="line">          .reduce((result, ele) -&gt; result + ele)</span><br><span class="line">          .get();</span><br><span class="line">  System.out.println(sum);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>​	也可以通过<code>parallelStream</code>直接获取<code>并行流对象</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">authors.parallelStream()</span><br><span class="line">        .map(author -&gt; author.getAge())</span><br><span class="line">        .map(age -&gt; age + <span class="number">10</span>)</span><br><span class="line">        .filter(age-&gt;age&gt;<span class="number">18</span>)</span><br><span class="line">        .map(age-&gt;age+<span class="number">2</span>)</span><br><span class="line">        .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="代码">代码</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Stream 关注的是对数据的运算，与Cpu打交道，集合关注的是数据的存储，与内存打交道</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Stream 的操作三个步骤</span></span><br><span class="line"><span class="comment"> * 1- 创建 Stream(即实例化)</span></span><br><span class="line"><span class="comment"> *      一个数据源（如：集合、数组），获取一个流</span></span><br><span class="line"><span class="comment"> *  2- 中间操作(一系列的过滤、映射......)</span></span><br><span class="line"><span class="comment"> *      一个中间操作链，对数据源的数据进行处理</span></span><br><span class="line"><span class="comment"> *  3- 终止操作(终端操作)</span></span><br><span class="line"><span class="comment"> *      一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stream_api</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *实例化，创建</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        创建 Stream 方式一  ： 通过集合</span></span><br><span class="line"><span class="comment">           Java8 中的 Collection 接口被扩展，提供了两个获取流的方法：</span></span><br><span class="line"><span class="comment">             1. default Stream&lt;E&gt; stream() : 返回一个顺序流</span></span><br><span class="line"><span class="comment">             2. default Stream&lt;E&gt; parallelStream() : 返回一个并行流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">        <span class="comment">// default Stream&lt;E&gt; stream() : 返回一个顺序流</span></span><br><span class="line">        Stream&lt;Employee&gt; stream = employees.stream();</span><br><span class="line">        <span class="comment">// default Stream&lt;E&gt; parallelStream() : 返回一个并行流</span></span><br><span class="line">        Stream&lt;Employee&gt; employeeStream = employees.parallelStream();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        创建 Stream 方式二 ： 通过数组</span></span><br><span class="line"><span class="comment">        Java8 中的 Arrays 的静态方法 stream() 可以获取数组流</span></span><br><span class="line"><span class="comment">            static &lt;T&gt; Stream&lt;T&gt; stream(T[] array): 返回一个流</span></span><br><span class="line"><span class="comment">          重载形式，能够处理对应基本类型的数组：</span></span><br><span class="line"><span class="comment">            public static IntStream stream(int[] array)</span></span><br><span class="line"><span class="comment">            public static LongStream stream(long[] array)</span></span><br><span class="line"><span class="comment">            public static DoubleStream stream(double[] array)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// int 型</span></span><br><span class="line">        <span class="type">IntStream</span> <span class="variable">stream</span> <span class="operator">=</span> Arrays.stream(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 泛型</span></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1001</span>,<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1002</span>,<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1003</span>,<span class="string">&quot;john&quot;</span>);</span><br><span class="line">        Employee[] employees = <span class="keyword">new</span> <span class="title class_">Employee</span>[]&#123;e1, e2&#125;;</span><br><span class="line">        Stream&lt;Employee&gt; stream1 = Arrays.stream(employees);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建 Stream方式三：通过Stream的of()</span></span><br><span class="line"><span class="comment">    可以调用Stream类静态方法 of(), 通过显示值创建一个流。它可以接收任意数量的参数。</span></span><br><span class="line"><span class="comment">    public static&lt;T&gt; Stream&lt;T&gt; of(T... values) : 返回一个流</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span>&#123;</span><br><span class="line">        Stream&lt;Integer&gt; integerStream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        创建 Stream方式四：创建无限流</span></span><br><span class="line"><span class="comment">        可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。</span></span><br><span class="line"><span class="comment">              迭代  : public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f)</span></span><br><span class="line"><span class="comment">              生成  : public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 迭代  : public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f)</span></span><br><span class="line">        <span class="comment">// 遍历前十个偶数</span></span><br><span class="line">        Stream.iterate(<span class="number">4</span>,t -&gt; t + <span class="number">2</span>).limit(<span class="number">20</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成  : public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</span></span><br><span class="line">        Stream.generate(Math :: random).limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中间操作</span></span><br><span class="line"><span class="comment">     *      1-筛选与切片</span></span><br><span class="line"><span class="comment">     *      2-映 射</span></span><br><span class="line"><span class="comment">     *      3-排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m5</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *  2.1-筛选与切片</span></span><br><span class="line"><span class="comment">             *    filter(Predicate p) 接收 Lambda ， 从流中排除某些元素</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             *    limit(long maxSize) 截断流，使其元素不超过给定数量</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             *    distinct() 筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             *    skip(long n) 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//filter(Predicate p) 接收 Lambda ， 从流中排除某些元素</span></span><br><span class="line">            <span class="comment">//查询工资大于 7000 的员工信息</span></span><br><span class="line">            System.out.println(<span class="string">&quot;filter&quot;</span>);</span><br><span class="line">            List&lt;Employee&gt; list = EmployeeData.getEmployees();</span><br><span class="line">            Stream&lt;Employee&gt; stream = list.stream();</span><br><span class="line">            stream.filter(e -&gt; e.getSalary() &gt; <span class="number">7000</span>).forEach(System.out :: println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//limit(long maxSize) 截断流，使其元素不超过给定数量</span></span><br><span class="line">            System.out.println(<span class="string">&quot;limit&quot;</span>);</span><br><span class="line">            list.stream().limit(<span class="number">4</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//skip(long n) 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补</span></span><br><span class="line">            System.out.println(<span class="string">&quot;skip&quot;</span>);</span><br><span class="line">            list.stream().skip(<span class="number">4</span>).forEach(System.out :: println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//distinct() 筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素</span></span><br><span class="line">            System.out.println(<span class="string">&quot;distinct&quot;</span>);</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1000</span>,<span class="string">&quot;库克&quot;</span>,<span class="number">56</span>,<span class="number">1500</span>));</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1000</span>,<span class="string">&quot;库克&quot;</span>,<span class="number">56</span>,<span class="number">1500</span>));</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1000</span>,<span class="string">&quot;库克&quot;</span>,<span class="number">56</span>,<span class="number">1500</span>));</span><br><span class="line">            System.out.println(list);</span><br><span class="line">            list.stream().distinct().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">m6</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 2.2-映 射</span></span><br><span class="line"><span class="comment">         *  map(Function f)  接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *  mapToDouble(ToDoubleFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 DoubleStream。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *  mapToInt(ToIntFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 IntStream。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *  mapToLong(ToLongFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 LongStream。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *  flatMap(Function f) 接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//map(Function f)  接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</span></span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">        list.stream().map(str -&gt; str.toUpperCase() + <span class="string">&quot;\t&quot;</span>).forEach(System.out::print);</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//练习一 ：获取员工姓名长度大于 3 的员工姓名</span></span><br><span class="line">        System.out.println(<span class="string">&quot;练习一&quot;</span>);</span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">        Stream&lt;String&gt; nameStream = employees.stream().map(Employee::getName);</span><br><span class="line">        nameStream.filter(name -&gt; name.length() &gt; <span class="number">3</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//练习二 ：</span></span><br><span class="line">        System.out.println(<span class="string">&quot;练习二&quot;</span>);</span><br><span class="line">        Stream&lt;Stream&lt;Character&gt;&gt; streamStream =	 		 																			list.stream().map(Stream_api::fromStringToStream);</span><br><span class="line">        streamStream.forEach(s -&gt; &#123;</span><br><span class="line">            s.forEach(System.out::print);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//flatMap(Function f) 接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</span></span><br><span class="line">        Stream&lt;Character&gt; characterStream = 																							list.stream().flatMap(Stream_api::fromStringToStream);</span><br><span class="line">        characterStream.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="type">ArrayList</span>  <span class="variable">integers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span> ();</span><br><span class="line">        integers.add(<span class="number">1</span>);</span><br><span class="line">        integers.add(<span class="number">2</span>);</span><br><span class="line">        integers.add(<span class="number">3</span>);</span><br><span class="line">        <span class="type">ArrayList</span>  <span class="variable">integers1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span> ();</span><br><span class="line">        integers1.add(<span class="number">1</span>);</span><br><span class="line">        integers1.add(<span class="number">2</span>);</span><br><span class="line">        integers1.add(<span class="number">3</span>);</span><br><span class="line">        integers1.add(integers);      <span class="comment">//[1, 2, 3, [1, 2, 3]]   类似 map</span></span><br><span class="line">        integers1.addAll(integers);   <span class="comment">//[1, 2, 3, 1, 2, 3]   类似 flatmap</span></span><br><span class="line">        System.out.println(integers1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将字符串中的多个字符构成的集合转换成对应的Stream的实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Character&gt; <span class="title function_">fromStringToStream</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        ArrayList&lt;Character&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Character character :str.toCharArray()) &#123;</span><br><span class="line">            list.add(character);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.stream();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  2.3-排序</span></span><br><span class="line"><span class="comment">     *      sorted() 产生一个新流，其中按自然顺序排序</span></span><br><span class="line"><span class="comment">     *      sorted(Comparator com) 产生一个新流，其中按比较器顺序排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m7</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//sorted() 产生一个新流，其中按自然顺序排序</span></span><br><span class="line">        List&lt;Integer&gt; integers = Arrays.asList(<span class="number">12</span>, <span class="number">23</span>, <span class="number">34</span>, <span class="number">41</span>, <span class="number">5</span>, <span class="number">34</span>, <span class="number">32</span>, <span class="number">2</span>, <span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        integers.stream().sorted().forEach(System.out::println);</span><br><span class="line"><span class="comment">//          产生异常，</span></span><br><span class="line"><span class="comment">//              java.lang.ClassCastException: com.Java8_.References.Employee cannot be cast to 															java.lang.Comparable</span></span><br><span class="line"><span class="comment">//              原因， EmployeeData 没有实现 Comparable 接口</span></span><br><span class="line"><span class="comment">//        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span></span><br><span class="line"><span class="comment">//        employees.stream().sorted().forEach(System.out::println);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//sorted(Comparator com) 产生一个新流，其中按比较器顺序排序</span></span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">        employees.stream().sorted((o1,o2) -&gt; Integer.compare(o1.getAge(),o2.getAge())).</span><br><span class="line">                forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        List&lt;Employee&gt; employees1 = EmployeeData.getEmployees();</span><br><span class="line">        employees1.stream().sorted((o1,o2) -&gt;&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">compare</span> <span class="operator">=</span> Integer.compare(o1.getAge(), o2.getAge());</span><br><span class="line">            <span class="keyword">if</span> (compare != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> compare;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> -Double.compare(o2.getSalary(),o1.getSalary());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3- 终止操作(终端操作)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Stream 的终止操作</span></span><br><span class="line"><span class="comment">     *  3.1-匹配与查找</span></span><br><span class="line"><span class="comment">     *  allMatch(Predicate p) 检查是否匹配所有元素</span></span><br><span class="line"><span class="comment">     *  anyMatch(Predicate p) 检查是否至少匹配一个元素</span></span><br><span class="line"><span class="comment">     *  noneMatch(Predicate p) 检查是否没有匹配所有元素</span></span><br><span class="line"><span class="comment">     *  findFirst() 返回第一个元素</span></span><br><span class="line"><span class="comment">     *  findAny() 返回当前流中的任意元素</span></span><br><span class="line"><span class="comment">     *  count() 返回流中元素总数</span></span><br><span class="line"><span class="comment">     *  max(Comparator c) 返回流中最大值</span></span><br><span class="line"><span class="comment">     *  min(Comparator c) 返回流中最小值</span></span><br><span class="line"><span class="comment">     *  forEach(Consumer c) 内部迭代(使用 Collection 接口需要用户去做迭代，称为外部迭代。相反，Stream API 使用内部迭代——它帮你把迭代做了)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m8</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//allMatch(Predicate p) 检查是否匹配所有元素</span></span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">allMatch</span> <span class="operator">=</span> employees.stream().allMatch(e -&gt; e.getAge() &gt; <span class="number">13</span>);</span><br><span class="line">        System.out.println(allMatch);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//anyMatch(Predicate p) 检查是否至少匹配一个元素</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">anyMatch</span> <span class="operator">=</span> employees.stream().anyMatch(e -&gt; e.getSalary() &gt; <span class="number">8000</span>);</span><br><span class="line">        System.out.println(anyMatch);</span><br><span class="line">        <span class="comment">//noneMatch(Predicate p) 检查是否没有匹配所有元素</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">noneMatch</span> <span class="operator">=</span> employees.stream().noneMatch(e -&gt; e.getId() == <span class="number">1001</span>);</span><br><span class="line">        System.out.println(noneMatch);</span><br><span class="line">        <span class="comment">//findFirst() 返回第一个元素</span></span><br><span class="line">        System.out.println(employees.stream().findFirst());</span><br><span class="line">        <span class="comment">//findAny() 返回当前流中的任意元素</span></span><br><span class="line">        System.out.println(employees.parallelStream().findAny());</span><br><span class="line">        <span class="comment">//count() 返回流中元素总数</span></span><br><span class="line">        System.out.println(employees.stream().filter(e -&gt; e.getSalary() &gt; <span class="number">4000</span>).count());</span><br><span class="line">        <span class="comment">//max(Comparator c) 返回流中最大值</span></span><br><span class="line">        Stream&lt;Double&gt; doubleStream = employees.stream().map(e -&gt; e.getSalary());</span><br><span class="line">        System.out.println(doubleStream.max(Double::compare));</span><br><span class="line">        <span class="comment">//min(Comparator c) 返回流中最小值</span></span><br><span class="line">        Optional&lt;Employee&gt; min = employees.stream().min((o1, o2) -&gt; Double.compare(o1.getSalary(), o2.getSalary()));</span><br><span class="line">        System.out.println(min);</span><br><span class="line">        <span class="comment">//forEach(Consumer c) 内部迭代(使用 Collection 接口需要用户去做迭代，称为外部迭代。相反，Stream API 使用内部迭代——它帮你把迭代做了)</span></span><br><span class="line">        <span class="comment">//forEach(Consumer c) 内部迭代</span></span><br><span class="line">        employees.stream().forEach(System.out::println);</span><br><span class="line">        <span class="comment">//使用集合的遍历方式</span></span><br><span class="line">        employees.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m9</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 3.2-归约</span></span><br><span class="line"><span class="comment">         *  reduce(T iden, BinaryOperator b) 可以将流中元素反复结合起来，得到一个值。返回 T</span></span><br><span class="line"><span class="comment">         *  reduce(BinaryOperator b) 可以将流中元素反复结合起来，得到一个值。返回 Optional&lt;T&gt;</span></span><br><span class="line"><span class="comment">         *      PS : 备注：map 和 reduce 的连接通常称为 map-reduce 模式，因 Google用它来进行网络搜索而出名。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//reduce(T iden, BinaryOperator b) 可以将流中元素反复结合起来，得到一个值。返回 T</span></span><br><span class="line">        <span class="comment">//1~10 求和</span></span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line">        System.out.println(list.stream().reduce(<span class="number">0</span>, Integer::sum));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//reduce(BinaryOperator b) 可以将流中元素反复结合起来，得到一个值。返回 Optional&lt;T&gt;</span></span><br><span class="line">        <span class="comment">//所有员工求和</span></span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">        Stream&lt;Double&gt; doubleStream = employees.stream().map(Employee::getSalary);</span><br><span class="line">        Stream&lt;Double&gt; doubleStream1 = employees.stream().map(Employee::getSalary);</span><br><span class="line">        System.out.println(doubleStream.reduce(Double::sum));</span><br><span class="line">        System.out.println(doubleStream1.reduce((d1,d2) -&gt; d1 +d2));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m10</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 3.3-收集</span></span><br><span class="line"><span class="comment">         * Collector 接口中方法的实现决定了如何对流执行收集的操作(如收集到 List、Set、Map)。</span></span><br><span class="line"><span class="comment">         *  另外， Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表</span></span><br><span class="line"><span class="comment">         *  toList List&lt;T&gt; 把流中元素收集到List List&lt;Employee&gt; emps= list.stream().collect(Collectors.toList());</span></span><br><span class="line"><span class="comment">         * toSet Set&lt;T&gt; 把流中元素收集到Set  Set&lt;Employee&gt; emps= list.stream().collect(Collectors.toSet());</span></span><br><span class="line"><span class="comment">         * toCollection Collection&lt;T&gt; 把流中元素收集到创建的集合 Collection&lt;Employee&gt; emps =list.stream().collect(Collectors.toCollection(ArrayList::new))</span></span><br><span class="line"><span class="comment">         * 等等.......</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//Collector 接口中方法的实现决定了如何对流执行收集的操作(如收集到 List、Set、Map)。</span></span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">        System.out.println(employees.stream().filter(e -&gt; e.getSalary() &gt; <span class="number">4009</span>).collect(Collectors.toList()));</span><br><span class="line"></span><br><span class="line">        System.out.println(employees.stream().filter(e -&gt; e.getSalary() &gt; <span class="number">4009</span>).collect(Collectors.toSet()));</span><br><span class="line"></span><br><span class="line">        Set&lt;Employee&gt; collect = employees.stream().filter(e -&gt; e.getSalary() &gt; <span class="number">4009</span>).collect(Collectors.toSet());</span><br><span class="line">        collect.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Optional类">Optional类</h3>
<blockquote>
<p>这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象</p>
</blockquote>
<h4 id="方法">方法</h4>
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202303040038511.png" alt="image-20230304003853444" style="zoom:25%;">
<h4 id="Optional-使用实例">Optional 使用实例</h4>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202303040040403.png" alt="image-20230304004029341" style="zoom:25%;"><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202303040040763.png" alt="image-20230304004040697" style="zoom:25%;"></p>
<h4 id="使用">使用</h4>
<h5 id="1-创建对象">1 创建对象</h5>
<blockquote>
<p>1、我们一般<code>推荐</code>使用<strong>Optional</strong>的<strong>静态方法ofNullable</strong>来把数据封装成一个Optional对象。无论传入的参数是否为null都不会出现问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Author</span> <span class="variable">author</span> <span class="operator">=</span> getAuthor();</span><br><span class="line">Optional&lt;Author&gt; authorOptional = Optional.ofNullable(author);</span><br></pre></td></tr></table></figure>
<p>2.1、如果你<strong>确定一个对象不是空</strong>的则可以使用<strong>Optional</strong>的<strong>静态方法of</strong>来把数据封装成Optional对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Author</span> <span class="variable">author</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Author</span>();</span><br><span class="line">Optional&lt;Author&gt; authorOptional = Optional.of(author);</span><br></pre></td></tr></table></figure>
<p>但是一定要注意，如果使用of的时候传入的参数<code>必须不为null</code>。</p>
<p>​</p>
<p>2.2、如果一个方法的返回值类型是Optional类型。而如果我们经判断发现某次计算得到的返回值为null，这个时候就需要把null封装成Optional对象返回。这时则可以使用<strong>Optional</strong>的<strong>静态方法empty</strong>来进行封装。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional.empty()</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="2-安全消费值">2 安全消费值</h5>
<blockquote>
<p>我们获取到一个Optional对象后肯定需要对其中的数据进行使用。这时候我们可以使用其<strong>ifPresent</strong>方法对来消费其中的值。</p>
<p>这个方法会判断其内封装的数据是否为空，不为空时才会执行具体的消费代码。这样使用起来就更加安全了。</p>
<p>​	例如,以下写法就优雅的避免了空指针异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Author&gt; authorOptional = Optional.ofNullable(getAuthor());</span><br><span class="line"></span><br><span class="line">authorOptional.ifPresent(author -&gt; System.out.println(author.getName()));</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="3-安全获取值">3 安全获取值</h5>
<blockquote>
<p>如果我们期望安全的获取值。我们不推荐使用get方法，而是使用Optional提供的以下方法。</p>
<ul>
<li>orElseGet</li>
</ul>
<p>获取数据并且<code>设置数据为空时的默认值</code>。如果数据<code>不为空</code>就能<code>获取到该数据</code>。如果<code>为空</code>则根据你传入的参数来创建对象作为<code>默认值</code>返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Author&gt; authorOptional = Optional.ofNullable(getAuthor());</span><br><span class="line"><span class="type">Author</span> <span class="variable">author1</span> <span class="operator">=</span> authorOptional.orElseGet(() -&gt; <span class="keyword">new</span> <span class="title class_">Author</span>());</span><br></pre></td></tr></table></figure>
<ul>
<li>orElseThrow</li>
</ul>
<p>获取数据，如果数据<code>不为空</code>就能<code>获取到该数据</code>。如果<code>为空</code>则根据你传入的参数来<code>创建异常抛出</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Author&gt; authorOptional = Optional.ofNullable(getAuthor());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Author</span> <span class="variable">author</span> <span class="operator">=</span> authorOptional.orElseThrow((Supplier&lt;Throwable&gt;) () -&gt; <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;author为空&quot;</span>));</span><br><span class="line">    System.out.println(author.getName());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">    throwable.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="4-过滤">4 过滤</h5>
<blockquote>
<p>我们可以使用filter方法对数据进行过滤。如果原本是有数据的，但是不符合判断，也会变成一个无数据的Optional对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Author&gt; authorOptional = Optional.ofNullable(getAuthor());</span><br><span class="line">authorOptional.filter(author -&gt; author.getAge()&gt;<span class="number">100</span>)</span><br><span class="line">  			  .ifPresent(author -&gt; System.out.println(author.getName()));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="5-判断">5 判断</h5>
<blockquote>
<p>​	我们可以<code>使用isPresent方法进行是否存在数据的判断</code>。如果<code>为空</code>返回值<code>为false</code>,如果<code>不为空</code>，返回值为<code>true</code>。但是这种方式并不能体现Optional的好处，<strong>更推荐使用上面的ifPresent方法</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Author&gt; authorOptional = Optional.ofNullable(getAuthor());</span><br><span class="line"><span class="keyword">if</span> (authorOptional.isPresent()) &#123;</span><br><span class="line">    System.out.println(authorOptional.get().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="6-数据转化">6 数据转化</h5>
<blockquote>
<p>​	Optional还提供了<code>map</code>可以让我们的<code>对数据进行转换</code>，并且转换得到的数据也还是被Optional包装好的，保证了我们的使用安全。</p>
<p>例如我们想获取作家的书籍集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testMap</span><span class="params">()</span> &#123;</span><br><span class="line">  Optional&lt;Author&gt; authorOptional = getAuthorOptional();</span><br><span class="line">  Optional&lt;List&lt;Book&gt;&gt; optionalBooks = authorOptional.map(author -&gt; author.getBooks());</span><br><span class="line">  optionalBooks.ifPresent(books -&gt; System.out.println(books));</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="代码-2">代码</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Optional&lt;T&gt; 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表这个值存在。</span></span><br><span class="line"><span class="comment">     * 或者仅仅保存null，表示这个值不存在。原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。</span></span><br><span class="line"><span class="comment">     * Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</span></span><br><span class="line"><span class="comment">     *  创建Optional类对象的方法：</span></span><br><span class="line"><span class="comment">     *  Optional.of(T t) : 创建一个 Optional 实例，t必须非空；  Optional.empty() : 创建一个空的 Optional 实例</span></span><br><span class="line"><span class="comment">     *  Optional.ofNullable(T t)：t可以为null</span></span><br><span class="line"><span class="comment">     *  判断Optional容器中是否包含对象：</span></span><br><span class="line"><span class="comment">     *  boolean isPresent() : 判断是否包含对象</span></span><br><span class="line"><span class="comment">     *  void ifPresent(Consumer&lt;? super T&gt; consumer) ：如果有值，就执行Consumer接口的实现代码，并且该值会作为参数传给它。</span></span><br><span class="line"><span class="comment">     *  获取Optional容器的对象：</span></span><br><span class="line"><span class="comment">     *  T get(): 如果调用对象包含值，返回该值，否则抛异常</span></span><br><span class="line"><span class="comment">     *  T orElse(T other) ：如果有值则将其返回，否则返回指定的other对象。</span></span><br><span class="line"><span class="comment">     *  T orElseGet(Supplier&lt;? extends T&gt; other) ：如果有值则将其返回，否则返回由Supplier接口实现提供的对象。</span></span><br><span class="line"><span class="comment">     *  T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) ：如果有值则将其返回，否则抛出由Supplier接口实现提供的异常。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">//dog = null;   //有这句  会有java.lang.NullPointerException</span></span><br><span class="line">        Optional&lt;Dog&gt; opdog = Optional.of(dog);</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        dog = <span class="literal">null</span>;</span><br><span class="line">        System.out.println(Optional.ofNullable(dog));  <span class="comment">//不会报错, dog 可以是 null</span></span><br><span class="line">        <span class="comment">// orElse(T other) ：如果有值则将其返回，否则返回指定的other对象</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">keji</span> <span class="operator">=</span> Optional.ofNullable(dog).orElse(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;柯基&quot;</span>));</span><br><span class="line">        System.out.println(keji);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n\n\n&quot;</span>);</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();   <span class="comment">//二哈</span></span><br><span class="line"><span class="comment">//        cat = null;  //小鸡毛</span></span><br><span class="line">        cat = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;柴犬&quot;</span>));  <span class="comment">//柴犬</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">dogName</span> <span class="operator">=</span> getDogName(cat);</span><br><span class="line">        System.out.println(dogName);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    public String getDogName(Cat cat)&#123;</span></span><br><span class="line"><span class="comment">//        return cat.getDog().getName();     //有java.lang.NullPointerException 空指针异常</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//优化 getDogName()</span></span><br><span class="line"><span class="comment">//    public String getDogName(Cat cat)&#123;</span></span><br><span class="line"><span class="comment">//        if (cat != null)&#123;</span></span><br><span class="line"><span class="comment">//            Dog dog = cat.getDog();</span></span><br><span class="line"><span class="comment">//            if (dog != null)&#123;</span></span><br><span class="line"><span class="comment">//                return dog.getName();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        return null;                //不会有 java.lang.NullPointerException 空指针异常</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">// Optional类的getDogName();</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDogName</span><span class="params">(Cat cat)</span> &#123;</span><br><span class="line">        Optional&lt;Cat&gt; cat1 = Optional.ofNullable(cat);</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">jimao</span> <span class="operator">=</span> cat1.orElse(<span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;小鸡毛&quot;</span>)));</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> jimao.getDog();</span><br><span class="line">        Optional&lt;Dog&gt; dog1 = Optional.ofNullable(dog);</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">erha</span> <span class="operator">=</span> dog1.orElse(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;二哈&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> erha.getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">其中Dog为：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">以及对应的setter getter toString 构造器等方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat为：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(dog, cat.dog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(dog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Cat&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;dog=&quot;</span> + dog +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Dog <span class="title function_">getDog</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDog</span><span class="params">(Dog dog)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dog = dog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(Dog dog)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dog = dog;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="函数式-Functional-接口">函数式(Functional)接口</h3>
<blockquote>
<p>1、只包含一个抽象方法的接口，称为<strong>函数式接口</strong>。</p>
<p>2、可以通过 Lambda 表达式来创建该接口的对象。</p>
<p>3、可以在一个接口上使用 <strong>@FunctionalInterface</strong> 注解，这样做可以检查它是否是一个函数式接口。但是无论是否加上该注解只要接口中只有一个抽象方法，都是函数式接口。</p>
<p><strong>自定义函数式接口</strong>                                                                <strong>作为参数传递</strong> <strong>Lambda</strong> <strong>表达式</strong></p>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304091556449.png" alt="image-20230303234809023" style="zoom:30%;"><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202303032349573.png" alt="image-20230303234942425" style="zoom:26%;"></p>
</blockquote>
<h4 id="Java-内置四大核心函数式接口"><strong>Java</strong> <strong>内置四大核心函数式接口</strong></h4>
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202303032350600.png" alt="image-20230303235009550" style="zoom:33%;">
<blockquote>
<p>java 内置的4大核心函数式接口</p>
<ul>
<li>
<p>消费型接口 Consumer<T>  包含方法：void accept(T t)</T></p>
</li>
<li>
<p>根据其中抽象方法的参数列表和返回值类型知道，我们可以<code>在方法中对传入的参数进行消费</code>。</p>
</li>
<li>
<p>供给型接口 Supplier<T>  包含方法：T get()</T></p>
</li>
<li>
<p>根据其中抽象方法的参数列表和返回值类型，我们可以在<code>方法中对传入的参数计算或转换</code>，把结果返回</p>
</li>
<li>
<p>函数型接口 Function&lt;T, R&gt; 包含方法：R apply(T t)</p>
</li>
<li>
<p>根据其中抽象方法的参数列表和返回值类型知道，我们可以在<code>方法中对传入的参数条件判断</code>，返回判断结果</p>
</li>
<li>
<p>断定型接口 Predicate<T> 包含方法：boolean test(T t)</T></p>
</li>
<li>
<p>根据其中抽象方法的参数列表和返回值类型知道，我们可以在<code>方法中创建对象</code>，把创建好的对象返回</p>
</li>
</ul>
</blockquote>
<h4 id="其它接口">其它接口</h4>
<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202303032350025.png" alt="image-20230303235044966" style="zoom:33%;">
<blockquote>
<p>java 内置的其他函数式接口</p>
<ul>
<li>BiFunction&lt;T, U, R&gt;  包含方法： R apply(T t, U u);</li>
<li>UnaryOperator&lt;T&gt;    包含方法为：T apply(T t);</li>
<li>BinaryOperator&lt;T&gt;    包含方法为： T apply(T t1, T t2);</li>
<li>BiConsumer&lt;T, U&gt;    包含方法为： void accept(T t, U u)</li>
<li>BiPredicate&lt;T,U&gt;     包含方法为： boolean test(T t,U u)</li>
</ul>
</blockquote>
<p><strong>以上可以使用lambda表达式</strong></p>
<blockquote>
<p>ToIntFunction&lt;T&gt;、ToLongFunction&lt;T&gt;、ToDoubleFunction&lt;T&gt; 分别计算int、long、double值的函数</p>
<p>IntFunction&lt;R&gt;、LongFunction&lt;R&gt;、DoubleFunction&lt;R&gt;     参数分别为int、long、double 类型的函数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Function_</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">        time(<span class="number">2000</span>, <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Double&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Double aDouble)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;南京旅游&quot;</span> + aDouble);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//lambda 表达式</span></span><br><span class="line">        time(<span class="number">2000</span>,aDouble-&gt; System.out.println(<span class="string">&quot;去南京旅游&quot;</span> + aDouble));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">time</span><span class="params">(<span class="type">double</span> money, Consumer&lt;Double&gt; con)</span>&#123;</span><br><span class="line">        con.accept(aDouble);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;南京&quot;</span>, <span class="string">&quot;南京8&quot;</span>, <span class="string">&quot;南京7&quot;</span>, <span class="string">&quot;南京6&quot;</span>, <span class="string">&quot;南京5&quot;</span>, <span class="string">&quot;南京4&quot;</span>, <span class="string">&quot;南京3&quot;</span>, <span class="string">&quot;南京1&quot;</span>, <span class="string">&quot;南京2&quot;</span>);</span><br><span class="line">        List&lt;String&gt; filterString = filterString(strings, <span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> s.contains(<span class="string">&quot;南京&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(filterString);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//lambda表达式</span></span><br><span class="line">        List&lt;String&gt; filterString1 = filterString(strings, s -&gt; s.contains(<span class="string">&quot;京&quot;</span>));</span><br><span class="line">        System.out.println(filterString1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据给定的规则过滤集合中的字符串，规则有predicate 的方法决定</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">filterString</span><span class="params">(List&lt;String&gt; list, Predicate&lt;String&gt; predicate)</span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; strings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String Str:list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (predicate.test(Str))&#123;</span><br><span class="line">                strings.add(Str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strings;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="常用方法-2">常用方法</h4>
<blockquote>
<ul>
<li>and</li>
</ul>
<p>我们在使用Predicate接口时候可能需要进行判断条件的拼接。而and方法相当于是使用<code>&amp;&amp;</code>来拼接两个判断条件</p>
<p>例如：</p>
<p>打印作家中年龄大于17并且姓名的长度大于1的作家。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">Stream&lt;Author&gt; authorStream = authors.stream();</span><br><span class="line">authorStream.filter(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Author&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> author.getAge()&gt;<span class="number">17</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.and(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Author&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> author.getName().length()&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)).forEach(author -&gt; System.out.println(author));</span><br></pre></td></tr></table></figure>
<ul>
<li>or</li>
</ul>
<p>我们在使用Predicate接口时候可能需要进行判断条件的拼接。而or方法相当于是使用<code>||</code>来拼接两个判断条件。</p>
<p>例如：</p>
<p>打印作家中年龄大于17或者姓名的长度小于2的作家。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//        打印作家中年龄大于17或者姓名的长度小于2的作家。</span></span><br><span class="line">       List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">       authors.stream()</span><br><span class="line">               .filter(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Author&gt;() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">                       <span class="keyword">return</span> author.getAge()&gt;<span class="number">17</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;.or(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Author&gt;() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">                       <span class="keyword">return</span> author.getName().length()&lt;<span class="number">2</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;)).forEach(author -&gt; System.out.println(author.getName()));</span><br></pre></td></tr></table></figure>
<ul>
<li>negate</li>
</ul>
<p>Predicate接口中的方法。negate方法相当于是在判断添加前面加了个<code>! </code>表示取反</p>
<p>例如：</p>
<p>打印作家中年龄不大于17的作家。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//        打印作家中年龄不大于17的作家。</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">        authors.stream()</span><br><span class="line">                .filter(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Author&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> author.getAge()&gt;<span class="number">17</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;.negate()).forEach(author -&gt; System.out.println(author.getAge()));</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="未看">未看</h2>
<h4 id="正则表达式">正则表达式</h4>
<h5 id="正则表达式底层实现">正则表达式底层实现</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegTheory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;1998年12月8日，第二代Java平台的企业版J2EE发布。1999年6月，Sun公司发布了&quot;</span> +</span><br><span class="line">                <span class="string">&quot;第二代Java平台（简称为Java2）的3个版本：J2ME（Java2 Micro Edition，Java2平台的微型&quot;</span> +</span><br><span class="line">                <span class="string">&quot;版），应用于移动、无线及有限资源的环境；J2SE（Java 2 Standard Edition，Java 2平台的&quot;</span> +</span><br><span class="line">                <span class="string">&quot;标准版），应用于桌面环境；J2EE（Java 2Enterprise Edition，Java 2平台的企业版），应&quot;</span> +</span><br><span class="line">                <span class="string">&quot;用3443于基于Java的应用服务器。Java 2平台的发布，是Java发展过程中最重要的一个&quot;</span> +</span><br><span class="line">                <span class="string">&quot;里程碑，标志着Java的应用开始普及9889 &quot;</span>;</span><br><span class="line">        <span class="comment">//目标：匹配所有四个数字</span></span><br><span class="line">        <span class="comment">//说明</span></span><br><span class="line">        <span class="comment">//1. \\d 表示一个任意的数字</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">regStr</span> <span class="operator">=</span> <span class="string">&quot;(\\d\\d)(\\d\\d)&quot;</span>;</span><br><span class="line">        <span class="comment">//2. 创建模式对象[即正则表达式对象]</span></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regStr);</span><br><span class="line">        <span class="comment">//3. 创建匹配器</span></span><br><span class="line">        <span class="comment">//说明：创建匹配器matcher， 按照 正则表达式的规则 去匹配 content字符串</span></span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(content);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.开始匹配</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * matcher.find() 完成的任务 （考虑分组）</span></span><br><span class="line"><span class="comment">         * 什么是分组，比如  (\d\d)(\d\d) ,正则表达式中有() 表示分组,第1个()表示第1组,第2个()表示第2组...</span></span><br><span class="line"><span class="comment">         * 1. 根据指定的规则 ,定位满足规则的子字符串(比如(19)(98))</span></span><br><span class="line"><span class="comment">         * 2. 找到后，将 子字符串的开始的索引记录到 matcher对象的属性 int[] groups;</span></span><br><span class="line"><span class="comment">         *    2.1 groups[0] = 0 , 把该子字符串的结束的索引+1的值记录到 groups[1] = 4</span></span><br><span class="line"><span class="comment">         *    2.2 记录1组()匹配到的字符串 groups[2] = 0  groups[3] = 2</span></span><br><span class="line"><span class="comment">         *    2.3 记录2组()匹配到的字符串 groups[4] = 2  groups[5] = 4</span></span><br><span class="line"><span class="comment">         *    2.4.如果有更多的分组.....</span></span><br><span class="line"><span class="comment">         * 3. 同时记录oldLast 的值为 子字符串的结束的 索引+1的值即35, 即下次执行find时，就从35开始匹配</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * matcher.group(0) 分析</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 源码:</span></span><br><span class="line"><span class="comment">         * public String group(int group) &#123;</span></span><br><span class="line"><span class="comment">         *         if (first &lt; 0)</span></span><br><span class="line"><span class="comment">         *             throw new IllegalStateException(&quot;No match found&quot;);</span></span><br><span class="line"><span class="comment">         *         if (group &lt; 0 || group &gt; groupCount())</span></span><br><span class="line"><span class="comment">         *             throw new IndexOutOfBoundsException(&quot;No group &quot; + group);</span></span><br><span class="line"><span class="comment">         *         if ((groups[group*2] == -1) || (groups[group*2+1] == -1))</span></span><br><span class="line"><span class="comment">         *             return null;</span></span><br><span class="line"><span class="comment">         *         return getSubSequence(groups[group * 2], groups[group * 2 + 1]).toString();</span></span><br><span class="line"><span class="comment">         *     &#125;</span></span><br><span class="line"><span class="comment">         *  1. 根据 groups[0]=31 和 groups[1]=35 的记录的位置，从content开始截取子字符串返回</span></span><br><span class="line"><span class="comment">         *     就是 [31,35) 包含 31 但是不包含索引为 35的位置</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *  如果再次指向 find方法.仍然按照上面分析的来执行</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">            <span class="comment">//小结</span></span><br><span class="line">            <span class="comment">//1. 如果正则表达式有() 即分组</span></span><br><span class="line">            <span class="comment">//2. 取出匹配的字符串规则如下</span></span><br><span class="line">            <span class="comment">//3. group(0) 表示匹配到的子字符串</span></span><br><span class="line">            <span class="comment">//4. group(1) 表示匹配到的子字符串的第一组字串</span></span><br><span class="line">            <span class="comment">//5. group(2) 表示匹配到的子字符串的第2组字串</span></span><br><span class="line">            <span class="comment">//6. ... 但是分组的数不能越界.</span></span><br><span class="line">            System.out.println(<span class="string">&quot;找到: &quot;</span> + matcher.group(<span class="number">0</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;第1组()匹配到的值=&quot;</span> + matcher.group(<span class="number">1</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;第2组()匹配到的值=&quot;</span> + matcher.group(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="正则表达式—元字符">正则表达式—元字符</h5>
<h6 id="元字符大致按功能分类：">元字符大致按功能分类：</h6>
<blockquote>
<p>1.限定符	 2.选择匹配符	3.分组组合和反向引用符	4.特殊字符	5.字符匹配符	6.定位符</p>
</blockquote>
<h6 id="元字符-Metacharacter-转义号">元字符( Metacharacter)-转义号 \\</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\\符号 说明:在我们使用正则表达式去检索某些特殊字符的时候，需要用到转义符号，否则检索不到结果，甚至会报错的。</span><br><span class="line">提示: 在Java的正则表达式中，两个 \\ 代表其他语言中的一个\</span><br><span class="line">需要用到转义符号的字符有以下:  .  *  +  ( )  $  /   \   ?   [ ]  ^  &#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="元字符-字符匹配符">元字符-字符匹配符</h6>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304091556619.png" alt></p>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304091556889.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegExp03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;a11c8abc _ABCy @&quot;</span>;</span><br><span class="line">        <span class="comment">//String regStr = &quot;[a-z]&quot;;//匹配 a-z之间任意一个字符</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;[A-Z]&quot;;//匹配 A-Z之间任意一个字符</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;abc&quot;;//匹配 abc 字符串[默认区分大小写]</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;(?i)abc&quot;;//匹配 abc 字符串[不区分大小写]</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;[0-9]&quot;;//匹配 0-9 之间任意一个字符</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;[^a-z]&quot;;//匹配 不在 a-z之间任意一个字符</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;[^0-9]&quot;;//匹配 不在 0-9之间任意一个字符</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;[abcd]&quot;;//匹配 在 abcd中任意一个字符</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;\\D&quot;;//匹配 不在 0-9的任意一个字符</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;\\w&quot;;//匹配 大小写英文字母, 数字，下划线</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;\\W&quot;;//匹配 等价于 [^a-zA-Z0-9_]</span></span><br><span class="line">        <span class="comment">//\\s 匹配任何空白字符(空格,制表符等)</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;\\s&quot;;</span></span><br><span class="line">        <span class="comment">//\\S 匹配任何非空白字符 ,和\\s刚好相反</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;\\S&quot;;</span></span><br><span class="line">        <span class="comment">//.  匹配出 \n 之外的所有字符,如果要匹配.本身则需要使用 \\.</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">regStr</span> <span class="operator">=</span> <span class="string">&quot;.&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//说明</span></span><br><span class="line">        <span class="comment">//1. 当创建Pattern对象时，指定 Pattern.CASE_INSENSITIVE, 表示匹配是不区分字母大小写.</span></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regStr<span class="comment">/*, Pattern.CASE_INSENSITIVE*/</span>);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(content);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;找到 &quot;</span> + matcher.group(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="元字符-选择匹配符">元字符-选择匹配符</h6>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202303032120619.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegExp04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;hanshunping 韩 寒冷&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">regStr</span> <span class="operator">=</span> <span class="string">&quot;han|韩|寒&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regStr<span class="comment">/*, Pattern.CASE_INSENSITIVE*/</span>);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(content);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;找到 &quot;</span> + matcher.group(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="元字符-限定符">元字符-限定符</h6>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202303032119943.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegExp05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;a211111aaaaaahello&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//a&#123;3&#125;,1&#123;4&#125;,\\d&#123;2&#125;</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;a&#123;3&#125;&quot;;// 表示匹配 aaa</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;1&#123;4&#125;&quot;;// 表示匹配 1111</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;\\d&#123;2&#125;&quot;;// 表示匹配 两位的任意数字字符</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//a&#123;3,4&#125;,1&#123;4,5&#125;,\\d&#123;2,5&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//细节：java匹配默认贪婪匹配，即尽可能匹配多的</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;a&#123;3,4&#125;&quot;; //表示匹配 aaa 或者 aaaa</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;1&#123;4,5&#125;&quot;; //表示匹配 1111 或者 11111</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;\\d&#123;2,5&#125;&quot;; //匹配2位数或者3,4,5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1+</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;1+&quot;; //匹配一个1或者多个1</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;\\d+&quot;; //匹配一个数字或者多个数字</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1*</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;1*&quot;; //匹配0个1或者多个1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//演示?的使用, 遵守贪婪匹配</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">regStr</span> <span class="operator">=</span> <span class="string">&quot;a1?&quot;</span>; <span class="comment">//匹配 a 或者 a1</span></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regStr<span class="comment">/*, Pattern.CASE_INSENSITIVE*/</span>);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(content);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;找到 &quot;</span> + matcher.group(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="元字符-定位符">元字符-定位符</h6>
<p><strong>定位符:规定要匹配的字符串出现的位置</strong></p>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304091556074.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegExp06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;hanshunping sphan nnhan&quot;</span>;</span><br><span class="line">        <span class="comment">//String content = &quot;123-abc&quot;;</span></span><br><span class="line">        <span class="comment">//以至少1个数字开头，后接任意个小写字母的字符串</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;^[0-9]+[a-z]*&quot;;</span></span><br><span class="line">        <span class="comment">//以至少1个数字开头, 必须以至少一个小写字母结束</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;^[0-9]+\\-[a-z]+$&quot;;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//表示匹配边界的han[这里的边界是指：被匹配的字符串最后,</span></span><br><span class="line">        <span class="comment">// 也可以是空格的子字符串的后面]</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;han\\b&quot;;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//和\\b的含义刚刚相反</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">regStr</span> <span class="operator">=</span> <span class="string">&quot;han\\B&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regStr);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(content);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;找到=&quot;</span> + matcher.group(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="分组">分组</h6>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202303032124320.png" alt></p>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202303032125552.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">	*分组</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegExp07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;hanshunping s7789 nn1189han&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面就是非命名分组</span></span><br><span class="line">        <span class="comment">//说明</span></span><br><span class="line">        <span class="comment">// 1. matcher.group(0) 得到匹配到的字符串</span></span><br><span class="line">        <span class="comment">// 2. matcher.group(1) 得到匹配到的字符串的第1个分组内容</span></span><br><span class="line">        <span class="comment">// 3. matcher.group(2) 得到匹配到的字符串的第2个分组内容</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//String regStr = &quot;(\\d\\d)(\\d\\d)&quot;;//匹配4个数字的字符串</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//命名分组： 即可以给分组取名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">regStr</span> <span class="operator">=</span> <span class="string">&quot;(?&lt;g1&gt;\\d\\d)(?&lt;g2&gt;\\d\\d)&quot;</span>;<span class="comment">//匹配4个数字的字符串</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regStr);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(content);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;找到=&quot;</span> + matcher.group(<span class="number">0</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;第1个分组内容=&quot;</span> + matcher.group(<span class="number">1</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;第1个分组内容[通过组名]=&quot;</span> + matcher.group(<span class="string">&quot;g1&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;第2个分组内容=&quot;</span> + matcher.group(<span class="number">2</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;第2个分组内容[通过组名]=&quot;</span> + matcher.group(<span class="string">&quot;g2&quot;</span>));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 演示非捕获分组, 语法比较奇怪</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegExp08</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;hello韩顺平教育 jack韩顺平老师 韩顺平同学hello韩顺平学生&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        找到 韩顺平教育 、韩顺平老师、韩顺平同学 子字符串</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;韩顺平教育|韩顺平老师|韩顺平同学&quot;;</span></span><br><span class="line">        <span class="comment">//上面的写法可以等价非捕获分组, 注意：不能 matcher.group(1)</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;韩顺平(?:教育|老师|同学)&quot;;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到 韩顺平 这个关键字,但是要求只是查找韩顺平教育和 韩顺平老师 中包含有的韩顺平</span></span><br><span class="line">        <span class="comment">//下面也是非捕获分组，不能使用 matcher.group(1)</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;韩顺平(?=教育|老师)&quot;;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到 韩顺平 这个关键字,但是要求只是查找 不是 (韩顺平教育 和 韩顺平老师) 中包含有的韩顺平</span></span><br><span class="line">        <span class="comment">//下面也是非捕获分组，不能使用 matcher.group(1)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">regStr</span> <span class="operator">=</span> <span class="string">&quot;韩顺平(?!教育|老师)&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regStr);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(content);</span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;找到: &quot;</span> + matcher.group(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非贪婪匹配</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegExp09</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;hello111111 ok&quot;</span>;</span><br><span class="line">        <span class="comment">//String regStr = &quot;\\d+&quot;; //默认是贪婪匹配</span></span><br><span class="line">       <span class="comment">// String regStr = &quot;\\d+?&quot;; //非贪婪匹配</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">regStr</span> <span class="operator">=</span> <span class="string">&quot;\\d+?&quot;</span>; <span class="comment">//非贪婪匹配</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regStr);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(content);</span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;找到: &quot;</span> + matcher.group(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="应用实例">应用实例</h6>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202303032134057.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegExp10</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;13588889999&quot;</span>;</span><br><span class="line">        <span class="comment">// 汉字</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;^[\u0391-\uffe5]+$&quot;;</span></span><br><span class="line">        <span class="comment">// 邮政编码</span></span><br><span class="line">        <span class="comment">// 要求：1.是1-9开头的一个六位数.  比如：123890</span></span><br><span class="line">        <span class="comment">//      2.</span></span><br><span class="line">        <span class="comment">//      3.</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;^[1-9]\\d&#123;5&#125;$&quot;;</span></span><br><span class="line">        <span class="comment">// QQ号码</span></span><br><span class="line">        <span class="comment">// 要求:  是1-9开头的一个(5位数-10位数)  比如:  12389 , 1345687 , 187698765</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;^[1-9]\\d&#123;4,9&#125;$&quot;;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 手机号码</span></span><br><span class="line">        <span class="comment">// 要求: 必须以13,14,15,18 开头的11位数 , 比如 13588889999</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">regStr</span> <span class="operator">=</span> <span class="string">&quot;^1[3|4|5|8]\\d&#123;9&#125;$&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regStr);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(content);</span><br><span class="line">        <span class="keyword">if</span>(matcher.find()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;满足格式&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不满足格式&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegExp11</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//String content = &quot;https://www.bilibili.com/video/BV1fh411y7R8?from=search&amp;seid=1831060912083761326&quot;;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;http://edu.3dsmax.tech/yg/bilibili/my6652/pc/qg/05-51/index.html#201211-1?track_id=jMc0jn-hm-yHrNfVad37YdhOUh41XYmjlss9zocM26gspY5ArwWuxb4wYWpmh2Q7GzR7doU0wLkViEhUlO1qNtukyAgake2jG1bTd23lR57XzV83E9bAXWkStcAh4j9Dz7a87ThGlqgdCZ2zpQy33a0SVNMfmJLSNnDzJ71TU68Rc-3PKE7VA3kYzjk4RrKU&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 思路</span></span><br><span class="line"><span class="comment">         * 1. 先确定 url 的开始部分 https:// | http://</span></span><br><span class="line"><span class="comment">         * 2.然后通过 ([\w-]+\.)+[\w-]+ 匹配 www.bilibili.com</span></span><br><span class="line"><span class="comment">         * 3. /video/BV1fh411y7R8?from=sear 匹配(\/[\w-?=&amp;/%.#]*)?</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">regStr</span> <span class="operator">=</span> <span class="string">&quot;^((http|https)://)?([\\w-]+\\.)+[\\w-]+(\\/[\\w-?=&amp;/%.#]*)?$&quot;</span>;<span class="comment">//注意：[. ? *]表示匹配就是.本身</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regStr);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(content);</span><br><span class="line">        <span class="keyword">if</span>(matcher.find()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;满足格式&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不满足格式&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里如果使用Pattern的matches 整体匹配 比较简洁</span></span><br><span class="line">        System.out.println(Pattern.matches(regStr, content));<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="正则表达式三个常用类">正则表达式三个常用类</h5>
<blockquote>
<p>java.util.regex包主要包括以下三个类<strong>Pattern类、Matcher 类和PatternSyntaxException类</strong></p>
<p><strong>Pattern类</strong></p>
<p>pattern对象是一个正则表达式对象。 Pattern 类没有公共构造方法。要创建一个Pattern 对</p>
<p>象，调用其公共静态方法，它返回个Pattern对象。该方法接受个正则表达式作为它的第一个参数，比如: Pattern pat = Pattern.compile(pattrn);</p>
<p><strong>Matcher类</strong></p>
<p>Matcher对象是对输入字符串进行解释和匹配的引擎。与Pattern 类一样，Matcher 也没有</p>
<p>公共构造方法。你需要调用Pattern对象的matcher方法来获得一个Matcher对象</p>
<p><strong>PatternSyntaxException</strong></p>
<p>PatternSyntaxException是一个非强制异常类， 它表示一个正则表达式模式中的语法错误。</p>
</blockquote>
<h6 id="Pattern">Pattern</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示matches方法，用于整体匹配, 在验证输入的字符串是否满足条件使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PatternMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;hello abc hello, 韩顺平教育&quot;</span>;</span><br><span class="line">        <span class="comment">//String regStr = &quot;hello&quot;;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">regStr</span> <span class="operator">=</span> <span class="string">&quot;hello.*&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">matches</span> <span class="operator">=</span> Pattern.matches(regStr, content);</span><br><span class="line">        System.out.println(<span class="string">&quot;整体匹配= &quot;</span> + matches);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="Matcher">Matcher</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Matcher 类的常用方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MatcherMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;hello edu jack hspedutom hello smith hello hspedu hspedu&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">regStr</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regStr);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(content);</span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;=================&quot;</span>);</span><br><span class="line">            System.out.println(matcher.start());</span><br><span class="line">            System.out.println(matcher.end());</span><br><span class="line">            System.out.println(<span class="string">&quot;找到: &quot;</span> + content.substring(matcher.start(), matcher.end()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//整体匹配方法，常用于，去校验某个字符串是否满足某个规则</span></span><br><span class="line">        System.out.println(<span class="string">&quot;整体匹配=&quot;</span> + matcher.matches());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//完成如果content 有 hspedu 替换成 韩顺平教育</span></span><br><span class="line">        regStr = <span class="string">&quot;hspedu&quot;</span>;</span><br><span class="line">        pattern = Pattern.compile(regStr);</span><br><span class="line">        matcher = pattern.matcher(content);</span><br><span class="line">        <span class="comment">//注意：返回的字符串才是替换后的字符串 原来的 content 不变化</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">newContent</span> <span class="operator">=</span> matcher.replaceAll(<span class="string">&quot;韩顺平教育&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;newContent=&quot;</span> + newContent);</span><br><span class="line">        System.out.println(<span class="string">&quot;content=&quot;</span> + content);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="分组、捕获、反向引用">分组、捕获、反向引用</h5>
<blockquote>
<p>1.分组</p>
<p>我们可以用圆括号组成个比较复杂的匹配模式，那么一个圆括号的部分我们可以看作是一个子表达式/一个分组。</p>
<p>2.捕获</p>
<p>把正则表达式中子表达式/分组匹配的内容，保存到内存中以数字编号或显式命名的组里，方便后面引用，从左向右，以分组的左括号为标志，第一个出现的分组的组号为1,第二个为2,以此类推。组0代表的是整个正则式</p>
<p>3.反向引用</p>
<p>圆括号的内容被捕获后，可以在这个括号后被使用，从而写出一一个比较实用的匹配模式，这个我们称为反向引用这种引用既可以是在正则表达式内部，也可以是在正则表达式外部，内部反向引用 \ 分组号,外部反向引用 $ 分组号</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反向引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegExp12</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;h1234el9876lo33333 j12324-333999111a1551ck14 tom11 jack22 yyy12345 xxx&quot;</span>;</span><br><span class="line">        <span class="comment">//要匹配两个连续的相同数字 :  (\\d)\\1</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;(\\d)\\1&quot;;</span></span><br><span class="line">        <span class="comment">//要匹配五个连续的相同数字： (\\d)\\1&#123;4&#125;</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;(\\d)\\1&#123;4&#125;&quot;;</span></span><br><span class="line">        <span class="comment">//要匹配个位与千位相同，十位与百位相同的数 5225 , 1551  (\\d)(\\d)\\2\\1</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;(\\d)(\\d)\\2\\1&quot;;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 请在字符串中检索商品编号,形式如:12321-333999111 这样的号码,</span></span><br><span class="line"><span class="comment">         * 要求满足前面是一个五位数,然后一个-号,然后是一个九位数,连续的每三位要相同</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">regStr</span> <span class="operator">=</span> <span class="string">&quot;\\d&#123;5&#125;-(\\d)\\1&#123;2&#125;(\\d)\\2&#123;2&#125;(\\d)\\3&#123;2&#125;&quot;</span>;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regStr);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(content);</span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;找到 &quot;</span> + matcher.group(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="结巴程序">结巴程序</h6>
<blockquote>
<p>把类似 : &quot;我…我要…学学学学…编程 java!&quot;通过正则表达式 修改成 “我要学编程 java”</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegExp13</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;我....我要....学学学学....编程java!&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 去掉所有的.</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(content);</span><br><span class="line">        content = matcher.replaceAll(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//       System.out.println(&quot;content=&quot; + content);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 去掉重复的字  我我要学学学学编程java!</span></span><br><span class="line">        <span class="comment">// 思路</span></span><br><span class="line">        <span class="comment">//(1) 使用 (.)\\1+</span></span><br><span class="line">        <span class="comment">//(2) 使用 反向引用$1 来替换匹配到的内容</span></span><br><span class="line">        <span class="comment">// 注意：因为正则表达式变化，所以需要重置 matcher</span></span><br><span class="line"><span class="comment">//        pattern = Pattern.compile(&quot;(.)\\1+&quot;);//分组的捕获内容记录到$1</span></span><br><span class="line"><span class="comment">//        matcher = pattern.matcher(content);</span></span><br><span class="line"><span class="comment">//        while (matcher.find()) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;找到=&quot; + matcher.group(0));</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        //使用 反向引用$1 来替换匹配到的内容</span></span><br><span class="line"><span class="comment">//        content = matcher.replaceAll(&quot;$1&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;content=&quot; + content);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 使用一条语句 去掉重复的字  我我要学学学学编程java!</span></span><br><span class="line">        content = Pattern.compile(<span class="string">&quot;(.)\\1+&quot;</span>).matcher(content).replaceAll(<span class="string">&quot;$1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;content=&quot;</span> + content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="String类中使用正则表达式">String类中使用正则表达式</h5>
<blockquote>
<p>替换功能:		String类   public String replaceAll(String regex,String replacement)</p>
<p>判断功能:		String类   public boolean matches(String regex)} //使用Pattern和Matcher 类</p>
<p>分割功能:		String类    public String[] split(String regex)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringReg</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;2000年5月，JDK1.3、JDK1.4和J2SE1.3相继发布，几周后其&quot;</span> +</span><br><span class="line">                <span class="string">&quot;获得了Apple公司Mac OS X的工业标准的支持。2001年9月24日，J2EE1.3发&quot;</span> +</span><br><span class="line">                <span class="string">&quot;布。&quot;</span> +</span><br><span class="line">                <span class="string">&quot;2002年2月26日，J2SE1.4发布。自此Java的计算能力有了大幅提升&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//替换</span></span><br><span class="line">        <span class="comment">//使用正则表达式方式，将 JDK1.3 和 JDK1.4 替换成JDK</span></span><br><span class="line">        content = content.replaceAll(<span class="string">&quot;JDK1\\.3|JDK1\\.4&quot;</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        System.out.println(content);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//验证/判断</span></span><br><span class="line">        <span class="comment">//要求 验证一个 手机号， 要求必须是以138 139 开头的</span></span><br><span class="line">        content = <span class="string">&quot;13888889999&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (content.matches(<span class="string">&quot;1(38|39)\\d&#123;8&#125;&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;验证成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;验证失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//分割</span></span><br><span class="line">        <span class="comment">//要求按照 # 或者 - 或者 ~ 或者 数字 来分割</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===================&quot;</span>);</span><br><span class="line">        content = <span class="string">&quot;hello#abc-jack12smith~北京&quot;</span>;</span><br><span class="line">        String[] split = content.split(<span class="string">&quot;#|-|~|\\d+&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : split) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://rycan.top">Ryang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://rycan.top/post/554bb3d.html">http://rycan.top/post/554bb3d.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://rycan.top" target="_blank">杨睿的学习手记</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="/img/47.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><!--.post-reward--><!--  .reward-button--><!--    i.fas.fa-qrcode--><!--    = ' ' + _p('donate')--><!--  .reward-main--><!--    ul.reward-all--><!--      each item in theme.reward.QR_code--><!--        - var clickTo = item.link ? item.link : item.img--><!--        li.reward-item--><!--          a(href=url_for(clickTo) target='_blank')--><!--            img.post-qr-code-img(src=url_for(item.img) alt=item.text)--><!--          .post-qr-code-desc=item.text--><link rel="stylesheet" href="/" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">打赏</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></button></div><audio id="coinAudio" src="https://npm.elemecdn.com/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer="defer" src="/"></script><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/f313cf4f.html" title="springcloud核心代码思路篇"><img class="cover" src="/img/69.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">springcloud核心代码思路篇</div></div></a></div><div class="next-post pull-right"><a href="/post/f5f9fa9b.html" title="Docker"><img class="cover" src="/img/43.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Docker</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/2da05edf.html" title="JUC 学习合集"><img class="cover" src="/img/48.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-03</div><div class="title">JUC 学习合集</div></div></a></div><div><a href="/post/d366874c.html" title="集合"><img class="cover" src="/img/18.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-06</div><div class="title">集合</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Livere</span><span class="switch-btn"></span><span class="second-comment">Valine</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81ODY2MC8zNTEyMg=="></div></div><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">Java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="toc-number">1.0.1.</span> <span class="toc-text">转义字符:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.0.2.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.0.3.</span> <span class="toc-text">运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">1.0.4.</span> <span class="toc-text">标识符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6"><span class="toc-number">1.0.5.</span> <span class="toc-text">进制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.0.6.</span> <span class="toc-text">位运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%A0%81-%E5%8F%8D%E7%A0%81-%E8%A1%A5%E7%A0%81"><span class="toc-number">1.0.7.</span> <span class="toc-text">原码 反码 补码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="toc-number">1.0.8.</span> <span class="toc-text">控制结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%B3%E5%87%BA%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.0.9.</span> <span class="toc-text">跳出控制语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.0.10.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.0.10.0.1.</span> <span class="toc-text">一维数组</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.0.10.0.2.</span> <span class="toc-text">二维数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">1.0.11.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%86%92%E6%B3%A1"><span class="toc-number">1.0.11.0.1.</span> <span class="toc-text">冒泡</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OOP"><span class="toc-number">1.0.12.</span> <span class="toc-text">OOP</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%92%8C-equals-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.0.12.0.1.</span> <span class="toc-text">&#x3D;&#x3D;和 equals 的对比</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#hashCode"><span class="toc-number">1.0.12.0.2.</span> <span class="toc-text">hashCode</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#toString-%E6%96%B9%E6%B3%95"><span class="toc-number">1.0.12.0.3.</span> <span class="toc-text">toString 方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#finalize-%E6%96%B9%E6%B3%95"><span class="toc-number">1.0.12.0.4.</span> <span class="toc-text">finalize 方法</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E4%B8%AD%E9%98%B6"><span class="toc-number">2.</span> <span class="toc-text">Java中阶</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">2.1.</span> <span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.2.</span> <span class="toc-text">注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">2.3.</span> <span class="toc-text">异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E9%AB%98%E9%98%B6"><span class="toc-number">3.</span> <span class="toc-text">Java高阶</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-number">3.1.</span> <span class="toc-text">常用类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#String"><span class="toc-number">3.1.0.1.</span> <span class="toc-text">String</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#StringBuffer"><span class="toc-number">3.1.0.2.</span> <span class="toc-text">StringBuffer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#StringBuilder"><span class="toc-number">3.1.0.3.</span> <span class="toc-text">StringBuilder </span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Math"><span class="toc-number">3.1.0.4.</span> <span class="toc-text">Math</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Arrays"><span class="toc-number">3.1.0.5.</span> <span class="toc-text">Arrays</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#System"><span class="toc-number">3.1.0.6.</span> <span class="toc-text">System</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Date"><span class="toc-number">3.1.0.7.</span> <span class="toc-text">Date</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">3.1.0.8.</span> <span class="toc-text">包装类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">3.2.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ArrayList"><span class="toc-number">3.2.0.1.</span> <span class="toc-text">ArrayList:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#list"><span class="toc-number">3.2.0.2.</span> <span class="toc-text">list</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LinkedList"><span class="toc-number">3.2.0.3.</span> <span class="toc-text">LinkedList</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Set"><span class="toc-number">3.2.0.4.</span> <span class="toc-text">Set</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LinkedHashSet"><span class="toc-number">3.2.0.5.</span> <span class="toc-text">LinkedHashSet</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Map"><span class="toc-number">3.2.0.6.</span> <span class="toc-text">Map</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">3.3.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%EF%BC%9A"><span class="toc-number">3.3.0.0.1.</span> <span class="toc-text">自定义泛型：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.4.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="toc-number">3.4.0.1.</span> <span class="toc-text">使用：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.4.0.2.</span> <span class="toc-text">模拟多线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.4.0.3.</span> <span class="toc-text">终止线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">3.4.0.4.</span> <span class="toc-text">常用方法:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.4.0.5.</span> <span class="toc-text">线程的生命周期</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">3.4.0.6.</span> <span class="toc-text">线程同步</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">3.4.0.7.</span> <span class="toc-text">互斥锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">3.4.0.8.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E9%94%81"><span class="toc-number">3.4.0.9.</span> <span class="toc-text">释放锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E6%B5%81"><span class="toc-number">3.5.</span> <span class="toc-text">IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6"><span class="toc-number">3.5.1.</span> <span class="toc-text">文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO-%E6%B5%81"><span class="toc-number">3.5.2.</span> <span class="toc-text">IO 流</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#InputStream%EF%BC%88%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81%EF%BC%89"><span class="toc-number">3.5.2.1.</span> <span class="toc-text">InputStream（字节输入流）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#OutputStream%EF%BC%88%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81%EF%BC%89"><span class="toc-number">3.5.2.2.</span> <span class="toc-text">OutputStream（字节输出流）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Reader%EF%BC%88%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81%EF%BC%89"><span class="toc-number">3.5.2.3.</span> <span class="toc-text">Reader（字符输入流）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Writer%EF%BC%88%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81%EF%BC%89"><span class="toc-number">3.5.2.4.</span> <span class="toc-text">Writer（字符输出流）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#FileInputStream"><span class="toc-number">3.5.2.5.</span> <span class="toc-text">FileInputStream</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DataInputStream"><span class="toc-number">3.5.2.6.</span> <span class="toc-text">DataInputStream</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#FileOutputStream"><span class="toc-number">3.5.2.7.</span> <span class="toc-text">FileOutputStream</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DataOutputStream"><span class="toc-number">3.5.2.8.</span> <span class="toc-text">DataOutputStream</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E6%B5%81"><span class="toc-number">3.5.2.9.</span> <span class="toc-text">节点流</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#FileReader"><span class="toc-number">3.5.2.9.1.</span> <span class="toc-text">FileReader</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#FileWriter"><span class="toc-number">3.5.2.9.2.</span> <span class="toc-text">FileWriter</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E6%B5%81%E5%92%8C%E5%A4%84%E7%90%86%E6%B5%81"><span class="toc-number">3.5.2.10.</span> <span class="toc-text">节点流和处理流</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%B5%81"><span class="toc-number">3.5.2.11.</span> <span class="toc-text">处理流</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#BufferedReader"><span class="toc-number">3.5.2.11.1.</span> <span class="toc-text">BufferedReader</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#BufferedWriter"><span class="toc-number">3.5.2.11.2.</span> <span class="toc-text">BufferedWriter</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#BufferedInputStream-%E5%92%8C-BufferedOutputStream-%E4%B9%9F%E6%98%AF%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-number">3.5.2.11.3.</span> <span class="toc-text">BufferedInputStream 和 BufferedOutputStream  也是字节流</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%B5%81"><span class="toc-number">3.5.2.12.</span> <span class="toc-text">对象流</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">3.5.2.12.1.</span> <span class="toc-text">序列化和反序列化</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#ObjectInputStream"><span class="toc-number">3.5.2.12.2.</span> <span class="toc-text">ObjectInputStream</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#ObjectOutputStream"><span class="toc-number">3.5.2.12.3.</span> <span class="toc-text">ObjectOutputStream</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">3.5.2.13.</span> <span class="toc-text">标准输入输出流</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-number">3.5.2.14.</span> <span class="toc-text">转换流</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#InputStreamReader"><span class="toc-number">3.5.2.14.1.</span> <span class="toc-text">InputStreamReader </span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#OutputStreamWriter"><span class="toc-number">3.5.2.14.2.</span> <span class="toc-text">OutputStreamWriter</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E6%B5%81"><span class="toc-number">3.5.2.15.</span> <span class="toc-text">打印流</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#PrintStream"><span class="toc-number">3.5.2.15.1.</span> <span class="toc-text">PrintStream </span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#PrintWriter"><span class="toc-number">3.5.2.15.2.</span> <span class="toc-text"> PrintWriter</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E6%B5%81"><span class="toc-number">3.5.2.16.</span> <span class="toc-text">随机访问流</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">3.6.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%BC%95%E5%85%A5"><span class="toc-number">3.6.1.</span> <span class="toc-text">问题引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83"><span class="toc-number">3.6.2.</span> <span class="toc-text">核心</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-number">3.6.3.</span> <span class="toc-text">类加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E4%BF%A1%E6%81%AF"><span class="toc-number">3.6.4.</span> <span class="toc-text">通过反射获取类的结构信息</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java-lang-Class-%E7%B1%BB"><span class="toc-number">3.6.4.1.</span> <span class="toc-text">java.lang.Class 类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#java-lang-reflect-Field-%E7%B1%BB"><span class="toc-number">3.6.4.2.</span> <span class="toc-text">java.lang.reflect.Field 类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#java-lang-reflect-Method-%E7%B1%BB"><span class="toc-number">3.6.4.3.</span> <span class="toc-text">java.lang.reflect.Method 类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#java-lang-reflect-Constructor-%E7%B1%BB"><span class="toc-number">3.6.4.4.</span> <span class="toc-text">java.lang.reflect.Constructor 类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.6.5.</span> <span class="toc-text">通过反射创建对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%AE%BF%E9%97%AE%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-number">3.6.6.</span> <span class="toc-text">通过反射访问类中的成员</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%B1%9E%E6%80%A7"><span class="toc-number">3.6.6.1.</span> <span class="toc-text">访问属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95"><span class="toc-number">3.6.6.2.</span> <span class="toc-text">访问方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">3.7.</span> <span class="toc-text">网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#InetAddress-%E7%B1%BB"><span class="toc-number">3.7.0.1.</span> <span class="toc-text">InetAddress 类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Socket"><span class="toc-number">3.7.0.2.</span> <span class="toc-text">Socket</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%BC%96%E7%A8%8B"><span class="toc-number">3.7.0.3.</span> <span class="toc-text">TCP网络通信编程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#netstat-%E6%8C%87%E4%BB%A4"><span class="toc-number">3.7.0.4.</span> <span class="toc-text">netstat 指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#UDP-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%BC%96%E7%A8%8B"><span class="toc-number">3.7.0.5.</span> <span class="toc-text">UDP 网络通信编程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDBC"><span class="toc-number">3.8.</span> <span class="toc-text">JDBC</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#JDBC-%E7%9A%84%E7%9B%B8%E5%85%B3-API-%E5%B0%8F%E7%BB%93"><span class="toc-number">3.8.0.1.</span> <span class="toc-text">JDBC 的相关 API 小结</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java8%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">4.</span> <span class="toc-text">Java8新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda"><span class="toc-number">4.1.</span> <span class="toc-text">Lambda</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">4.1.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-number">4.1.2.</span> <span class="toc-text">类型推断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lambda%E4%BD%BF%E7%94%A8"><span class="toc-number">4.1.3.</span> <span class="toc-text">Lambda使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lambda%E4%BD%BF%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="toc-number">4.1.4.</span> <span class="toc-text">Lambda使用举例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E4%B8%8E%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8"><span class="toc-number">4.2.</span> <span class="toc-text">方法引用与构造器引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8-Method-References"><span class="toc-number">4.2.1.</span> <span class="toc-text">方法引用(Method References)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="toc-number">4.2.2.</span> <span class="toc-text">方法引用举例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">引用类的静态方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">引用对象的实例方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.2.3.</span> <span class="toc-text">引用类的实例方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8"><span class="toc-number">4.2.3.</span> <span class="toc-text">构造器引用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%89%8D%E6%8F%90"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">使用前提</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stream%E6%B5%81"><span class="toc-number">4.3.</span> <span class="toc-text">&#x3D;&#x3D;Stream流&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E5%87%86%E5%A4%87"><span class="toc-number">4.3.1.</span> <span class="toc-text">前置准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">4.3.2.</span> <span class="toc-text">常用操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E6%B5%81"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">1 创建流</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">2 中间操作</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#filter"><span class="toc-number">4.3.2.2.1.</span> <span class="toc-text">filter</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#map"><span class="toc-number">4.3.2.2.2.</span> <span class="toc-text">map</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#distinct"><span class="toc-number">4.3.2.2.3.</span> <span class="toc-text">distinct</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#sorted"><span class="toc-number">4.3.2.2.4.</span> <span class="toc-text">sorted</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#limit"><span class="toc-number">4.3.2.2.5.</span> <span class="toc-text">limit</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#skip"><span class="toc-number">4.3.2.2.6.</span> <span class="toc-text">skip</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#flatMap"><span class="toc-number">4.3.2.2.7.</span> <span class="toc-text">flatMap</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E7%BB%88%E7%BB%93%E6%93%8D%E4%BD%9C"><span class="toc-number">4.3.2.3.</span> <span class="toc-text">3 终结操作</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#forEach"><span class="toc-number">4.3.2.3.1.</span> <span class="toc-text">forEach</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#count"><span class="toc-number">4.3.2.3.2.</span> <span class="toc-text">count</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#max-min"><span class="toc-number">4.3.2.3.3.</span> <span class="toc-text">max&amp;min</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#collect"><span class="toc-number">4.3.2.3.4.</span> <span class="toc-text">collect</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E4%B8%8E%E5%8C%B9%E9%85%8D"><span class="toc-number">4.3.2.3.5.</span> <span class="toc-text">查找与匹配</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#anyMatch"><span class="toc-number">4.3.2.3.6.</span> <span class="toc-text">anyMatch</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#allMatch"><span class="toc-number">4.3.2.3.7.</span> <span class="toc-text">allMatch</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#noneMatch"><span class="toc-number">4.3.2.3.8.</span> <span class="toc-text">noneMatch</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#findAny"><span class="toc-number">4.3.2.3.9.</span> <span class="toc-text">findAny</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#findFirst"><span class="toc-number">4.3.2.3.10.</span> <span class="toc-text">findFirst</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#reduce%E5%BD%92%E5%B9%B6"><span class="toc-number">4.3.2.3.11.</span> <span class="toc-text">reduce归并</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">4.3.3.</span> <span class="toc-text">注意</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFStream"><span class="toc-number">4.3.4.</span> <span class="toc-text">什么是Stream</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Stream%E7%9A%84%E6%93%8D%E4%BD%9C%E4%B8%89%E4%B8%AA%E6%AD%A5%E9%AA%A4"><span class="toc-number">4.3.5.</span> <span class="toc-text">Stream的操作三个步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-Stream%E6%96%B9%E5%BC%8F"><span class="toc-number">4.3.5.1.</span> <span class="toc-text">创建 Stream方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Stream%E7%9A%84%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C"><span class="toc-number">4.3.5.2.</span> <span class="toc-text">Stream的中间操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Stream-%E7%9A%84%E7%BB%88%E6%AD%A2%E6%93%8D%E4%BD%9C"><span class="toc-number">4.3.5.3.</span> <span class="toc-text">Stream 的终止操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Collectors"><span class="toc-number">4.3.5.4.</span> <span class="toc-text">Collectors</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96"><span class="toc-number">4.3.5.5.</span> <span class="toc-text">基本数据类型优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E6%B5%81%E4%BC%98%E5%8C%96"><span class="toc-number">4.3.5.6.</span> <span class="toc-text">并行流优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">4.3.5.7.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Optional%E7%B1%BB"><span class="toc-number">4.4.</span> <span class="toc-text">Optional类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">4.4.1.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Optional-%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">4.4.2.</span> <span class="toc-text">Optional 使用实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">4.4.3.</span> <span class="toc-text">使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.4.3.1.</span> <span class="toc-text">1 创建对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%AE%89%E5%85%A8%E6%B6%88%E8%B4%B9%E5%80%BC"><span class="toc-number">4.4.3.2.</span> <span class="toc-text">2 安全消费值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%AE%89%E5%85%A8%E8%8E%B7%E5%8F%96%E5%80%BC"><span class="toc-number">4.4.3.3.</span> <span class="toc-text">3 安全获取值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E8%BF%87%E6%BB%A4"><span class="toc-number">4.4.3.4.</span> <span class="toc-text">4 过滤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%88%A4%E6%96%AD"><span class="toc-number">4.4.3.5.</span> <span class="toc-text">5 判断</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8C%96"><span class="toc-number">4.4.3.6.</span> <span class="toc-text">6 数据转化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="toc-number">4.4.3.7.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F-Functional-%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.5.</span> <span class="toc-text">函数式(Functional)接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E5%86%85%E7%BD%AE%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.5.1.</span> <span class="toc-text">Java 内置四大核心函数式接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.5.2.</span> <span class="toc-text">其它接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-2"><span class="toc-number">4.5.3.</span> <span class="toc-text">常用方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AA%E7%9C%8B"><span class="toc-number">5.</span> <span class="toc-text">未看</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">5.0.1.</span> <span class="toc-text">正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.0.1.1.</span> <span class="toc-text">正则表达式底层实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E2%80%94%E5%85%83%E5%AD%97%E7%AC%A6"><span class="toc-number">5.0.1.2.</span> <span class="toc-text">正则表达式—元字符</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%83%E5%AD%97%E7%AC%A6%E5%A4%A7%E8%87%B4%E6%8C%89%E5%8A%9F%E8%83%BD%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="toc-number">5.0.1.2.1.</span> <span class="toc-text">元字符大致按功能分类：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%83%E5%AD%97%E7%AC%A6-Metacharacter-%E8%BD%AC%E4%B9%89%E5%8F%B7"><span class="toc-number">5.0.1.2.2.</span> <span class="toc-text">元字符( Metacharacter)-转义号 \\</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%83%E5%AD%97%E7%AC%A6-%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D%E7%AC%A6"><span class="toc-number">5.0.1.2.3.</span> <span class="toc-text">元字符-字符匹配符</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%83%E5%AD%97%E7%AC%A6-%E9%80%89%E6%8B%A9%E5%8C%B9%E9%85%8D%E7%AC%A6"><span class="toc-number">5.0.1.2.4.</span> <span class="toc-text">元字符-选择匹配符</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%83%E5%AD%97%E7%AC%A6-%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-number">5.0.1.2.5.</span> <span class="toc-text">元字符-限定符</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%83%E5%AD%97%E7%AC%A6-%E5%AE%9A%E4%BD%8D%E7%AC%A6"><span class="toc-number">5.0.1.2.6.</span> <span class="toc-text">元字符-定位符</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E7%BB%84"><span class="toc-number">5.0.1.2.7.</span> <span class="toc-text">分组</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">5.0.1.2.8.</span> <span class="toc-text">应用实例</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%89%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-number">5.0.1.3.</span> <span class="toc-text">正则表达式三个常用类</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Pattern"><span class="toc-number">5.0.1.3.1.</span> <span class="toc-text">Pattern</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Matcher"><span class="toc-number">5.0.1.3.2.</span> <span class="toc-text">Matcher</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E3%80%81%E6%8D%95%E8%8E%B7%E3%80%81%E5%8F%8D%E5%90%91%E5%BC%95%E7%94%A8"><span class="toc-number">5.0.1.4.</span> <span class="toc-text">分组、捕获、反向引用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%93%E5%B7%B4%E7%A8%8B%E5%BA%8F"><span class="toc-number">5.0.1.4.1.</span> <span class="toc-text">结巴程序</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#String%E7%B1%BB%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">5.0.1.5.</span> <span class="toc-text">String类中使用正则表达式</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By Ryang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><!--button#darkmode(type="button" title=_p('rightside.night_mode_title'))--><!--  i.fas.fa-adjust--><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"></svg><use id="modeicon" xlink:href="#icon-moon"></use></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();" rel="external nofollow noreferrer"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();" rel="external nofollow noreferrer"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();" rel="external nofollow noreferrer"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();" rel="external nofollow noreferrer"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();" rel="external nofollow noreferrer"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();" rel="external nofollow noreferrer"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();" rel="external nofollow noreferrer"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()" rel="external nofollow noreferrer"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()" rel="external nofollow noreferrer"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()" rel="external nofollow noreferrer"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()" rel="external nofollow noreferrer"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()" rel="external nofollow noreferrer"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()" rel="external nofollow noreferrer"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()" rel="external nofollow noreferrer"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()" rel="external nofollow noreferrer"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()" rel="external nofollow noreferrer"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();" rel="external nofollow noreferrer"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();" rel="external nofollow noreferrer"><i class="fa fa-book"></i><span>阅读模式</span></a><a class="rightMenu-item" href="/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();" rel="external nofollow noreferrer"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();" rel="external nofollow noreferrer"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();" rel="external nofollow noreferrer"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.19/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !true) {
  if (true) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'Adx946D8MgrhiaHCsXZfLp1L-gzGzoHsz',
      appKey: 'rvkGzSypPhV7c8TIk5TAM8iy',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: {"2020":"dc709fac0d361370bcf0d36d32adb97df7c95824.png","tv_白眼":"c1d59f439e379ee50eef488bcb5e5378e5044ea4.png","tv_doge":"6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png","tv_坏笑":"1f0b87f731a671079842116e0991c91c2c88645a.png","tv_难过":"87f46748d3f142ebc6586ff58860d0e2fc8263ba.png","tv_生气":"26702dcafdab5e8225b43ffd23c94ac1ff932654.png","tv_委屈":"d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png","tv_斜眼笑":"911f987aa8bc1bee12d52aafe62bc41ef4474e6c.png","tv_呆":"fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png","tv_发怒":"34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png","tv_惊吓":"0d15c7e2ee58e935adc6a7193ee042388adc22af.png","tv_呕吐":"9f996894a39e282ccf5e66856af49483f81870f3.png","tv_思考":"90cf159733e558137ed20aa04d09964436f618a1.png","tv_微笑":"70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png","tv_疑问":"0793d949b18d7be716078349c202c15ff166f314.png","tv_大哭":"23269aeb35f99daee28dda129676f6e9ea87934f.png","tv_鼓掌":"1d21793f96ef4e6f48b23e53e3b9e42da833a0f6.png","tv_抠鼻":"c666f55e88d471e51bbd9fab9bb308110824a6eb.png","tv_亲亲":"a8111ad55953ef5e3be3327ef94eb4a39d535d06.png","tv_调皮":"b9c41de8e82dd7a8515ae5e3cb63e898bf245186.png","tv_笑哭":"1abc628f6d4f4caf9d0e7800878f4697abbc8273.png","tv_晕":"5443c22b4d07fb1907ccc610c8e6db254f2461b7.png","tv_点赞":"f85c354995bd99e28fc76c869bfe42ba6438eff4.png","tv_害羞":"a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png","tv_睡着":"8b196675b53af58264f383c50ad0945048290b33.png","tv_色":"61822c7e9aae5da76475e7892534545336b23a6f.png","tv_吐血":"09dd16a7aa59b77baa1155d47484409624470c77.png","tv_无奈":"ea8ed89ee9878f2fece2dda0ea8a5dbfe21b5751.png","tv_再见":"180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png","tv_流汗":"cead1c351ab8d79e9f369605beb90148db0fbed3.png","tv_偷笑":"bb690d4107620f1c15cff29509db529a73aee261.png","tv_抓狂":"fe31c08edad661d63762b04e17b8d5ae3c71a757.png","tv_黑人问号":"45821a01f51bc867da9edbaa2e070410819a95b2.png","tv_困":"241ee304e44c0af029adceb294399391e4737ef2.png","tv_打脸":"56ab10b624063e966bfcb76ea5dc4794d87dfd47.png","tv_闭嘴":"c9e990da7f6e93975e25fd8b70e2e290aa4086ef.png","tv_鄙视":"6e72339f346a692a495b123174b49e4e8e781303.png","tv_腼腆":"89712c0d4af73e67f89e35cbc518420380a7f6f4.png","tv_馋":"fc7e829b845c43c623c8b490ee3602b7f0e76a31.png","tv_可爱":"9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png","tv_发财":"34db290afd2963723c6eb3c4560667db7253a21a.png","tv_生病":"8b0ec90e6b86771092a498c54f09fc94621c1900.png","tv_流鼻血":"c32d39db2737f89b904ca32700d140a9241b0767.png","tv_尴尬":"7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png","tv_大佬":"093c1e2c490161aca397afc45573c877cdead616.png","tv_流泪":"7e71cde7858f0cd50d74b0264aa26db612a8a167.png","tv_冷漠":"b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png","tv_皱眉":"72ccad6679fea0d14cce648b4d818e09b8ffea2d.png","tv_鬼脸":"0ffbbddf8a94d124ca2f54b360bbc04feb6bbfea.png","tv_调侃":"4bc022533ef31544ca0d72c12c808cf4a1cce3e3.png","tv_目瞪口呆":"0b8cb81a68de5d5365212c99375e7ace3e7891b7.png","2233娘_大笑":"16b8794be990cefa6caeba4d901b934a227ee3b8.png","2233娘_疑问":"0b41f509351958dbb63d472fec0132d1bd03bd14.png","2233娘_吃惊":"d1628c43d35b1530c0504a643ff80b6189fa0a43.png","2233娘_汗":"247cd9df8cdf84b18368c21e3b2dd374e84c0927.png","2233娘_大哭":"476a2a60f6e337b8c0697a592e0aa82781f6b33b.png","2233娘_困惑":"714eeb4eae0d0933b4ff08b7df788b1982f6b940.png","2233娘_耶":"d7178e258a0efc969b65ccc2b1322fb235f5dff4.png","2233娘_怒":"f31953119c51b9748016440ac0b632f779929b37.png","2233娘_卖萌":"ea893aa25355de95ab4f03c2dad3f0c58d0c159e.png","2233娘_委屈":"d9d0bf9d358af8d5761093ec66d4e3f60d963a63.png","2233娘_郁闷":"485203fe7100f2c8fc40b2800a18fe20b35f2f1a.png","2233娘_第一":"3754ee6e5985bd0bd7dfb668981f2a8733398ebd.png","2233娘_喝水":"695bf5429472049b52c1e0de586f8a2511195a23.png","2233娘_吐魂":"e999af499edf38a91ca68b1a9d2f97042c1d6734.png","2233娘_无言":"fdb5870f32cfaf7949e0f88a13f6feba4a48b719.png","热词系列_增加":"142409b595982b8210b2958f3d340f3b47942645.png","热词系列_泪目":"bba3703ab90b7d16fe9dbcb85ed949db687f8331.png","热词系列_保护":"55f8f6445ca7c3170cdfc5b16036abf639ce9b57.png","热词系列_害怕":"d77e2de26da143249f0c0ad7a608c27152c985bf.png","热词系列_爱了爱了":"2a165b555ba20391316366c664ed7891883dc5aa.png","热词系列_问号":"c1d1e76c12180adc8558f47006fe0e7ded4154bb.png","热词系列_吹爆":"b528220f9c37256ed6a37f05bf118e44b08b81e5.png","热词系列_三连":"21f15fe11b7a84d2f2121c16dec50a4e4556f865.png","热词系列_可以":"e08543c71202b36c590094417fcfbb80c3506cd8.png","热词系列_打卡":"a9cf77c78e1b9b40aa3ed4862402fba008ee2f51.png","热词系列_妙啊":"0e98299d7decf5eaffad854977946075c3e91cb8.png","热词系列_这次一定":"a01ca28923daa7cc896c42f27deb4914e20dd572.png","热词系列_AWSL":"c37f88cf799f9badf9d84b7671dc3dd98c0fc0c2.png","热词系列_递话筒":"98e6950e39fbb4dd1c576042063ca632074070ba.png","热词系列_你细品":"535e00658e7e47966f154d3a167fa2365ebc4321.png","热词系列_咕咕":"d8065c2e7ce48c929317a94553499a46fecc262a.png","热词系列_标准结局":"3de98174b510cf7dc5fd1bd08c5d881065e79137.png","热词系列_危":"5cc6c3357c4df544dd8de9d5c5c0cec97c7c9a56.png","热词系列_张三":"255a938f39cea625032b6650036b31aa26c50a3c.png","热词系列_害":"cbe798a194612958537c5282fcca7c3bcd2aa15c.png","热词系列_我裂开了":"29bd57ec4e8952880fea6c9e47aee924e91f10c4.png","热词系列_有内味了":"7ca61680a905b5b6e2e335c630e725b648b03b4d.png","热词系列_猛男必看":"c97064450528a0e45c7e7c365a15fbb13fd61d8c.png","热词系列_奥力给":"c9b8683827ec6c00fea5327c9bec14f581cef2aa.png","热词系列_我哭了":"9e0b3877d649aaf6538fbdd3f937e240a9d808e4.png","热词系列_高产":"9db817cba4a7f4a42398f3b2ec7c0a8e0c247c42.png","热词系列_我酸了":"a8cbf3f6b8cd9377eeb15b9172f3cd683b2e4650.png","热词系列_真香":"e68497c775feaac1c3b1a6cd63a50cfb11b767c4.png","热词系列_我全都要":"d424d1ad8d14c1c9b8367842bc68c658b9229bc1.png","热词系列_神仙UP":"a49e0d0db1e7d35a0f7411be13208951ab448f03.png","热词系列_你币有了":"84820c2b147a8ca02f3c4006b63f76c6313cbfa0.png","热词系列_不愧是你":"9ff2e356797c57ee3b1675ade0883d2d2247be9b.png","热词系列_锤":"35668cc12ae25b9545420e4a85bf21a0bfc03e5d.png","热词系列_秀":"50782fbf5d9b7f48f9467b5c53932981e321eedc.png","热词系列_爷关更":"faad40c56447f1f8abcb4045c17ce159d113d1fd.png","热词系列_有生之年":"f41fdafe2d0fbb8e8bc1598d2cf37e355560103a.png","热词系列_镇站之宝":"24e7a6a6e6383c987215fb905e3ee070aca259b5.png","热词系列_我太男了":"a523f3e4c63e4db1232365765d0ec452f83be97e.png","热词系列_完结撒花":"ea9db62ff5bca8e069cd70c4233353a802835422.png","热词系列_大师球":"f30089248dd137c568edabcb07cf67e0f6e98cf3.png","热词系列_知识盲区":"ccc94600b321a28116081e49ecedaa4ee8728312.png","热词系列_“狼火”":"33ccd3617bfa89e9d1498b13b7542b63f163e5de.png","加油武汉":"eb966aaa5b690d3f9308a9f936f5b5a72a7f956b.png","口罩":"3ad2f66b151496d2a5fb0a8ea75f32265d778dd3.png","鸡腿":"c7860392815d345fa69c4f00ef18d67dccfbd574.png","微笑":"685612eadc33f6bc233776c6241813385844f182.png","笑":"81edf17314cea3b48674312b4364df44d5c01f17.png","呲牙":"b5a5898491944a4268360f2e7a84623149672eb6.png","OK":"4683fd9ffc925fa6423110979d7dcac5eda297f4.png","星星眼":"63c9d1a31c0da745b61cdb35e0ecb28635675db2.png","哦呼":"362bded07ea5434886271d23fa25f5d85d8af06c.png","嫌弃":"de4c0783aaa60ec03de0a2b90858927bfad7154b.png","喜欢":"8a10a4d73a89f665feff3d46ca56e83dc68f9eb8.png","酸了":"92b1c8cbceea3ae0e8e32253ea414783e8ba7806.png","大哭":"2caafee2e5db4db72104650d87810cc2c123fc86.png","害羞":"9d2ec4e1fbd6cb1b4d12d2bbbdd124ccb83ddfda.png","无语":"44667b7d9349957e903b1b62cb91fb9b13720f04.png","疑惑":"b7840db4b1f9f4726b7cb23c0972720c1698d661.png","调皮":"8290b7308325e3179d2154327c85640af1528617.png","喜极而泣":"485a7e0c01c2d70707daae53bee4a9e2e31ef1ed.png","奸笑":"bb84906573472f0a84cebad1e9000eb6164a6f5a.png","偷笑":"6c49d226e76c42cd8002abc47b3112bc5a92f66a.png","大笑":"ca94ad1c7e6dac895eb5b33b7836b634c614d1c0.png","阴险":"ba8d5f8e7d136d59aab52c40fd3b8a43419eb03c.png","捂脸":"6921bb43f0c634870b92f4a8ad41dada94a5296d.png","囧":"12e41d357a9807cc80ef1e1ed258127fcc791424.png","呆":"33ad6000d9f9f168a0976bc60937786f239e5d8c.png","抠鼻":"cb89184c97e3f6d50acfd7961c313ce50360d70f.png","惊喜":"0afecaf3a3499479af946f29749e1a6c285b6f65.png","惊讶":"f8e9a59cad52ae1a19622805696a35f0a0d853f3.png","笑哭":"c3043ba94babf824dea03ce500d0e73763bf4f40.png","妙啊":"b4cb77159d58614a9b787b91b1cd22a81f383535.png","doge":"bba7c12aa51fed0199c241465560dfc2714c593e.png","滑稽":"d15121545a99ac46774f1f4465b895fe2d1411c3.png","吃瓜":"4191ce3c44c2b3df8fd97c33f85d3ab15f4f3c84.png","打call":"431432c43da3ee5aab5b0e4f8931953e649e9975.png","点赞":"1a67265993913f4c35d15a6028a30724e83e7d35.png","鼓掌":"895d1fc616b4b6c830cf96012880818c0e1de00d.png","尴尬":"cb321684ed5ce6eacdc2699092ab8fe7679e4fda.png","冷":"cb0ebbd0668640f07ebfc0e03f7a18a8cd00b4ed.png","灵魂出窍":"43d3db7d97343c01b47e22cfabeca84b4251f35a.png","委屈":"d2f26cbdd6c96960320af03f5514c5b524990840.png","傲娇":"010540d0f61220a0db4922e4a679a1d8eca94f4e.png","疼":"905fd9a99ec316e353b9bd4ecd49a5f0a301eabf.png","吓":"9c10c5ebc7bef27ec641b8a1877674e0c65fea5d.png","生病":"0f25ce04ae1d7baf98650986454c634f6612cb76.png","吐":"06946bfe71ac48a6078a0b662181bb5cad09decc.png","嘘声":"e64af664d20716e090f10411496998095f62f844.png","捂眼":"c5c6d6982e1e53e478daae554b239f2b227b172b.png","思考":"cfa9b7e89e4bfe04bbcd34ccb1b0df37f4fa905c.png","再见":"fc510306bae26c9aec7e287cdf201ded27b065b9.png","翻白眼":"eba54707c7168925b18f6f8b1f48d532fe08c2b1.png","哈欠":"888d877729cbec444ddbd1cf4c9af155a7a06086.png","奋斗":"bb2060c15dba7d3fd731c35079d1617f1afe3376.png","墨镜":"3a03aebfc06339d86a68c2d893303b46f4b85771.png","撇嘴":"531863568e5668c5ac181d395508a0eeb1f0cda4.png","难过":"a651db36701610aa70a781fa98c07c9789b11543.png","抓狂":"4c87afff88c22439c45b79e9d2035d21d5622eba.png","生气":"3195714219c4b582a4fb02033dd1519913d0246d.png","干杯":"8da12d5f55a2c7e9778dcc05b40571979fe208e6.png","爱心":"ed04066ea7124106d17ffcaf75600700e5442f5c.png","锦鲤":"643d6c19c8164ffd89e3e9cdf093cf5d773d979c.png","胜利":"b49fa9f4b1e7c3477918153b82c60b114d87347c.png","加油":"c7aaeacb21e107292d3bb053e5abde4a4459ed30.png","保佑":"fafe8d3de0dc139ebe995491d2dac458a865fb30.png","抱拳":"89516218158dbea18ab78e8873060bf95d33bbbe.png","响指":"1b5c53cf14336903e1d2ae3527ca380a1256a077.png","支持":"3c210366a5585706c09d4c686a9d942b39feeb50.png","拥抱":"41780a4254750cdaaccb20735730a36044e98ef3.png","怪我咯":"07cc6077f7f7d75b8d2c722dd9d9828a9fb9e46d.png","跪了":"f2b3aee7e521de7799d4e3aa379b01be032698ac.png","黑洞":"e90ec4c799010f25391179118ccd9f66b3b279ba.png","老鼠":"8e6fb491eb1bb0d5862e7ec8ccf9a3da12b6c155.png","福到了":"5de5373d354c373cf1617b6b836f3a8d53c5a655.png"},
      path: window.location.pathname,
      // master: '8a517fba7c520dddace09b926c0775c3',   //博主邮箱md5加密32位小写
      // tagMeta: ["博主", "小伙伴", "访客"],     //标识字段名
      // friends: [],  //小伙伴邮箱Md5
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdnjs.cloudflare.com/ajax/libs/valine/1.5.1/Valine.min.js').then(initValine)
}

if ('Livere' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="/js/sun_moon.js" async></script><script async src="/js/charts.js"></script><script async src="//at.alicdn.com/t/c/font_4146777_2b7ofuf0dew.js"></script><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/cat.js"></script><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async data-pjax src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.6.0/jquery.min.js" type="application/javascript"></script><script src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><script src="/js/newYear.js"></script><script async data-pjax src="/js/newYear.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script defer src="/js/lunar.js"></script><script defer src="/js/day.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><div id="fps"></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><div class="aplayer no-destroy" data-id="3136179094" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/gh/xiabo2/CDN@latest/fishes.js"></script><script defer src="https://cdn.jsdelivr.net/combine/npm/jquery@latest/dist/jquery.min.js,gh/weilining/jsdelivr/jquery/circlemagic/circlemagic.min.js,gh/weilining/jsdelivr@latest/jquery/circlemagic/butterflycirclemagic.js"></script><script src="https://cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/rightMenu.js"></script><script defer src="https://rmt.dogedoge.com/fetch/~/source/jsdelivr/npm/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="https://cdn.jsdelivr.net/gh/sirxemic/jquery.ripples/dist/jquery.ripples.js"></script><script defer data-pjax src="/js/ripples.js"></script><script src="/js/yinghua.js"></script><script src="/js/fengye.js"></script><script src="/js/emoji.js"></script><script defer src="https://cdn.jsdelivr.net/gh/graingert/wow@1.3.0/dist/wow.min.js"></script><script defer data-pjax src="/js/wow_init.js"></script><script async src="/js/title.js"></script><script src="/js/visitor.js"></script><script src="/js/random.js"></script><script src="https://npm.elemecdn.com/vue@2.6.11"></script><script async src="/js/fps.js"></script><script src="https://unpkg.com/swiper/swiper-bundle.min.js"></script><script src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/js/main.js"></script><script src="/js/random.js"></script><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async data-pjax src="/js/txmap.js"></script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script src="/js/weather.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/canvas-nest.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>function history_calendar_injector_config(){
                var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
                var item_html = '<div class="card-widget card-history"><div class="card-content"><div class="item-headline"><i class="fas fa-clock fa-spin"></i><span>那年今日</span></div><div id="history-baidu" style="height: 100px;overflow: hidden"><div class="history_swiper-container" id="history-container" style="width: 100%;height: 100%"><div class="swiper-wrapper" id="history_container_wrapper" style="height:20px"></div></div></div></div>';
                console.log('已挂载history_calendar')
                // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
            }if( document.getElementsByClassName('sticky_layout')[0] && (location.pathname ==='/'|| '/' ==='all')){

            history_calendar_injector_config()
        } </script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/js/main.js"></script><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://img2.baidu.com/it/u=3745692040,3005247474&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=500);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/AOP/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">AOP</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://img1.baidu.com/it/u=1341754829,1132645464&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=400&amp;h=400);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CPU飙升/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">CPU飙升</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://img0.baidu.com/it/u=2484535052,376615361&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=503&amp;h=500);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/版本控制工具/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">版本控制工具</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://img0.baidu.com/it/u=3312661278,78172823&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=554);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/缓存/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">缓存</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://img2.baidu.com/it/u=1036154364,590128025&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=502);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/中间件/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">中间件</a><span class="categoryBar-list-count">8</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://img2.baidu.com/it/u=3063786176,3698143304&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=500);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/框架/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">框架</a><span class="categoryBar-list-count">12</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://img1.baidu.com/it/u=2409457391,176527849&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=500);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/JVM/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">JVM</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://img0.baidu.com/it/u=3401319367,1066543955&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=500);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/FaceToFace/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">FaceToFace</a><span class="categoryBar-list-count">13</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://img1.baidu.com/it/u=1451814033,3212292494&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=500);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/MySQL/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">MySQL</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://img1.baidu.com/it/u=658968858,3133674973&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=500);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Java/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">Java</a><span class="categoryBar-list-count">4</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://img2.baidu.com/it/u=3712249756,1004016377&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=400&amp;h=400);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/分布式/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">分布式</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://img0.baidu.com/it/u=1096296806,2670130004&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=500);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/redis/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">redis</a><span class="categoryBar-list-count">10</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://img0.baidu.com/it/u=247517196,3882144171&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=667);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/fail/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">fail</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://img2.baidu.com/it/u=3488341470,3045652602&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=500);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/lambda/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">lambda</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://img0.baidu.com/it/u=707871741,1630757806&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=400&amp;h=400);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/算法/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">算法</a><span class="categoryBar-list-count">5</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/基础/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">基础</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/SpringCloud/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">SpringCloud</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/设计模式/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">设计模式</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/杂记/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">杂记</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Future/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">Future</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/7608.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt=""><img width="48" height="48" src="img/75.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-06-24</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/7608.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt="">算法的手记</a><div class="blog-slider__text">算法相关学习笔记</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/7608.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/2da05edf.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt=""><img width="48" height="48" src="img/48.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-07-03</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/2da05edf.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt="">JUC 学习合集</a><div class="blog-slider__text">JUC合集</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/2da05edf.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/4f46b5ba.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt=""><img width="48" height="48" src="img/55.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-07-03</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/4f46b5ba.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt="">Netty 基础学习</a><div class="blog-slider__text">Netty 初级</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/4f46b5ba.html&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = 'e2b04289e870b005374ee030148d64fd&s=rsv3';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '112.982279,28.19409';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '2');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 280px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/charts/'|| '/charts/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("https://gitcalendar.fomal.cc/api?YangruiY",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'YangruiY')
    }
  </script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>