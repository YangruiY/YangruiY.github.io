{"type":"getPostById","data":{"title":"秒杀问题分析总结","date":"2023-07-06T18:00:28.000Z","description":"Springboot 整合 redis、","categories":[{"name":"redis","_id":"cljrhcuxh001sna138ovz1a88"}],"tags":[{"name":"redis","_id":"cljrhcuxl003ana13etrvabbv"},{"name":"项目实践","_id":"cljrhcuxt005ina13eez12dhd"}],"content":"<meta name=\"referrer\" content=\"no-referrer\">\n<h2 id=\"业务角度\">业务角度</h2>\n<h3 id=\"首先从业务角度进行初步分析：\">首先从业务角度进行初步分析：</h3>\n<p>其中涉及的业务包括</p>\n<ul>\n<li>\n<p>准备阶段：</p>\n<p>​      商家准备库存、进行计时操作</p>\n</li>\n<li>\n<p>秒杀订单阶段：</p>\n<ul>\n<li>\n<p>判断时间</p>\n</li>\n<li>\n<p>时间到了之后，服务器接收到<code> 用户购买请求后</code>，首先校验用户身份和限购条件（如购买数量是否超出限制）</p>\n<ul>\n<li>如果校验通过，服务器会尝试从商品库存中扣减相应数量的商品</li>\n<li>如果库存充足，生成秒杀订单；如果库存不足，返回秒杀失败信息</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>创建订单阶段</p>\n<ul>\n<li>生成秒杀订单后，服务器将订单存储到数据库或内存中，标记为<code>未支付</code>状态；返回生成的订单ID给用户，提示秒杀成功。 用户可以继续支付订单。</li>\n</ul>\n</li>\n<li>\n<p>支付阶段</p>\n<ul>\n<li>用户在指定时间内进行支付，如果支付成功，更新订单状态为已支付；如果支付失败，返回支付失败信息。</li>\n</ul>\n</li>\n<li>\n<p>订单完成阶段</p>\n<ul>\n<li>进行后续的物流发货等操作</li>\n</ul>\n</li>\n</ul>\n<p>而我这里的实现的模块主要就是<code>准备 、 秒杀、创建订单阶段</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">    用户 --- 抢购/付款/退款 --&gt; 库存</span><br><span class=\"line\">    商家 --- 提供/修改/调整/核销 --&gt; 库存</span><br><span class=\"line\">    商家 -- 发货 --&gt; 用户</span><br></pre></td></tr></table></figure>\n<p>不难看出重点在于 <code>库存</code>上</p>\n<blockquote>\n<p>在实现具体业务之前  可以使用<code>CDN</code>对详情页进行 缓存就可以减少 临近抢购时间时，用户不断刷新页面造成的服务器的压力问题，加上CDN缓存之后，就不再对后台内存造成压力了</p>\n</blockquote>\n<p>CDN</p>\n<ul>\n<li>\n<p>按照  <strong><code>预热</code>&lt;指在 CDN 上提前将内容缓存到 CDN 节点上&gt;</strong> 的方式将<code>源站</code>的资源同步到 CDN 的节点中</p>\n</li>\n<li>\n<p>用户首次请求资源可以直接从 CDN 节点中获取，<code>无需回源</code>&lt;回源说的就是:   当 <code>CDN 节点</code>上没有用户请求的资源或该资源的<code>缓存已经过期</code>时，CDN 节点需要从<code>原始服务器</code>获取最新的资源内容 &gt;</p>\n</li>\n<li>\n<p>随后资源进行更新的时候就会进行进行 <strong>刷新</strong> ，删除 CDN 节点上<code>缓存的旧资源</code>，并强制 CDN 节点回源站获取最新资源</p>\n</li>\n<li>\n<p>通过<code>全局负载均衡 GSLB</code> 找到最适合的<code>CDN </code></p>\n<p>具体流程</p>\n<ul>\n<li>浏览器向 DNS 服务器发送域名请求；</li>\n<li>DNS 服务器向根据 <code>CNAME</code>( Canonical Name ) 别名记录向 <code>GSLB</code> 发送请求；</li>\n<li>GSLB 返回性能最好（通常距离请求地址最近）的 CDN 节点（边缘服务器，真正缓存内容的地方）的地址给浏览器；</li>\n<li>浏览器直接访问<code>指定的 CDN 节点</code></li>\n</ul>\n</li>\n<li>\n<p>为了 防止资源被盗刷，可以进行</p>\n<ul>\n<li>先设置 <strong><code>Referer 防盗链</code></strong>，具体来说就是根据 HTTP 请求的头信息里面的 <code>Referer</code> 字段对请求进行限制</li>\n<li>为了防止绕开<code>防盗链</code>，需要配合其他机制来确保静态资源被盗用\n<ul>\n<li><strong>时间戳防盗链</strong>   URL 通常会有两个参数一个是签名字符串，一个是过期时间</li>\n<li>或者<code> IP 黑白名单配置</code>、<code>IP 访问限频配置</code>等机制来防盗刷</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"技术角度\">技术角度</h2>\n<h3 id=\"非高并发时的秒杀版本\">非高并发时的秒杀版本</h3>\n<p>主要的业务逻辑就是：</p>\n<ol>\n<li>\n<p>数据预处理</p>\n<p>将优惠券以及秒杀订单的信息都进行记录随后 <code>存到 redis</code>中  <code> stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());</code></p>\n</li>\n<li>\n<p>下单操作</p>\n<ol>\n<li>\n<p>查询获取优惠券  <code>SeckillVoucher voucher = seckillVoucherService.getById(voucherId);</code></p>\n</li>\n<li>\n<p>首先判断是否 属于 秒杀时间内</p>\n<p><code>if (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;&#125;</code></p>\n<p><code> if (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;&#125;</code></p>\n</li>\n<li>\n<p>其次判断是否还有库存 <code>if (voucher.getStock() &lt; 1) &#123;&#125;</code></p>\n</li>\n<li>\n<p>只要上述两个条件有一个条件不满足就进行直接退出，只有当两个条件都满足的时候才会进行<code>创建订单+扣减库存</code></p>\n</li>\n<li>\n<p>扣减库存的逻辑 <code>boolean success = seckillVoucherService.update() .setSql(&quot;stock= stock -1&quot;) .eq(&quot;voucher_id&quot;, voucherId).update();</code></p>\n</li>\n<li>\n<p>创建订单的逻辑   ：   创建<code>订单  用户 商品 三者的id</code>,保存到  订单表中</p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"高并发时秒杀版本\">高并发时秒杀版本</h3>\n<h4 id=\"单机版本-并发时会产生的问题以及解决的逻辑\">单机版本  并发时会产生的问题以及解决的逻辑</h4>\n<ol>\n<li>\n<p>超卖少卖的问题</p>\n<p>此处使用的<code>乐观锁机制</code>；核心逻辑就是  使用<code>库存</code>代替一般使用的<code>版本号</code>进行，稍有不同的就是 此处要是使用<code>库存是否一致</code>的话就会造成每次高并发就只有一个线程才能成功的获取锁,所以优化的写法就是判断是否<code>库存&gt;0</code></p>\n<p>所以具体的<code>扣库存</code>的逻辑优化为：   <code>boolean success = seckillVoucherService.update().setSql(&quot;stock= stock -1&quot;) .eq(&quot;voucher_id&quot;, voucherId).update().gt(&quot;stock&quot;,0); //where id = ? and stock &gt; 0</code></p>\n</li>\n<li>\n<p>一人一单无法保证</p>\n<ol>\n<li>\n<p>添加一层不能重复下订单的逻辑： 根据<code>优惠券id</code>和<code>用户id</code>查询是否已经下过这个订单，会返回一个 int 值，根据这个结果进行<code>下订单</code>还是<code>直接返回</code></p>\n<p>在扣减库存之前进行一人一单的逻辑判断：<code>int count = query().eq(&quot;user_id&quot;, userId).eq(&quot;voucher_id&quot;, voucherId).count();</code></p>\n</li>\n<li>\n<p>高并发的时候还是有问题的，和前面一样，此时所有线程在 查询数据库的时候返回的结果都是 不存在订单的，所以我们还是需要加锁，但是<code>乐观锁</code>比较适合<code>更新</code>数据，而现在是<code>插入数据</code>，所以我们需要使用<code>悲观锁</code>进行操作</p>\n<p>封装   <code>判断是否存在订单，进行扣减库存，创建订单 </code>  为一个方法  <code>createVoucherOrder (Long voucherId) </code></p>\n<p>并对该<code>方法</code>进行加锁<code>synchronized</code>    <code>@Transactional   public synchronized Result createVoucherOrder(Long voucherId) &#123;&#125;</code></p>\n</li>\n<li>\n<p>优化：</p>\n<p>为了提升性能，不让每一个线程进入此封装的方法都被锁住，所以要减少锁的粒度   <code>synchronized(userId.toString().intern())&#123;&#125;</code></p>\n<p>原因：<code>intern()</code>这个方法是从<code>常量池</code>中拿到数据，如果我们<code>直接使用userId.toString() </code>他拿到的对象<code>实际上是不同的对象</code>，是<code>new</code>出来的对象，我们使用锁必须保证<code>所有线程的锁是同一把</code>，所以我们需要使用<code>intern()</code>方法</p>\n</li>\n</ol>\n</li>\n<li>\n<p>当前方法被<code>spring的事务控制</code>，如果在<code>方法内部加锁</code>，可能会导致当前方法<code>事务还没有提交</code>，但是<code>锁已经释放</code>也会导致问题，所以我们选择将<code>当前方法</code>整体包裹起来，确保事务不会出现问题，而且  <code>synchronized</code>关键字只能用于同步代码块或者同步方法，并不能直接用于事务的控制。</p>\n<ol>\n<li>\n<p>仍旧使用封装过的<code>判断是否存在订单，进行扣减库存，创建订单</code>   为 <code> createVoucherOrder(voucherId)</code>   并在锁<code>userid</code>代码块内部调用这个方法</p>\n<p>只是在<code>主函数</code>调用的时候要<code>加锁</code>才能执行这个<code>封装</code>代码</p>\n</li>\n<li>\n<p>事务想要生效，还得利用<code>代理(AspectJ)</code>来生效，所以这个地方，我们需要获得原始的事务对象， 来操作事务</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Long</span> <span class=\"variable\">userId</span> <span class=\"operator\">=</span> UserHolder.getUser().getId();</span><br><span class=\"line\"><span class=\"keyword\">synchronized</span> (userId.tostring().intern())&#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取代理对象（事务）</span></span><br><span class=\"line\">    <span class=\"type\">IVoucherorderService</span> <span class=\"variable\">proxy</span> <span class=\"operator\">=</span> (IVoucherorderService)AopContext.currentProxy();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> proxy.createVoucherorder(voucherId);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ol>\n<blockquote>\n<p>问题的引入：</p>\n<ul>\n<li><code>加锁</code>可以解决在<code>单机</code>情况下的<code>一人一单</code>安全问题，但是在<code>集群</code>模式下就<code>不行</code>了</li>\n</ul>\n<p>具体的分析：</p>\n<ul>\n<li>当部署了多个<code>tomcat</code>，每个<code>tomcat</code>都有一个属于自己的<code>jvm</code>，</li>\n<li>假设在<code>服务器A</code>的<code>tomcat</code>内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的</li>\n<li>但是如果现在是<code>服务器B</code>的<code>tomcat</code>内部，又有两个线程线程3和线程4，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，</li>\n<li>所以线程3和线程4可以<code>实现互斥</code>，但是却无法和线程1和线程2实现互斥，这就是 <code>集群环境下</code>，<code>synchronized</code>锁失效的原因，在这种情况下，我们就需要使用<code>分布式锁</code>来解决这个问题。</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306201521824.png\" alt=\"image-20230620152116636\" style=\"zoom:33%;\">\n</blockquote>\n<h4 id=\"集群版本-分布式锁进行解决\">集群版本 分布式锁进行解决</h4>\n<h5 id=\"分布式锁：\">分布式锁：</h5>\n<ul>\n<li>满足分布式系统或集群模式下多进程<code>可见并且互斥的锁</code>。</li>\n</ul>\n<h5 id=\"核心思想：\">核心思想：</h5>\n<ul>\n<li>就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能<code>锁住线程</code>，不让线程进行，让程序<code>串行</code>执行</li>\n</ul>\n<h5 id=\"font-color-blue-分布式锁的三种实现方式：-font\"><font color=\"blue\">分布式锁的三种实现方式：</font></h5>\n<ul>\n<li><code>Mysql</code>：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见</li>\n<li><code>Redis</code>：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用setnx这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁</li>\n<li><code>Zookeeper</code>：zookeeper也是企业级开发中较好的一个实现分布式锁的方案</li>\n</ul>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202307051812940.png\" alt=\"image-20230527105802579\" style=\"zoom:33%;\">\n<h5 id=\"分布式锁需要满足的条件\">分布式锁需要满足的条件</h5>\n<p><code>可见性</code>：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能<code>感知到变化</code>的意思</p>\n<p><code>独占性(互斥)： </code>：互斥是分布式锁的<code>最基本</code>的条件，指的是任何时刻有且只能有一个线程持有，使得程序串行执行</p>\n<p><code>高可用</code>：若为redis集群环境下，不能因为某一个节点挂了而出现获取锁和释放锁失败的情况 ，高并发请求下，性能依旧好使</p>\n<p><code>高性能</code>：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就<code>较高的加锁性能和释放锁性能</code></p>\n<p><code>安全性</code>：安全也是程序中必不可少的一环， 不能<code>unlock</code>别人的锁，只能自己加锁自己释放</p>\n<p><code>防死锁</code>：杜绝死锁，必须有超时控制机制或者撤销操作，有个兜底终止跳出方案</p>\n<p><code>重入性</code>:    同一个节点的同一个线程如果获得锁之后，它也可以再次获取这个锁</p>\n<h5 id=\"实现思路\">实现思路</h5>\n<ul>\n<li>获取锁——要求： <code>互斥(每次只有一个线程获取锁执行逻辑代码)</code>  与  <code>非阻塞(只会尝试一次获取锁)</code></li>\n<li>释放锁——实现的角度： <code> 手动释放</code>  OR    <code>自动超时释放(获取锁时添加一个超时时间)</code></li>\n</ul>\n<p><strong>流程：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\"></span><br><span class=\"line\">subgraph 线程1</span><br><span class=\"line\">    H(redis:setnx   抢锁 )  </span><br><span class=\"line\">    G(商品服务)  --&gt;H --&gt; B&#123;结果是1吗?&#125; -- 是,表示抢锁成功 --&gt; B1(获得锁) --&gt; C(执行业务) --&gt;D(删除锁) --&gt;E(退出锁逻辑)</span><br><span class=\"line\">    G1(商品服务) --&gt;H </span><br><span class=\"line\">    G2(商品服务) --&gt;H</span><br><span class=\"line\">B  -- 否,表示抢锁失败 --&gt; F(没有获得锁) </span><br><span class=\"line\">F  -- 等待一定时间之后重试 --&gt; H</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<h5 id=\"实现过程\">实现过程</h5>\n<ol>\n<li>\n<p>利用<code>setnx</code>方法进行加锁，同时<code>增加过期时间</code>，防止死锁，此方法可以保证<code>加锁和增加</code>过期时间具有<code>原子性</code></p>\n<p><code>【其中[SimpleRedisLock implements ILock&#123;tryLock()&#123;.见下..&#125;unlock()&#123;..见下.&#125; &#125;]】</code></p>\n<p><strong>加锁：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String KEY_PREFIX=<span class=\"string\">&quot;lock:&quot;</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryLock</span><span class=\"params\">(<span class=\"type\">long</span> timeoutSec)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//  获取锁</span></span><br><span class=\"line\">    <span class=\"type\">Boolean</span> <span class=\"variable\">success</span> <span class=\"operator\">=</span> stringRedisTemplate.opsForValue()</span><br><span class=\"line\">            .setIfAbsent(KEY_PREFIX + name, threadId + <span class=\"string\">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Boolean.TRUE.equals(success);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>解锁：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">unlock</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//通过del删除锁</span></span><br><span class=\"line\">    stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>此时不在使用 <code>synchronized</code>的锁，而是使用<code>自己自定义的锁(simpleRedis)</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Long</span> <span class=\"variable\">userId</span> <span class=\"operator\">=</span> UserHolder.getUser().getId();</span><br><span class=\"line\"><span class=\"keyword\">synchronized</span> (userId.tostring().intern())&#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取代理对象（事务）</span></span><br><span class=\"line\">    <span class=\"type\">IVoucherorderService</span> <span class=\"variable\">proxy</span> <span class=\"operator\">=</span> (IVoucherorderService)AopContext.currentProxy();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> proxy.createVoucherorder(voucherId);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">——————————————————————————————————变—————————为—————————————————————————————————————————</span><br><span class=\"line\"><span class=\"type\">Long</span> <span class=\"variable\">userId</span> <span class=\"operator\">=</span> UserHolder.getUser().getId();</span><br><span class=\"line\"><span class=\"comment\">//创建锁对象(新增代码)</span></span><br><span class=\"line\"><span class=\"type\">SimpleRedisLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SimpleRedisLock</span>(<span class=\"string\">&quot;order:&quot;</span> + userId, stringRedisTemplate);</span><br><span class=\"line\"><span class=\"comment\">//获取锁对象</span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"variable\">isLock</span> <span class=\"operator\">=</span> lock.tryLock(<span class=\"number\">1200</span>);</span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//获取代理对象(事务)</span></span><br><span class=\"line\">  <span class=\"type\">IVoucherOrderService</span> <span class=\"variable\">proxy</span> <span class=\"operator\">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//释放锁</span></span><br><span class=\"line\">  lock.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>解决防误删操作</p>\n<p><font color=\"red\">基本情况的误删原因分析:</font></p>\n<p><code>持有锁的线程</code>在锁的内部<code>出现了阻塞</code>，导致他的锁<code>自动释放</code>，这时其他线程再来尝试获得锁，是可以拿到了这把锁的，随后<code>其他线程中的一个</code>在持有锁执行过程中，<code>先前的线程</code>反应过来，会继续执行，而<code>先前的线程</code>在执行过程中，走到了<code>删除锁逻辑</code>，此时就会把本应该属于<code>当前线程</code>的锁进行删除，这就是<code>误删别人锁的情况说明</code></p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202307052114510.png\" alt=\"image-20230705211442490\" style=\"zoom:33%;\">\n</li>\n</ol>\n<p><font color=\"red\">极端情况的误删原因分析:</font></p>\n<p><code>线程1</code>现在持有锁之后，在执行业务逻辑过程中，他<code>正准备删除锁</code>，而且已经走到了条件判断的过程中，<code>比如</code>他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是<code>此时他的锁到期了</code>，那么此时<code>线程2进来</code>，但是线程1他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，<code>相当于条件判断并没有起到作用</code>，这就是删锁时的原子性问题，之所以有这个问题，是因为线程1的<code>拿锁，比锁，删锁</code>，<code>实际上并不是原子性的</code>，我们要防止刚才的情况发生</p>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202307052130088.png\" alt></p>\n<p><font color=\"red\">基本情况的解决方案：</font></p>\n<p>在每个线程释放锁的时候，去<code>判断一下当前这把锁是否属于自己</code>，如果属于自己，则不进行锁的删除  ————使用<code>uuid</code></p>\n<p>假设此时 <code>线程1</code>卡顿，锁自动释放，<code>线程2</code>进入到锁的内部执行逻辑，此时<code>线程1</code>反应过来，然后删除锁，但是<code>线程1</code>一看当前这把锁不是属于自己，于是不进行删除锁逻辑，当<code>线程2</code>走到删除锁逻辑时，如果<code>没有到达自动释放锁的时间点</code>，则判断当前这把锁是<code>属于自己</code>的，于是<code>删除</code>这把锁</p>\n<p><font color=\"red\">极端情况的解决方案：</font></p>\n<p>使用<code>lua脚本</code> 编写多条 <code>redis</code> 命令，从而<code>确保原子性</code></p>\n<p><font color=\"red\">基本情况的具体做法</font></p>\n<ol>\n<li>\n<p>在<code>获取锁的时候</code>存入<code>线程标识</code>,再之后  要<code>释放锁</code>时先<code>获取</code>锁中的<code>线程标示</code>，<code>判断是否</code>与当前线程标示<code>一致</code>,<code>一致</code>才会进行<code>释放</code>，否则就<code>不释放</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//加锁</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">ID_PREFIX</span> <span class=\"operator\">=</span> UUID.randomUUID().toString(<span class=\"literal\">true</span>) + <span class=\"string\">&quot;-&quot;</span>;</span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryLock</span><span class=\"params\">(<span class=\"type\">long</span> timeoutSec)</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">// 获取线程标示</span></span><br><span class=\"line\">   <span class=\"type\">String</span> <span class=\"variable\">threadId</span> <span class=\"operator\">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class=\"line\">   <span class=\"comment\">// 获取锁</span></span><br><span class=\"line\">   <span class=\"type\">Boolean</span> <span class=\"variable\">success</span> <span class=\"operator\">=</span> stringRedisTemplate.opsForValue()</span><br><span class=\"line\">                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);</span><br><span class=\"line\">   <span class=\"keyword\">return</span> Boolean.TRUE.equals(success);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//解锁</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">unlock</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取线程标示</span></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">threadId</span> <span class=\"operator\">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class=\"line\">    <span class=\"comment\">// 获取锁中的标示</span></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class=\"line\">    <span class=\"comment\">// 判断标示是否一致</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span>(threadId.equals(id)) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 释放锁</span></span><br><span class=\"line\">      stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><font color=\"red\">极端情况的具体做法</font></p>\n<ol>\n<li>\n<p><code>lua</code> 脚本</p>\n<p>简单回顾<code>释放锁</code>的逻辑：</p>\n<p>​    1、获取锁中的<code>线程标示</code></p>\n<p>​\t2、判断是否与指定的<code>标示（当前线程标示）一致</code></p>\n<p>​\t3、如果<code>一致</code>则释放锁（删除）</p>\n<p>​\t4、如果<code>不一致</code>则什么都不做</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--  拿到锁   比较锁  删除锁的lua 脚本</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示</span></span><br><span class=\"line\"><span class=\"comment\">-- 获取锁中的标示，判断是否与当前线程标识是 一致 的</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (redis.call(<span class=\"string\">&#x27;GET&#x27;</span>, KEYS[<span class=\"number\">1</span>]) == ARGV[<span class=\"number\">1</span>]) <span class=\"keyword\">then</span></span><br><span class=\"line\">  <span class=\"comment\">-- 一致，则删除锁</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> redis.call(<span class=\"string\">&#x27;DEL&#x27;</span>, KEYS[<span class=\"number\">1</span>])</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"comment\">-- 不一致，则直接返回</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>Java 调用</code>上述脚本</p>\n<p>在<code>RedisTemplate</code>中，可以利用<code>execute方法</code>去<code>执行lua脚本</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//释放锁的最终代码</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        UNLOCK_SCRIPT = <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;();</span><br><span class=\"line\">        UNLOCK_SCRIPT.setLocation(<span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathResource</span>(<span class=\"string\">&quot;unlock.lua&quot;</span>));</span><br><span class=\"line\">        UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">unlock</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用lua脚本</span></span><br><span class=\"line\">    stringRedisTemplate.execute(</span><br><span class=\"line\">            UNLOCK_SCRIPT,</span><br><span class=\"line\">            Collections.singletonList(KEY_PREFIX + name),</span><br><span class=\"line\">            ID_PREFIX + Thread.currentThread().getId());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>总结：</p>\n<p><code>set   </code>加锁</p>\n<p>优点</p>\n<ul>\n<li>利用<code>set nx</code>满足<code>互斥性</code></li>\n<li>利用<code>set ex</code>保证故障时锁依然能释放，<code>避免死锁</code>，提高安全性</li>\n<li>利用<code>Redis集群</code>保证<code>高可用和高并发</code>特性</li>\n</ul>\n<p>缺点</p>\n<ul>\n<li>重入问题：获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁</li>\n<li>不可重试：目前的分布式<code>只能尝试一次</code>，我们认为<code>合理的情况是</code>：当线程在<code>获得锁失败后</code>，他应该<code>能再次尝试获得锁</code></li>\n<li>超时释放：如果卡顿的时间超长，线程可能没有锁住，有安全隐患</li>\n<li>主从一致性：如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</li>\n<li>主要是   不满足  <code>可重入性  (可以使用 hset) </code> 和 <code>自动续费两大功能</code></li>\n</ul>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202307052203727.png\" alt></p>\n<h2 id=\"官方提供的满足所有的特性的锁\">官方提供的满足所有的特性的锁</h2>\n<h3 id=\"最优解：——redission\">最优解：——redission</h3>\n<h4 id=\"是什么\">是什么</h4>\n<p>是一个在redis的基础上实现 java  <code>驻内存数据网格</code>,提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中包含了各种分布式锁的实现。</p>\n<h4 id=\"提供的功能\">提供的功能</h4>\n<ol>\n<li>可重入锁(<code>Reentrant Lock</code>)</li>\n<li>公平锁(<code>Fair Lock</code>)</li>\n<li>联锁(<code>MultiLock</code>)</li>\n<li>红锁(<code>RedLock</code>)</li>\n<li>读写锁(<code>ReadWriteLock</code>)</li>\n<li>信号量(<code>Semaphore</code>)</li>\n<li>可过期性信号量(<code>PermitExpirableSemaphore</code>)</li>\n<li>闭锁(<code>CountDownLatch</code>)</li>\n</ol>\n<h4 id=\"使用\">使用</h4>\n<ol>\n<li>\n<p>引入<code>redission</code>依赖</p>\n</li>\n<li>\n<p>配置<code>redission</code>的配置类    <code>连接   redis   并创建 RedissonClient对象</code></p>\n</li>\n<li>\n<p>使用Redission的分布式锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Long</span> <span class=\"variable\">userId</span> <span class=\"operator\">=</span> UserHolder.getUser().getId();</span><br><span class=\"line\"><span class=\"comment\">//创建锁对象(新增代码)</span></span><br><span class=\"line\"><span class=\"type\">SimpleRedisLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SimpleRedisLock</span>(<span class=\"string\">&quot;order:&quot;</span> + userId, stringRedisTemplate);</span><br><span class=\"line\"><span class=\"comment\">//获取锁对象</span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"variable\">isLock</span> <span class=\"operator\">=</span> lock.tryLock(<span class=\"number\">1200</span>);</span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//获取代理对象(事务)</span></span><br><span class=\"line\">  <span class=\"type\">IVoucherOrderService</span> <span class=\"variable\">proxy</span> <span class=\"operator\">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//释放锁</span></span><br><span class=\"line\">  lock.unlock();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">——————————————————————————————————变—————————为—————————————————————————————————————————</span><br><span class=\"line\"><span class=\"type\">Long</span> <span class=\"variable\">userId</span> <span class=\"operator\">=</span> UserHolder.getUser().getId();</span><br><span class=\"line\"><span class=\"comment\">//1. 获取锁(可重入)，指定锁的名称</span></span><br><span class=\"line\"><span class=\"type\">RLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> redissonClient.getLock(<span class=\"string\">&quot;lock:order:&quot;</span> + userId);</span><br><span class=\"line\"><span class=\"comment\">//2. 尝试获取锁，tryLock() 函数后面可以增加参数：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位</span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"variable\">isLock</span> <span class=\"operator\">=</span> lock.tryLock();</span><br><span class=\"line\">       </span><br><span class=\"line\"><span class=\"comment\">//加锁失败</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!isLock) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Result.fail(<span class=\"string\">&quot;不允许重复下单&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">//获取代理对象(事务)</span></span><br><span class=\"line\">   <span class=\"type\">IVoucherOrderService</span> <span class=\"variable\">proxy</span> <span class=\"operator\">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class=\"line\">   <span class=\"keyword\">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">//释放锁</span></span><br><span class=\"line\">   lock.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"原理\">原理</h4>\n<h5 id=\"1-可重入的原理\">1. 可重入的原理</h5>\n<ul>\n<li>\n<p><code>LOCK </code>锁 的 底层的一个<code>voaltile</code> 修饰 的变量   <code>state</code>   ,其是可以用来记录重入的状态的，</p>\n<ul>\n<li><code>比如</code>当前没有人持有这把锁，那么<code>state=0</code>，假如有人持有这把锁，那么<code>state=1</code>，如果持有这把锁的人<code>再次持有这把锁</code>，那么state就会<code>+1</code> 。如果是对于<code>synchronized</code>而言，他在c语言代码中会有一个<code>count</code>，原理和<code>state</code>类似，也是重入一次就<code>+1</code>，释放一次就<code>-1 </code>，直到<code>减少成0 </code>时，表示当前这把锁没有被人持有。</li>\n</ul>\n</li>\n<li>\n<p>redission 提供的多种分布式锁中，也是<code>支持可重入的</code></p>\n<p>其采用<code>hash结构</code>用来<code>存储锁</code>，</p>\n<p>hash 的结构就是：k-v(V 又是一个k-v) 其中外面的<code>大key</code>表这把锁<code>是否存在</code>，里面的<code>小key</code>表示<code>当前锁被哪个线程持有</code>，<code>小value</code>表示<code>已经重入的次数</code>；自此每次重入锁的时候就会进行+1 ，退出的时候就会-1,直到最后 <code>小value</code>为 0  的时候才可以删除锁</p>\n<p>基本思想就是这样，不过  redission  已经写好这个<code>lua</code>脚本了</p>\n</li>\n<li>\n<p><code>lua脚本</code>中的<code>lua表达式</code>    这个地方一共有3个参数</p>\n<p><strong>key = KEYS[1] ： 锁的大key</strong></p>\n<p><strong>threadId = ARGV[1]：  线程唯一标识   小key</strong></p>\n<p>**releaseTime = ARGV[2]：  锁的自动释放时间  **</p>\n</li>\n<li>\n<p><code>获取锁的脚本的逻辑</code>：</p>\n<ol>\n<li>\n<p><code>if(redis.call('exists',key)==0)then</code>: 判断锁是否存在</p>\n</li>\n<li>\n<p>如果<code>==0</code>，就表示当前这把锁<code>不存在,就获取锁</code>,并将值设为<code>1</code>，<code>redis.call('hset', KEYS[1], ARGV[1], '1')</code>;</p>\n</li>\n<li>\n<p>设置锁的有效期<code>redis.call('expire',key,releaseTime);</code></p>\n</li>\n<li>\n<p>最后返回 <code>1</code></p>\n</li>\n<li>\n<p>否则，就表示当前这把锁<code>已经存在</code>， 判断<code>threadId</code>是否是自己<code>if(redis.call('hexists',key,threadId)==1 then</code></p>\n</li>\n<li>\n<p>如果<code>==1</code>,表示 获取的锁是自己的，就将锁的<code>重入次数+1</code>   <code>redis.call('hincrby',key,threadId,'1);</code></p>\n</li>\n<li>\n<p>随后 设置有效期<code>redis.call('expire',key,releaseTime);</code></p>\n</li>\n<li>\n<p>最后也  <code>return     1</code></p>\n</li>\n<li>\n<p>否则 ，获取的锁就不是自己的,获取锁失败  <code>return  0</code></p>\n</li>\n</ol>\n</li>\n<li>\n<p>释放锁的脚本逻辑</p>\n<ol>\n<li>判断当前锁是否被自己做持有，如果<code>==0</code> 表示<code>不是</code>自己的，那么锁就已经被释放掉了，返回<u><code>null</code></u> <code>if(redis.call('HEXISTS',key,threadId)== 0)     then   return nil;</code></li>\n<li>反之，如果是自己的锁，则重入次数<code>-1 </code>    <code>local count = redis.call('HINCRBY',key,threadId,-1);</code></li>\n<li>最后 判断 <code>重入次数</code>是否<code>==0</code>  ,<code>大于0</code>说明不能释放锁，重置有效期然后返回<br>\n<code>if (count &gt; 0)then   redis.call(EXPIRE',key,releaseTime);  return nil;</code></li>\n<li><code>等于0</code>说明<code>可以释放锁</code>，<code>直接删除</code>，并通知其他线程  【publish】<br>\n<code>redis.call('DEL',key);   return nil;</code></li>\n</ol>\n</li>\n</ul>\n<p>总结：</p>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202307060001727.png\" style=\"zoom:53%;\">\n<h5 id=\"2-可重试的原理\">2. 可重试的原理</h5>\n<p>​       可以看到，在源码中，会去判断当前这个方法的返回值是否为<code>null</code>，如果<code>是null</code>，则对应则<code>前两个if</code>对应的条件&lt;<code>都代表获取锁成功</code>，要么是重入成功，要么是首次获取锁成功&gt;，退出抢锁逻辑；如果返回的不是null，就是说返回的是 <code>pttl</code>，返回的就是<code>当前锁的剩余有效期(ms)[time]</code>；</p>\n<p><font color=\"red\">如果<code>剩余有效期&lt; =0</code>  就会直接返回 <code>false</code>;否则当前线程就会订阅【subscribe】<code>其他线程释放锁的信号</code> ,并会尝试  等待  <code>锁的最大剩余时间</code>，</font></p>\n<p><font color=\"red\">要是<code>等待最大剩余时间内还没有</code>收到订阅的信号，就取消订阅，返回<code>false</code>,获取锁失败；否则其他线程释放锁成功，该线程进行重试</font></p>\n<p><font color=\"red\">重试的时候进行判断 <code>time</code>是否是 <code>&lt;= 0</code>,没时间了，return  false；要是此时的<code>剩余有效期 &gt; 0</code> ，就会进行重试，进到<code>while(true)</code>的自旋抢锁的逻辑，并获取充实的时间<code>ttl</code>，要是<code>ttl == 0 </code>  说明获取锁成功，否还是失败，此时<code>time 还是&gt; 0</code>  ，会将<code> ttl</code>  和  <code>剩余有限期 </code>进行对比  ，取两者小的进行<code>尝试获取锁</code>， 只要 <code>time &gt;0 </code>就会不断地进行循环while，直到 <code>time &lt;= 0 才会返回false，获取锁失败。 </code></font></p>\n<p>特点就是使用了  <code>消息的发布订阅 和 信号量的机制</code>，并不是盲目的无休止的等待。只有在释放之后才会尝试</p>\n<h5 id=\"3-WatchDog的原理\">3. WatchDog的原理</h5>\n<p><code>leaseTime(锁的释放时间) == -1 </code>的时候<code>才</code>会使用 看门狗的<code>默认释放时间</code>(30s),就是说 源码中 ： 相当于对<code>以上抢锁逻辑</code>进行了监听，当<code>上边抢锁完毕</code>后，<code>onComplete</code>方法会被调用，具体调用的逻辑就是去后台开启一个线程，进行续约逻辑，也就是看门狗线程</p>\n<p>主要的逻辑就是 不管一个  🔐  重入几次，都能确保拿到的是同一个<code>Entry</code>，并将到来的线程加到<code>entry</code>中，但是第一次来的时候需要进行一次<code>renewExpiration</code>的操作</p>\n<p><code>renewExpiration</code> 方法：</p>\n<ul>\n<li>先从<code>ConcurrentHashMap</code>  中获取得到<code>entry</code></li>\n<li>开一个定时任务，该定时任务有三个参数 <code>new TimerTask() &#123;&#125; ,  参数2(延时时间  源码是 internalLockLeaseTime / 3 =30*1000 /3=10000) ,参数3(单位  源码 ms)</code>    意思就是  经过 10s之后    <code>TimerTask()&#123;&#125;</code> 函数才会执行</li>\n<li><code>TimerTask()&#123;&#125;</code>   的逻辑\n<ul>\n<li>10s之后  拿到 entry 随后从entry中 去除线程ID,然后调用函数<code>renewExpirationAsync</code>刷新指定线程持有锁的有效期，在这个函数里面就是进行重置锁的有效期</li>\n<li>调用自己，进行递归，从而实现不断 <code>自动续费</code>的功能</li>\n<li>最后封装到 <code>entry</code> 中，（<code>entry</code>  最后存放的就是 <code>threadid  &amp;  上述定时任务</code>）</li>\n<li>最后在释放锁的时候取消这个定时任务 <code>cancelExpirationRenewal(threadId)</code>\n<ul>\n<li><code>cancelExpirationRenewal</code> 中逻辑\n<ul>\n<li>通过<code>entryname</code> 从<code>ConcurrentHashMap</code> 中  获取锁 对应的任务</li>\n<li>移除线程ID</li>\n<li>取消对应的任务</li>\n<li>在<code>ConcurrentHashMap</code> 中移除对应的<code>entry</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"小结：\">小结：</h5>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202307060053487.png\" alt=\"image-20230706005359454\" style=\"zoom:53%;\">\n<h5 id=\"简述：\">简述：</h5>\n<ul>\n<li>可重入：利用<code>hash结构</code>记录<code>线程id和重入次数</code></li>\n<li>可重试：利用<code>信号量</code>和<code>PubSub</code>功能实现等待、唤醒，获取锁失败的重试机制</li>\n<li>超时续约：利用<code>watchDog</code>,每隔一段时间（<code>releaseTime/3</code>)，重置超时时间</li>\n</ul>\n<h5 id=\"4-主从一致性\">4. 主从一致性</h5>\n<h6 id=\"1-基于悲观锁机制的MutiLock-联锁-原理\"><strong>1. 基于悲观锁机制的MutiLock(联锁)原理</strong></h6>\n<ul>\n<li>引入：\n<ul>\n<li>为了提高redis的可用性，我们会搭建集群或者主从，现在以<code>主从</code>为例</li>\n<li>在执行完写命令之后，会写在主机上， 主机会将数据同步给从机，但是假设在<code>主机还没有来得及</code>把数据写入到从机去的时候，此时<code>主机宕机</code>，哨兵会发现主机宕机，并且<code>选举</code>一个slave变成master，而此时新的master中<code>实际上并没有锁信息</code>，此时<code>锁信息</code>就已经丢掉了,锁就会失效了</li>\n</ul>\n</li>\n<li>解决\n<ul>\n<li><code>redission</code>提出来了<code>MutiLock</code>锁，使用这把锁咱们就<code>不使用主从</code>了，<code>每个节点的地位都是一样的</code>， 这把锁<code>加锁的逻辑</code>需要<code>写入到每一个主从节点</code>上，只有<code>所有的服务器都写入成功</code>，此时才是<code>加锁成功</code>，假设现在某个节点挂了，那么他去获得锁的时候，<code>只要有一个节点拿不到</code>，都<code>不能算是加锁成功</code>，就保证了<code>加锁的可靠性</code>。</li>\n</ul>\n</li>\n<li>原理简述\n<ul>\n<li><code>Multilock</code> 使用的是一种<code>悲观锁</code>的机制。当一个节点<code>需要获取锁</code>时，它会向<code>所有的其他节点</code>发送请求，并等待它们的响应。<code>只有当所有节点</code>都<code>同意将锁释放时</code>，<code>请求节点才能获取到锁</code>。</li>\n</ul>\n</li>\n<li>源码过程简述</li>\n</ul>\n<hr>\n<h6 id=\"2-基于乐观锁机制的redlock\"><strong>2. 基于乐观锁机制的redlock</strong></h6>\n<p>因为 <code>redis</code>是复制是异步的，所以在<code>主机宕机</code>之后会产生竞争关系，就很有可能出现<code>一把锁</code>被<code>2个线程&lt;一个是主机宕机之前的线程获得到的锁，一个是宕机之后出现slave 升级为 master 之后，由于新的master 不含有原来 线程 的  k-v 键值对，所以 还可能有新的线程会获取到 这个锁&gt;</code> <code>同时使用</code>的情况</p>\n<p>可以使用 <code>redlock</code> 的方式<code>加锁</code></p>\n<ul>\n<li>\n<p>红锁原理简述</p>\n<p><code>Redlock </code>使用的是一种<code>乐观锁</code>的机制。当一个节点需要获取锁时，它会尝试在<code>大多数节点上获取锁</code>，只要<code>获取锁的节点数满足条件 &amp; </code>    <code>获取锁花费的时间</code>小于<code>锁失效的时间</code>，即可认为<code>获取到锁</code></p>\n<p>如果<code>需要释放锁</code>，则向<code>所有</code>节点发送解锁请求。</p>\n</li>\n<li>\n<p>红锁算法的原理</p>\n<p>所有的节点都是独立的，将所有的 <code>节点</code> 都可以看成<code>master</code></p>\n<p><strong>设计理念</strong>  ——还是基于<code>set   lua进行的加锁解锁</code></p>\n<ul>\n<li>获取锁&lt;<code>假设有N个主节点</code>&gt;\n<ul>\n<li>尝试从每个实例中  使用相同的<code>key  +  随机值</code>获取锁，当向<code>Redis</code> 请求获取锁时，客户端应该<code>设置一个超时时间</code>，这个超时时间应该<code>小于</code>锁的失效时间；<code>&lt;</code>的目的是： 可以防止客户端在试图与一个宕机的 Redis 节点对话时长时间处于阻塞状态</li>\n<li>一旦一个redis 实例不能使用，那么 <code>客户端 </code>应该尽快<code>尝试去另外一个 Redis 实例</code>请求获取锁；</li>\n<li>客户端进行计算 获取锁的时间，只有满足一下   <code>2 个条件</code>才算是真正的获取到锁了\n<ul>\n<li>当且仅当  获取锁的数量  <code>&gt;=</code>   <code>N/2+1</code> 的时候</li>\n<li>并且   <code>获取锁花费的时间</code>小于<code>锁失效的时间</code></li>\n</ul>\n</li>\n<li>一旦取得🔐，那么 这把锁的<code>真正有效时间</code>就是  <code>锁的有效时间 -  获取锁花费的时间</code></li>\n<li>但是 要是没有超过   <code>N/2+1</code> 个实例获取锁 <code>或</code> <code>获取锁的时间   超过 锁的有效时间</code>，那么就无法去得到锁</li>\n<li>客户端应该在<code>所有的 Redis 实例</code>上<code>进行解锁</code>\n<ul>\n<li>即便某些Redis实例<code>根本就没有加锁成功</code>，是为了 防止  <code>某些节点获取到锁</code>但是<code>客户端没有得到响应</code>而<code>导致</code>接下来的一段时间<code>不能被重新获取锁</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"Redlock-VS-MutiLock\">Redlock  VS. MutiLock</h6>\n<p><strong>Multilock（多节点锁）：</strong></p>\n<ul>\n<li><strong>使用场景：</strong> <code>Multilock</code> 适用于<code>低并发</code>的情况，或者是在<code>分布式环境中节点数量较少</code>且<code>网络延迟较小</code>的场景。</li>\n<li>优点：\n<ul>\n<li>实现简单，<code>不需要依赖外部的分布式系统</code>。</li>\n<li>在<code>节点数量较少和网络延迟较小</code>的情况下，可以提供良好的性能。</li>\n</ul>\n</li>\n<li>缺点：\n<ul>\n<li>大量节点和高并发情况下性能会受到影响，<code>容易出现死锁</code>问题。</li>\n<li>对网络延迟敏感，节点之间<code>通信时间过长</code>可能导致性能下降。</li>\n</ul>\n</li>\n</ul>\n<p><strong>Redlock（红锁）：</strong></p>\n<ul>\n<li><strong>使用场景：</strong> <code>Redlock</code> 适用于<code>高并发</code>情况下或者在<code>分布式环境中节点数量较多</code>且<code>网络延迟较大</code>的场景。</li>\n<li>优点：\n<ul>\n<li>在高并发和大规模节点的情况下，Redlock 提供了<code>更好的性能和可靠性</code>。</li>\n<li>可以应对<code>网络延迟较大</code>的情况，降低死锁的风险。</li>\n</ul>\n</li>\n<li>缺点：\n<ul>\n<li>实现相对复杂，需要依赖外部的分布式系统。</li>\n<li>受制于网络通信的稳定性和延迟，可能导致性能下降。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"性能优化\">性能优化</h2>\n<p>回顾一下,可以发现总共 6 步</p>\n<p>1、查询优惠卷</p>\n<p>2、判断秒杀库存是否足够</p>\n<p>3、查询订单</p>\n<p>4、校验是否是一人一单</p>\n<p>5、扣减库存</p>\n<p>6、创建订单</p>\n<h3 id=\"优化思路：\">优化思路：</h3>\n<ul>\n<li>\n<p>使用<code>消息队列</code>的方式来完成我们的需求</p>\n</li>\n<li>\n<p>而<code>不是</code> <code>使用线程池</code>或者<code>异步编排</code>的方式来完成这个需求这两者会导致 <code>线程池中的线程</code>可能一下子就被消耗完了</p>\n</li>\n</ul>\n<h3 id=\"优化方案：\">优化方案：</h3>\n<p>将<code>耗时比较短</code>的逻辑判断放入到<code>redis</code>中，比如<code>是否库存足够</code>，<code>是否一人一单</code>，这样的操作，只要这种逻辑可以完成，就意味着我们是<code>一定可以下单完成的</code>，我们<code>只需要进行快速的逻辑判断</code>，根本就<code>不用等下单逻辑走完</code>，我们<code>直接给用户返回成功</code>， <code>再在后台开一个线程</code>，<code>后台线程</code>慢慢的去执行<code>queue</code>里边的消息，这样程序就超级快了，而且也不用担心线程池消耗殆尽的问题，因为这里我们的程序中并没有手动使用任何线程池，当然这里边有两个难点</p>\n<ul>\n<li>\n<p>第一个难点是我们怎么在redis中去快速校验一人一单，还有库存判断</p>\n</li>\n<li>\n<p>第二个难点是由于我们<code>校验</code>和<code>tomcat</code>下单是两个线程，那么我们如何知道到底哪个单最后下单成功</p>\n<ul>\n<li>为了完成这件事我们在<code>redis操作完之后</code>，我们<code>会将一些信息</code>返回给<code>前端</code>，同时也会把这些<code>信息丢到异步queue</code>中去，后续操作中，可以<code>通过这个id来查询我们tomcat中的下单逻辑是否完成了</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"整体思路\">整体思路</h3>\n<ol>\n<li>\n<p>当用户下单之后，判断库存<code>是否充足</code>只需要到redis中去根据<code>key</code>找对应的<code>value</code>是否大于0即可，</p>\n<ul>\n<li>\n<p>如果不充足，则直接结束</p>\n</li>\n<li>\n<p>如果充足，继续在redis中判断用户是否可以下单</p>\n<ul>\n<li>如果set集合中没有这条数据，说明他<code>可以下单</code>,随后 将<code>userId</code>和<code>优惠券id</code>存入到<code>redis</code>中，并且返回<code>0</code>，使用<code>lua</code>保证整个过程的原子性</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>当以上判断逻辑走完之后，我们可以<code>判断当前redis</code>中<code>返回的结果</code>是否<code>是0</code></p>\n<ul>\n<li>如果<code>是0</code>，则表示可以下单，则将之前的信息全部都存入到<code>queue</code>中去，然后返回然后</li>\n</ul>\n</li>\n<li>\n<p>最后来个线程异步的下单，<code>前端</code>可以通过返回的<code>订单id</code>来判断<code>是否下单成功</code></p>\n</li>\n</ol>\n<h3 id=\"技术实现\">技术实现</h3>\n<ol>\n<li>\n<p>一样的,将 <code>优惠券 秒杀的订单信息</code>都存到 <code>redis</code> 中</p>\n</li>\n<li>\n<p>lua脚本进行业务逻辑的判断</p>\n<ol>\n<li>判断库存是否充足,  库存不足，返回1  <code>if(tonumber(redis.call('get', stockKey)) &lt;= 0) then   return 1</code></li>\n<li>判断用户是否下单,存在，说明是重复下单，返回2 <code>if(redis.call('sismember', orderKey, userId) == 1) then   return 2</code></li>\n<li>扣库存 <code>redis.call('incrby', stockKey, -1)</code></li>\n<li>下单（保存用户）<code>redis.call('sadd', orderKey, userId)</code></li>\n<li>成功返回 0 <code>return 0</code></li>\n</ol>\n</li>\n<li>\n<p>java 代码中</p>\n<ol>\n<li>\n<p>执行lua脚本<code>Long result = stringRedisTemplate.execute( SECKILL_SCRIPT, Collections.emptyList(), voucherId.toString(), userId.toString(), String.valueOf(orderId) );</code></p>\n</li>\n<li>\n<p>判断结果是否为0，只有<code>为 0 </code> 才会 将 <code>订单 用户 优惠券的id</code>放入到  <code>消息队列</code>中</p>\n<ol>\n<li>先封装到订单对象中 <code> voucherOrder.setVoucherId(3ids...);</code></li>\n<li>将 VoucherOrder 对象转换为消息体   <code>byte[] messageBody = convertToBytes(voucherOrder);</code></li>\n<li>发布消息到 RabbitMQ 队列   <code> channel.basicPublish(&quot;&quot;, QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, messageBody);</code></li>\n</ol>\n</li>\n<li>\n<p>获取代理对象 <code>proxy = (IVoucherOrderService)AopContext.currentProxy();</code></p>\n</li>\n<li>\n<p>创建 <code>异步处理线程池</code>  <code>private static final ExecutorService SECKILL_ORDER_EXECUTOR = Executors.newSingleThreadExecutor();</code></p>\n<ol>\n<li>在类初始化之后执行线程池<br>\n<code>@PostConstruct private void init() &#123; SECKILL_ORDER_EXECUTOR.submit(new VoucherOrderHandler()); &#125;</code></li>\n</ol>\n</li>\n<li>\n<p>线程池处理的任务<code>VoucherOrderHandler</code>当初始化完毕后，<code>异步线程</code>  会去从  队列  中去拿信息</p>\n<ol>\n<li>\n<p>获取队列中的<code>订单信息</code></p>\n</li>\n<li>\n<p>创建订单——具体包括：</p>\n<ol>\n<li>对于<code>正常消息</code>\n<ol>\n<li>创建消费者 <code>Consumer consumer = new DefaultConsumer(channel) &#123;...&#125;</code>\n<ol>\n<li>判断消息队列中的订单信息是否为空，非空就进行解析数据  <code> Map&lt;String, Object&gt; value = parseMessage(message);</code></li>\n<li>创建订单\n<ol>\n<li>获取用户</li>\n<li>创建<code>redission</code>锁对象</li>\n<li>尝试获取锁</li>\n<li>判断是否获得锁成功;成功才会代理类下创建订单\n<ol>\n<li>查询订单</li>\n<li>判断是否存在</li>\n<li>扣减库存</li>\n<li>保存订单表中</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>确认消息 ACK  <code>channel.basicAck(envelope.getDeliveryTag(), false);</code></li>\n</ol>\n</li>\n<li>监听消息队列 <code> channel.basicConsume(QUEUE_NAME, false, consumer);</code></li>\n<li>如果有异常就会处理<code>异常消息</code></li>\n</ol>\n</li>\n<li>对于<code>异常消息</code>\n<ol>\n<li>和上面逻辑一样，只是在  监听消息队列之后会sleep 一段时间 <code> channel.basicConsume(QUEUE_NAME, false, consumer);            Thread.sleep(20); // 等待一段时间继续处理</code></li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n","_path":"post/6fbb7716.html","_link":"http://rycan.top/post/6fbb7716.html","_id":"cljrhcuxs0057na137wrtfyd0"}}