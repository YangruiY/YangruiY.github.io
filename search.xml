<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MySQL索引</title>
    <url>/post/43a71ae4.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h2 id="为什么使用索引"><a href="#为什么使用索引" class="headerlink" title="为什么使用索引"></a>为什么使用索引</h2><p>目的： 减少磁盘的<code>IO</code>次数，快速找到数据的记录，没有建立索引的时候，进行数据读取的时候是非常耗时的</p>
<h2 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么"></a>索引是什么</h2><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>就是一种数据结构，由于其 <code>在存储引擎中实现</code>，所以每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型</p>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>唯一索引可以 保证表中每一行数据的唯一性</li>
<li>可以加速 <code>表之间的连接</code></li>
<li>降低了CPU的消耗，减少查询中<code>分组 和 排序</code>的时间</li>
</ul>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li>创建和维护索引 需要<code>耗费一定的时间</code>，并且会随着数据库中数据量的增加所耗费的时间也会增加</li>
<li>索引会<code>占用一定的磁盘空间</code>，每个索引还需要一定的物理空间存储在磁盘中</li>
<li><code>会降低更新表的速度</code>，因为在更新表数据的时候，索引也是需要进行动态维护的，从而间接影响了数据的维护速度</li>
</ul>
<h3 id="Innodb存储引擎的数据结构"><a href="#Innodb存储引擎的数据结构" class="headerlink" title="Innodb存储引擎的数据结构"></a><code>Innodb</code>存储引擎的数据结构</h3><ul>
<li><p>B+树</p>
<p>索引快的原因：</p>
<p>​    <strong>其一：</strong> 因为<strong>B+树一般不会超过 4 层，所以在进行键值对查找的时候最多只需要4次磁盘IO操作，指挥进行3次目录项页和1次记录页</strong></p>
<p>​    <strong>其二：</strong> 在每个页面之间是进行<code>二分法</code>进行 快速定位 记录的</p>
</li>
<li><p>特点：</p>
<ul>
<li>一个B+树索引的根节点不会移动</li>
<li>B+树的同一层页节点的目录项记录<code>除页号</code>这个字段<code>以外</code>是<code>唯一的</code></li>
<li>一个页面最少存储 2 条记录</li>
<li>一个B+树只需要很少的层级就可以存储数亿条记录</li>
</ul>
</li>
</ul>
<p>​</p>
<h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><ul>
<li>功能逻辑上分为：普通索引，唯一索引，逐渐索引，全文索引</li>
<li>物理实现方式： 聚簇索引和非聚簇索引</li>
<li>作用字段个数：单列索引和联合索引</li>
</ul>
<h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><h4 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h4><ul>
<li>所有的记录都是存储在叶子结点的</li>
</ul>
<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul>
<li><p>B+树的 叶子节点 存储的是<code>数据记录</code></p>
</li>
<li><p>一个表<code>只能有一个聚簇索引</code>，因为只能有一种排序存储的方式</p>
</li>
<li><p>使用记录主键值的<code>大小</code>进行记录并对其进行页的排序</p>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202307021912998.png" alt="image-20230702191254974" style="zoom:50%;"></p>
<ul>
<li><p><code>页内记录</code>是按照<code>主键大小</code>顺序排成一个 <code>单向链表</code></p>
</li>
<li><p>不同的层次存放的 <code>目录项记录的页</code> 在同一层次中的页也是根据页中目录项记录的<code>主键大小</code>顺序排成一个 <code>双向链表</code></p>
</li>
<li><p>存放 <code>用户记录的页</code> 也是根据页中用户记录的<code>主键大小</code>顺序排成一个 <code>双向链表</code></p>
</li>
</ul>
</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li><code>数据访问更快</code> ，因为聚簇索引将<code>索引和数据保存在同一个B+树中</code>，因此从聚簇索引中获取数据更快</li>
<li>聚簇索引支持主键的 <code>排序查找</code> 和 <code>范围查找</code> ，所以速度非常快</li>
<li>按照聚簇索引排列顺序，<code>查询</code>显示<code>一定范围数据</code>的时候，由于数据都是紧密相连，数据库不用从多 个数据块中提取数据，所以 <code>节省了大量的IO操作</code></li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><code>插入速度严重依赖于插入顺序</code> ，按照主键的顺序插入是最快的方式，否则将会出现<code>页分裂</code>，严重影响性能。<ul>
<li>因此，对于InnoDB表，我们一般都会定义一个<code>自增的ID列为主键</code></li>
</ul>
</li>
<li><code>更新主键的代价很高</code> ，因为将会导致被更新的行移动。<ul>
<li>因此，对于InnoDB表，我们一般定义<strong>主键为不可更新</strong></li>
</ul>
</li>
</ul>
<h3 id="非聚簇索引（二级索引-辅助索引）"><a href="#非聚簇索引（二级索引-辅助索引）" class="headerlink" title="非聚簇索引（二级索引 / 辅助索引）"></a>非聚簇索引（二级索引 / 辅助索引）</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>非聚簇索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个非聚簇索引</li>
<li>非聚簇索引的叶子节点存储的是<code>数据位置</code></li>
<li>对数据进行插入，删除，更新等操作，效率会比聚簇索引高</li>
</ul>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li><code>更新主键的代价不是很高</code></li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><code>插入速度严重依赖于插入顺序</code></li>
<li><code>会进行回表查询</code></li>
</ul>
<h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><ul>
<li><p>每条目录项都有<code>c2、c3、页号</code>这三个部分组成，各条记录先按照<code>c2</code>列的值进行排序，如果记录的<code>c2</code>列相同，则按照<code>c3</code>列的值进行排序</p>
</li>
<li><p>B+树叶子节点处的用户记录由<code>c2、c3和主键c1</code>列组成</p>
</li>
<li><p>以c2和c3列的大小为排序规则建立的B+树称为 <code>联合索引</code> ，本质上也是一个<code>二级索引</code>。</p>
<p>注意一点，它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：</p>
<ul>
<li>建立 联合索引 只会建立1棵B+树。</li>
<li>为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。</li>
</ul>
</li>
</ul>
<h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><ul>
<li>在创建普通索引时，不附加任何限制条件，只是用于提高查询效率。</li>
</ul>
<h3 id="唯一性索引"><a href="#唯一性索引" class="headerlink" title="唯一性索引"></a>唯一性索引</h3><ul>
<li>使用UNIQUE:参数可以设置索引为唯一性索引 ，限制该索引的值必须是唯一的，但允许有空值。在一张数据表里可以有多个唯一索引。<br>可以更快速地确定某条记录。</li>
</ul>
<h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><ul>
<li>在唯一索引的基础上增加了不为空的约束，也就是<code>NOT NULL+UNIQUE</code>,一张表里最多只有一个主键索引。这是由主键索引的物理实现方式决定的，因为数据存储在文件中只能按照一种顺序进行存储。</li>
</ul>
<h3 id="单列索引"><a href="#单列索引" class="headerlink" title="单列索引"></a>单列索引</h3><ul>
<li>在表中的单个字段上创建索引。单列索引只根据该字段进行索引。单列索引可以是普通索引，也可以是唯一性索引，还可以是全文索引。只要保证该索引只对应一个字段即可。一个表可以有多个单列索引。</li>
</ul>
<h3 id="多列（组合、联合）索引"><a href="#多列（组合、联合）索引" class="headerlink" title="多列（组合、联合）索引"></a>多列（组合、联合）索引</h3><ul>
<li>多列索引是在表的多个字段组合上创建一个索引。该索引指向创建时对应的多个字段，可以通过这几个字段进行查询，但是只有查询条件中使用了这些字段中的第一个字段时才会被使用。使用组合索引时遵循最左前缀集合。</li>
</ul>
<h3 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h3><ul>
<li>利用【分词技术】等多种算法智能分析出文本文字中关键词的频率和重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。全文索引非常适合大型数据集，对于小的数据集，它的用处比较小。</li>
</ul>
<blockquote>
<p><code>Innodb</code>和<code>MyISAM</code>默认的索 引是<code>Btree索引</code>；而<code>Memory</code>默认的索引是<code>Hash索引</code>。</p>
</blockquote>
<h2 id="Innodb和MyISAM区别"><a href="#Innodb和MyISAM区别" class="headerlink" title="Innodb和MyISAM区别"></a><code>Innodb</code>和<code>MyISAM</code>区别</h2><p>①在InnoDB存储引擎中，我们<code>只</code>需要根据<code>主键值</code>对 <code>聚簇索引</code> 进行<code>一次查找就能找到对应的记录</code>；而在 MyISAM 中<code>却需要进行一次 回表</code> 操作，意味着MyISAM中建立的<code>索引</code>相当于全部都是 <code>二级索引</code>。</p>
<p>② InnoDB的数据文件本身就是<code>索引文件</code>;  而MyISAM<code>索引文件和数据文件</code>是分离的 ，<code>MyISAM</code>de索引文件仅保存数据记录的地址。</p>
<p>③ InnoDB的非聚簇索引data域存储相应记录 <code>主键的值</code> ，而MyISAM索引记录的是 <code>地址</code>。换句话说，InnoDB的所有非聚簇索引都引用主键作为data域。</p>
<blockquote>
<p>为什么不建议使用过长的字段作为主键？  因为所有二级索引都引用主键索引，过长的主键索引会令二级索引变得过大。</p>
</blockquote>
<h2 id="多种索引数据结构的选择"><a href="#多种索引数据结构的选择" class="headerlink" title="多种索引数据结构的选择"></a>多种索引数据结构的选择</h2><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><blockquote>
<p>Hash结构<code>效率高</code>，那为什么索引结构要设计成树型呢？</p>
<ul>
<li>Hash索引<code>仅能</code>满足(=)(&lt;  &gt; )和IN查询。如果进行范围查询，哈希型的索引，时间复杂度会退化为O(n)；而树型的“有序”特性，依然能够保持<code>O(logN)</code>的高效率。</li>
<li>另一个缺陷，数据的存储是<code>没有顺序</code>的，在ORDER BY的情况下，使用Hash索引还需要对数据重新排序。</li>
<li>对于<code>联合索引</code>的情况，Hash值是将联合索引键<code>合并后一起来计算</code>的，无法对单独的一个键或者几个索键进行查询。</li>
<li>对于<code>等值查询</code>来说，通常<code>Hash索引的效率更高</code>，不过也存在一种情况，就是索引列的<code>重复值如果很多</code>，效率就会降低。这是因为遇到Hash冲突时，需要遍历桶中的行指针来进行比较，找到查询的关键字，非常耗时。</li>
<li>所以，Hash索引通常不会用到重复值多的列上，比如列为性别、年龄的情况等。</li>
</ul>
</blockquote>
<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><blockquote>
<p>磁盘的IO次数和索引树的高度是相关的,<code>特殊情况下会达到O(n)的复杂度，此时就会退化为链表</code></p>
</blockquote>
<h3 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h3><blockquote>
<p>可以解决<code>退化为链表</code> 的问题，但是当节点很多的时候，树的深度还是会很大。</p>
</blockquote>
<h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><blockquote>
<ul>
<li>B树在插入和删除节点的时候如果导致树不平衡，就通过自动调整节点的位置来保持树的自平衡。</li>
<li>关键字集合分布在整棵树中，即叶子节点和非叶子节点都存放数据。搜索有可能在非叶子节点结束</li>
<li>其搜索性能等价于在关键字全集内做一次二分查找。</li>
<li><p>一个 M 阶的 B 树（M&gt;2）有以下的特性：</p>
<ol>
<li>根节点的<code>孩子数</code>的范围是 [2,M]</li>
<li>每个中间节点包含<code>k-1</code> 个关键字和<code>k</code> 个孩子，孩子的数量 = 关键字的数量 +1，k 的取值范围为<code>[ceil(M/2), M]</code></li>
<li>叶子节点包括 <code>k-1</code>个关键字（叶子节点没有孩子），<code>k</code> 的取值范围为<code>[ceil(M/2), M]</code></li>
<li>假设中间节点节点的关键字为：<code>Key[1], Key[2], …, Key[k-1]</code>，且关键字按照升序排序，即 <code>Key[i]&lt;Key[i+1]</code>。此时 <code>k-1</code> 个关键字相当于划分了<code>k</code> 个范围，也就是对应着 <code>k</code>个指针，即为：<code>P[1], P[2], …, P[k]</code>，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k] 指向关键字大于 Key[k-1] 的子树</li>
<li>所有叶子节点位于同一层</li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h3><blockquote>
<p>B+树的中间节点并不直接存储数据。这样的好处都有什么呢？</p>
<ul>
<li>首先，<code>B+树查询效率更稳定</code>。因为B+树每次只有访问到叶子节点才能找到对应的数据；而在<code>B树</code>中，非叶子节点也会存储数据，这样就会造成查询效率不稳定的情况，有时候访问到了非叶子节点就可以找到关键字，而有时需要访问到叶子节点才能找到关键字。</li>
<li>其次，<code>在单个关键字上，B+树的查询效率更高</code>。这是因为通常B+树比B树更矮胖（阶数更大，深度更低），查询所需要的磁盘IO也会更少。同样的磁盘页大小，B+树可以存储更多的节点关键字。</li>
<li><code>在查询范围上，B+树的效率也比B树高</code>。这是因为所有关键字都出现在B+树的叶子节点中，叶子节点之间会有指针，数据又是递增的，这使得我们范围查找可以通过指针连接查找。而在B树中则需要通过中序遍历才能完成查询范围的查找，效率要低很多。</li>
</ul>
</blockquote>
<h3 id="R树"><a href="#R树" class="headerlink" title="R树"></a>R树</h3><blockquote>
<ul>
<li>仅支持 <code>geometry</code>数据类型</li>
<li>R树就很好的 解决了这种<code>高维空间搜索问题</code></li>
<li>它把B 树的思想很好的扩展到了多维空间，采用了B树分割空间的思想，并在添加、删除操作时采用合并、分解 结点的方法，保证树的平衡性。</li>
<li>因此，R树就是一棵用来 存储高维数据的平衡树 。相对于<code>B-Tree，R-Tree</code> 的优势在于范围查找。</li>
</ul>
</blockquote>
<h2 id="B树-VS-B-树"><a href="#B树-VS-B-树" class="headerlink" title="B树 VS. B+树"></a><code>B树</code> VS. <code>B+树</code></h2><blockquote>
<ol>
<li>B+树  有 k 个孩子的节点就有 k 个关键字。也就是<code>孩子数量 = 关键字数</code>，而 B 树中，<code>孩子数量 = 关键字数 +1</code>。</li>
<li>B+树  <code>非叶子节点</code>的关键字也会同时存在<code>子节点</code>中，并且是在子节点中所有关键字的<code>最大（或最小）</code>。</li>
<li>B+树  <code>非叶子节点</code>仅用于索引，不保存数据记录，跟<code>记录有关的信息都放在叶子节点</code>中。而 <code>B 树</code>中， <code>非叶子节点既保存索引，也保存数据记录</code> 。</li>
<li>B+树  所有<code>关键字</code>都在<code>叶子节点</code>出现，叶子节点构成一个<code>有序链表</code>，而且叶子节点本身按照关键字的大小<code>从小到大顺序链接</code></li>
</ol>
</blockquote>
<h2 id="Hash-索引-VS-B-树索引"><a href="#Hash-索引-VS-B-树索引" class="headerlink" title="Hash 索引 VS. B+树索引"></a><code>Hash 索引</code> VS. <code>B+</code>树索引</h2><ul>
<li>Hash索引<code>不能进行范围查询</code>，而B+树<code>可以</code>。这是因为<code>Hash索引指向的数据是无序</code>的，而B+树的叶子节点是个有序的链表。</li>
<li>Hash索引<code>不支持</code>联合索引的<code>最左匹配原则</code>（即联合索引的部分索无法使用），而<code>B+树可以</code>。对于联合索引来说，Hash索引在计算Hash值的时候是将<code>索引键合并</code>后再一起计算Hash值，所以不会针对每个索引单独计算Hash值。因此如果用到联合索引的一个或者几个索时，联合索引无法被利用。</li>
<li>Hash索引不支持<code>ORDER BY</code>排序，因为<code>Hash</code>索引指向的数据是<code>无序</code>的，因此无法起到排序优化的作用，而<code>B+树</code>索引数据是有序的，可以起到对该字段<code>ORDER BY</code>排序优化的作用</li>
<li>无法用<code>Hash索引</code>进行模糊查询，而B+树使用<code>LIKE</code>进行模糊查询的时候，<code>LIKE</code>后面模糊查询（比如%结尾）的话就可以起到优化作用。</li>
<li><code>InnoDB</code>不支持哈希索引</li>
</ul>
<h2 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a>索引的设计原则</h2><h3 id="哪些情况适合创建索引"><a href="#哪些情况适合创建索引" class="headerlink" title="哪些情况适合创建索引"></a>哪些情况适合创建索引</h3><ul>
<li>如果某个字段是<code>唯一性</code>的，就可以直接创建<code>唯一性索引</code>，或者<code>主键索引</code>（具有唯一特性的字段，即使是组合字段，也必须建成唯一索引）</li>
<li>频繁作为 <code>WHERE</code>查询条件的字段</li>
<li>经常 <code>GROUP BY 和 ORDER BY</code>的列</li>
<li><code>UPDATE、DELETE 的 WHERE</code>条件列</li>
<li><code>DISTINCT</code> 字段需要创建索引</li>
<li><p>使用列的<code>类型小（数据范围小）的创建索引</code></p>
<ul>
<li>数据类型越小，在查询时进行的比较操作越快</li>
<li>数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘I0带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</li>
</ul>
</li>
<li>使用<code>字符串前缀创建索引</code>:  可以通过截取字段的前面一部分内容建立索引，这个就叫前缀索引</li>
<li><code>区分度高(散列性高)的列</code>适合作为索引</li>
<li>使用<code>最频繁的列</code>放到<code>联合索引</code>的左侧</li>
</ul>
<blockquote>
<p>但是使用索引列前缀的方式 <code>无法支持使用索引排序</code> ，只能使用文件排序。</p>
<p>==ps==  在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据<code>实际文本</code> 区分度决定<code>索引长度</code>。</p>
</blockquote>
<h3 id="多表-JOIN-连接操作时，创建索引注意事项"><a href="#多表-JOIN-连接操作时，创建索引注意事项" class="headerlink" title="多表 JOIN 连接操作时，创建索引注意事项"></a>多表 JOIN 连接操作时，创建索引注意事项</h3><ul>
<li>首先， <code>连接表的数量尽量不要超过 3 张</code></li>
<li>其次， <code>对 WHERE 条件创建索引</code> ，因为 WHERE 才是对数据条件的过滤。</li>
<li><p>最后， <code>对用于连接的字段创建索引</code> ，并且该字段在多张表中的 类型必须一致</p>
</li>
<li><p>在多个字段都要创建索引的情况下，<code>联合索引优于单值索引</code></p>
<ul>
<li>在where中使用不到的字段，不要设置索引</li>
<li><code>数据量小</code>的表最好不要使用索引</li>
<li>避免对经常<code>更新的表</code>创建过多的索引</li>
<li>有<code>大量重复数据的列</code>上不要建立索引</li>
<li>不建议用<code>无序的值</code>作为索引    eg：身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字 符串等。</li>
<li><code>删除不再使用或者很少使用的索引</code></li>
<li><code>不要定义冗余或重复</code>的索引</li>
</ul>
</li>
</ul>
<blockquote>
<p>为了减少IO，索引树会一次性加载吗？</p>
</blockquote>
<ul>
<li>数据量非常大的时候不太可能，只能逐一加载</li>
</ul>
<blockquote>
<p> B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO</p>
</blockquote>
<p>InnoDB存储引擎中<code>页的大小为16KB</code>,一个页(B+Tre中的一个节点)中大概存储<code>1K个键值</code>（因为是估值，为方便计算，这里的K取值为10^3^。也就是说一个<code>深度为3</code>的<code>B+Tree索引可以维护</code>10^3^*10^3^*10^3^=<code>10亿条记录</code>。（这里假定一个数据页也存储10^3^条行记录数据了）<br>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2~4层。MySQL的InnoDB存储引擎在设计时是将<code>根节点常驻内存</code>的，也就是说查找某一键值的行记录时<code>最多只需要1~3次磁盘</code>I0操作。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL调优与优化</title>
    <url>/post/917a6f4c.html</url>
    <content><![CDATA[<h2 id="性能分析工具的使用思路"><a href="#性能分析工具的使用思路" class="headerlink" title="性能分析工具的使用思路"></a>性能分析工具的使用思路</h2><ul>
<li>先观察服务器状态，进行判断是否<code>存在周期性波动</code>&lt;比如双十一、各种促销活动&gt;<ul>
<li>存在周期性波动,==就加大缓存，更改缓存失效策略==</li>
</ul>
</li>
<li>不存在周期性波动 或者 缓存失效的策略即使更改了依旧无法解决，分析 <code>仍然出现不规则的延迟或者卡顿</code>的现象出现的原因<ul>
<li>==开启慢查询==<ul>
<li>目的是  ： 定位执行慢的<code>sql</code>语句,设置慢的阈值，设置的参数就是<code>long_query_time</code>,一旦<code>SQL</code>执行时间超过了所设定的阈值，那么就认为是慢查询。当收集上来这些慢查询之后，我们就可以通过<code>分析工具</code>对<code>慢查询日志</code>进行分析。</li>
</ul>
</li>
<li>对于<code>执行慢的SQL语句</code>，我们可以使用==EXPLAIN==语句查询执行计划，或者使用==show profile==查看SQL中<code>每一个步骤的时间成本</code>，从而判断是==执行时间长==还是==等待的时间长==<ul>
<li>对于 <code>等待的时间长</code> ，可以==调优服务器的参数== &lt;比如适当增加数据库缓冲池等&gt;</li>
<li>对于 <code>执行的时间长</code>， ==考虑是不是索引的问题，是不是关联查询的数据表过多的问题，是不是数据库的某一个字段设计的不合理导致的==，并针对性的进行调优</li>
<li>从上述的两个方向去 查看是否能够解决<code>延迟卡顿</code>的问题</li>
</ul>
</li>
<li>要是 <code>参数调优</code>和  <code>上述优化思路</code>都无法进行解决的话，考虑的角度就应该应该是==数据库自身的SQL查询性能是否已经达到了瓶颈==<ul>
<li>要是没有的话就进行反复检查，重复上述的步骤</li>
<li>已经达到瓶颈的话就进行<code>增加服务器的数量</code>，进行<code>读写分离的主从架构 或者 对数据库进行分库分表(垂直分库、水平分表、水平分库)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：</p>
<ul>
<li>对于数据库的延时卡顿的现象我们可以进行分析工具帮助我们定位有问题的语句，常见的<code>三种工具</code>：<ul>
<li>慢查询：主要帮助我们发现<code>执行时间特别长</code>的SQL查询，针对性的优化，从而提高整体的效率，一般默认不开启，需要手动开启此参数；</li>
<li>分析查询语句<code>Explain</code>： 定位了查询慢的SQL之后，我们就可以使用<code>EXPLAIN</code>或<code>DESCRIBE</code>工具做针对性的分析查询语句，两者的语法和分析结果都是一样的，主要作用是 表和数据的读取，索引的使用、表之间的引用等</li>
<li>分析优化器的执行计划：<code>trace</code></li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="数据库调优"><a href="#数据库调优" class="headerlink" title="数据库调优"></a>数据库调优</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标:"></a>目标:</h3><ul>
<li>尽可能节省系统资源 ，以便系统可以<code>提供更大负荷的服务</code>。（吞吐量更大）</li>
<li>合理的结构设计和参数调整，以<code>提高用户操作响应的速度</code> 。（响应速度更快）</li>
<li>减少系统的瓶颈，提高<code>MySQL</code>数据库整体的性能。</li>
</ul>
<h3 id="方向："><a href="#方向：" class="headerlink" title="方向："></a>方向：</h3><ul>
<li>索引失效、没有充分利用到索引——<code>建立索引</code></li>
<li>关联查询太多JOIN（设计缺陷或不得已的需求）——<code>SQL优化</code></li>
<li>服务器调优及各个参数设置（缓冲、线程数等）——<code>调整my.cnf</code></li>
<li>数据过多——<code>分库分表</code></li>
</ul>
<h3 id="调优的角度"><a href="#调优的角度" class="headerlink" title="调优的角度:"></a>调优的角度:</h3><h4 id="优化sql参数配置和相关的服务器硬件"><a href="#优化sql参数配置和相关的服务器硬件" class="headerlink" title="优化sql参数配置和相关的服务器硬件"></a>优化sql参数配置和相关的服务器硬件</h4><h4 id="优化数据库结构"><a href="#优化数据库结构" class="headerlink" title="优化数据库结构"></a>优化数据库结构</h4><ul>
<li><p><code>拆分表：冷热数据分离</code></p>
<ul>
<li><p>拆分表的思路是: 把1个包含很多字段的表拆分成2个或者多个相对较小的表。<code>冷热数据分离</code>的目的是：</p>
<p>①<code>减少磁盘IO</code>,保证<code>热数据</code>的内存缓存命中率。</p>
<p>②<code>更有效的利用缓存</code>，避免读入无用的冷数据。</p>
</li>
</ul>
</li>
<li><p><code>增加中间表</code></p>
<ul>
<li>对于需要经常联合查询的表，可以建立中间表以提高查询效率。</li>
<li>通过建立中间表，把需要经常联合查询的数据插入中间表中，然后将原来的<code>联合查询</code> <code>改为</code> 对<code>中间表</code>的查询，以此来提高查询效率。</li>
<li>做法:<ul>
<li>首先，分析经常联合查询表中的字段；</li>
<li>然后，使用这些字段建立一个中间表，并将原来联合查询的表的数据插入中间表中；</li>
<li>最后，使用中间表来进行查询。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>增加冗余字段</code></p>
</li>
<li><p><code>优化数据类型</code>   ： 优先选择符合存储需要的<code>最小的数据类型</code></p>
</li>
<li><p><code>优化插入记录的速度</code></p>
<ul>
<li><p><code>MyISAM</code>引擎的表的实现方式</p>
<p><strong>① 禁用索引</strong></p>
<p><strong>② 禁用唯一性检查</strong></p>
<p><strong>③ 使用批量插入</strong></p>
<p><strong>④ 使用LOAD DATA INFILE 批量导入</strong></p>
</li>
<li><p><code>InnoDB</code>引擎的表的实现方式</p>
<p><strong>① 禁用唯一性检查</strong></p>
<p><strong>② 禁用外键检查</strong></p>
<p><strong>③ 禁止自动提交</strong></p>
</li>
</ul>
</li>
<li><p><code>使用非空约束</code></p>
</li>
</ul>
<h4 id="大表的优化"><a href="#大表的优化" class="headerlink" title="大表的优化"></a>大表的优化</h4><ul>
<li><code>限定查询的范围</code><ul>
<li>禁止不带任何限制数据范围条件的查询语句</li>
</ul>
</li>
<li><p><code>读/写分离  ： 主库负责写，从库负责读</code></p>
<ul>
<li><p>垂直拆分 :当数据量级达到 <code>千万级</code> 以上时，有时候我们需要把一个数据库切成多份，放到不同的数据库服务器上，减少对单一数据库服务器的访问压力。</p>
<ul>
<li><p>如果数据库的数据<code>表过多</code>，可以采用<code>垂直分库</code>的方式，将关联的数据库部署在同一个数据库上。</p>
</li>
<li><p>如果数据库中的<code>列过多</code>，可以采用<code>垂直分表</code>的方式，将一张数据表分拆成多张数据表，把经常一起使用的列放在同一张表里。</p>
</li>
<li><p><code>垂直拆分的优点</code>： 可以使得列数据变小，在查询时减少读取的<code>Block数，减少I/O次数</code>。此外，垂直分区可以简化表的结构，易于维护。</p>
</li>
<li><p><code>垂直拆分的缺点</code>： 主键会出现冗余，需要管理冗余列，并会引起 JOIN 操作。此外，垂直拆分会让事务变得更加复杂。</p>
</li>
</ul>
</li>
<li><p>水平拆分</p>
<ul>
<li>尽量控制单表数据量的大小，建议控制在<code>千万级别</code>以内。</li>
<li>这里我们主要考虑业务数据的<code>水平分表</code>策略。将大的数据表按照某个属性维度分拆成不同的小表，每张小表保持相同的表结构。比如你可以按照年份来划分，把不同年份的数据放到不同的数据表中。</li>
<li>水平分表仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以<code>水平拆分最好分库</code>，从而达到分布式的目的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h4><ul>
<li><p>逻辑查询优化</p>
<ul>
<li>使用更高效的<code>sql</code>语句进行等价代替</li>
</ul>
</li>
<li><p>物理查询优化</p>
<ul>
<li><p>使用<code>索引</code>减少执行的代价</p>
</li>
<li><p>使用<code>缓存技术</code></p>
</li>
<li><p>使用<code>读写分离 和 数据分片&lt;垂直分库和水平分表&gt;</code></p>
</li>
</ul>
</li>
</ul>
<h4 id="索引的优化"><a href="#索引的优化" class="headerlink" title="索引的优化"></a>索引的优化</h4><h5 id="何时失效"><a href="#何时失效" class="headerlink" title="何时失效"></a>何时失效</h5><ul>
<li>全值匹配   <code>select *</code></li>
<li>联合索引不遵循 <code>最佳左前缀法则</code></li>
<li><code>字符串不加单引号</code>，造成索引失效。</li>
<li><code>计算、函数、类型转换</code>(自动或手动)导致索引失效</li>
<li>范围查询条件<code>【(&lt;) (&lt;=) (&gt;) (&gt;=) 和 between 等】右边的列</code>索引失效</li>
<li><code>不等于(!= 或者&lt;&gt;)索引</code>失效</li>
<li><code>is null可以</code>使用索引，<code>is not null无法</code>使用索引</li>
<li>like以通配符<code>%开头</code>索引失效</li>
<li><code>OR 前后</code>存在非索引的列，索引失效<ul>
<li>因为OR的含义就是两个只要满足一个即可，因此<code>只有一个条件列进行了索引是没有意义的</code>，只要有条件列没有进行索引，就会进行<code>全表扫描</code>，因此所以的条件列也会失效</li>
</ul>
</li>
</ul>
<h5 id="使用索引进行查询时候优化的角度"><a href="#使用索引进行查询时候优化的角度" class="headerlink" title="使用索引进行查询时候优化的角度"></a>使用索引进行查询时候优化的角度</h5><ul>
<li>关联查询<ul>
<li>参与</li>
<li><code>join</code>字段已经创建了索引</li>
<li>参与<code>join</code>字段的数据类型需要保持绝对的一致</li>
<li>在使用<code>left join</code> 的时候使用<code>小表为驱动表</code>，<code>大表为被驱动表</code>，从而减少外层循环的次数</li>
<li>使用<code>INNER JOIN</code> 时，MySQL会自动将 小结果集的表选为驱动表 。选择相信MySQL优化策略。</li>
<li>能够直接多表关联的尽量直接关联，不用子查询。(减少查询的趟数)</li>
</ul>
</li>
<li>子查询<ul>
<li>可以使用连接（JOIN）查询来替代子查询<ul>
<li>连接查询 <code>不需要建立临时表</code> ，其 <code>速度比子查询</code> 要快 ，如果查询中使用索引的话，性能就会更好。</li>
</ul>
</li>
<li>尽量<code>不要</code>使用<code>NOT IN</code>或者<code>NOT EXISTS</code>，用<code>LEFT JOIN xxx ON xx WHERE xx IS NULL</code>替代</li>
</ul>
</li>
</ul>
<blockquote>
<details>
    <summary>展开查看 子查询为什么速度比较慢</summary> 
<pre>
① 执行子查询时，MYSQL需要为内层查询语句的查询结果 建立一个临时表 ，然后外层查询语句从临时表中查询记录。查询完毕后，再撤销这些临时表 。这样会消耗过多的CPU和IO资源，产生大量的慢查询。
② 子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都不会存在索引 ，所以查询性能会受到一定的影响。
③ 对于返回结果集比较大的子查询，其对查询性能的影响也就越大。
</pre>
</details>




</blockquote>
<ul>
<li>分页查询<ul>
<li>在<code>索引上</code>完成<code>排序分页操作</code>，最后根据<code>主键</code>关联<code>回原表</code>查询所需要的其他列内容</li>
<li>适用于主键自增的表，可以把<code>Limit</code>查询转换成某个位置的查询</li>
</ul>
</li>
<li>使用索引<ul>
<li>优先考虑覆盖索引</li>
<li>在<code>where</code> 字段和<code>Order by</code>字段都要加上索引</li>
</ul>
</li>
</ul>
<blockquote>
<details>
    <summary>展开查看： 覆盖索引</summary> 
  <pre> 
1.是什么：一个索引包含了满足查询结果的数据就叫做覆盖索引
2.优点：
    可避免`Innodb表`索引的二次查询，因为在 覆盖索引中，二级索引的键值中可以获取所要的数据，避免了对主键的二次查询，减少了I0操作，所以提升了查询效率。
    可以把随机IO 变化为顺序IO ,也可以加快查询效率，由于覆盖索引是按键值的顺序存储的，对于I0密集型的范围查找来说，对比随机从磁盘读取每一行的数据I0要少的多
3.缺点：
    索引字段的维护是有一定的代价的
    </pre> 
</details> 



<details>
    <summary>展开查看： 为什么OrderBy字段也要加上索引</summary> 
   <pre>
在MySQL中，支持两种排序方式，分别是 `FileSort` 和 `Index` 排序
① 在 Index 排序中，索引可以保证数据的有序性，不需要再进行排序，`效率更高`
② 在 FileSort 排序则一般在 `内存中` 进行排序，占用`CPU较多`。如果待排结果较大，会产生临时文件 I/O 到磁盘进行排序的情况，效率较低
所以就是说：在`Order by` 中使用索引时要尽量避免使用`FileSort`排序；尽量使用 `Index` 完成 `ORDER BY` 排序，。如果 `WHERE` 和` ORDER BY `后面是相同的列就使用`单列索引`； 如果不同就使用`联合索引`。 
   </pre> 
</details>



</blockquote>
<h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><h5 id="数据库的设计"><a href="#数据库的设计" class="headerlink" title="数据库的设计"></a>数据库的设计</h5><ul>
<li>遵循三范式原则</li>
<li>适当的使用反范式</li>
<li>对于表的字段类型的设计要谨慎考虑</li>
</ul>
<blockquote>
<details>
    <summary>展开查看： 范式与反范式</summary> 
    <pre>
范式：
①第一范式 ： 主要确保数据库中每个字段的值必须具有`原子性`，也就是说数据表中每个字段的值为`不可再次拆分`的最小数据单元。
②第二范式： 在满足第一范式的基础上，还要**满足数据库里的每一条数据记录，都是可唯一标识的。而且所有非主键字段，都必须完全依赖主键，不能只依赖主键的一部分**。第二范式（2NF）要求实体的属性完全依赖主关键字。
③第三范式：  在第二范式的基础上，确保数据表中的每一个非主键字段都和主键字段直接相关，也就是说，**要求数据表中的所有非主键字段不能依赖于其他非主键字段**。（即，不能存在非主属性A依赖于非主属性B，非主属性B依赖于主键C的情况，即存在“A->B->C"的决定关系）通俗地讲，该规则的意思是所有`非主键属性`之间不能由依赖关系，必须`相互独立`。
④BCNF(巴斯范式)： 若一个关系达到了第三范式，并且它只有一个候选键，或者它的每个候选键都是单属性，则该关系自然达到BC范式。
⑤第四范式 ： 在满足巴斯 - 科德范式（BCNF）的基础上，消除非平凡且非函数依赖的多值依赖（即把同一表的多对多关系删除）。
所谓的三范式原则说的就是`①②③`
反范式:
- 优点
  可以通过在数据表中增加`冗余字段`来`提高数据库的读性能`
- 缺点：
  存储 空间变大了
  一个表中字段做了修改，另一个表中冗余的字段也需要做同步修改，否则数据不一致
  若采用存储过程来支持数据的更新、删除等额外操作，如果更新频繁，会非常消耗系统资源
  在 数据量小 的情况下，反范式不能体现性能的优势，可能还会让数据库的设计更加复杂
- 使用场景:
  当冗余信息有价值或者能 `大幅度提高查询效率` 的时候
</pre>
</details>




</blockquote>
<h5 id="表的设计"><a href="#表的设计" class="headerlink" title="表的设计"></a>表的设计</h5><ul>
<li>数据<code>表的个数</code>越少越好</li>
<li>数据表中的<code>字段个数</code>越少越好</li>
<li>数据表中<code>联合主键</code>的字段个数越少越好</li>
<li>使用<code>主键和外键</code>越多越好</li>
</ul>
<h2 id="实例场景"><a href="#实例场景" class="headerlink" title="实例场景"></a>实例场景</h2><ul>
<li><p>TB的订单号的设计策略：<code>订单ID = 时间+ 去重字段+ UserId后6位</code></p>
</li>
<li><p><code>自增ID</code>的问题</p>
<ul>
<li>可靠性： 存在自增ID回溯的问题</li>
<li>安全性：对外暴露的接口可以非常容易猜测对应的信息。</li>
<li>性能差：自增ID的性能较差，需要在数据库服务器端生成。</li>
<li>交互多：业务还需要额外执行一次类似 <code>last_insert_id()</code>的函数才能知道刚才插入的自增值，这需要多一次的网络交互。在海量并发的系统中，多1条SQL，就多一次性能上的开销。</li>
<li>局部唯一性：自增ID是局部唯一，只在当前数据库实例中唯一，而<code>不是全局唯一</code>，也不是在任意服务器间都 是唯一的。所以对于分布式系统不适用</li>
</ul>
</li>
<li><p>主键的设计的一种简单的策略</p>
<ul>
<li>使用<code>UUID</code>:<strong>其特点：</strong>全局唯一，占用36字节，数据无序，插入性能差。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Springboot 整合 redis</title>
    <url>/post/9981ab8f.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h3 id="使用Spring-Data-Redis："><a href="#使用Spring-Data-Redis：" class="headerlink" title="使用Spring Data Redis："></a>使用Spring Data Redis：</h3><ul>
<li>Spring Data Redis是Spring提供的一个模块，可以简化与Redis的集成。它提供了一组简单易用的API，可以通过注解或者编程方式与Redis进行交互。</li>
</ul>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305242101617.png" alt="image-20230524210152588" style="zoom:33%;"></p>
<h4 id="产生问题-转圈圈"><a href="#产生问题-转圈圈" class="headerlink" title="产生问题: 转圈圈"></a>产生问题: 转圈圈</h4><ul>
<li><p>原因：SpringBoot客户端没有<code>动态感知</code>RedisCluster的最新集群信息</p>
</li>
<li><p>现象：Redis Cluster集群部署采用了3主3从拓扑结构，数据读写访问master节点，slave节点负责备份。当master宕机主从切换成功，redis可以正常运行，但是<code>java程序出现异常</code></p>
</li>
<li><p>解决：</p>
<ul>
<li><p>排除lettuce采用Jedis（不推荐）</p>
</li>
<li><p>重写连接工厂实例（极度不推荐）</p>
</li>
<li><p><code>刷新节点集群拓扑动态感应</code>==（推荐）==</p>
<ul>
<li>调用 <code>RedisClusterClient.reloadPartitions</code></li>
<li>后台基于时间间隔的周期刷新</li>
<li>后台基于持续的 <strong>断开</strong> 和 <strong>移动</strong>、<strong>重定向</strong> 的自适应更新</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#支持集群拓扑动态感应刷新，自适应拓扑刷新是否使用所有可用的更新，默认false关闭</span></span><br><span class="line"><span class="string">spring.redis.lettuce.cluster.refresh.adaptive=true</span></span><br><span class="line"><span class="comment">#定时刷新</span></span><br><span class="line"><span class="string">spring.redis.lettuce.cluster.refresh.period=2000</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="使用Jedis或Lettuce："><a href="#使用Jedis或Lettuce：" class="headerlink" title="使用Jedis或Lettuce："></a>使用Jedis或Lettuce：</h3><ul>
<li><p>Jedis和Lettuce是两个常用的Java Redis客户端库。你可以直接使用它们来连接Redis，并且Spring提供了对它们的集成支持。这种方式需要手动配置Redis连接和操作。</p>
</li>
<li><p>Jedis本身是<code>线程不安全</code>的，并且<code>频繁的创建和销毁连接</code>会有性能损耗，推荐使用Jedis<code>连接池</code>代替Jedis的<code>直连</code>方式。</p>
</li>
</ul>
<h3 id="使用Spring-Boot的自动配置："><a href="#使用Spring-Boot的自动配置：" class="headerlink" title="使用Spring Boot的自动配置："></a>使用Spring Boot的自动配置：</h3><ul>
<li>如果你使用Spring Boot，它提供了自动配置Redis的功能。只需在项目的配置文件中添加相关配置，Spring Boot将自动创建和配置与Redis的连接。</li>
</ul>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/post/16107.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>b-草稿</title>
    <url>/post/57317.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">


<p>:blush:<br><!-- raw的外挂标签是告诉渲染引擎这段代码不用渲染。 --><br>
<div class="example wow animate__bounceInUp">
Content to Reveal Here
</div>
</p>
]]></content>
  </entry>
  <entry>
    <title>a-搭建整个博客的过程简单记录</title>
    <url>/post/19656.html</url>
    <content><![CDATA[<!-- raw的外挂标签是告诉渲染引擎这段代码不用渲染。 -->

<div class="example wow animate__bounceInUp">

<meta name="referrer" content="no-referrer">
# 基础
## 简单搭建

- [官网][http://nodejs.cn/]安装`nodejs`
- 安装 `git`    `brew install git`

- 查看nodejs版本     `npm -version`

- 安装cnpm 依赖于淘宝源：`npm install -g cnpm --registry=https://registry.npm.taobao.org`
- 查看cnpm 版本  `cnpm -v`
- 我使用` cnpm install -g hexo-cli`   出现了问题   但是  使用` npm install -g hexo-cli`可以
- 查看 `hexo -v`
- `mkdir RyCanBlog`
- `cd /Users/yangrui/RycanBlog`
- ` hexo init `      适当连接手机热点         
  - 安装成功： `INFO  Start blogging with Hexo!`
-  `  hexo s`  启动服务   `http://localhost:4000/`   平时写博客的时候可以进行`预览`
- `cd source/_posts`
- ` hexo n "搭建整个博客的过程简单记录"`  创建文章
- `vim 搭建整个博客的过程简单记录`
- ` cd /Users/yangrui/Z_RycanBlog`

- `hexo clean`
- `hexo g`
- `hexo s`  浏览

## 部署

- `Github ` 登录新建一个仓库，必须要和自己的用户名一样  ： 命名规则`XXX.github.io`
- `/Users/yangrui/Z_RycanBlog` 下安装插件`npm install --save hexo-deployer-git`

- 设置`vim _config.yml `     必须要是 ssh才能获取成功

  <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">--</span> <span class="string">最后の位置</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:YangruiY/YangruiY.github.io.git</span> </span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>

- `hexo clean`
- `hexo g`
- `hexo d`

- 浏览器直接访问自己的`XXX.github.io` 即可

## 更换主题

`cd /Users/yangrui/Z_RycanBlog`

- 下载主题 `git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia`
- 修改hexo根目录下的 `_config.yml` ： `theme: yilia`

- `vim _config.yml `

  <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">yilia</span></span><br></pre></td></tr></table></figure>

- `hexo clean & hexo g &hexo s`

![成功效果](https://gitee.com/Ryang1118/typora/raw/master/images/202306210117794.png)

## 提升

- DIY定制化主题   `butteryfly`
- `npm install hexo-renderer-pug hexo-renderer-stylus --save`安装pug 以及 stylus 的渲染器

- `npm install hexo-abbrlink --save`   给每一篇文章来上一个属于自己的链接所需要的插件

- `vim _config.yml`

  <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#permalink: :year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">post/:abbrlink.html</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line"><span class="attr">alg:</span> <span class="string">crc32</span></span><br><span class="line"><span class="attr">rep:</span> <span class="string">hex</span></span><br></pre></td></tr></table></figure>

- 新建文章

  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm i hexo-deployer-git</span><br><span class="line">hexo new post <span class="string">&quot;草稿&quot;</span></span><br><span class="line">hexo cl &amp;&amp; hexo g  &amp;&amp; hexo d  &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>

  

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  首页: https://haiyong.site/ || fas fas fa-home</span><br><span class="line">  资源合集|| fas fa-tags: </span><br><span class="line">    免费资源: https://code.haiyong.site/ziyuan/free/ || fas fa-tools</span><br><span class="line">    网站模板: https://code.haiyong.site/moban/ || fas fa-gamepad</span><br><span class="line">    游戏源码: https://code.haiyong.site/ziyuan/game/ || fas fa-anchor</span><br><span class="line">    编程资料: https://code.haiyong.site/program/ || fas fa-tools</span><br><span class="line">    ppt模板: https://code.haiyong.site/ziyuan/ppt/ || fas fa-gamepad</span><br><span class="line">    PC软件: https://code.haiyong.site/ziyuan/pc/ || fas fa-anchor</span><br><span class="line">  导航||fas fa-list:</span><br><span class="line">    源码资源库: https://code.haiyong.site/ || fas fa-tags</span><br><span class="line">    学习资料: https://haiyong.site/doc/ || fas fa-folder-open</span><br><span class="line">    时间线: /archives/ || fas fa-archive</span><br><span class="line">    标签: /tags/ || fas fa-tags</span><br><span class="line">  摸鱼||fas fa-fish:</span><br><span class="line">    游戏: /moyu/ || fas fa-gamepad</span><br><span class="line">    工具: /tools/ || fas fa-tools</span><br><span class="line">    动画: /demo/ || fas fa-anchor</span><br><span class="line">  摸鱼大军: /chat/ || fas fa-place-of-worship</span><br><span class="line">  友人帐: /link/ || fas fa-link</span><br><span class="line">  关于我: /about/ || fas fa-heart</span><br></pre></td></tr></table></figure>

</div>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Random Article</title>
    <url>/post/0.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>redis的线程</title>
    <url>/post/eca5e3e6.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h2 id="Redis单线程与多线程"><a href="#Redis单线程与多线程" class="headerlink" title="Redis单线程与多线程"></a>Redis单线程与多线程</h2><h3 id="redis单线程"><a href="#redis单线程" class="headerlink" title="redis单线程"></a>redis单线程</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>主要是指Redis的网络IO和键值对读写是由一个线程来完成的，Redis在处理客户端的请求时包括获取(socket 读)、解析、执行、内容返回(socket 写) 等都由一个顺序串行的主线程处理，这就是所谓的“单线程”</p>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul>
<li>使用单线程模型使 Redis 的开发和维护更简单，因为单线程模型方便开发和调试;</li>
<li>即使使用单线程模型也并发的处理多客户端的请求，主要使用的是<code>IO多路复用和非阻塞IO</code>；</li>
<li>对于Redis系统来说，主要的<code>性能瓶颈</code>是内存或者网络带宽而并非 CPU。</li>
</ul>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul>
<li>大key删除会陷入等待   [因为是单线程原子命令操作，这就会导致 Redis 服务卡顿]</li>
<li>随着网络硬件的性能提升，Redis的性能瓶颈有时会出现在网络IO的处理上,单个主线程处理网络请求的速度跟不上底层网络硬件的速度</li>
</ul>
<h3 id="redis多线程"><a href="#redis多线程" class="headerlink" title="redis多线程"></a>redis多线程</h3><blockquote>
<p>Redis的<code>多线程</code>只是用来处理网络请求的，<strong>对于读写操作命令Redis仍然使用单线程来处理</strong></p>
</blockquote>
<h4 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h4><ul>
<li>Redis处理请求时，网络处理经常是瓶颈，通过多个IO线程并行处理网络操作，可以提升实例的整体处理性能。</li>
<li>而继续使用单线程执行命令，就不用为了保证Lua脚本、事务的原子性，额外开发多线程$\textcolor{red}{互斥加锁机制了(不管加锁操作处理)}$，这样一来，Redis线程模型实现就简单了</li>
</ul>
<h4 id="主线程和IO线程协作完成请求处理的过程"><a href="#主线程和IO线程协作完成请求处理的过程" class="headerlink" title="主线程和IO线程协作完成请求处理的过程"></a>主线程和IO线程协作完成请求处理的过程</h4><p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202307031639240.png" alt="image-20230525204935302" style="zoom:33%;"></p>
<h3 id="多线程下操作Redis不会有线程安全问题"><a href="#多线程下操作Redis不会有线程安全问题" class="headerlink" title="多线程下操作Redis不会有线程安全问题"></a>多线程下操作Redis不会有线程安全问题</h3><ul>
<li><p>对于<code>网络数据读写、请求协议解析</code> 是通过多个IO线程的来处理</p>
<p>而命令的执行依旧是由主线程串行执行的</p>
<p>因此在多线程下操作Redis不会出现线程安全的问题</p>
</li>
</ul>
<p><strong>为什么Redis要选择单线程？</strong></p>
<ul>
<li>抛开持久化不谈，Redis是<code>纯内存</code>操作，执行速度非常快，它的性能瓶颈是网络延迟而不是执行速度，因此多线程并不会带来巨大的性能提升。</li>
<li>多线程会导致过多的上下文切换，带来不必要的开销</li>
<li>引入多线程会面临线程安全问题，必然要引入线程锁这样的安全手段，实现复杂度增高，而且性能也会大打折扣</li>
</ul>
<blockquote>
<p>Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器。</p>
<p>Reactor 模式，是指通过一个或多个输入同时传递给服务处理器的服务请求的事件驱动处理模式。服务端程序处理传入多路请求，并将它们同步分派给请求对应的处理线程，Reactor 模式也叫 Dispatcher 模式</p>
</blockquote>
<h2 id="redis-为什么快"><a href="#redis-为什么快" class="headerlink" title="redis 为什么快"></a>redis 为什么快</h2><p><span style="color:red">IO多路复用  + epoll  + 存于内存之中+ 单线程命令+ 提供的数据结构</span></p>
<h2 id="IO多路复用和epoll"><a href="#IO多路复用和epoll" class="headerlink" title="IO多路复用和epoll"></a>IO多路复用和epoll</h2><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><ul>
<li><p>IO多路复用是什么</p>
<p>一种同步的IO模型，实现<font color="red">一个线程</font>监视<font color="green"><code>多个</code>文件句柄(文件描述符),一旦某个文件句柄就绪</font>就能够通知到对应的应用程序进行相应的读写操作，<font color="red">没有文件句柄就绪时</font>就会阻塞应用程序从而释放CPU资源</p>
<ul>
<li>多路：多个客户端连接(连接就是套接字描述符，即 socket 或者 channel)</li>
<li>复用：复用一个或几个线程</li>
<li>IO多路复用：就是一个或一组线程处理多个TCP连接，使用单进程就能够实现同时处理多个客户端的连接，<font color="red">无需创建或者维护过多的进程/线程</font></li>
<li>实现IO多路复用的模型有3种: 可以分<code>select-&gt;poll-&gt;epoll</code>三个阶段来描述。</li>
</ul>
</li>
</ul>
<p>IO多路复用原理: 有请求就响应，没请求不打扰</p>
<p>采用多路/O复用技术可以让单个线程高效的处理多个连接请求一个服务端进程可以同时处理多个套接字描述符。</p>
<ul>
<li>浅谈<code>epoll</code>是什么</li>
</ul>
<blockquote>
<p>浅记：你站在讲台上等，谁解答完谁举手。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案然后继续回到讲台上等] 此时E、A又举手，然后去处理E和A。。。这种就是IO复用模型。</p>
</blockquote>
<ul>
<li><p>工作原理：</p>
<ul>
<li><p>将用户socket对应的文件描述符(FileDescriptor)注册进epoll，然后epoll帮你监听哪些socket上有消息到达，这样就避免了大量的无用操作。</p>
</li>
<li><p>此时的socket应该采用<font color="red">非阻塞模式</font>。这样，整个过程只在调用<code>select、poll、epoll</code>这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的<code>reactor反应模式</code></p>
</li>
</ul>
</li>
</ul>
<h3 id="深入"><a href="#深入" class="headerlink" title="深入"></a>深入</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a><font color="red">是什么</font></h4><p>I/O  : 网络 I/O</p>
<p>多路 : 多个客户端连接（连接就是套接字描述符，即socket 或者 channel），指的是多条 TCP 连接</p>
<p>复用:    用一个进程来处理多条的连接，使用单进程就能实现同时处理多个客户端的连接</p>
<p>IO多路复用: 实现了用一个进程来处理大量的用户连接</p>
<p>文件描述符（File Descriptor）：简称FD，是一个从0 开始的无符号整数，用来关联Linux中的一个文件。在Linux中，一切皆文件。</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a><font color="red">定义</font></h4><p>IO多路复用是<code>利用单个线程</code>来同时<code>监听多个FD</code>，并在某个FD可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。不过<code>监听FD的方式、通知的方式又有多种实现</code>，常见的有：</p>
<ul>
<li><code>select</code></li>
<li><code>poll</code></li>
<li><code>epoll</code></li>
</ul>
<p>其中select和pool相当于<code>是当被监听的数据准备好之后</code>，会把你监听的FD整个数据都发给你，你需要到整个FD中去找，哪些是处理好了的，需要通过遍历的方式，所以性能也并不是那么好</p>
<p>而epoll，则相当于内核准备好了之后，他会把准备好的数据，直接发给你，省去了遍历的动作。</p>
<h4 id="差异"><a href="#差异" class="headerlink" title="差异"></a><font color="red">差异</font></h4><ul>
<li><code>select和poll</code>只会通知用户进程有FD就绪，但不确定具体是哪个FD,需要用户进程逐个遍历FD来确认</li>
<li><code>epol</code>则会在通知用户进程FD就绪的同时，把已就绪的FD写入用户空间</li>
</ul>
<h4 id="Select"><a href="#Select" class="headerlink" title="Select"></a><code>Select</code></h4><p>存在的问题：</p>
<ul>
<li>需要将整个<code>fd_set</code>从用户空间拷贝到内核空间，select结束还要再次拷贝回用户空间<code>2次拷贝</code></li>
<li>select无法得知具体是哪个fd就绪，需要遍历整个<code>fd_set</code>    就是说他<code>知道有几个就绪 但是不知道具体是谁就绪了</code></li>
<li><code>fd_set</code>监听的fd数量不能超过1024  <code>数量上有限制</code></li>
</ul>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202307031639980.png" alt="image-20230527214058848" style="zoom:55%;"></p>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a><code>poll</code></h4><p>IO流程： &lt;和select差不多,唯一的改进就是 增加了监听的fd 数量，但是  监听FD越多，每次遍历消耗时间也越久，性能反而会下降 &gt;</p>
<ul>
<li>创建<code>pollfd数组</code>，向其中添加关注的fd信息，数组大小自定义</li>
<li>调用<code>poll函数</code>，将<code>pollfd数组</code>拷贝到内核空间，转链表存储，<code>无上限</code></li>
<li>内核遍历fd，判断是否就绪</li>
<li>数据就绪或超时后，拷贝<code>pollfd</code>数组到用户空间，返回就绪fd数量n</li>
<li>用户进程判断n是否大于0,大于0则遍历pollfd数组，找到就绪的fd数量</li>
</ul>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a><code>epoll</code></h4><ul>
<li><p>是非阻塞的</p>
</li>
<li><p>大大减少了fd拷贝的次数，大大减少了fd拷贝的数量</p>
</li>
<li><p>监听的FD理论上无上限</p>
</li>
</ul>
<blockquote>
<p>多路复用快的原因在于，操作系统提供了<code>epoll</code>系统调用，使得原来的whi训e循环里多次系统调用，变成了<code>一次系统调用+内核层遍历这些文件描述符</code></p>
<p>epoll 将拷贝与等待分开了</p>
<p>epoll_ctl:  进行拷贝，只会拷贝一次</p>
<p>epoll_wait:  等待就绪，之后每次只调用<code>epoll_wait</code>进行等待就可以了，无需再次拷贝</p>
</blockquote>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202307031639013.jpg" alt="202305272200567"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><code>总结</code></h4><blockquote>
<p>select模式存在的三个问题：</p>
</blockquote>
<ul>
<li>能监听的FD最大不超过1024</li>
<li>每次select都需要把所有要监听的FD都拷贝到内核空间</li>
<li>每次都要遍历所有FD来判断就绪状态</li>
</ul>
<blockquote>
<p>poll模式的问题：</p>
</blockquote>
<ul>
<li>poll利用链表解决了select中监听FD上限的问题，但依然要遍历所有FD，如果监听较多，性能会下降</li>
</ul>
<blockquote>
<p>epoll模式中如何解决这些问题的？</p>
</blockquote>
<ul>
<li>基于epoll实例中的<code>红黑树</code>保存要监听的FD，理论上无上限，而且增删改查效率都非常高</li>
<li>每个FD只需要执行一次<code>epoll_ctl</code>添加到<code>红黑树</code>，以后每次<code>epol_wait</code>无需传递任何参数，无需重复拷贝<code>FD</code>到内核空间</li>
<li>利用<code>ep_poll_callback</code>机制来监听FD状态，无需遍历所有FD，因此性能不会随监听的FD数量增多而下降</li>
</ul>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202307031639480.png" alt="image-20230528000644005" style="zoom: 43%;"></p>
<h4 id="事件通知机制"><a href="#事件通知机制" class="headerlink" title="事件通知机制"></a><font color="red">事件通知机制</font></h4><p>当FD有数据可读时，我们调用<code>epoll_wait（或者select、poll）</code>可以得到通知。但是事件通知的模式有两种：</p>
<ul>
<li>LevelTriggered：简称LT，也叫做<code>水平触发</code>。只要某个FD中有数据可读，每次调用<code>epoll_wait</code>都会得到通知。</li>
<li>EdgeTriggered：简称ET，也叫做<code>边沿触发</code>。只有在某个FD有状态变化时，调用<code>epoll_wait</code>才会被通知。</li>
</ul>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202307031639760.png" alt="image-20230527220918750" style="zoom:45%;"></p>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305272214385.png" alt="image-20230527221455305" style="zoom:43%;"></p>
<h2 id="redis网络模型"><a href="#redis网络模型" class="headerlink" title="redis网络模型"></a><code>redis网络模型</code></h2>]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建整个博客的过程简单记录</title>
    <url>/post/44109.html</url>
    <content><![CDATA[<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
  <iframe src="//player.bilibili.com/player.html?aid=xxx&cid=yyy&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe>
</div>
]]></content>
  </entry>
  <entry>
    <title>redis缓存</title>
    <url>/post/d27b7f98.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">



<h2 id="缓存四问"><a href="#缓存四问" class="headerlink" title="缓存四问"></a>缓存四问</h2><h3 id="1-缓存预热"><a href="#1-缓存预热" class="headerlink" title="1.缓存预热"></a>1.缓存预热</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a><font color="red">是什么</font></h4><ul>
<li>缓存预热就是系统上线后，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据进行写回到缓存的问题！用户直接查询事先被预热的缓存数据！</li>
</ul>
<h4 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a><font color="red">怎么做</font></h4><ul>
<li>将热点数据提前加载到<code>redis</code>缓存中，可以通过<code>@PostConstruct</code>提前在运行某个程序之前，将其加载到<code>redis</code>中</li>
<li>或者使用 <code>Spring FrameFramework 提供的接口CommandLineRunner 自定义 预加载类在程序启动的时候</code>存到<code>redis</code>中</li>
</ul>
<h3 id="雪崩"><a href="#雪崩" class="headerlink" title="雪崩"></a>雪崩</h3><h4 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a><font color="red">是什么</font></h4><ul>
<li>缓存雪崩就是同一时段大量的缓存<code>key</code>同时失效或者<code>Redis服务宕机</code>，导致大量请求到达数据库，给数据库带来巨大压力。</li>
</ul>
<h4 id="何时发生"><a href="#何时发生" class="headerlink" title="何时发生"></a><font color="red">何时发生</font></h4><ul>
<li>Redis主机挂了，Redis全盘<code>崩溃</code></li>
<li>Redis中有大量<code>key同时</code>过期<code>大面积失效</code>，</li>
</ul>
<h4 id="解决-与-预防"><a href="#解决-与-预防" class="headerlink" title="解决 与 预防"></a><font color="red">解决 与 预防</font></h4><ul>
<li>Redis中key设置为<code>永不过期</code>或者过期时间为<code>指定时间+随机时间</code>，<code>错开同时过期的概率</code></li>
<li><p>Redis缓存集群实现高可用 [ <code>主从+哨兵</code>   <code>集群</code>  <code>开启Redis持久化机制AOF/RDB，尽快恢复缓存集群</code>]</p>
</li>
<li><p>多级缓存结合预防雪崩   <code>ehcache本地缓存 + Redis缓存</code></p>
</li>
<li><p>服务降级               <code>Hystrix</code>或者阿里<code>sentinel</code>限流&amp;降级</p>
</li>
</ul>
<h3 id="击穿"><a href="#击穿" class="headerlink" title="击穿"></a>击穿<redis 先有后失效></redis></h3><h4 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a><font color="red">是什么</font></h4><ul>
<li>大量请求同时查询一个key时，此时这个key正好失效了，就会导致大量的请求都打到数据库，<font color="red">就是热点key突然失效了，MySQL压力增加</font></li>
</ul>
<h4 id="热点key失效可能"><a href="#热点key失效可能" class="headerlink" title="热点key失效可能"></a><font color="red">热点key失效可能</font></h4><ul>
<li>时间到了自然清除但还是被访问到</li>
<li>delete掉的key，刚好又被访问到</li>
</ul>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a><font color="red">解决</font></h4><ul>
<li>方案一：差异失效时间，对于访问频繁的热点key，干脆就<code>不设置过期时间</code>   而是设置<code>逻辑过期时间</code>，但是会有一定的数据不一致性</li>
<li><font color="red">方案二：互斥锁，互斥更新，采用双检加锁策略</font>        多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个互斥锁来锁住它。其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存</li>
</ul>
<h3 id="穿透-lt-两库都没-gt"><a href="#穿透-lt-两库都没-gt" class="headerlink" title="穿透&lt;两库都没&gt;"></a>穿透&lt;两库都没&gt;</h3><h4 id="是什么-3"><a href="#是什么-3" class="headerlink" title="是什么"></a><font color="red">是什么</font></h4><ul>
<li>请求去查询一条记录，先查redis，后查mysql，都查询不到，说明数据源是不存在的，但是请求每次都会打到数据库上面去，导致后台数据库压力暴增，这种现象我们称为缓存穿透</li>
</ul>
<h4 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a><font color="red">解决</font></h4><ol>
<li>使用布隆过滤器(<code>Guava</code>)</li>
<li>对空对象缓存</li>
</ol>
<ul>
<li><p>回写增强: 如果发生了缓存穿透，我们可以针对要查询的数据，在Redis里存一个规定的缺省值(比如,零、负数、defaultNull等)</p>
<p>第一次来查询一旦 <code>redis</code>和<code>mysql</code>都没有，返回<code>nul</code>给<code>调用者</code>，同时也让<code>redis</code>存入刚刚查不到的<code>key</code>，并对应的填上<code>规定的缺省值</code>，那么第二次来查，此时redis就有值了。</p>
</li>
</ul>
<blockquote>
<p>对空值缓存的弊端</p>
<ul>
<li><p>一旦多次穿透，redis就会有很多 垃圾 key ，占用内存（可以设置ttl定期删除），</p>
</li>
<li><p>但是因为这个<code>ttl</code> 可能会导致数据短期的不一致性 [mysql新增数据的时候同时存到redis,同样会有内存问题]</p>
<p>所以没有根本不能解决问题</p>
</li>
</ul>
</blockquote>
<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202307031742656.png" alt="image-20230526130227733" style="zoom:33%;"></p>
<h2 id="缓存删除过期键的策略"><a href="#缓存删除过期键的策略" class="headerlink" title="缓存删除过期键的策略"></a>缓存删除过期键的策略</h2><h3 id="Redis-过期键的删除策略"><a href="#Redis-过期键的删除策略" class="headerlink" title="Redis 过期键的删除策略"></a>Redis 过期键的删除策略</h3><ul>
<li><p>立即删除      对CPU不友好，用处理器性能换取存储空间（拿时间换空间）</p>
</li>
<li><p>惰性删除      对 内存 不友好，用存储空间换取处理器性能（拿空间换时间）</p>
</li>
<li><p>定期删除    每隔一段时间执行一次删除过期键操作并通过限制删除操作执行时长和频率来减少删除操作对CPU时间的影响。定期抽样key，判断是否过期</p>
</li>
</ul>
<blockquote>
<p>定期清理的<code>两种模式</code>：</p>
<ol>
<li><p><code>SLOW</code>模式执行频率默认为10，每次不超过25ms</p>
</li>
<li><p><code>FAST</code>模式执行频率不固定，但两次间隔不低于2ms，每次耗时不超过1ms</p>
</li>
</ol>
</blockquote>
<h2 id="缓存淘汰的策略"><a href="#缓存淘汰的策略" class="headerlink" title="缓存淘汰的策略"></a>缓存淘汰的策略</h2><h3 id="redis-缓存淘汰策略"><a href="#redis-缓存淘汰策略" class="headerlink" title="redis 缓存淘汰策略"></a>redis 缓存淘汰策略</h3><h4 id="主要两类："><a href="#主要两类：" class="headerlink" title="主要两类："></a>主要两类：</h4><ul>
<li>LRU   <code>最近最少</code>使用的页面置换算法，淘汰最长时间未被使用的页面，看页面<code>最后一次被使用到发生调度的时间长短</code>，首先<code>淘汰最长时间未被使用</code>的页面</li>
<li>LFU   <code>最近最不常用</code>页面置换算法，淘汰一定时期内被访问次数最少的页面，看<code>一定时间段内被访问次数最少的页</code>，<code>看一定时间段内页面被使用的频率</code>，淘汰一定时期内被访问<code>次数最少的页</code></li>
</ul>
<h4 id="细分8类："><a href="#细分8类：" class="headerlink" title="细分8类："></a>细分8类：</h4><ul>
<li>noevication ： <code>不会驱逐任何key</code>，表示<code>即使内存达到上限也不进行置换</code>，所有能引起内存增加的命令都返回 error，<code>默认</code>就是这种策略。</li>
<li><code>allkeys-lru</code>： 对所有key使用 LRU算法进行删除，<code>优先删除掉最近不经常使用的key</code>，用以保存新数据  <code>工作中常用</code></li>
<li><code>volatie</code>-lru : 对所有<code>设置了过期时间的key</code>使用<code>LRU 算法</code>删除</li>
<li>allkeys-random ：对所有key<code>随机删除</code></li>
<li><code>volatie</code>-random ： 对所有<code>设置了过期时间的key</code> <code>随机删除</code></li>
<li>volatie-ttl ：对所有设置了过期时间的key<code>随即删除</code></li>
<li>allkeys-lfu：对所有key使用LFU算法进行删除</li>
<li>volatile-lfu：对所有设置了过期时间的key使用LFU算法进行删除</li>
</ul>
<blockquote>
<p>上面8种模式:   2 * 4 =8、<code>2</code>个维度(过期键中筛选、所有键中筛选)、<code>4</code>个方面(LRU、LFU、random、ttl)、<code>8</code>个选项</p>
</blockquote>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202307031742321.png" alt="image-20230527223142532" style="zoom=55%;"></p>
<h3 id="选择原则"><a href="#选择原则" class="headerlink" title="选择原则"></a>选择原则</h3><ul>
<li><p>在所有的key都是最近最经常使用，那么就需要选择<code>allkeys-lru</code>进行置换最近最不经常使用的key,如果你不确定使用哪种策略，那么推荐使用<code>allkeys-lru</code></p>
</li>
<li><p>如果所有的key的访问概率都是差不多的，那么可以选用<code>allkeys-random</code>策略去置换数据</p>
</li>
<li><p>如果对数据有足够的了解，能够为key指定<code>hint</code>(通过<code>expire/ttl</code>指定)，那么可以选择<code>volatile-ttl</code>进行置换</p>
</li>
</ul>
<h3 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h3><ul>
<li><code>避免</code>存储bigkey</li>
<li>redis缓存淘汰策略配置性能建议<code>开启橢性淘汰</code>，<code>lazyfree-lazy-eviction=yes</code></li>
</ul>
<h2 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h2><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><ul>
<li>如果redis中<font color="red">有数据</font> ，需要和数据库中的值相同</li>
<li>如果redis中<font color="red">无数据</font> ，数据库中的值要是最新值，且准备回写redis</li>
</ul>
<h3 id="缓存一致性的2种发生情况"><a href="#缓存一致性的2种发生情况" class="headerlink" title="缓存一致性的2种发生情况"></a>缓存一致性的2种发生情况</h3><ul>
<li><p><code>只读缓存</code></p>
</li>
<li><p><code>读写缓存</code></p>
<ul>
<li><p>同步直写策略<code>[就是只要查到数据库就立刻回写到缓存，保持同步,及时生效]</code></p>
<ul>
<li><p>写数据库之后也同步写redis缓存，缓存和数据库中的数据一致；</p>
</li>
<li><p>对于读写缓存来说，要想保证缓存和数据库中的数据一致，就要采用<code>同步直写策略</code></p>
</li>
</ul>
</li>
<li><p>异步缓写策略<code>[业务上有一定的延时允许]</code></p>
<ul>
<li><p>正常业务中，MySQL数据变了，但是可以在业务上容许出现一定时间后才作用于redis，比如仓库、物流系统</p>
</li>
<li><p>异常情况出现了， 不得不将失败的动作重新修补，有可能需要借助kafka或者RabbitMQ等消息中间件，实现重试重写</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="优化使用"><a href="#优化使用" class="headerlink" title="优化使用"></a>优化使用</h3><blockquote>
<p> 采用  <code>双检加锁</code>的思想</p>
</blockquote>
<h4 id="没有加锁的隐患："><a href="#没有加锁的隐患：" class="headerlink" title="没有加锁的隐患："></a>没有加锁的隐患：</h4><ol>
<li><p>对于mysql的请求会大量增加<code>（mysql会被打爆）</code>0</p>
</li>
<li><p>对于redis 的回写操作可能会 数据覆盖（不是原子操作，多线程就会并发，引发问题）</p>
</li>
</ol>
<h4 id="实现思路："><a href="#实现思路：" class="headerlink" title="实现思路："></a>实现思路：</h4><p>当有多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个<code>互斥锁</code>来锁住它。</p>
<p>其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存；后面的线程进来发现已经有缓存了，就直接走缓存。</p>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202307031742344.png" alt="image-20230525225420679" style="zoom: 25%;"></p>
<h3 id="一致性的更新策略"><a href="#一致性的更新策略" class="headerlink" title="一致性的更新策略"></a>一致性的更新策略</h3><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>达到数据的 <code>最终一致性</code></p>
<h4 id="一致性要求"><a href="#一致性要求" class="headerlink" title="一致性要求"></a>一致性要求</h4><h5 id="弱一致性："><a href="#弱一致性：" class="headerlink" title="弱一致性："></a>弱一致性：</h5><ul>
<li>过期剔除：   使用<code>redis</code>的内存淘汰机制 ； <font color="blue">给缓存设置过期时间，定期清理缓存并回写，是保证最终一致性的解决方案。</font></li>
</ul>
<p>我们可以对存入缓存的数据设置过期时间，所有的<font color="red">写操作以数据库为准</font>，对缓存操作只是尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存，达到一致性，<font color="red">切记，要以mysql的数据库写入库为准</font>。</p>
<h5 id="强一致性："><a href="#强一致性：" class="headerlink" title="强一致性："></a>强一致性：</h5><ol>
<li>可以停机：停机升级，服务降级</li>
<li><p>不可以停机：四种策略</p>
<ul>
<li><p>先更新数据库，在更新缓存</p>
</li>
<li><p>先更新缓存，再更新数据库</p>
</li>
<li><p>先删除缓存，在更新数据库</p>
</li>
<li><p>先更新数据库，在删除缓存</p>
</li>
</ul>
</li>
</ol>
<h4 id="细说四种方式"><a href="#细说四种方式" class="headerlink" title="细说四种方式"></a>细说四种方式</h4><h5 id="先更新数据库，再更新缓存"><a href="#先更新数据库，再更新缓存" class="headerlink" title="先更新数据库，再更新缓存"></a><span style="color:red">先更新数据库，再更新缓存</span></h5><h6 id="异常情况："><a href="#异常情况：" class="headerlink" title="异常情况："></a><strong>异常情况：</strong></h6><p>多线程环境下，A、B两个线程有快有慢，有前有后有并行</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1 A update mysql 100</span><br><span class="line">3 B update mysql 80</span><br><span class="line">4 B update redis 80</span><br><span class="line">2 A update redis 100</span><br></pre></td></tr></table></figure>
<p>最终结果，mysql和lredis数据不一致，  <code>mysql  80,redis   100</code></p>
<h5 id="先更新缓存，再更新数据库"><a href="#先更新缓存，再更新数据库" class="headerlink" title="先更新缓存，再更新数据库"></a><span style="color:red">先更新缓存，再更新数据库</span></h5><h6 id="异常情况：-1"><a href="#异常情况：-1" class="headerlink" title="异常情况："></a><strong>异常情况</strong>：</h6><p>多线程环境下，A、B两个线程有快有慢，有前有后有并行</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">A update redis 100</span><br><span class="line">B update redis 80</span><br><span class="line">B update mysql 80</span><br><span class="line">A update mysql 100</span><br><span class="line">mysql 100,redis 80</span><br></pre></td></tr></table></figure>
<p>最终结果，mysql和lredis数据不一致，  <code>mysql  100,redis  80</code></p>
<h5 id="先删除缓存，再更新数据库"><a href="#先删除缓存，再更新数据库" class="headerlink" title=" 先删除缓存，再更新数据库 "></a><span style="color:red"> 先删除缓存，再更新数据库 </span></h5><h6 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a><strong>异常情况</strong></h6><ol>
<li><p>A线程先成功删除了redis里面的数据，然后去更新mysql,  此时mysql正在更新中，还没有结束。(比如网络延时)</p>
</li>
<li><p>B突然出现要来读取缓存数据。此时redis里面的数据是空的，B线程来读取，先去读redis里数据(已经被A线程delete掉了)，</p>
</li>
</ol>
<p>此处出来2个问题:<br>2.1 B从mysql获得了旧值   B线程发现redis里没有(缓存缺失)马上去mysql里面读取，从数据库里面读取来的是旧值。<br>2.2 B会把获得的旧值写回redis  获得旧值数据后返回前台并回写进redis(刚被A线程删除的旧数据有极大可能早被写回了)。</p>
<ol>
<li><p>就是说   A线程更新完mysql,发现redis里面的缓存是脏数据，两个并发操作，一个是更新操作，另一个是查询操作，A删除缓存后，B查询操作没有命中缓存，B先把老数据读出来后放到缓存中，然后A更新操作更新了数据库。于是，在缓存中的数据还是老的数据，导致缓存中的数据是脏的，而且还一直这样脏下去了。</p>
</li>
<li><p>总结流程:<br>(1)请求A进行写操作，删除redis缓存后，工作正在进行中，更新mysql….. A还没有彻底更新完mysql,还没commit<br>(2)请求B开工查询，查询redis发现缓存不存在(被A从redis中删除了)<br>(3)请求B继续，去数据库查询得到了mysql中的旧值(A还没有更新完)<br>(4)请求B将旧值写回redis缓存<br>(5)请求A将新值写入mysql数据库</p>
</li>
</ol>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202307031742941.png" alt="image-20230525231633568" style="zoom:43%;"></p>
<p>问题：如果数据库更新失败或超时或返回不及时，导致B线程请求访问缓存时发现redis里面没数据，缓存缺失，B再去读取mysql时，从数据库中读取到旧值，还写回redis， 导致A白干了</p>
<h6 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a><strong>解决方案：</strong></h6><blockquote>
<p>$\textcolor{blue}{\large延时双删}$：<font color="red">采用<code>延时双删</code>[ 在第一次删除缓存值后，延迟一段时间再次进行删除]  策略 </font></p>
</blockquote>
<p>主要思想就是： 让一个线程删除前先进行休眠，并且其sleep的时间  需要大于另一个正在进行  <code>读取数据+ 写入缓存</code>的线程 的耗时之和</p>
<h6 id="追问"><a href="#追问" class="headerlink" title="追问"></a><font color="red"><strong>追问</strong></font></h6><ul>
<li><p><strong>这个删除该休眠多久呢</strong>？</p>
<ul>
<li>线程A <code>sleep的时间</code>，就需要<code>大于</code>线程B<code>读取数据再写入缓存的时间之和</code>。</li>
</ul>
</li>
<li><p><strong>这个时间怎么确定呢</strong>?</p>
<font color="blue">第一种方法：</font>在业务程序运行的时候，统计下线程读数据和写缓存的操作时间，`自行评估`自己的项目的读数据业务逻辑的耗时，以此为基础来进行估算。然后写数据的`休眠时间`则在`读数据业务逻辑的耗时基础上`加`百毫秒`即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。
<font color="blue">第二种方法：</font><font color="blue">新启动一个后台监控程序，比如 `WatchDog`监控程序，会自动续费加时</font>
</li>
<li><p><strong>这种同步淘汰策略，吞吐量降低怎么办？</strong></p>
<ul>
<li>将第二次删除作为异步的，再启动一个线程进行异步删除，就可以不让写请求进行sleep 之后再返回，即可加大吞吐量</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202307031742326.png" alt="image-20230525233149371" style="zoom:50%;"></p>
<p>​</p>
<h5 id="先更新数据库，再删除缓存"><a href="#先更新数据库，再删除缓存" class="headerlink" title=" 先更新数据库，再删除缓存 "></a><span style="color:red"> 先更新数据库，再删除缓存 </span></h5><div class="table-container">
<table>
<thead>
<tr>
<th>时间</th>
<th>线程A</th>
<th>线程B</th>
<th>出现的问题</th>
</tr>
</thead>
<tbody>
<tr>
<td>t1</td>
<td>更新数据库中的值……</td>
<td></td>
<td></td>
</tr>
<tr>
<td>t2</td>
<td></td>
<td>缓存立刻命中，此时B读取的是缓存旧值</td>
<td>A还没来得及删除缓存的值，导致B缓存命中读到旧值</td>
</tr>
<tr>
<td>t3</td>
<td>更新缓存的数据，over</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h6 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h6><p>先更新数据库，在删除缓存，假如缓存删除失败或者来不及删除，导致请求再次访问redis时缓存命中，<font color="red">读取到的是缓存的旧值。</font></p>
<h6 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h6><ul>
<li>使用MQ</li>
<li>使用 基于 订阅MySQL的 binlog程序的中间件<code>canal</code>   [代码0侵入，所以会更优]</li>
</ul>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202307031742833.png" alt="image-20230525233703703" style="zoom:35%;"></p>
<p>使用<code>消息队列</code>的基本思想</p>
<ul>
<li>可以把要删除的缓存值或者是要更新的数据库值<code>暂存</code>到<code>消息队列</code>中（例如使用Kafka/RabbitMQ等)。</li>
<li>当程序<code>没有能够成功地删除</code>缓存值或者是更新数据库值时，可以从消息队列中<code>重新读取</code>这些值，然后再次进行删除或更新。</li>
<li>如果<code>能够成功地删除或更新</code>，我们就要把这些值<code>从消息队列中去除</code>，以免重复操作，此时，我们也可以保证数据库和缓存的数据一致了，否则还需要再次进行重试</li>
<li>如果<code>重试超过的一定次数后还是没有成功</code>，我们就需要向业务层发送报错信息了，通知运维人员。</li>
</ul>
<p>此种模式下严格意义上的 <code>强一致性</code>：</p>
<ul>
<li>如果业务层要求必须读取一致性的数据，那么我们就需要在更新数据库时，先在Redis缓存客户端暂停并发读请求，等数据库更新完、缓存值删除后，再读取数据，从而保证数据一致性</li>
</ul>
<font color="blue" size="4">只能达到最终一致性!!!!</font>



<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305262244890.png" alt="image-20230526224429842" style="zoom:35%;"></p>
<h4 id="textcolor-red-总结"><a href="#textcolor-red-总结" class="headerlink" title="$\textcolor{red}{总结}$"></a>$\textcolor{red}{总结}$</h4><div class="table-container">
<table>
<thead>
<tr>
<th>策略</th>
<th>是否是高并发多线程条件下</th>
<th>问题</th>
<th>现象</th>
<th>解决方案</th>
</tr>
</thead>
<tbody>
<tr>
<td>先删再更</td>
<td>否</td>
<td>缓存删除成功但数据库更新失败</td>
<td>Java程序从数据库中读到旧值</td>
<td>再次更新数据库，重试</td>
</tr>
<tr>
<td>先删再更</td>
<td>是</td>
<td>缓存删除成功但数据库更新中…有并发请求</td>
<td>并发请求从数据库读到旧值并回写到redis，导致后续都是从redis读取到旧值</td>
<td>延迟双删</td>
</tr>
<tr>
<td>先更再删</td>
<td>否</td>
<td>数据库更新成功，但缓存删除失败</td>
<td>Java程序从redis中读到旧值</td>
<td>再次删除缓存，重试</td>
</tr>
<tr>
<td>先更再删</td>
<td>是</td>
<td>数据库更新成功但缓存删除中……有并发读请求</td>
<td>并发请求从缓存读到旧值</td>
<td>等待redis删除完成，这段时间数据不一致，短暂存在。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="三种缓存的设计模式："><a href="#三种缓存的设计模式：" class="headerlink" title="三种缓存的设计模式："></a>三种缓存的设计模式：</h2><ul>
<li><p><code>Cache Aside Pattern</code> 旁路缓存模式：缓存调用者在<code>更新完数据库后再去更新缓存</code>，也称之为双写方案</p>
</li>
<li><p><code>Read/Write Through Pattern</code> 读写穿透模式: 由系统本身完成，<code>数据库与缓存的问题交由系统本身去处理</code></p>
</li>
<li><p><code>Write Behind Caching Pattern</code> 异步缓存写入模式：调用者只操作缓存，其他线程去<code>异步处理数据库</code>，实现最终一致</p>
</li>
</ul>
<h4 id="如何保证缓存与数据库的操作的同时成功或失败"><a href="#如何保证缓存与数据库的操作的同时成功或失败" class="headerlink" title="如何保证缓存与数据库的操作的同时成功或失败"></a>如何保证缓存与数据库的操作的同时成功或失败</h4><ul>
<li>单体系统，将缓存与数据库操作放在一个<code>事务</code></li>
<li>分布式系统，利用<code>TCC等分布式事务</code>方案</li>
</ul>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis 源码</title>
    <url>/post/e8b61f90.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">


<h2 id="redis数据结构"><a href="#redis数据结构" class="headerlink" title="redis数据结构"></a>redis数据结构</h2><h3 id="redis6-数据结构"><a href="#redis6-数据结构" class="headerlink" title="redis6 数据结构"></a>redis6 数据结构</h3><p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202307031648466.png" alt="image-20230526172020470" style="zoom:33%;"></p>
<h3 id="redis7-数据结构"><a href="#redis7-数据结构" class="headerlink" title="redis7    数据结构"></a>redis7    数据结构</h3><p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202307031648946.png" alt="image-20230526171836200" style="zoom:33%;"></p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202307031648219.png" alt="image-20230526172050397" style="zoom:25%;"></p>
<h2 id="底层数据结构种类"><a href="#底层数据结构种类" class="headerlink" title="底层数据结构种类"></a>底层数据结构种类</h2><h3 id="动态字符串"><a href="#动态字符串" class="headerlink" title="动态字符串"></a>动态字符串</h3><ul>
<li>获取字符串长度的时间复杂度为O(1)</li>
<li>支持动态扩容</li>
<li>减少内存分配次数</li>
<li>二进制安全</li>
</ul>
<h3 id="intset"><a href="#intset" class="headerlink" title="intset"></a>intset</h3><ul>
<li>Redis会确保Intset中的元素唯一、有序</li>
<li>具备类型升级机制，可以节省内存空间</li>
<li>底层采用二分查找方式来查询</li>
</ul>
<h3 id="Dict"><a href="#Dict" class="headerlink" title="Dict"></a>Dict</h3><p>键与值的映射关系正是通过Dict来实现的</p>
<p>Dict由三部分组成，分别是：哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）</p>
<p>Dict的伸缩：</p>
<ul>
<li>当LoadFactor大于5或者LoadFactor大于1并且没有子进程任务时，Dict扩容</li>
<li>当LoadFactor小于0.1时，Dict收缩</li>
<li>扩容大小为第一个大于等于used + 1的2^n</li>
<li>收缩大小为第一个大于等于used 的2^n</li>
<li>Dict采用渐进式rehash，每次访问Dict时执行一次rehash</li>
<li>rehash时ht[0]只减不增，新增操作只在ht[1]执行，其它操作在两个哈希表</li>
</ul>
<h3 id="ZipList"><a href="#ZipList" class="headerlink" title="ZipList"></a>ZipList</h3><p>一种特殊的“双端链表” ,由一系列特殊编码的连续内存块组成。可以在任意一端进行压入/弹出操作, 并且该操作的时间复杂度为 O(1)。</p>
<p><strong>ZipList特性：</strong></p>
<ul>
<li>压缩列表的可以看做一种连续内存空间的”双向链表”</li>
<li>列表的节点之间不是通过指针连接，而是记录上一节点和本节点长度来寻址，内存占用较低</li>
<li>如果列表数据过多，导致链表过长，可能影响查询性能</li>
<li>增或删较大数据时有可能发生连续更新问题</li>
</ul>
<h3 id="QuickList"><a href="#QuickList" class="headerlink" title="QuickList"></a>QuickList</h3><p>问题1：ZipList虽然节省内存，但申请内存必须是连续空间，如果内存占用较多，申请内存效率很低。怎么办？</p>
<p>​    答：为了缓解这个问题，我们必须限制ZipList的长度和entry大小。</p>
<p>问题2：但是我们要存储大量数据，超出了ZipList最佳的上限该怎么办？</p>
<p>​    答：我们可以创建多个ZipList来分片存储数据。</p>
<p>问题3：数据拆分后比较分散，不方便管理和查找，这多个ZipList如何建立联系？</p>
<p>​    答：Redis在3.2版本引入了新的数据结构QuickList，它是一个双端链表，只不过链表中的每个节点都是一个ZipList。</p>
<p>特点</p>
<ul>
<li>是一个节点为ZipList的双端链表</li>
<li>节点采用ZipList，解决了传统链表的内存占用问题</li>
<li>控制了ZipList大小，解决连续内存空间申请效率问题</li>
<li>中间节点可以压缩，进一步节省了内存</li>
</ul>
<h3 id="SkipList"><a href="#SkipList" class="headerlink" title="SkipList"></a>SkipList</h3><p><code>SkipList</code>（跳表）首先是链表，但与传统链表相比有几点差异：</p>
<ul>
<li>元素按照升序排列存储</li>
<li>节点可能包含多个指针，指针跨度不同。</li>
</ul>
<p><code>SkipList</code>的特点：</p>
<ul>
<li>跳跃表是一个双向链表，每个节点都包含score和ele值</li>
<li>节点按照score值排序，score值一样则按照ele字典排序</li>
<li>每个节点都可以包含多层指针，层数是1到32之间的随机数</li>
<li>不同层指针到下一个节点的跨度不同，层级越高，跨度越大</li>
<li>增删改查效率与红黑树基本一致，实现却更简单</li>
</ul>
<h3 id="RedisObject"><a href="#RedisObject" class="headerlink" title="RedisObject"></a>RedisObject</h3><p>Redis中的任意数据类型的键和值都会被封装为一个<code>RedisObject</code>，也叫做Redis对象</p>
<h2 id="源码级别"><a href="#源码级别" class="headerlink" title="源码级别"></a>源码级别</h2><blockquote>
<p>WILLDO</p>
</blockquote>
]]></content>
      <categories>
        <category>redis</category>
        <category>Future</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>单机redis基本概念</title>
    <url>/post/691706ae.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">


<h2 id="NoSQL的特点："><a href="#NoSQL的特点：" class="headerlink" title="NoSQL的特点："></a><code>NoSQL</code>的特点：</h2><ol>
<li><p>相对于<code>MySQL</code>这样的<code>关系型</code>数据库来说，<code>非关系型</code>的数据库是基于内存操作的，读写速度非常的快，性能好些，</p>
</li>
<li><p>关系型数据库一般使用<code>主从集群</code>的模式保证数据的一致性，进行数据的备份，即为垂直扩展；<code>非关系型</code>数据库是将<code>数据进行拆分</code>，分别存储在不同的机器上，用来保存海量的数据，解决<code>内存大小受限的问题</code>，即为水平扩展</p>
</li>
</ol>
<h2 id="resdis的基本数据类型"><a href="#resdis的基本数据类型" class="headerlink" title="resdis的基本数据类型"></a><code>resdis</code>的基本数据类型</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a><code>String</code></h3><ul>
<li>value 的数据类型有<code>string  int  float</code>   底层的存储方式是<code>字节数组形式</code></li>
<li>其基本编码方式是RAW，基于简单动态字符串（SDS）实现，存储上限为512mb。</li>
<li>底层实现⽅式：动态字符串sds 或者 long<ul>
<li>String的内部存储结构⼀般是sds（Simple Dynamic String，可以动态扩展内存），但是如果⼀个String类型的value的值是数字，那么Redis内部会把它转成long类型来存储，从⽽减少内存的使用。</li>
<li>如果存储的字符串是整数值，并且大小在LONG_MAX范围内，则会采用INT编码：直接将数据保存在RedisObject的ptr指针位置（刚好8字节），不再需要SDS了</li>
</ul>
</li>
</ul>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a><code>hash</code></h3><ul>
<li>与<code>Redis</code>中的<code>Zset</code>非常类似：<ul>
<li>都是键值存储</li>
<li>都需求根据键获取值</li>
<li>键必须唯一</li>
</ul>
</li>
<li>区别<ul>
<li><code>zset</code>的键是<code>member</code>，值是<code>score</code>；<code>hash</code>的键和值都是任意值</li>
<li><code>zset</code>要根据<code>score</code>排序；<code>hash</code>则无需排序</li>
</ul>
</li>
<li><p>底层实现方式：压缩列表<code>ziplist</code> 或者<code>字典dict</code>，当Hash中数据项比较少的情况下，Hash底层才⽤压缩列表<code>ziplist</code>进⾏存储数据，随着数据的增加，底层的<code>ziplist</code>就可能会转成<code>dict</code></p>
</li>
<li><p>value 是一个无序字典,也是一个键值对，类似<code>Java</code>的 <code>HashMap</code></p>
<ul>
<li>应用： 可以针对每个字段做增删改查的操作</li>
</ul>
</li>
</ul>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a><code>list</code></h3><ul>
<li><p>List结构类似一个双端链表，可以从首、尾操作列表中的元素：</p>
</li>
<li><p>类似于<code>Java</code>中的<code>LinkedList</code> ,可以看成是一个双向链表的结构，可以<code>正向的检索</code>和<code>反向的检索</code></p>
<ul>
<li>应用：<code>朋友圈点赞列表，评论列表</code></li>
</ul>
</li>
</ul>
<blockquote>
<details><summary>常见的四种统计</summary>
<pre>聚合统计       统计多个集合元素的聚合结果  <font color="red">交差并等集合统计</font></pre>
<pre>排序统计       在面对需要展示最新列表、排行榜等场景时，如果数据更新频繁或者需要分页显示，建议使用ZSet</pre>
<pre>二值统计       集合元素的取值就只有0和1两种。在钉钉上签到打卡的场景中，我们只用记录有签到(1)或没有签单(0)</pre>
<pre>基数统计       指统计一个集合中<font color="red">不重复的元素个数</font>，就是对集合去重复后剩余元素的计算</pre>
</details>

</blockquote>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a><code>set</code></h3><ul>
<li>底层数据结构： <code>HashTable</code>，也就是Redis中的<code>Dict</code>，不过Dict是双列集合（可以存键、值对）</li>
<li>为了查询效率和唯一性，set采用<code>HT编码（Dict）</code>。<code>Dict</code>中的key用来存储元素，value统一为null。</li>
<li><p>当存储的所有数据都是整数，并且元素数量不超过<code>set-max-intset-entries</code>时，<code>Set</code>会采用<code>IntSet</code>编码，以节省内存</p>
</li>
<li><p>类似于<code>hashset</code> ;内部实现相当于一个特殊的字典，字典中所有的value都是一个值NULL，可以看做是一个<code>value</code>为<code>null</code>的<code>HashMap</code></p>
<ul>
<li>应用： <code>微信抽奖小程序。（SRANDMEMBER） 微信朋友圈共友点赞。（SINTER）   QQ推荐可能认识的人。（SDIFF）</code></li>
</ul>
</li>
</ul>
<h3 id="SortSet"><a href="#SortSet" class="headerlink" title="SortSet"></a><code>SortSet</code></h3><ul>
<li><p>底层数据结构：</p>
<p><code>SkipList</code>：可以排序，并且可以同时存储score和ele值（member）</p>
<p><code>HT（Dict</code>）：可以键值存储，并且可以根据key找value</p>
</li>
<li><p><code>ziplist</code>本身没有排序功能，而且没有键值对的概念，因此需要有zset通过编码实现：</p>
<ul>
<li>ZipList是连续内存，因此score和element是紧挨在一起的两个entry， element在前，score在后</li>
<li>score越小越接近队首，score越大越接近队尾，按照score值升序排列</li>
</ul>
</li>
<li><p>当元素数量不多时，HT和SkipList的优势不明显，而且更耗内存。因此zset还会采用ZipList结构来节省内存，不过需要同时满足两个条件：</p>
<ul>
<li>元素数量小于zset_max_ziplist_entries，默认值128</li>
<li>每个元素都小于zset_max_ziplist_value字节，默认值64</li>
</ul>
</li>
<li><p>每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表,score的值可以是 整型 和浮点型并且可以重复</p>
<ul>
<li>应用：<code>排行榜</code></li>
</ul>
</li>
</ul>
<h3 id="HyprLoglog"><a href="#HyprLoglog" class="headerlink" title="HyprLoglog"></a><code>HyprLoglog</code></h3><ul>
<li><p>一种概率数据结构，只会根据输入的元素来计算<code>计数</code>，<code>不会存储</code>输入的<code>元素本身</code></p>
<ul>
<li>应用： <code>网站文章的UV        网站某关键词的搜索数量        用户每天搜索的不同词条数目</code></li>
</ul>
</li>
<li><p>什么是UV           Unique Visitor，独立访客，一般理解为客户端IP      <font color="red">需要去重考虑</font></p>
</li>
<li><p>什么是PV            Page View，页面浏览量        不用去重</p>
</li>
<li><p>什么是DAU        Daily Active User，日活跃量用户，<font color="red">登录或者使用了某个产品的用户数（去重复登录的用户）</font>    常用于反映网站、互联网应用或者网络游戏的运营情况</p>
</li>
<li><p>什么是MAU        Monthly Active User，月活跃用户量</p>
</li>
</ul>
<h4 id="HyprLoglog的引入："><a href="#HyprLoglog的引入：" class="headerlink" title="HyprLoglog的引入："></a>HyprLoglog的引入：</h4><ul>
<li>去重方式<ul>
<li>HashSet</li>
<li>bitmap： 所占内存巨大；bitmaps还是不适用大数据量下(亿级)的基数计数场景，<font color="red">但是bitmaps方法是精确计算的。</font></li>
</ul>
</li>
</ul>
<h4 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h4><ul>
<li>概率算法<ul>
<li><font color="red">通过牺牲准确率来换取空间</font>，对于不要求<font color="blue">绝对准确率</font>的场景下可以使用，因为<font color="red">概率算法不直接存储数据本身</font>，通过一定的概率统计方法预估基数值，同时保证误差在一定范围内，由于又不储存数据故此可以大大节约内存.</li>
</ul>
</li>
</ul>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul>
<li><p>只是进行不重复的基数统计，不是集合也不保存数据，只记录数量而不是具体内容</p>
</li>
<li><p>有误差，但是很低 0.81% （<code>1.04/sqrt(16384)</code>）；HyperLogLog提供不精确的去重计数方案</p>
</li>
</ul>
<h4 id="亿级UV的Redis设计方案"><a href="#亿级UV的Redis设计方案" class="headerlink" title="亿级UV的Redis设计方案"></a>亿级UV的Redis设计方案</h4><h5 id="不可行的方案："><a href="#不可行的方案：" class="headerlink" title="不可行的方案："></a>不可行的方案：</h5><ul>
<li>MySQL   高并发下，3000万的数据就需要分库分表了</li>
<li>redis的hash结构存储   太占内存了</li>
</ul>
<h5 id="可行的方案："><a href="#可行的方案：" class="headerlink" title="可行的方案："></a>可行的方案：</h5><ul>
<li>HyperLogLog   在Redis里面，每个HyperLogLog键只需要花费12KB内存，就可以计算接近2^64^个不同元素的基数</li>
</ul>
<blockquote>
<p>为什么是只需要花费12Kb?</p>
<p>Redist使用了2^14^=16384个桶，按照上面的标准差，误差为0.81%，精度相当高。Redis使用一个log型哈希值的前14个比特用来确定桶编号，剩下的50个比特用来做基数估计。而2^6^=64，所以只需要用6个比特表示下标值，在一般情况下，一个HyperLogLog数据结构(每个桶占6位)占用内存的大小为16384*6/8=12kB,Redis将这种情况称为密集(dense)存储。</p>
</blockquote>
<h3 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a><code>Bitmap</code></h3><ul>
<li>一种统计<code>二值状态</code>的数据类型，由多个二进制位组成，本质是数组，但是值只能是0和1，默认是 0;可以极大的节约存储空间, 每一个二进制位都对应一个偏移量<ul>
<li>应用：<code>打卡、签到        用户是否登陆过Y、N，比如软件的每日签到功能        电影、广告是否被点击播放过</code></li>
</ul>
</li>
</ul>
<h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a><code>Stream</code></h3><p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202307022236895.png" alt="image-20230525002759535"></p>
<ul>
<li>流，可以使用<code>流</code>来<code>实时记录</code>和<code>同时聚合事件</code>,就是  <code>Redis</code> 版的<code>MQ消息中间件+阻塞队列</code> ,它支持消息的持久化、支持自动生成全局唯一ID、支持ack确认消息的模式、支持消费组模式等，让消息队列更加的稳定和可靠。</li>
</ul>
<blockquote>
<ul>
<li>Message Content：消息内容</li>
<li>Consumer group：消费组，通过<code>XGROUP CREATE</code>命令创建，同一个消费组可以有多个消费者</li>
<li>Last_delivered_id：游标，每个消费组会有个游标<code>last_delivered_id</code>，任意一消费者读取了消息都会使</li>
<li>游标 <code>last_delivered_id</code> 往前移动。</li>
<li>Consumer：消费者，消费组中的消费者</li>
<li>Pending_ids：消费者会有一个状态变量，用于记录被当前消费已读取但<code>未ack</code>的<code>消息Id</code>，如果客户端没有<code>ack</code>，这个变量里面的消息ID会越来越多，一旦某个消息被ack它就开始减少。这个<code>pending_ids</code>变量被官方称之为 <code>PEL(Pending Entries List)</code>，记录了当前已经被客户端读取的消息，但是还没有 ack (Acknowledge character：确认字符），它用来确保客户端至少消费了消息一次，而不会在网络传输的中途丢失了没处理</li>
</ul>
</blockquote>
<h3 id="Bitfield"><a href="#Bitfield" class="headerlink" title="Bitfield"></a>Bitfield</h3><ul>
<li>将一个<code>redis</code>字符串看作是<strong>一个由二进制位组成的数组</strong> 并能对变长位宽和任意没有字节对齐的指定整型<code>位域进行寻址和修改</code></li>
<li>主要作用 ： 它能够将很多<code>小的整数储存到一个长度较大的位图</code>中，又或者<code>将一个非常庞大的键分割为多个较小的键来进行储存</code><ul>
<li>位域修改</li>
<li>溢出控制</li>
</ul>
</li>
</ul>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a><font color="red">定义</font></h4><ul>
<li>将某一时刻的数据以快照&lt;全量快照——所有的数据&gt;的方式写到磁盘上，也就是在指定的时间间隔内将内存中的数据集写入磁盘。写的是二进制文件</li>
<li>之后恢复的时候直接将硬盘中的快照文件读回内存即可</li>
<li>默认情况下，redis 会将数据库快照保存在<code>dump.rdb</code> 的文件中，<ul>
<li>随后 可以设置配置文件<code>自动保存</code>数据集，也可以<code>手动</code>&lt;<code>save   bgsave</code>&gt;的形式保存数据集</li>
</ul>
</li>
</ul>
<h4 id="何时触发"><a href="#何时触发" class="headerlink" title="何时触发"></a><font color="red">何时触发</font></h4><ul>
<li>配置文件中默认的快照配置</li>
<li>手动<code>save/bgsave</code>命令</li>
<li>执行<code>flushdb/fulshall</code>命令也会产生dump.rdb文件，但是也会将命令记录到dump.rdb文件中，恢复后依旧是空，无意义</li>
<li>执行<code>shutdown且没有</code>设置开启AOF持久化</li>
<li>主从复制时，<code>主节点自动触发</code></li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a><font color="red">优点</font></h4><ul>
<li>适用于灾难恢复。  可以传输到远程数据中心或Amazon S3(可能已加密）的压缩文件</li>
<li>提高了Redis 的性能。</li>
<li>RDB在使用大数据集时仍能更快地重启。</li>
<li>在副本上，RDB支持重启和故障转移后的部分重新同步。</li>
<li>RDB文件非常适合备份。</li>
<li>对数据完整性和一致性要求不高。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><font color="red">缺点</font></h4><ul>
<li>在一定间隔时间做一次备份，所以如果<code>redis</code>意外<code>down</code>掉的话，就会丢失从当前至最近一次快照期间的数据，<strong>快照之间的数据会丢失</strong></li>
<li>内存数据的全量同步，如果数据量太大会导致<code>IO严重影响服务器性能</code></li>
<li>RDB依赖于主进程的<code>fork</code>，在更大的数据集中，这可能会导致服务请求的瞬间延迟。fork的时候内存中的数据被克隆了一份，大致2倍的膨胀性，需要考虑</li>
</ul>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a><font color="red">定义</font></h4><ul>
<li><p><font color="red">以日志的形式来记录每个写操作</font>，随后追加到文件缓冲区中，再根据配置文件将文件写到磁盘中</p>
</li>
<li><p>之后redis重启的话就根据日志文件的内容将<code>写指令</code>  <code>从前到后执行一次</code>以完成数据的恢复工作</p>
</li>
<li><p>默认情况下，redis是没有开启AOF的。开启AOF功能需要设置配置：<code>appendonly yes</code></p>
</li>
</ul>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a><font color="red">流程</font></h4><ol>
<li><p>Client作为命令的来源，会有多个源头以及源源不断的请求命令。</p>
</li>
<li><p>在这些命令到达Redis Server 以后并不是直接写入AOF文件，会将这些命令先放入AOF缓存中进行保存。这里的AOF缓冲区存在的目的是当这些命令达到一定量以后再写入磁盘，避免频繁的磁盘IO操作。</p>
</li>
<li><p>AOF缓冲会根据AOF缓冲区<strong>同步文件的三种写回策略</strong>将命令写入磁盘上的AOF文件。</p>
</li>
<li><p>随着写入AOF内容的增加为避免文件膨胀，会根据规则进行命令的合并(<strong>又称AOF重写</strong>)，从而起到AOF文件压缩的目的。</p>
</li>
<li><p>当Redis Server服务器重启的时候会对AOF文件载入数据。</p>
</li>
</ol>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305251051356.png" alt="image-20230525105157332" style="zoom:53%;"></p>
<h4 id="写回策略"><a href="#写回策略" class="headerlink" title="写回策略"></a><font color="red">写回策略</font></h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">配置项</th>
<th style="text-align:center">写回时机</th>
<th style="text-align:center">优点</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>Always</code></td>
<td style="text-align:center">同步写回</td>
<td style="text-align:center">可靠性高，数据基本不丢失</td>
<td style="text-align:center">每个写命令都要同步记录，性能影响较大</td>
</tr>
<tr>
<td style="text-align:center"><code>Everysec</code></td>
<td style="text-align:center">每秒写回</td>
<td style="text-align:center">性能适中</td>
<td style="text-align:center">宕机时丢失一秒内的数据</td>
</tr>
<tr>
<td style="text-align:center"><code>No</code></td>
<td style="text-align:center">操作系统控制的写回</td>
<td style="text-align:center">性能好</td>
<td style="text-align:center">宕机时丢失数据较多</td>
</tr>
</tbody>
</table>
</div>
<h4 id="变化"><a href="#变化" class="headerlink" title="变化"></a><font color="red">变化</font></h4><ul>
<li><p>redis7之前 aof 文件有且只有一个</p>
</li>
<li><p>redis7之后 aof文件变为了multi part</p>
<ul>
<li><strong>BASE: 表示基础AOF</strong>，它一般由子进程通过重写产生，该文件<code>最多只有一个</code>。</li>
</ul>
</li>
</ul>
<pre><code>- **INCR:表示增量AOF**，它一般会在AOFRW开始执行时被创建，该文件`可能存在多个`。
- **HISTORY:表示历史AOF**，它由`BASE`和`INCR`变化而来，每次`AOFRW`成功完成时，本次`AOFRW`之前对应的`BASE`和`INCR` 都将变为`HISTORY`，`HISTORY类型的AOF会被Redis自动删除`。
</code></pre><p>为了管理这些AOF文件，我们引入了一个<code>manifest (清单)</code>文件来跟踪、管理这些AOF。</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a><font color="red">优点</font></h4><ul>
<li>使用AOF 持久化会使 Redis 更加持久。</li>
<li>AOF 日志是一个仅附加日志，因此<code>不会出现寻道问题</code>，也<code>不会在断电时出现损坏问题</code>。</li>
<li><p>当AOF 变得太大时，Redis 能够在<code>后台自动重写AOF</code>。</p>
<ul>
<li>重写是安全的，因为当 Redis继续附加到旧文件时，会使用创建当前数据集所需的最少操作集生成一个全新的文件，一旦第二个文件准备就绪，Redis 就会切换两者并开始附加到新的那一个。</li>
</ul>
</li>
<li><p>AOF<code>以易于理解和解析的格式</code>依次包含所有操作的日志。可以轻松导出AOF文件。</p>
</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a><font color="red">缺点</font></h4><ul>
<li><code>相同数据集</code>的数据而言<code>AOF文件要远大于</code>RDB文件，<code>恢复速度</code> <code>慢</code>于RDB</li>
<li>AOF运行效率要<code>慢于RDB</code>，每秒<code>同步策略效率较好</code>，<code>不同步效率和RDB相同</code></li>
</ul>
<h4 id="重写机制"><a href="#重写机制" class="headerlink" title="重写机制"></a><font color="red">重写机制</font></h4><ul>
<li>当AOF文件的大小超过所设定的峰值时，Redis就会<strong><code>自动</code></strong>启动AOF文件的<code>内容压缩</code>。只保留可以恢复数据的最小指令集。</li>
</ul>
<p>何时触发：</p>
<ul>
<li>自动触发<ul>
<li>满足配置文件中的选项后，Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时</li>
</ul>
</li>
<li><strong>手动触发</strong><ul>
<li>客户端向服务器发送<code>bgrewriteaof</code>命令</li>
</ul>
</li>
</ul>
<blockquote>
<p>AOF文件重写并不是对原文件进行重新整理，而是直接读取服务器现有的键值对，然后用一条命令去代替之前记录这个键值对的多条命令，生成一个新的文件后去替换原来的AOF文件</p>
</blockquote>
<p>原理：</p>
<ol>
<li>在重写开始前，redis会创建一个“重写子进程”，这个子进程会读取现有的AOF文件，并将其包含的指令进行分析压缩并写入到一个临时文件中。</li>
<li>与此同时，主进程会将新接收到的写指令一边累积到内存缓冲区中，一边继续写入到原有的AOF文件中（这样做是保证原有的AOF文件的可用性，避免在重写过程中出现意外。）</li>
<li>当“重写子进程”完成重写工作后，它会给父进程发一个信号，父进程收到信号后就会将内存中缓存的写指令追加到新AOF文件中</li>
<li>当追加结束后，redis就会用新AOF文件来代替旧AOF文件，之后再有新的写指令，就都会追加到新的AOF文件中</li>
<li>重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似</li>
</ol>
<h3 id="混合模式持久化"><a href="#混合模式持久化" class="headerlink" title="混合模式持久化"></a>混合模式持久化</h3><p>两者在同时开启，也就是混合模式下，重启只会加载 <code>aof</code> 文件</p>
<h4 id="同时开启两种持久化方式"><a href="#同时开启两种持久化方式" class="headerlink" title="同时开启两种持久化方式"></a><span style="color:red">同时开启两种持久化方式</span></h4><ul>
<li>当redis重启的时候会<code>优先载入AOF文件</code>来恢复原始的数据，因为在通常情况下<code>AOF文件保存的数据集</code>要比RDB文件保存的数据集<code>要完整</code>。</li>
<li>RDB的数据不是实时的，同时使用两者时服务器重启也只会找AOF文件。 redis  的 作者也不建议只使用AOF方式备份，因为<code>RDB更适合用于备份数据库</code>（AOF在不断的变化不好备份），留着RDB是为了作为一个以防万一的手段。</li>
</ul>
<blockquote>
<p>推荐使用<code>两者混合使用</code></p>
<ul>
<li><p>RDB镜像做<code>全量持久化</code>，AOF做<code>增量持久化</code></p>
</li>
<li><p>建议<code>先</code>使用RDB进行快照存储，<code>然后</code>使用AOF持久化记录所有的写操作，当重写策略满足或手动触发重写的时候，将最新的数据存储为新的RDB记录。</p>
</li>
<li><p>这样的话，重启服务的时候会从RDB和AOF两部分恢复数据，既保证了数据完整性，又提高了恢复数据的性能。</p>
</li>
<li><p>简单来说:混合持久化方式产生的文件一部分是RDB格式，一部分是AOF格式。====&gt;    AOF包括了RDB头部+AOF混写</p>
</li>
</ul>
</blockquote>
<h3 id="纯缓存模式"><a href="#纯缓存模式" class="headerlink" title="纯缓存模式"></a>纯缓存模式</h3><p><code>同时关闭</code>RDB+AOF，只用缓存</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>本质是一组命令的集合，一个事务中的所有命令都会序列化，<code>按顺序地串行化执行而不会被其他命令插入，不许加塞</code></p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a><font color="red">特点</font></h3><div class="table-container">
<table>
<thead>
<tr>
<th>单独的隔离操作</th>
<th>Redis的事务仅仅是保证事务里的操作会被连续独占的执行，redis命令执行是单线程架构，在执行完事务内所有指令前是不可能再去同时执行其他客户端的请求的</th>
</tr>
</thead>
<tbody>
<tr>
<td>没有隔离级别的概念</td>
<td>因为事务提交前任何指令都不会被实际执行，也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这种问题了</td>
</tr>
<tr>
<td>不保证原子性</td>
<td>Redis的事务不保证原子性，也就是不保证所有指令同时成功或同时失败，只有决定是否开始执行全部指令的能力，没有执行到一半进行回滚的能力</td>
</tr>
<tr>
<td>排它性</td>
<td>Redis会保证一个事务内的命令依次执行，而不会被其它命令插入</td>
</tr>
</tbody>
</table>
</div>
<h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a><font color="red">流程</font></h3><p>（1）开启：以<code>MULTI</code>命令开启一个事务</p>
<p>（2）入队：将多个命令加入到事务队列中，接到这些命令并<code>不会立即执行</code>。</p>
<p>（3）执行：由<code>EXEC</code>命令执行事务队列中的命令。</p>
<h2 id="管道-pipeline"><a href="#管道-pipeline" class="headerlink" title="管道(pipeline)"></a>管道(pipeline)</h2><ul>
<li><p>是什么： 客户端和redis服务器之间的进行建立连接的一种<code>双向通道</code>,它可以让客户端<code>在一次请求</code>中<code>发送多个命令</code>并<code>一次性</code>接收<code>多个命令的响应结果</code></p>
</li>
<li><p>目的: 可以让客户端减少网络通信的次数，从而<code>提高</code> Redis 的<code>吞吐量和性能</code></p>
</li>
<li>总结：<ul>
<li>Pipeline与原生批量命令(<code>mset</code>)对比：<ul>
<li>原生批量命令（例如mset、mget）具有<code>原子性</code>，pipeline是<code>非原子性</code>。</li>
<li>原生批量命令一次<code>只能执行一种命令</code>，pipeline<code>支持批量执行不同命令</code>。</li>
<li>原生批命令是<code>redis服务端</code>实现，而pipeline需要<code>redis服务端和客户端</code>共同完成。</li>
</ul>
</li>
<li>Pipeline与<code>事务</code>对比：<ul>
<li>事务具有原子性，pipeline不具有原子性。</li>
<li>pipeline<code>一次性</code>将命令发送给服务器，事务是<code>一条一条</code>的发，事务只有在接收到EXEC命令后才会执行。</li>
<li>执行事务时会阻塞其他命令的执行，而执行管道中的命令不会。</li>
</ul>
</li>
<li>使用Pipeline注意事项：<ul>
<li>pipeline缓冲的指令只会<code>依次执行，不保证原子性</code>，如果执行中指令发生异常，还会继续执行后续的指令。</li>
<li>使用pipeline传输的命令也不能太多，如果数据量大客户端的阻塞时间可能会过久，同时服务端此时也被迫回复一个队列答复，占用很多内存。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><ul>
<li><p>发布和订阅（Publish/Subscribe，简称 Pub/Sub）是一种消息传递模式；</p>
</li>
<li><p>发布者（Publisher）可以将消息发送到一个或多个频道（Channel），订阅者（Subscriber）可以订阅一个或多个频道，以接收发布者发送的消息。当发布者在某个频道上发布一条消息时，所有订阅该频道的订阅者都会收到这条消息。</p>
</li>
<li><code>Redis Pub/Sub</code> 是基于消息传递的<code>异步通信模型</code>，可以用于构建实时系统、聊天室、实时广播等应用场景。</li>
</ul>
<p>==注意==</p>
<ul>
<li><code>发布的消息</code>在Redis系统<code>不能持久化</code>，因此必须<code>先执行订阅</code>，再<code>等待消息发布</code>，如果先发布了消息且该消息<code>没有订阅者接收</code>，那么该消息被<code>直接丢弃</code>。</li>
<li>消息只管发送，对于发布者而言消息是<code>即发即失</code>的，也<code>没有ACK机制</code>，无法保证消息是否消费成功。</li>
<li>Redis5.0新增了<code>Stream数据结构，不但支持多播，还支持数据持久化，比Pub/Sub更加强大</code>。</li>
</ul>
<h2 id="BigKey"><a href="#BigKey" class="headerlink" title="BigKey"></a>BigKey</h2><blockquote>
<details>
 <summary>使用 <font color="red">scan</font> 而不是 <font color="red">keys *</font></summary>
 <pre>1.生产环境中使用 ： <font color="red">keys * </font>这个指令有致命的弊端，在实际环境中最好不要使用；一般使用的是<font color="red">Scan</font></pre>
<pre>2.SCAN命令是一个基于<font color="red">游标</font>的迭代器，每次被调用之后，都会向用户<font color="red">返回一个新的游标</font>，<font color="red">用户在下次迭代时需要使用这个新游标作为SCAN命令的游标参数</font>，以此来延续之前的迭代过程。</pre>
     <pre>3.命令<font color="red">SCAN cursor [MATCH pattern] [COUNT count]</font></pre>
     <pre>3.1 cursor - 游标。</pre>
     <pre>3.2 pattern - 匹配的模式。</pre>
     <pre>3.3 count - 指定从数据集里返回多少元素，默认值为 10 。</pre>
<pre><font color="red" size="4">4.SCAN的遍历顺序</font></pre>
<pre><font color="red">非常特别，它不是从第一维数组的第零位一直遍历到末尾，而是采用了高位进位加法来遍历。之所以使用这样特殊的方式进行遍历，是考虑到字典的扩容和缩容时避免槽位的遍历重复和遗漏。</font></pre>
<pre>5.返回值</pre>
<pre>5.1 SCAN返回一个包含<font color="blue">两个元素的数组</font></pre>
<pre>5.2 第一个元素是用于进行下一次迭代的新游标，</pre>
<pre>5.3 第二个元素则是一个数组，这个数组中包含了所有被迭代的元素。<font color="red">如果新游标返回零表示迭代已结束。</font></pre></details>



</blockquote>
<h3 id="多大算BigKey"><a href="#多大算BigKey" class="headerlink" title="多大算BigKey"></a>多大算BigKey</h3><ul>
<li><p>通常我们说的BigKey，不是在值的Key很大，而是指的Key对应的value很大</p>
</li>
<li><p>list、hash、set和zset，value的实际上个数超过5000就是bigkey</p>
</li>
<li><p>string是value，理论上最大是512MB，但是  实际上 ≥10KB就是bigkey</p>
</li>
<li><p>非字符串的bigkey,不要使用del删除，使用<code>hscan、sscan、zscan</code>方式<code>渐进式删除</code>，同时要注意防止<code>bigkeyi过期时间自动删除问题</code></p>
</li>
</ul>
<h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><ul>
<li>内存不均，集群迁移困难</li>
<li>超时删除，大key删除作梗  ：对元素较多的hash、list、zset等做运算会耗时较旧，使主线程被阻塞</li>
<li>网络流量阻塞 ：对BigKey执行读请求时，少量的QPS就可能导致带宽使用率被占满，导致Redis实例，乃至所在物理机变慢</li>
<li>数据倾斜 ：   BigKey所在的Redis实例内存使用率远超其他实例，无法使数据分片的内存资源达到均衡</li>
</ul>
<h3 id="如何发现"><a href="#如何发现" class="headerlink" title="如何发现"></a>如何发现</h3><ul>
<li><font color="red">--bigkeys参数 + （查询大于10kb的所有key）memory usage  [给出一个 `key` 和它的值在 内存 中所占用的字节数。] </font>



</li>
</ul>
<h3 id="如何删除"><a href="#如何删除" class="headerlink" title="如何删除"></a>如何删除</h3><ul>
<li>String   一般用del，如果<code>过于庞大</code>使用<code>unlink key</code>删除</li>
<li>hash    使用<code>hscan</code>每次获取少量<code>field-value</code>，再使用<code>hdel</code>删除每个<code>field</code></li>
<li>list       使用<code>ltrim</code>渐进式逐步删除   [让列表只保留指定区间内的元素，不在指定区间之内的元素都将被除。]</li>
<li>set      使用<code>sscan</code>每次获取部分元素，在使用<code>srem</code>命令删除每个元素</li>
</ul>
<ul>
<li>zset     使用<code>zscan</code>每次获取部分元素，在使用<code>zremrangebyrank</code>命令删除每个元素</li>
</ul>
<h3 id="生产调优-—-”惰性释放“"><a href="#生产调优-—-”惰性释放“" class="headerlink" title="生产调优   — ”惰性释放“"></a>生产调优   — ”惰性释放“</h3><p>redis有两种删除的方式</p>
<ul>
<li><code>del</code>    阻塞型删除</li>
</ul>
<blockquote>
<p>即 服务器停止处理新命令，以便以同步方式回收与对象关联的所有内存。</p>
<ul>
<li><p>如果删除的键与一个小对象相关联，则执行DEL命令所需的时间非常短  ，Redis中的O(1)或O(Iog_N)命令。</p>
</li>
<li><p>但是，如果键与包含数百万个元素的聚合值相关联，则服务器可能会阻塞很长时间（甚至几秒钟）才能完成操作。</p>
</li>
</ul>
</blockquote>
<ul>
<li><code>unlink</code> 非阻塞型删除</li>
</ul>
<blockquote>
<p>基于上述原因，Redis还提供了非阻塞删除原语，例如<code>UNLINK</code>(非阻塞DEL)以及<code>FLUSHALL</code>和<code>FLUSHDB</code>命令的<code>ASYNC</code>选项，以便在后台回收内存。这些命令在恒定时间内执行。另一个线程将尽可能快地逐步释放后台中的对象。<code>FLUSHALL</code>和<code>FLUSHDB</code>的<code>DEL</code>、<code>UNLINK</code>和<code>ASYNC</code>选项是用户控<br>制的。</p>
</blockquote>
<h3 id="优化配置"><a href="#优化配置" class="headerlink" title="优化配置"></a>优化配置</h3><blockquote>
<p><code>lazyfree-lazy-server-del        yes</code></p>
<p><code>replica-lazy-flush              yes</code></p>
<p><code>lazyfree-lazy-user-del          yes</code></p>
</blockquote>
<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305262258692.png" alt="image-20230526225827642" style="zoom:43%;"></p>
<h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a><font color="red">是什么</font></h3><ul>
<li>由<code>一个初值都为零的bit数组</code>和<code>多个哈希函数构成</code>，用来快速判断集合中是否存在某个元素  <code>&lt;bit数组+hash函数&gt;</code></li>
</ul>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a><font color="red">目的</font></h3><ul>
<li>可以减少内存占用；因为他 <code>不保存数据信息</code>，只是在内存中做一个是否存在的标记flag</li>
</ul>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a><font color="red">特点</font></h3><ul>
<li>可以<code>高效地插入和查询</code>，占用空间少，返回的结果是不确定的</li>
<li>一个元素的判断结果：判断结果为<code>存在</code>时，元素<code>不一定存在</code>，但是判断结果为<code>不存在</code>时，则<code>一定不存在</code></li>
<li>布隆过滤器可以添加元素，但是<font color="red">不能删除元素，</font>由于涉及<code>hashcode</code>判断依据，删除元素会导致误判率增加。</li>
</ul>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a><font color="red">原理</font></h3><ul>
<li>实质就是<font color="red">一个大型位数组和几个不同的无偏hash函数</font>(无偏表示分布均匀)。由一个初值都为零的bit数组和多个哈希函数构成，用来快速判断某个数据是否存在。</li>
<li>但是跟 HyperLogLog 一样，它也一样有那么一点不精确，也存在一定的误判概率</li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><font color="red">数据结构</font></h3><ul>
<li><p><font color="blue">添加key时</font><br>使用<code>多个</code>hash函数对<code>key</code>进行<code>hash</code>运算得到一个整数索引值，对<code>位数组</code>长度进行<code>取模</code>运算得到一个位置，每个<code>hash函数</code>都会得到一个不同的位置，将这<code>几个位置</code>都置<code>1</code>就完成了<code>add</code>操作。</p>
</li>
<li><p><font color="blue">查询key时</font><br>只要有其中一位是零就表示这个key不存在，但如果都是1，则不一定存在对应的值</p>
</li>
</ul>
<h3 id="数据不精准的原因分析"><a href="#数据不精准的原因分析" class="headerlink" title="数据不精准的原因分析"></a>数据不精准的原因分析</h3><ul>
<li>直接原因就在于 <code>哈希函数</code>会导致<code>哈希冲突</code></li>
<li>当有变量被加入集合时，通过<code>N个映射函数</code>将这个变量映射成位图中的<code>N个点</code>,把它们都要置为 1，当查询某个变量的时候我们只要看看这些点是不是都是 <code>1</code>，就可以大概率知道集合中有没有它了；如果这些点，<font color="red">有任何一个为零则被查询变量一定不在;</font>如果都是 1，则被查询变量很<font color="red">可能存在</font>，<font color="red">为什么说是可能存在，而不是一定存在呢?那是因为`映射函数本身就是散列函数`，`散列函数是会有碰撞的`。</font>


</li>
</ul>
<blockquote>
<p>正是基于布隆过滤器的<code>快速检测特性</code>，我们可以在把数据写入数据库时，使用布隆过滤器做个标记。</p>
<p>当缓布缺失后，应用查询数据库时，可以通过查询布隆过滤器快速判断数据是否存在。</p>
<p>如果不存在，就不用再去据库中查询了。</p>
<p>这样一来，即使发生缓存穿透了，大量请求只会查询Redis和布隆过滤器，而不会积压到数据库，也就不会影响数据库的正常运行。</p>
<p>布隆过滤器可以使用Redis实现，本身就能承担较大的并发访问压力</p>
</blockquote>
<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a><font color="red">如何使用</font></h3><ul>
<li>初始化bitmap       所有的值均设置为0</li>
<li>添加数据                为了尽量使得地址不冲突，<font color="red">会使用多个 hash 函数对 key 进行运算</font>，算得一个下标索引值，然后对位数组长度进行<font color="red">取模运算</font>得到一个位置，每个 hash 函数都会算得一个不同的位置。再把位数组的这几个位置都置为 1 就完成了 add 操作。</li>
<li>判断是否存在         先把这个 key 通过相同的<font color="red">多个 hash 函数进行运算</font>，查看对应的位置是否都为 1，<font color="red">只要有一个位为零，那么说明布隆过滤器中这个 key 不存在；</font><font color="red">如果这几个位置全都是 1，那么说明极有可能存在；</font></li>
</ul>
<h3 id="即使误判也不要删除"><a href="#即使误判也不要删除" class="headerlink" title="即使误判也不要删除"></a><font color="red">即使误判也不要删除</font></h3><ul>
<li>误判的根源在于相同的 bit 位被多次映射且置 1</li>
<li>布隆过滤器的每一个 bit 并不是独占的，很有可能多个元素共享了某一位。如果我们直接删除这一位的话，会影响其他的元素</li>
<li>删掉元素会导致误判率增加。</li>
</ul>
<h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a><font color="red">建议</font></h3><ul>
<li>使用时最好不要让实际元素数量远大于初始化数量，最好避免扩容</li>
<li>当实际元素数量超过初始化数量时，应该对布隆过滤器进行重建，重新分配一个size 更大的过滤器，再将所有的历史元素批量add到新分配的布隆过滤器中</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title=" 使用场景"></a><font color="red"> 使用场景</font></h3><ol>
<li><font color="red"> 解决缓存穿透的问题，和redis结合bitmap使用</font>

<ul>
<li><p>思路</p>
<ul>
<li><p>把已存在数据的key存在布隆过滤器中，相当于redis前面挡着一个布隆过滤器。当有新的请求时，先到布隆过滤器中查询是否存在:</p>
<p>如果布隆过滤器中<code>不存在</code>该条数据则直接返回;如果布隆过滤器中<code>已存在</code>，才去查询缓存redis，如果redis里没查询到则再查询Mysql数据库</p>
</li>
</ul>
</li>
</ul>
</li>
<li><font color="red"> 黑名单校验，识别垃圾邮件</font>

<ul>
<li>思路<ul>
<li>发现存在黑名单中的，就执行特定操作。比如:识别垃圾邮件，只要是邮箱在黑名单中的邮件，就识别为垃圾邮件。把所有黑名单都放在布隆过滤器中，在收到邮件时，判断邮件地址是否在布隆过滤器中即可。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a><font color="red">优点：</font></h3><ul>
<li>高效地插入和查询，内存中占用bit空间小</li>
</ul>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a><font color="red">缺点：</font></h3><ul>
<li><code>不能删除</code>元素[<code>布谷鸟过滤器</code>可以删除]，因为删除元素会导致误判率增加，因为hash冲突同一个位置可能存的东西是多个共有的</li>
<li>存在误差，<code>不能精准过滤</code></li>
</ul>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/post/4a17b156.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="3e2030d3762f5bf81eb89c00208b5b28f54980956f6bc12c87236dd375d4e3b3">d36d2f4437a113f718ffbdd57d70fc1dba08e8718605f9458b1ac7bc22f8892ad39cace688f3633317d04514164ebd0d7de6831a6a968130f12ab9a7b6692d38b8c4c49dd791262e5ca5b1b377fdab858c920bca5955844130ccbc8d4f9b064e25ee4fdb596ec632f9d89d4979022419c3342f239afb3681f5b460cf70d1244600c9f5e2343c1eb088240d9c70dec9ba82bb9b70260e6ed40590f5b9624dc13b</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-xray">
      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>私密文章</tag>
      </tags>
  </entry>
  <entry>
    <title>网站还没做的功能</title>
    <url>/post/c4fc293b.html</url>
    <content><![CDATA[<p>[首页词条完善][<a href="https://www.fomal.cc/posts/eec9786.html">https://www.fomal.cc/posts/eec9786.html</a>]<br>[四个主题][<a href="https://www.fomal.cc/posts/5389e93f.html">https://www.fomal.cc/posts/5389e93f.html</a>  <a href="https://www.fomal.cc/posts/d739261b.html">https://www.fomal.cc/posts/d739261b.html</a>]<br>[挂载猫咪][<a href="https://www.fomal.cc/posts/5389e93f.html">https://www.fomal.cc/posts/5389e93f.html</a>]<br>[节日弹窗与公祭日变灰][<a href="https://www.fomal.cc/posts/2d7ac914.html">https://www.fomal.cc/posts/2d7ac914.html</a>]<br>[日记][<a href="https://www.fomal.cc/posts/d1927166.html">https://www.fomal.cc/posts/d1927166.html</a>]<br>[倒计时][<a href="https://www.fomal.cc/posts/d1927166.html">https://www.fomal.cc/posts/d1927166.html</a>]<br>右键相关功能没实现</p>
]]></content>
      <categories>
        <category>Future</category>
      </categories>
      <tags>
        <tag>TODO</tag>
      </tags>
  </entry>
  <entry>
    <title>集群下的redis</title>
    <url>/post/b56c4548.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">



<h2 id="redis的主从复制"><a href="#redis的主从复制" class="headerlink" title="redis的主从复制"></a>redis的主从复制</h2><h3 id="复制的好处"><a href="#复制的好处" class="headerlink" title="复制的好处"></a>复制的好处</h3><ul>
<li>可以提高系统的<code>可用性、可靠性和扩展性</code>，使 <code>redis</code> 在发生故障时可以快速地恢复数据。</li>
</ul>
<h3 id="复制的过程"><a href="#复制的过程" class="headerlink" title="复制的过程"></a>复制的过程</h3><p>（1）从节点向主节点发送 <code>SYNC</code> 命令,从节点<code>第一次</code>与主节点进行连接会进行一次全量复制（完全同步），slave自身原有数据会被master数据覆盖清除</p>
<p>（2）随后，在主节点接收到<code>SYNC 命令</code>后，开始在<code>后台保存快照</code>，生成 RDB 文件，收集并缓存此过程中记录所有执行的写命令。</p>
<p>（3）主节点在执行完<code>rdb持久化</code>后，将生成的 <code>RDB 文件和所有的缓存命令</code>发送给<code>从节点</code>，完成一次完全同步。</p>
<p>（4）从节点接收到主节点发送的 RDB 文件和写命令，会将其进行<code>存盘</code>，并<code>加载到内存</code>中，<code>完成复制初始化</code>，来保持与主节点的数据一致。</p>
<p>（5）从节点持续监听主节点发来的新命令，并将其执行，以保持与主节点的数据同步。</p>
<p>（6）为了<code>保持</code>主节点和从节点之间的<code>通信</code>，<code>master</code>会发出<code>PING</code>包的周期默认是10秒（：<code>repl-ping-replica-period 10</code>在661行）</p>
<p>（6）当主节点发生故障时，从节点会尝试与其他主节点建立连接，并选举出一个新的主节点（手动  slave of|自动 哨兵），从而成为新的从节点，<code>[注意：默认情况下，不会在slave节点中自动选一个master]</code></p>
<p>（7）从机下线重新连接的时候，<code>master</code>会进行检查<code>backlog</code>里面的<code>offset</code>,<code>master</code>只会把已经缓存的<code>offset后面</code>的数据复制给<code>slave</code></p>
<blockquote>
<p>Redis 复制是异步的，因此从节点可能存在数据不一致的情况。</p>
<p>为了避免数据不一致，可以设置 Redis 的<code>复制偏移量</code>（<code>replication offset</code>），当从节点与主节点连接断开后，从节点可以通过该偏移量快速地同步数据。</p>
</blockquote>
<h3 id="缺点-引出哨兵和集群"><a href="#缺点-引出哨兵和集群" class="headerlink" title="缺点(引出哨兵和集群)"></a>缺点(引出<code>哨兵和集群</code>)</h3><p>（1）<em>数据同步延迟</em>：由于 Redis 复制是异步的，从节点的数据可能会与主节点存在一定的延迟，因此从节点可能无法实时获取到最新的数据。</p>
<p>（2）<em>单点故障</em>：当主节点发生故障时，需要手动进行故障转移或者使用<code>集群</code>来保证系统的可用性。</p>
<p>（3）<em>网络通信问题</em>：当网络出现故障或者通信延迟过高时，复制的效率会受到影响，从节点可能无法及时接收到主节点发送的数据。</p>
<p>（4）<em>内存消耗问题</em>：当从节点处理不过来主节点发送过来的写命令时，从节点会自动触发执行全量复制，这会导致从节点内存消耗变大</p>
<p>（5）<em>数据安全问题</em>：当主节点的数据被误删或者篡改时，从节点也会受到影响，因此需要采取一定的措施来保证数据的安全性</p>
<h3 id="主从关系问答"><a href="#主从关系问答" class="headerlink" title="主从关系问答"></a>主从关系问答</h3><h4 id="slave-可以执行写命令吗"><a href="#slave-可以执行写命令吗" class="headerlink" title="slave 可以执行写命令吗"></a>slave 可以执行写命令吗</h4><ul>
<li><code>不可以</code>。master负责写命令，也可以执行读命令，slave负责读命令。<code>即使</code>slave是另一台slave的master，<code>也不能执行写命令</code>。</li>
</ul>
<h4 id="slave是从头开始复制还是从切入点开始复制"><a href="#slave是从头开始复制还是从切入点开始复制" class="headerlink" title="slave是从头开始复制还是从切入点开始复制?"></a>slave是从<code>头开始复制</code>还是从<code>切入点开始复制</code>?</h4><ul>
<li>都可以</li>
<li><p>当从节点<code>第一次连接主节点</code>时，如果主节点还<code>没有持久化数据</code>，从节点将<code>从头开始复制</code>。即主节点会将自己的全部数据发送给从节点，从节点将接收并保存全部数据。</p>
</li>
<li><p>当从节点与主节点<code>已经建立了连接</code>，并且已经有了初始数据同步，如果从节点断开与主节点的连接后重新连接，从节点可以选择从上次同步的位置（复制偏移量）继续同步数据，这样可以避免从头开始复制所带来的性能影响和数据冗余。（<code>master</code>会检查<code>backlog</code>里面的<code>offset</code>，<code>master</code>和<code>slave</code>都会保存一个复制的<code>offset</code>和一个<code>masterId</code>）</p>
</li>
</ul>
<p>​        ==特殊情况：==</p>
<ul>
<li>如果从节点断开与主节点的连接时间过长，主节点可能已经自动执行了 BGSAVE 命令，生成了新的 RDB 文件，此时从节点需要从头开始复制。</li>
<li>如果从节点的内存不足，也可能需要从头开始复制，以避免内存溢出。</li>
</ul>
<h4 id="主节点SHUTDOWN后，从节点会上位吗？"><a href="#主节点SHUTDOWN后，从节点会上位吗？" class="headerlink" title="主节点SHUTDOWN后，从节点会上位吗？"></a>主节点SHUTDOWN后，从节点会上位吗？</h4><ul>
<li>主节点关闭后，从节点<code>不会变成主节点</code>，它们会等待主节点重新启动，但是从节点的数据可以正常读取。主节点重启后，<code>主从关系依旧存在</code>。</li>
</ul>
<h2 id="哨兵Sentinel"><a href="#哨兵Sentinel" class="headerlink" title="哨兵Sentinel"></a>哨兵Sentinel</h2><p>是 Redis 的<code>高可用的</code>解决方案之一，它可以用于<code>监控和管理</code> Redis 主从复制集群，并在主节点发生故障时<code>自动</code>将从节点升级为新的主节点，从而保证系统的<code>高可用性</code>和<code>可靠性</code>。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol>
<li><p><strong>主从监控</strong>：监控主从redis库运行是否正常</p>
</li>
<li><p><strong>消息通知</strong>：哨兵可以将故障转移的结果发送给客户端</p>
</li>
<li><p><strong>故障转移</strong>：如果master异常，则会进行主从切换，将其中一个slave作为新master</p>
</li>
<li><p><strong>配置中心</strong>：客户端通过连接哨兵来获得当前Redis服务的主节点地址</p>
</li>
</ol>
<h3 id="哨兵的流程原理"><a href="#哨兵的流程原理" class="headerlink" title="哨兵的流程原理"></a>哨兵的流程原理</h3><ol>
<li>当哨兵检测到主节点不可用时，会将主节点标记为下线状态(sdown)，并向其他哨兵发送通知，通知其他哨兵主节点已经下线，其他哨兵也标记主节点下线后(odown)，确定主节点不可用</li>
</ol>
<blockquote>
<details>
<summary>  下线方式： </summary>
<pre>1. 主观下线(sdown)：指的是单个Sentinel实例对服务器做出的下线判断，即单个sentinel认为某个服务下线（有可能是接收不到订阅，之间的网络不通等等原因）。就是说如果服务器在给定的毫秒数之内没有回应PING命令或者返回一个错误消息， 那么这个Sentinel会主观的(单方面的)认为这个master不可以用了。</pre>
<pre>2. 客观下线(odown)：客观下线需要多个哨兵达成一致意见才能认为主节点真正不可用。quorum(票数)这个参数是进行客观下线的一个依据。</pre>
</details>

</blockquote>
<ol>
<li>哨兵在检测到主节点不可用后，会进入选举状态，此时开始选举哨兵的领导者。</li>
</ol>
<blockquote>
<details>
    <summary>  选举算法： </summary>
    <pre>
监视该主节点的所有哨兵都有可能被选为领导者，选举使用的算法是<font color="red">Raft算法</font>；Raft算法的<font color="red">基本思路是先到先得</font></pre>
</details>

</blockquote>
<ol>
<li>哨兵leader开始推动故障切换流程并选举出一个新的master</li>
</ol>
<blockquote>
<details>
    <summary>  选举规则： </summary>
<pre>1. 优先级 (slave-priority  、 replica-priority)  （数值越小优先级越高） </pre>
<pre>2. 复制偏移量（大的优先）</pre>
<pre>3. run id（小的优先，每个redis实例启动后都会随机生成一个40位的run id）</pre>
</details>

</blockquote>
<ol>
<li>选举出新的master后由Sentinel leader完成failover工作(故障切换)</li>
</ol>
<blockquote>
<details><summary>具体流程：</summary>
    <pre>1.执行<font color="red">slaveof no one</font>命令让选出来的从节点成为新的主节点，并通过<font color="red">slaveof</font>命令让其他节点（包括原来的master）成为新主节点的从节点。</pre>
 <pre><font color="red">2.Sentinel leader</font>会向被重新配置的实例发送一个<font color="red">CONFIG REWRITE</font> 命令,从而确保这些配置会持久化在硬盘里(写入配置文件)。</pre>
<pre><font color="red">值得注意的是：</font> 原来的master重连也将变成从节点</pre>
</details>

</blockquote>
<h3 id="故障恢复的流程"><a href="#故障恢复的流程" class="headerlink" title="故障恢复的流程"></a>故障恢复的流程</h3><ul>
<li><p>从下线的主服务的所有从服务里面挑选个<code>从服务</code>，将其转成主服务（<code>选举的原则</code>就是上面👆🏻的）</p>
</li>
<li><p>从服务挑选出新的主服务之后，<code>sentinel</code> 向原主服务的从服务发送自己是新主机的命令，其他的将变为该服务的从服务</p>
</li>
<li>下线的主机再次上线时，<code>sentinel</code>会向其发送<code>slaveof</code>命令：让其成为新主的从节点</li>
</ul>
<p>==注意==</p>
<ul>
<li><p>哨兵节点的数量应为多个，哨兵本身应该集群，保证高可用，哨兵节点的数量应该是奇数</p>
</li>
<li><p>哨兵集群+主从复制，并<code>不能保证数据零丢失</code>（引出集群cluster，集群可以解决这一问题），此时数据如果数据还是丢失了，那么丢失的<code>原因</code>就是：<code>master宕机后，哨兵需要在一定时间内选出新的master并执行failover操作，这段时间内从节点无法写入数据，造成数据丢失</code>。</p>
</li>
</ul>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><font color="red">定义</font></h3><p>集群是一个提供在多个Redis节点间<code>共享数据的程序集</code>，<code>Redis集群可以支持多个master</code></p>
<h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a><font color="red">作用</font></h3><ul>
<li>Redis集群支持<code>多个master</code>，每个master又可以挂载<code>多个slave</code><ol>
<li>读写分离</li>
<li>支持数据的高可用</li>
<li>支持海量数据的读写存储操作</li>
</ol>
</li>
<li>由于Cluster自带<code>Sentinel</code>的故障转移机制，内置了高可用的支持，<code>无需再去使用哨兵功能</code></li>
<li>客户端与Redis的节点连接，不再需要连接集群中所有的节点，<code>只需要任意连接集群中的一个可用节点即可</code></li>
<li>由 槽位<code>slot</code>负责分配到<code>各个物理服务节点</code>，由对应的集群来负责维护节点、插槽和数据之间的关系</li>
</ul>
<h3 id="槽位slot"><a href="#槽位slot" class="headerlink" title="槽位slot"></a><font color="red">槽位<code>slot</code></font></h3><p>Redis集群<code>没有使用一致性hash</code> 而是引入了哈希槽的概念。</p>
<p>Redis集群有<code>16384</code>个哈希槽每个key通过<code>CRC16校验</code>后对<code>16384取模</code>来决定放置哪个槽，集群的每个节点负责一部分hash槽</p>
<h3 id="分片"><a href="#分片" class="headerlink" title="分片"></a><font color="red">分片</font></h3><ul>
<li>是什么： 使用Redis集群时我们会将<code>存储的数据分散到多台redis机器上</code>，这称为<code>分片</code>。就是<code>集群中</code>的每个Redis实例都被认为是整个数据的一个分片。</li>
<li>如何找到给定key的分片<ul>
<li>对key进行<code>CRC16(key)</code>算法处理并通过对总分片数量取模。</li>
<li>然后，使用确定性<code>哈希函数</code>，这意味着<code>给定的key</code>将多次始终映射到同一个分片</li>
<li>至此我们就可以推断将来<code>读取到的特定key</code>的位置</li>
</ul>
</li>
</ul>
<h3 id="分片和槽位的优势"><a href="#分片和槽位的优势" class="headerlink" title="分片和槽位的优势"></a><font color="red">分片和槽位的优势</font></h3><ul>
<li><p><code>方便扩缩容</code>和<code>数据分派查找</code></p>
</li>
<li><p>容易添加或者删除节点，将一个结点的哈希槽移动到另一个节点并不会停止服务，所以无论<code>添加删除或者改变</code>某个节点的哈希槽的数量都不会造成集群不可用的状态。</p>
</li>
</ul>
<h3 id="槽位映射方案"><a href="#槽位映射方案" class="headerlink" title="槽位映射方案"></a><font color="red">槽位映射方案</font></h3><h4 id="哈希取余分区-textcolor-red-lt-和服务器数量有关-gt"><a href="#哈希取余分区-textcolor-red-lt-和服务器数量有关-gt" class="headerlink" title="哈希取余分区$\textcolor{red}{&lt;和服务器数量有关&gt;}$"></a>哈希取余分区$\textcolor{red}{&lt;和服务器数量有关&gt;}$</h4><ul>
<li>优点:<ul>
<li>简单有效，只需要预估好数据规划的节点就可以了</li>
<li>使用<code>Hash算法让固定的一部分请求落到同一台服务器上</code>，这样每台服务器固定处理一部分请求 (并维护这些请求的信息)， 起到<code>负载均衡+分而治之</code>的作用。</li>
</ul>
</li>
<li>缺点:<ul>
<li>扩容或者缩容就比较麻烦；一旦某个redis机器宕机了，由于台数数量变化，会导致hash取余全部数据重新洗牌。</li>
</ul>
</li>
</ul>
<h4 id="一致性哈希算法分区"><a href="#一致性哈希算法分区" class="headerlink" title="一致性哈希算法分区"></a>一致性哈希算法分区</h4><ul>
<li><p>作用</p>
<ul>
<li>可以解决分布式缓存数据变动和映射问题，当服务器个数发生变动时，尽量减少影响客户端到服务器的映射关系</li>
</ul>
</li>
<li>步骤</li>
</ul>
<blockquote>
<ol>
<li><p>由<code>一致性Hash算法</code>构建一致性哈希环</p>
<p>上面的节点取模法是对<code>节点（服务器）</code>的数量进行取模。而一致性Hash算法是对2^32^取模，简单来说，一致性Hash算法将整个<code>哈希值空间组织成一个虚拟的圆环</code><br><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202307030011466.png" alt="image-20230525170513937" style="zoom:35%;"></p>
</li>
<li><p>服务器IP节点映射: 将集群中各个IP节点映射到环上的某一个位置<br>将各个服务器使用Hash进行运算，可以选择服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置<br><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202307030011366.png" alt="image-20230525170644816" style="zoom:35%;"></p>
</li>
<li>key落到服务器的落键规则<br>当我们需要存储一个kv键值对时，首先计算key的hash值，hash(key)，将这个key使用相同的函数Hash计算出哈希值并确定此数据在环上的位置，<strong>从此位置沿环顺时针“行走”</strong>，第一台遇到的服务器就是其应该定位到的服务器，并将该键值对存储在该节点上。<br><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202307030011119.png" alt="image-20230525170901005" style="zoom:35%;"></li>
</ol>
</blockquote>
<ul>
<li><p>优点</p>
<blockquote>
<ol>
<li><p>一致性哈希算法的容错性</p>
<p>一般的，在一致性Hash算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器〈即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响</p>
</li>
</ol>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202307030011988.png" alt="image-20230525170927600" style="zoom:40%;"></p>
<ol>
<li><p>一致性哈希算法的扩展性</p>
<p>数据量增加了，需要增加一台节点NodeX，X的位置在A和B之间，那收到影响的也就是A到X之间的数据，重新把A到X的数据录入到X上即可，不会导致hash取余全部数据重新洗牌。</p>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202307030012869.png" alt="image-20230525170937921" style="zoom:40%;"></p>
</li>
</ol>
</blockquote>
</li>
<li><p>缺点</p>
<blockquote>
<ol>
<li><p>一致性哈希算法的数据倾斜问题</p>
<p>一致性Hash算法在服务<strong>节点太少时</strong>，容易因为节点分布不均匀而造成<strong>数据倾斜</strong>（被缓存的对象大部分集中缓存在某一台服务器上)问题</p>
</li>
</ol>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202307030011410.png" alt="image-20230525171000852" style="zoom:40%;"></p>
</blockquote>
</li>
</ul>
<h4 id="哈希槽分区"><a href="#哈希槽分区" class="headerlink" title="哈希槽分区"></a>哈希槽分区</h4><ul>
<li><p>作用</p>
<ul>
<li><p>解决均匀分配的问题，在数据和节点之间又加入了一层，把这层称为哈希槽(slot)，用于管理数据和节点之间的关系，现在就相当于节点上放的是槽，槽里面放的是数据。</p>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202307030011361.png" alt="image-20230525171159628" style="zoom:25%;"></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>为什么Redis集群的最大槽数是16384个</p>
<blockquote>
<p>Redis集群并没有使用一致性hash而是引入了哈希槽的概念,作用是：每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽</p>
</blockquote>
<ul>
<li>(1)如果槽位为65536，发送心跳信息的消息头达8k（65536÷8÷1024=8kb），发送的<code>心跳包过于庞大</code></li>
<li>(2)redis的集群主节点数量基本<code>不可能超过1000个</code></li>
<li>(3)槽位越小，节点少的情况下，<code>压缩比高，容易传输</code></li>
</ul>
</li>
</ul>
<p>==注意==</p>
<blockquote>
<p>Redis集群不保证强一致性： 在特定的条件下，Redis集群可能会丢掉一些被系统收到的写入请求命令</p>
</blockquote>
<h2 id="集群下的批处理"><a href="#集群下的批处理" class="headerlink" title="集群下的批处理"></a>集群下的批处理</h2><p>集群下的批处理命令的多个key必须落在一个插槽中，否则就会导致执行失败</p>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305272026267.png" alt="image-20230527202618094" style="zoom:43%;"></p>
<p>==第一种方案==：串行执行，所以这种方式没有什么意义，当然，执行起来就很简单了，缺点就是耗时过久。</p>
<p>==第二种方案==：串行slot，简单来说，就是执行前，客户端先计算一下对应的key的slot，一样slot的key就放到一个组里边，不同的，就放到不同的组里边，然后对每个组执行pipeline的批处理，他就能串行执行各个组的命令，这种做法比第一种方法耗时要少，但是缺点呢，相对来说复杂一点，所以这种方案还需要优化一下</p>
<p>==第三种方案==：并行slot，相较于第二种方案，在分组完成后串行执行，第三种方案，就变成了并行执行各个命令，所以他的耗时就非常短，但是实现呢，也更加复杂。</p>
<p>==第四种方案==：hash_tag，redis计算key的slot的时候，其实是根据key的有效部分来计算的，通过这种方式就能一次处理所有的key，这种方式耗时最短，实现也简单，但是如果通过操作key的有效部分，那么就会导致所有的key都落在一个节点上，产生数据倾斜的问题。</p>
<p>我们==推荐使用第三种方式==</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 redis总和</title>
    <url>/post/fa4c2b27.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><blockquote>
<p>关系型VS非关系型</p>
</blockquote>
<ul>
<li>存储方式<ul>
<li>关系型数据库基于磁盘进行存储，会有大量的磁盘IO，对性能有一定影响</li>
<li>非关系型数据库，他们的操作更多的是依赖于内存来操作，内存的读写速度会非常快，性能自然会好一些</li>
</ul>
</li>
</ul>
<ul>
<li>扩展性<ul>
<li>关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用，称为垂直扩展。</li>
<li>非关系型数据库可以将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题。称为水平扩展。</li>
<li>关系型数据库因为表之间存在关联关系，如果做水平扩展会给数据查询带来很多麻烦</li>
</ul>
</li>
</ul>
<blockquote>
<p>redis</p>
</blockquote>
<ul>
<li>是一个基于内存的键值型<code>NoSQL</code>数据库。</li>
</ul>
<p><strong>能干什么</strong></p>
<ul>
<li><p>缓存</p>
<blockquote>
<p>Redis常用于作为高速缓存，将常用的数据存储在内存中，提高访问速度和响应时间，减轻后端数据库的压力。Redis支持多种数据结构，可以根据数据的类型和特点选择合适的数据结构进行缓存。</p>
</blockquote>
</li>
<li><p><code>RDB</code>和<code>AOF</code>持久化</p>
<blockquote>
<p>redis<code>支持异步</code>将<code>内存</code>中的数据写到硬盘上，同时不影响继续服务。</p>
<p>即使设备断电了，数据也不会丢失，重启后重新<code>从硬盘恢复</code>数据。</p>
</blockquote>
</li>
<li><p>高可用架构搭配：单机、主从、哨兵、集群</p>
<blockquote>
<p>支持大规模数据存储和高并发访问。</p>
</blockquote>
</li>
<li><p>解决缓存穿透、击穿、雪崩</p>
<blockquote>
<ol>
<li>对查询不存在的数据的请求进行过滤，比如采用<code>Bloom Filter</code>进行<code>缓存预热或者对查询请求</code>进行<code>缓存穿透</code>保护。</li>
<li>对于热点数据的访问，可以采用<code>分布式锁</code>等方法对缓存进行保护，避免<code>缓存击穿</code>。</li>
<li>对于<code>缓存雪崩</code>，可以采用<code>缓存预热、缓存过期时间随机化、缓存数据的多级缓存</code>等方法进行缓解。</li>
</ol>
</blockquote>
</li>
<li><p>分布式锁</p>
<blockquote>
<p>Redis支持原子操作和过期时间等特性，可以用于实现分布式锁。</p>
<p>可以保证在分布式系统中同一时刻只有一个客户端可以持有锁，从而保证共享资源的互斥访问。</p>
<p>例如，可以使用Redis的SETNX命令实现基于key的锁，使用Lua脚本实现基于value的锁。</p>
</blockquote>
</li>
<li><p>消息队列</p>
<blockquote>
<p>redis提供了多种队列模式：List队列、Pub/Sub队列、Stream队列</p>
</blockquote>
</li>
<li><p>计数器和排行榜</p>
<blockquote>
<p>Redis支持原子操作，可以用于实现计数器和排行榜功能。</p>
<p>例如，可以使用Redis的INCR命令实现计数器功能，使用ZADD命令实现有序集合排行榜功能。</p>
</blockquote>
</li>
</ul>
<p>除了以上几个方面，Redis还可以用于实现<code>限流、地理位置服务、实时统计</code>等应用场景。</p>
<p>总之，Redis是一个功能丰富、性能优秀的内存数据库，适合于需要高性能、高可用(集群、主从、哨兵、集群)、高并发的应用场景。</p>
<p><strong>特征</strong>：</p>
<ul>
<li>键值（key-value）型，value支持多种不同数据结构，功能丰富</li>
<li>单线程，每个命令具备原子性</li>
<li>低延迟，速度快（基于内存、IO多路复用、良好的编码）。</li>
<li>支持数据持久化</li>
<li>支持主从集群、分片集群</li>
<li>支持多语言客户端</li>
</ul>
<p><strong>优势</strong></p>
<ul>
<li>性能极高 -Redis能读的速度是110000次/秒，写的速度是81000次/秒</li>
<li>Redis数据类型丰富，不仅仅支持简单的key-value类型的数据，同时还提供list，zset，set，hash等数据结构的存储</li>
<li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用</li>
<li>Redis支持数据的备份，即master-slave模式的数据备份</li>
</ul>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305242035738.png" alt="image-20230524203532710"></p>
<blockquote>
<p>String</p>
</blockquote>
<p>String类型，也就是字符串类型，是Redis中最简单的存储类型。</p>
<p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p>
<ul>
<li>string：普通字符串</li>
<li>int：整数类型，可以做自增、自减操作</li>
<li>float：浮点类型，可以做自增、自减操作</li>
</ul>
<p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m.</p>
<blockquote>
<p>Hash</p>
</blockquote>
<p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p>
<p>K-V模式不变，但v又是一个键值对：Map<key,Map<key,value>&gt;</key,Map<key,value></p>
<ul>
<li>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便</li>
<li>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD</li>
</ul>
<blockquote>
<p>List    <strong>列表</strong></p>
</blockquote>
<p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p>
<p>特征也与LinkedList类似：</p>
<ul>
<li>有序</li>
<li>元素可以重复</li>
<li>插入和删除快</li>
<li>查询速度一般</li>
</ul>
<p>Redis的List类型是一个单Key多Value的集合，其value值是有序可重复的。</p>
<p><em>如果键不存在，创建新的链表；</em></p>
<p><em>如果键已存在，新增内容，可重复；</em></p>
<p><em>如果值全移除，对应的键也就消失了。</em></p>
<p>常用来存储一个有序数据，例如：<code>朋友圈点赞列表，评论列表</code>等。</p>
<blockquote>
<p>set</p>
</blockquote>
<p>Redis的Set结构与Java中的HashSet类似，它内部键值对是无序的、唯一的。它的内部实现相当于一个特殊的字典，字典中所有的value都是一个值NULL，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p>
<ul>
<li>无序</li>
<li>元素不可重复</li>
<li>查找快</li>
<li>支持交集、并集、差集等功能</li>
</ul>
<p>应用场景：</p>
<ul>
<li>微信抽奖小程序。（SRANDMEMBER）</li>
<li>微信朋友圈共友点赞。（SINTER）</li>
<li>QQ推荐可能认识的人。（SDIFF）</li>
</ul>
<blockquote>
<p>SortedSet(ZSet)</p>
</blockquote>
<p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。</p>
<p>SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。score的值是一个<em>整型数值或者浮点数值</em>  的数，是可重复的。</p>
<p>SortedSet具备下列特性：</p>
<ul>
<li>可排序</li>
<li>元素不重复</li>
<li>查询速度快</li>
</ul>
<p>因为SortedSet的可排序特性，经常被用来实现<code>排行榜</code>这样的功能</p>
<blockquote>
<p>HyperLogLog  <strong>基数统计</strong></p>
</blockquote>
<p>HyperLogLog是一种概率数据结构，用于计数唯一的事物(技术上这是指<code>估计一个集合的基数</code>)。(基数就是一个数据集中去除重复数据后总的个数)</p>
<p>HyperLogLog的数据类型还是String。在Redis中的HyperLogLog，虽然技术上是不同的数据结构，但被编码为Redis字符串。</p>
<ul>
<li><p>在Redis里面每个HyperLogLog键只需要花费12kb内存就可以统计接近2^64个不同元素的基数。</p>
</li>
<li><p>HyperLogLog只会根据输入的元素来计算计数，不会存储输入的元素本身，所以HyperLogLog不能像集合那样返回输入的元素。</p>
</li>
</ul>
<p>应用场景:</p>
<ul>
<li>网站、文章的uv  (独立访客 要去重考虑)</li>
<li>网站某关键词的搜索数量</li>
<li>用户每天搜索的不同词条数目</li>
</ul>
<blockquote>
<p>Bitmap   <strong>位图</strong></p>
</blockquote>
<p>用String类型作为底层数据结构实现的一种统计二值状态的数据类型。</p>
<p>位图本质是数组，该数组由多个二进制位组成，<code>其值只能是1或0</code>，默认0，每个二进制位都对应一个偏移量(我们称之为一个索引)。偏移位从 <code>0</code> 开始</p>
<p>Bitmap支持的最大位数是2^32^位，它可以极大的节约存储空间，使用512M内存就可以存储多达42.9亿的字节信息。<br>(512<em>1024\</em>1024*8=2^9^*2^10^*2^10^*2^3^ = 2^32^)</p>
<p>一个字节占有8位，若在一个bitmap类型的key中，偏移量(索引)为8的位置存入1，前面7位会默认设置为0，那么该key占用两个字节，因为偏移量为8的那一位属于第二个字节了。</p>
<blockquote>
<p>应用使用 ：由于offset值得范围是[0,2^32^-1]，这个数非常大，可以将<u>用户id和偏移量形成映射关系</u>来存储很多二值数据：<br>通常先将用户存储到哈希表中，通过field值来标识每一位用户，然后再将field值和偏移量形成映射关系，比如<br><code>HSET user 1 uid1001 2 uid1002</code> ：1代表uid1001，2代表uid1002<br><code>SETBIT sign:Monday 1 1</code>    偏移量1的位置值为1，偏移量1对应用户uid1001（1表示已签到，0表示未签到）<br><code>SETBIT sign:Monday 2 1</code>    偏移量2的位置值为1，偏移量2对应用户uid1002<br>……<br><code>SETBIT sign:Monday n 1</code><br>再通过<code>BITCOUNT sign:Monday</code>就很容易获取Monday<code>签到的用户数量</code>了</p>
</blockquote>
<p>应用场景:</p>
<ul>
<li><code>打卡、签到</code></li>
<li>用户是否登陆过Y、N，比如软件的每日签到功能</li>
<li>电影、广告是否被点击播放过</li>
</ul>
<blockquote>
<p>Geospatial  <strong>地理空间</strong></p>
</blockquote>
<p>Redis地理空间索引可以存储坐标并搜索它们。</p>
<p>此数据结构用于在给定半径或包围框内查找附近点。</p>
<p>Geopatial的数据类型是Zset，相当于由之前的<code>score</code>变成了<code>longitude</code>和<code>latitude</code>，可以使用Zset的命令对其进行操作。</p>
<p>应用场景:</p>
<ul>
<li>交友软件中附近的人</li>
<li>外卖软件中附近的美食店铺</li>
<li>高德地图附近的核酸检查点</li>
</ul>
<blockquote>
<p>Stream  <strong>流</strong>    就是<code>redis</code>版本的<code>MQ</code></p>
<p>背景:</p>
<p>Redis5.0 之前</p>
<ul>
<li>List实现消息队列，List实现方式其实就是点对点的模式(一进一出)</li>
<li>Pub/Sub[发布/订阅]</li>
</ul>
<p>Redis5.0版本新增了一个更强大的数据结构—-Stream</p>
<ul>
<li>Stream流就是Redis版的MQ消息中间件+阻塞队列</li>
</ul>
</blockquote>
<p>Redis流是一种数据结构（Stream类型），它的作用类似于只能追加的日志。可以使用流来实时记录和同时聚合事件。</p>
<p>Redis流用例示例包括:</p>
<ul>
<li><p>事件来源(例如，跟踪用户操作、点击等)</p>
</li>
<li><p>传感器监测(例如，来自现场设备的读数)</p>
</li>
<li><p>通知(例如，在单独的流中存储每个用户通知的记录)</p>
</li>
</ul>
<p>Redis为每个流消息生成一个唯一的ID，可以使用这些id检索它们关联的消息，或者读取和处理流中的所有后续消息。</p>
<blockquote>
<p>四种和ID有关的特殊符号：<br><code>-</code>和<code>+</code>：当前流中最小ID和最大ID<br><code>$</code>：表示大于当前流中最大的id，用于新添加的消息<br><code>&gt;</code>：用于XREANGROUP命令，表示迄今没有发送给组中使用者的信息，会更新消费者组的最后ID<br><code>*</code>：用于XADD命令中，表示让系统自动生成ID</p>
</blockquote>
<p>Stream流就是Redis版的MQ消息中间件+阻塞队列，它能实现消息队列，它支持消息的持久化、支持自动生成全局唯一ID、支持ack确认消息的模式、支持消费组模式等，让消息队列更加的稳定和可靠。</p>
<blockquote>
<p>$\textcolor{blue}{一个消息链表，将所有加入的消息都串起来，每个消息都有一个唯一的ID和对应的内容}$</p>
</blockquote>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305250027574.png" alt="image-20230525002759535"></p>
<ul>
<li><p>Message Content：消息内容</p>
</li>
<li><p>Consumer group：消费组，通过<code>XGROUP CREATE</code>命令创建，同一个消费组可以有多个消费者</p>
</li>
<li><p>Last_delivered_id：游标，每个消费组会有个游标<code>last_delivered_id</code>，任意一消费者读取了消息都会使游标 <code>last_delivered_id</code> 往前移动。</p>
</li>
<li><p>Consumer：消费者，消费组中的消费者</p>
</li>
<li><p>Pending_ids：消费者会有一个状态变量，用于记录被当前消费已读取但未ack的消息Id，如果客户端没有ack，这个变量里面的消息ID会越来越多，一旦某个消息被ack它就开始减少。这个pending_ids变量在Redis官方被称之为 PEL(Pending Entries List)，记录了当前已经被客户端读取的消息，但是还没有 ack (Acknowledge character：确认字符），它用来确保客户端至少消费了消息一次，而不会在网络传输的中途丢失了没处理</p>
</li>
</ul>
<blockquote>
<p><em>Bitfield    位域(了解)</em></p>
</blockquote>
<p>将一个redis字符串看作是<strong>一个由二进制位组成的数组</strong>并能对变长位宽和任意没有字节对齐的指定整型<code>位域进行寻址和修改</code></p>
<p>主要作用：</p>
<ul>
<li><code>位域修改</code></li>
<li><code>溢出控制</code></li>
</ul>
<blockquote>
<p>BITFIELD命令的作用在于它能够将很多小的整数储存到一个长度较大的位图中，又或者将一个非常庞大的键分割为多个较小的键来进行储存，从而非常高效地使用内存，使得Rdis能够得到更多不同的应用一特别是在实时分析领域：BTFIELD能够以指定的方式对计算溢出进行控制的能力，使得它可以被应用于这一领域。</p>
</blockquote>
<p>Bitfield结构的底层也是String类型。</p>
<p>Redis位字段允许设置、递增和获取任意位长度的整数值。例如可以对从无符号1位整数到有符号63位整数的任何数字进行操作。</p>
<p>这些值使用二进制编码的Redis字符串存储。位字段支持原子读、写和递增操作，这使它们成为管理计数器和类似数值的好选择。</p>
<blockquote>
<p>例如:  hello 等价于<code>0110100001100101011011000110110001101111</code>，每八位对应一个字母，也对应一个十进制值。可以修改每一位的数字从而改变对应的数值从而改变对应的字母。</p>
</blockquote>
<hr>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><blockquote>
<p>将数据写入持久存储，如固态硬盘(SSD)</p>
<p>1、RDB</p>
</blockquote>
<p>$\textcolor{red} {定义}$</p>
<p>RDB  以指定的时间间隔执行数据集的时间点快照,就是把某一时刻的数据和状态以文件的形式写到磁盘上，也就是快照</p>
<p>在默认情况下， Redis 将数据库快照保存在名字为 dump.rdb的二进制文件中。可以对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动保存一次数据集。也可以通过调用 SAVE或者 BGSAVE ， 手动让 Redis 进行数据集保存操作。</p>
<p>在指定的时间间隔内将内存中的数据集快照写入磁盘，它恢复时再将硬盘快照文件直接读回到内存里。</p>
<p>Redis的数据都在内存中，保存备份时它执行的是全量快照，即：把内存中的所有数据都记录到磁盘中。</p>
<p>$\textcolor{red}{优劣}$</p>
<p>优:</p>
<ul>
<li>RDB是Redis 数据的一个非常紧凑的单文件时间点表示。RDB文件非常适合备份。例如，您可能希望在最近的24小时内每小时归档一次RDB文件，并在30天内每天保存一个RDB快照。这样就可以在发生灾难时轻松恢复不同版本的数据集。</li>
<li>RDB非常适合灾难恢复，它是一个可以传输到远程数据中心或Amazon S3(可能已加密）的压缩文件。</li>
<li>RDB最大限度地提高了Redis 的性能，因为Redis 父进程为了持久化而需要做的唯一工作就是派生一个将完成所有其余工作的子进程。父进程永远不会执行磁盘I/О或类似操作。</li>
<li>与AOF 相比，RDB允许使用大数据集更快地重启。</li>
<li>在副本上，RDB支持重启和故障转移后的部分重新同步。</li>
<li>对数据完整性和一致性要求不高</li>
</ul>
<p>劣:</p>
<ul>
<li>在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失从当前至最近一次快照期间的数据，<strong>快照之间的数据会丢失</strong></li>
<li>内存数据的全量同步，如果数据量太大会导致IO严重影响服务器性能</li>
<li>RDB依赖于主进程的fork，在更大的数据集中，这可能会导致服务请求的瞬间延迟。fork的时候内存中的数据被克隆了一份，大致2倍的膨胀性，需要考虑</li>
</ul>
<p>$\textcolor{red}{备份}$</p>
<blockquote>
<p>触发备份：</p>
<h5 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h5><ul>
<li>按照redis.conf里配置的 save \<seconds> \<changes></changes></seconds></li>
</ul>
<p><strong>备份：</strong></p>
<p>在 Redis 中，保存快照并不是在规定的时间到达后才进行，而是在修改数据时和时间间隔条件的<code>双重限制</code>下才进行的。</p>
<p>如果限制只按时间间隔来进行保存快照，则会出现两个问题：</p>
<ul>
<li><p>如果时间间隔太大，那么 Redis 持久化的数据可能会丢失，并且故障恢复时的数据可能会受到影响。</p>
</li>
<li><p>如果时间间隔太小，那么数据的保存成本就会过高，并可能导致 Redis 运行效率下降。</p>
</li>
</ul>
<p>因此，Redis 引入了按时间和数据修改次数双重限制的快照保存机制，以在灵活性和效率之间取得平衡。如果在 5 秒内修改的次数超过 2 次，则说明数据的变化较快，在此情况下保存快照并不会带来明显的性能问题。因此，Redis 将其纳入保存快照的范围，以保证数据的安全和一致性</p>
<p><strong>恢复：</strong></p>
<p>将备份文件(dump.rdb)移动到 Redis 安装目录并启动服务即可</p>
<p>物理恢复，一定要将服务产生的RDB文件备份一份，然后分机隔离，避免生产上物理损坏后备份文件也挂了。</p>
<h5 id="被动触发："><a href="#被动触发：" class="headerlink" title="被动触发："></a>被动触发：</h5><p>使用save或者bgsave命令  $\textcolor{red}{redis提供了两个命令来生成RDB文件，分别是save和bgsave}$</p>
<p><strong>save</strong>：在主程序中执行会<strong>阻塞</strong>当前redis服务器，直到持久化工作完成执行save命令期间，Redis不能处理其他命令，<strong>线上禁止使用</strong></p>
<p><strong>bgsave(默认)</strong>：redis会在后台异步进行快照操作，这就允许主进程同时可以修改数据。<strong>不阻塞</strong>快照同时还可以相应客户端请求，该触发方式会fork一个子进程由子进程复制持久化过程</p>
</blockquote>
<p>$\textcolor{red}{.rdb文件}$</p>
<p>哪些情况会触发RDB快照</p>
<ol>
<li>配置文件中默认的快照配置</li>
<li>手动<code>save/bgsave</code>命令</li>
<li>执行<code>flushdb/fulshall</code>命令也会产生dump.rdb文件，但是也会将命令记录到dump.rdb文件中，恢复后依旧是空，无意义</li>
<li>执行<code>shutdown且没有</code>设置开启AOF持久化</li>
<li>主从复制时，<code>主节点自动触发</code></li>
</ol>
<p>禁用快照</p>
<ol>
<li>动态所有停止RDB保存规则的方法：<code>redis-cli config set value &quot;&quot;</code></li>
<li>手动修改配置文件  <code>save &quot;&quot;</code></li>
</ol>
<blockquote>
<p>2、AOF</p>
</blockquote>
<p>$\textcolor{red}{定义}$</p>
<p>$\textcolor{red}{以日志的形式来记录每个写操作}$，将Redis执行过的所有写指令记录下来(读操作不记录)，只许追加文件但是不可以改写文件，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p>
<p>默认情况下，redis是没有开启AOF的。开启AOF功能需要设置配置：appendonly yes</p>
<p>$\textcolor{red}{流程}$</p>
<ol>
<li><p>Client作为命令的来源，会有多个源头以及源源不断的请求命令。</p>
</li>
<li><p>在这些命令到达Redis Server 以后并不是直接写入AOF文件，会将这些命令先放入AOF缓存中进行保存。这里的AOF缓冲区实际上是内存中的一片区域，存在的目的是当这些命令达到一定量以后再写入磁盘，避免频繁的磁盘IO操作。</p>
</li>
<li><p>AOF缓冲会根据AOF缓冲区<strong>同步文件的三种写回策略</strong>将命令写入磁盘上的AOF文件。</p>
</li>
<li><p>随着写入AOF内容的增加为避免文件膨胀，会根据规则进行命令的合并(<strong>又称AOF重写</strong>)，从而起到AOF文件压缩的目的。</p>
</li>
<li><p>当Redis Server服务器重启的时候会对AOF文件载入数据。</p>
</li>
</ol>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305251051356.png" alt="image-20230525105157332" style="zoom:33%;"></p>
<p>$\textcolor{red}{写回策略}$</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">配置项</th>
<th style="text-align:center">写回时机</th>
<th style="text-align:center">优点</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Always</td>
<td style="text-align:center">同步写回</td>
<td style="text-align:center">可靠性高，数据基本不丢失</td>
<td style="text-align:center">每个写命令都要同步记录，性能影响较大</td>
</tr>
<tr>
<td style="text-align:center">Everysec</td>
<td style="text-align:center">每秒写回</td>
<td style="text-align:center">性能适中</td>
<td style="text-align:center">宕机时丢失一秒内的数据</td>
</tr>
<tr>
<td style="text-align:center">No</td>
<td style="text-align:center">操作系统控制的写回</td>
<td style="text-align:center">性能好</td>
<td style="text-align:center">宕机时丢失数据较多</td>
</tr>
</tbody>
</table>
</div>
<p>$\textcolor{red}{变化}$</p>
<ul>
<li><p>redis7之前 aof 文件有且只有一个</p>
</li>
<li><p>redis7之后 aof文件变为了multi part</p>
<ul>
<li><strong>BASE: 表示基础AOF</strong>，它一般由子进程通过重写产生，该文件最多只有一个。</li>
</ul>
</li>
</ul>
<ul>
<li><strong>INCR:表示增量AOF</strong>，它一般会在AOFRW开始执行时被创建，该文件可能存在多个。</li>
</ul>
<ul>
<li><strong>HISTORY</strong>:表示历史AOF，它由BASE和INCR AOF变化而来，每次AOFRW成功完成时，本次AOFRW之前对应的BASE和INCR AOF都将变为HISTORY，HISTORY类型的AOF会被Redis自动删除。</li>
</ul>
<p>为了管理这些AOF文件，我们引入了一个manifest (清单)文件来跟踪、管理这些AOF。</p>
<p>$\textcolor{red}{优劣}$</p>
<p>优</p>
<ul>
<li>使用AOF Redis 更加持久。</li>
<li>AOF 日志是一个仅附加日志，因此不会出现寻道问题，也不会在断电时出现损坏问题。</li>
<li>当AOF 变得太大时，Redis 能够在后台自动重写AOF。重写是完全安全的，因为当 Redis继续附加到旧文件时，会使用创建当前数据集所需的最少操作集生成一个全新的文件，一旦第二个文件准备就绪，Redis 就会切换两者并开始附加到新的那一个。</li>
<li>AOF以易于理解和解析的格式依次包含所有操作的日志。可以轻松导出AOF文件。</li>
</ul>
<p>劣</p>
<ul>
<li>相同数据集的数据而言AOF文件要远大于RDB文件，恢复速度慢于RDB</li>
<li>AOF运行效率要慢于RDB，每秒同步策略效率较好，不同步效率和RDB相同</li>
</ul>
<p>$\textcolor{red}{重写机制}$</p>
<ul>
<li>当AOF文件的大小超过所设定的峰值时，Redis就会<strong>自动</strong>启动AOF文件的内容压缩。只保留可以恢复数据的最小指令集。</li>
</ul>
<p>何时触发：</p>
<ul>
<li>自动触发<ul>
<li>满足配置文件中的选项后，Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时</li>
</ul>
</li>
<li><strong>手动触发</strong><ul>
<li>客户端向服务器发送bgrewriteaof命令</li>
</ul>
</li>
</ul>
<blockquote>
<p>AOF文件重写并不是对原文件进行重新整理，而是直接读取服务器现有的键值对，然后用一条命令去代替之前记录这个键值对的多条命令，生成一个新的文件后去替换原来的AOF文件</p>
</blockquote>
<p>原理：</p>
<ol>
<li>在重写开始前，redis会创建一个“重写子进程”，这个子进程会读取现有的AOF文件，并将其包含的指令进行分析压缩并写入到一个临时文件中。</li>
<li>与此同时，主进程会将新接收到的写指令一边累积到内存缓冲区中，一边继续写入到原有的AOF文件中（这样做是保证原有的AOF文件的可用性，避免在重写过程中出现意外。）</li>
<li>当“重写子进程”完成重写工作后，它会给父进程发一个信号，父进程收到信号后就会将内存中缓存的写指令追加到新AOF文件中</li>
<li>当追加结束后，redis就会用新AOF文件来代替旧AOF文件，之后再有新的写指令，就都会追加到新的AOF文件中</li>
<li>重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似</li>
</ol>
<blockquote>
<p>3、混合持久化</p>
</blockquote>
<p><strong>$\textcolor{red}{数据恢复顺序和加载流程}$</strong></p>
<p>在<code>同时</code>开启<code>rdb</code>和<code>aof</code>持久化时，重启时<code>只会</code>加载<code>aof</code>文件，<code>不会</code>加载<code>rdb</code>文件</p>
<p>$\textcolor{blue}{定义区别}$</p>
<ul>
<li>RDB持久化方式能够在指定的时间间隔对你的数据进行快照存储。</li>
<li>AOF持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以redis协议追加保存每次写的操作到文件末尾。</li>
</ul>
<p><span style="color:red">同时开启两种持久化方式</span></p>
<ul>
<li>当redis重启的时候会<code>优先载入AOF文件</code>来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</li>
<li>RDB的数据不是实时的，同时使用两者时服务器重启也只会找AOF文件。 redis  的 作者也不建议只使用AOF方式备份，因为RDB更适合用于备份数据库（AOF在不断的变化不好备份），留着RDB是为了 作为一个以防万一的手段。</li>
</ul>
<blockquote>
<p>推荐使用<code>两者混合使用</code></p>
<ul>
<li>RDB镜像做全量持久化，AOF做增量持久化</li>
</ul>
<p>建议先使用RDB进行快照存储，</p>
<p>然后使用AOF持久化记录所有的写操作，</p>
<p>当重写策略满足或手动触发重写的时候，将最新的数据存储为新的RDB记录。</p>
<p>这样的话，重启服务的时候会从RDB和AOF两部分恢复数据，既保证了数据完整性，又提高了恢复数据的性能。</p>
<p>简单来说:混合持久化方式产生的文件一部分是RDB格式，一部分是AOF格式。——&gt;AOF包括了RDB头部+AOF混写</p>
<p>4、纯缓存模式</p>
</blockquote>
<p><code>同时关闭</code>RDB+AOF，只用缓存</p>
<ol>
<li><p>save “”  — 禁用RDB</p>
<p>禁用RDB持久化模式下，我们仍然可以使用命令save、bgsave生成RDB文件</p>
</li>
<li><p>appendonly no  — 禁用AOF</p>
<p>禁用AOF持久化模式下，我们仍然可以使用命令bgrewriteaof生成AOF文件</p>
</li>
</ol>
<hr>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>可以一次执行多个命令，本质是一组命令的集合，一个事务中的所有命令都会序列化，$\textcolor{red}{按顺序地串行化执行而不会被其他命令插入，不许加塞}$</p>
<p>$\textcolor{red}{特点}$</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>单独的隔离操作</th>
<th>Redis的事务仅仅是保证事务里的操作会被连续独占的执行，redis命令执行是单线程架构，在执行完事务内所有指令前是不可能再去同时执行其他客户端的请求的</th>
</tr>
</thead>
<tbody>
<tr>
<td>没有隔离级别的概念</td>
<td>因为事务提交前任何指令都不会被实际执行，也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这种问题了</td>
</tr>
<tr>
<td>不保证原子性</td>
<td>Redis的事务不保证原子性，也就是不保证所有指令同时成功或同时失败，只有决定是否开始执行全部指令的能力，没有执行到一半进行回滚的能力</td>
</tr>
<tr>
<td>排它性</td>
<td>Redis会保证一个事务内的命令依次执行，而不会被其它命令插入</td>
</tr>
</tbody>
</table>
</div>
<p>$\textcolor{red}{流程}$</p>
<p>（1）开启：以<code>MULTI</code>命令开启一个事务</p>
<p>（2）入队：将多个命令加入到事务队列中，接到这些命令并不会立即执行。</p>
<p>（3）执行：由<code>EXEC</code>命令执行事务队列中的命令。</p>
<hr>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>Redis 管道（Pipeline）是一种在客户端和 Redis 服务器之间建立的双向通道，它可以让客户端在一次请求中发送多个命令并一次性接收多个命令的响应结果。通过使用 Redis 管道，客户端可以减少网络通信的次数，从而提高 Redis 的吞吐量和性能。</p>
<blockquote>
<p>在传统的 Redis 操作中，每个命令都需要通过网络发送到 Redis 服务器，然后等待 Redis 服务器返回响应结果后再进行下一个命令的操作，这样就会产生大量的网络通信开销。而使用 Redis 管道，客户端可以将多个命令一次性发送到 Redis 服务器，然后一次性接收所有命令的响应结果，从而减少网络通信的次数和开销。</p>
</blockquote>
<p>$\textcolor{red}{总结}$</p>
<ul>
<li>Pipeline与原生批量命令(<code>mset</code>)对比：<ul>
<li>原生批量命令（例如mset、mget）具有原子性，pipeline是非原子性。</li>
<li>原生批量命令一次只能执行一种命令，pipeline支持批量执行不同命令。</li>
<li>原生批命令是redis服务端实现，而pipeline需要redis服务端和客户端共同完成。</li>
</ul>
</li>
<li>Pipeline与事务对比：<ul>
<li>事务具有原子性，管道不具有原子性。</li>
<li>管道一次性将命令发送给服务器，事务是一条一条的发，事务只有在接收到EXEC命令后才会执行。</li>
<li>执行事务时会阻塞其他命令的执行，而执行管道中的命令不会。</li>
</ul>
</li>
<li>使用Pipeline注意事项：<ul>
<li>pipeline缓冲的指令只是会依次执行，不保证原子性，如果执行中指令发生异常，还会继续执行后续的指令。</li>
<li>使用pipeline传输的命令也不能太多，如果数据量大客户端的阻塞时间可能会过久，同时服务端此时也被迫回复一个队列答复，占用很多内存。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="集群下的批处理"><a href="#集群下的批处理" class="headerlink" title="集群下的批处理"></a>集群下的批处理</h2><p>如果Redis是一个集群，那批处理命令的多个key必须落在一个插槽中，否则就会导致执行失败。</p>
<p><span style="color:red">方式</span></p>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305272026267.png" alt="image-20230527202618094" style="zoom:33%;"></p>
<p>第一种方案：串行执行，所以这种方式没有什么意义，当然，执行起来就很简单了，缺点就是耗时过久。</p>
<p>第二种方案：串行slot，简单来说，就是执行前，客户端先计算一下对应的key的slot，一样slot的key就放到一个组里边，不同的，就放到不同的组里边，然后对每个组执行pipeline的批处理，他就能串行执行各个组的命令，这种做法比第一种方法耗时要少，但是缺点呢，相对来说复杂一点，所以这种方案还需要优化一下</p>
<font color="red">第三种方案：并行slot</font>，相较于第二种方案，在分组完成后串行执行，第三种方案，就变成了并行执行各个命令，所以他的耗时就非常短，但是实现呢，也更加复杂。

第四种：hash_tag，redis计算key的slot的时候，其实是根据key的有效部分来计算的，通过这种方式就能一次处理所有的key，这种方式耗时最短，实现也简单，但是如果通过操作key的有效部分，那么就会导致所有的key都落在一个节点上，产生数据倾斜的问题，所以我们推荐使用第三种方式。



## 发布和订阅

- Redis 发布和订阅（Publish/Subscribe，简称 Pub/Sub）是一种消息传递模式，用于在 Redis 中实现消息的发布和订阅。

- 在 Redis 中，发布者（Publisher）可以将消息发送到一个或多个频道（Channel），订阅者（Subscriber）可以订阅一个或多个频道，以接收发布者发送的消息。当发布者在某个频道上发布一条消息时，所有订阅该频道的订阅者都会收到这条消息。

`Redis Pub/Sub` 是基于消息传递的异步通信模型，可以用于构建实时系统、聊天室、实时广播等应用场景。

$\textcolor{red}{总结}$

- 发布的消息在Redis系统不能持久化，因此必须先执行订阅，再等待消息发布，如果先发布了消息且该消息没有订阅者接收，那么该消息被直接丢弃。
- 消息只管发送，对于发布者而言消息是即发即失的，也没有ACK机制，无法保证消息是否消费成功。
- Redis5.0新增了Stream数据结构，不但支持多播，还支持数据持久化，比Pub/Sub更加强大。



---



## 复制

> Redis 复制可以提高系统的可用性、可靠性和扩展性，使得在发生故障时可以快速地恢复数据。

slave可以执行写命令吗？

- slave不可以执行写命令。master负责写命令，也可以执行读命令，slave负责读命令。即使slave是另一台slave的master，也不能执行写命令。

slave是从头开始复制还是从切入点开始复制?

- 都可以
- 当从节点`第一次连接主节点`时，如果主节点还`没有持久化数据`，从节点将`从头开始复制`。即主节点会将自己的全部数据发送给从节点，从节点将接收并保存全部数据。

- 当从节点与主节点`已经建立了连接`，并且已经有了初始数据同步，如果从节点断开与主节点的连接后重新连接，从节点可以选择从上次同步的位置（复制偏移量）继续同步数据，这样可以避免从头开始复制所带来的性能影响和数据冗余。（master会检查backlog里面的offset，master和slave都会保存一个复制的offset和一个masterId）

> 需要注意的是，如果从节点断开与主节点的连接时间过长，主节点可能已经自动执行了 BGSAVE 命令，生成了新的 RDB 文件，此时从节点需要从头开始复制。此外，如果从节点的内存不足，也可能需要从头开始复制，以避免内存溢出。

主节点SHUTDOWN后，从节点会上位吗？

- 主节点关闭后，从节点不会变成主节点，它们会等待主节点重新启动，但是从节点的数据可以正常读取。-主节点重启后，主从关系依旧存在。

$\textcolor{red}{复制的过程}$

（1）从节点向主节点发送 `SYNC` 命令,从节点`第一次`与主节点进行连接的时候会进行一次全量复制（完全同步），slave自身原有数据会被master数据覆盖清除

（2）主节点接收到` SYNC 命令`后，开始在`后台保存快照`，生成 RDB 文件，收集并缓存此过程中记录所有执行的写命令。

（3）主节点在执行完`rdb持久化`后，将生成的 RDB 文件和所有的缓存命令发送给从节点，完成一次完全同步。

（4）从节点接收到主节点发送的 RDB 文件和写命令，会将其进行存盘，并加载到内存中，完成复制初始化，来保持与主节点的数据一致。

（5）从节点持续监听主节点发来的新命令，并将其执行，以保持与主节点的数据同步。

（6）为了保持主节点和从节点之间的通信，master会发出PING包的周期默认是10秒（：`repl-ping-replica-period 10`在661行）

（6）当主节点发生故障时，从节点会尝试与其他主节点建立连接，并选举出一个新的主节点（手动  slave of|自动 哨兵），从而成为新的从节点，[注意：默认情况下，不会在slave节点中自动选一个master]

（7）从机下线重新连接的时候，master会进行检查backlog里面的offset,master只会把已经缓存的`offset后面`的数据复制给slave

> Redis 复制是异步的，因此从节点可能存在数据不一致的情况。
>
> 为了避免数据不一致，可以设置 Redis 的复制偏移量（replication offset），当从节点与主节点连接断开后，从节点可以通过该偏移量快速地同步数据。

$\textcolor{red}{缺点}$ (引出`哨兵和集群`)

（1）*数据同步延迟*：由于 Redis 复制是异步的，从节点的数据可能会与主节点存在一定的延迟，因此从节点可能无法实时获取到最新的数据。

（2）*单点故障*：当主节点发生故障时，需要手动进行故障转移或者使用集群来保证系统的可用性。

（3）*网络通信问题*：当网络出现故障或者通信延迟过高时，复制的效率会受到影响，从节点可能无法及时接收到主节点发送的数据。

（4）*内存消耗问题*：当从节点处理不过来主节点发送过来的写命令时，从节点会自动触发执行全量复制，这会导致从节点内存消耗变大

（5）*数据安全问题*：当主节点的数据被误删或者篡改时，从节点也会受到影响，因此需要采取一定的措施来保证数据的安全性





---

## 哨兵Sentinel

是 Redis 的高可用性解决方案之一，它可以用于监控和管理 Redis 主从复制集群，并在主节点发生故障时`自动`将从节点升级为新的主节点，从而保证系统的`高可用性`和可靠性。

$\textcolor{red}{作用:}$

1. **主从监控**：监控主从redis库运行是否正常

2. **消息通知**：哨兵可以将故障转移的结果发送给客户端

3. **故障转移**：如果master异常，则会进行主从切换，将其中一个slave作为新master

4. **配置中心**：客户端通过连接哨兵来获得当前Redis服务的主节点地址



$\textcolor{red}{哨兵的流程原理}$

1. 当哨兵检测到主节点不可用时，会将主节点标记为下线状态(sdown)，并向其他哨兵发送通知，通知其他哨兵主节点已经下线，其他哨兵也标记主节点下线后(odown)，确定主节点不可用

> 下线方式：
>
> - 主观下线(sdown)：指的是单个Sentinel实例对服务器做出的下线判断，即单个sentinel认为某个服务下线（有可能是接收不到订阅，之间的网络不通等等原因）。就是说如果服务器在给定的毫秒数之内没有回应PING命令或者返回一个错误消息， 那么这个Sentinel会主观的(单方面的)认为这个master不可以用了。
>
> - 客观下线(odown)：客观下线需要多个哨兵达成一致意见才能认为主节点真正不可用。quorum(票数)这个参数是进行客观下线的一个依据。

2. 哨兵在检测到主节点不可用后，会进入选举状态，此时开始选举哨兵的领导者。

> 选举算法：
>
> - 监视该主节点的所有哨兵都有可能被选为领导者，选举使用的算法是Raft算法；Raft算法的基本思路是先到先得

3. 哨兵leader开始推动故障切换流程并选举出一个新的master

> 选举规则：
>
> - 优先级 (slave-priority  、 replica-priority)  （数值越小优先级越高）
> - 复制偏移量（大的优先）
> - run id（小的优先，每个redis实例启动后都会随机生成一个40位的run id）

4. 选举出新的master后由Sentinel leader完成failover工作(故障切换)

> 具体流程：
>
> - 执行slaveof no one命令让选出来的从节点成为新的主节点，并通过slaveof命令让其他节点（包括原来的master）成为新主节点的从节点。
> - Sentinel leader会向被重新配置的实例发送一个 CONFIG REWRITE 命令， 从而确保这些配置会持久化在硬盘里(写入配置文件)。
> - 值得注意的是： 原来的master重连也将变成从节点

$\textcolor{red}{故障恢复的流程}$

- 从下线的主服务的所有从服务里面挑选个从服务，将其转成主服务（选举的原则就是上面👆🏻的）

- 从服务挑选出新的主服务之后，`sentinel` 向原主服务的从服务发送自己是新主机的命令，其他的将变为该服务的从服务
- 下线的主机再次上线时，`sentinel`会向其发送`slaveof`命令：让其成为新主的从节点



==注意==

- 哨兵节点的数量应为多个，哨兵本身应该集群，保证高可用，哨兵节点的数量应该是奇数

- 哨兵集群+主从复制，并`不能保证数据零丢失`（引出集群cluster，集群可以解决这一问题），此时数据丢失的原因就是：master宕机后，哨兵需要在一定时间内选出新的master并执行failover操作，这段时间内从节点无法写入数据，造成数据丢失。

---



## 集群

$\textcolor{red}{定义}$

Redis集群是一个提供在多个Redis节点间共享数据的程序集，Redis集群可以支持多个master

$\textcolor{red}{作用}$

- Redis集群支持`多个master`，每个master又可以挂载`多个slave`
    1. 读写分离
    2. 支持数据的高可用
    3. 支持海量数据的读写存储操作
- 由于Cluster自带`Sentinel`的故障转移机制，内置了高可用的支持，`无需再去使用哨兵功能`
- 客户端与Redis的节点连接，不再需要连接集群中所有的节点，`只需要任意连接集群中的一个可用节点即可`
- 槽位`slot`负责分配到各个物理服务节点，由对应的集群来负责维护节点、插槽和数据之间的关系



$\textcolor{red}{槽位slot}$

Redis集群没有使用一致性hash 而是引入了哈希槽的概念。

Redis集群有16384个哈希槽每个key通过`CRC16校验`后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽

$\textcolor{red}{分片}$

- 是什么： 使用Redis集群时我们会将存储的数据分散到多台redis机器上，这称为分片。就是集群中的每个Redis实例都被认为是整个数据的一个分片。

- 如何找到给定key的分片：为了找到给定key的分片，我们对key进行`CRC16(key)`算法处理并通过对总分片数量取模。然后，使用确定性`哈希函数`，这意味着`给定的key`将多次始终映射到同一个分片，我们可以推断将来读取特定key的位置。

$\textcolor{red}{分片和槽位的优势}$

- 方便扩缩容和数据分派查找
- 容易添加或者删除节点，将一个结点的哈希槽移动到另一个节点并不会停止服务，所以无论`添加删除或者改变`某个节点的哈希槽的数量都不会造成集群不可用的状态。

$\textcolor{red}{槽位映射方案}$

- 哈希取余分区$\textcolor{red}{<和服务器数量有关>}$

    - 优点:
        - 简单有效，只需要预估好数据规划的节点就可以了
        - 使用Hash算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求 (并维护这些请求的信息)， 起到负载均衡+分而治之的作用。
    - 缺点:
        - 扩容或者缩容就比较麻烦；一旦某个redis机器宕机了，由于台数数量变化，会导致hash取余全部数据重新洗牌。

- 一致性哈希算法分区

    - 作用

        - 可以解决分布式缓存数据变动和映射问题，当服务器个数发生变动时，尽量减少影响客户端到服务器的映射关系

    - 步骤

        - 由一致性Hash算法构建一致性哈希环

      > 上面的节点取模法是对`节点（服务器）`的数量进行取模。
      >
      > 而一致性Hash算法是对2^32^取模，简单来说，一致性Hash算法将整个`哈希值空间组织成一个虚拟的圆环`
      >
      > <img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305251705966.png" alt="image-20230525170513937" style="zoom:25%;">

        - 服务器IP节点映射: 将集群中各个IP节点映射到环上的某一个位置

      > 将各个服务器使用Hash进行运算，可以选择服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置
      >
      > <img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305251706848.png" alt="image-20230525170644816" style="zoom:25%;">

        - key落到服务器的落键规则

      > 当我们需要存储一个kv键值对时，首先计算key的hash值，hash(key)，将这个key使用相同的函数Hash计算出哈希值并确定此数据在环上的位置，**从此位置沿环顺时针“行走”**，第一台遇到的服务器就是其应该定位到的服务器，并将该键值对存储在该节点上。
      >
      > <img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305251709034.png" alt="image-20230525170901005" style="zoom:25%;">

    - 优点

        - 一致性哈希算法的容错性

      > 一般的，在一致性Hash算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器〈即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响
      >
      > <img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305251709670.png" alt="image-20230525170927600" style="zoom:20%;">

        - 一致性哈希算法的扩展性

      > 数据量增加了，需要增加一台节点NodeX，X的位置在A和B之间，那收到影响的也就是A到X之间的数据，重新把A到X的数据录入到X上即可，不会导致hash取余全部数据重新洗牌。
      >
      > <img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305251709030.png" alt="image-20230525170937921" style="zoom:25%;">

    - 缺点

        - 一致性哈希算法的数据倾斜问题

      > 一致性Hash算法在服务**节点太少时**，容易因为节点分布不均匀而造成**数据倾斜**（被缓存的对象大部分集中缓存在某一台服务器上)问题
      >
      > <img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305251710888.png" alt="image-20230525171000852" style="zoom:25%;">

- 哈希槽分区

    - 作用

        - 解决均匀分配的问题，在数据和节点之间又加入了一层，把这层称为哈希槽(slot)，用于管理数据和节点之间的关系，现在就相当于节点上放的是槽，槽里面放的是数据。

          <img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305251711708.png" alt="image-20230525171159628" style="zoom:25%;">

        -

---



- 为什么Redis集群的最大槽数是16384个

  > Redis集群并没有使用一致性hash而是引入了哈希槽的概念,作用是：每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽

    - (1)如果槽位为65536，发送心跳信息的消息头达8k（65536÷8÷1024=8kb），发送的心跳包过于庞大
    - (2)redis的集群主节点数量基本不可能超过1000个
    - (3)槽位越小，节点少的情况下，压缩比高，容易传输

==注意==

> Redis集群不保证强一致性： 在特定的条件下，Redis集群可能会丢掉一些被系统收到的写入请求命令



---

## 整合

> `Jedis`   Jedis本身是`线程不安全`的，并且`频繁的创建和销毁连接`会有性能损耗，推荐使用Jedis`连接池`代替Jedis的`直连`方式。



> `SpringDataRedis`    提供了RedisTemplate工具类，其中封装了各种对Redis的操作

<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305242101617.png" alt="image-20230524210152588" style="zoom:33%;">

> 解决序列化：

方式一：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 创建JSON序列化工具</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jsonRedisSerializer</span> <span class="operator">=</span> </span><br><span class="line">            							<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// 设置Key的序列化</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// 设置Value的序列化</span></span><br><span class="line">        template.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

==方式二：==

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowrited</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplete stringRedisTemplete</span><br><span class="line"><span class="comment">// JSON序列化工具</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">    <span class="comment">// 创建对象</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;虎哥&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    <span class="comment">// 手动序列化</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:200&quot;</span>, json);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonUser</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:200&quot;</span>);</span><br><span class="line">    <span class="comment">// 手动反序列化</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> mapper.readValue(jsonUser, User.class);</span><br><span class="line">    System.out.println(<span class="string">&quot;user1 = &quot;</span> + user1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



> 解决转圈圈

- 原因：SpringBoot客户端没有动态感知RedisCluster的最新集群信息

- 现象：Redis Cluster集群部署采用了3主3从拓扑结构，数据读写访问master节点，slave节点负责备份。当master宕机主从切换成功，redis可以正常运行，但是java程序出现异常

- 解决：

    - 排除lettuce采用Jedis（不推荐）

    - 重写连接工厂实例（极度不推荐）

    - `刷新节点集群拓扑动态感应`

        - 调用 RedisClusterClient.reloadPartitions
        - 后台基于时间间隔的周期刷新
        - 后台基于持续的 **断开** 和 **移动**、**重定向** 的自适应更新

      <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#支持集群拓扑动态感应刷新，自适应拓扑刷新是否使用所有可用的更新，默认false关闭</span></span><br><span class="line"><span class="string">spring.redis.lettuce.cluster.refresh.adaptive=true</span></span><br><span class="line"><span class="comment">#定时刷新</span></span><br><span class="line"><span class="string">spring.redis.lettuce.cluster.refresh.period=2000</span></span><br></pre></td></tr></table></figure>



## redis单线程 VS 多线程

> Redis是单线程究竟何意

Redis是单线程主要是指Redis的网络IO和键值对读写是由一个线程来完成的，Redis在处理客户端的请求时包括获取(socket 读)、解析、执行、内容返回(socket 写) 等都由一个顺序串行的主线程处理，这就是所谓的“单线程”

优点

- 使用单线程模型使 Redis 的开发和维护更简单，因为单线程模型方便开发和调试;
- 即使使用单线程模型也并发的处理多客户端的请求，主要使用的是`IO多路复用和非阻塞IO`；
- 对于Redis系统来说，主要的`性能瓶颈`是内存或者网络带宽而并非 CPU。

问题：

- 大key删除会陷入等待   [因为是单线程原子命令操作，这就会导致 Redis 服务卡顿]
- 随着网络硬件的性能提升，Redis的性能瓶颈有时会出现在网络IO的处理上,单个主线程处理网络请求的速度跟不上底层网络硬件的速度

> Redis的多IO线程只是用来处理网络请求的，**对于读写操作命令Redis仍然使用单线程来处理**

原因：

- Redis处理请求时，网络处理经常是瓶颈，通过多个IO线程并行处理网络操作，可以提升实例的整体处理性能。
- 而继续使用单线程执行命令，就不用为了保证Lua脚本、事务的原子性，额外开发多线程$\textcolor{red}{互斥加锁机制了(不管加锁操作处理)}$，这样一来，Redis线程模型实现就简单了

主线程和IO线程协作完成请求处理的过程

![image-20230525204935302](https://gitee.com/Ryang1118/typora/raw/master/images/202305252049332.png)

> redis 为什么快

<span style="color:red">IO多路复用  + epoll  + 存于内存之中+ 单线程命令</span>

- IO多路复用是什么
    - 一种同步的IO模型，实现<font color="red">一个线程</font>监视<font color="green">`多个`文件句柄(文件描述符),一旦某个文件句柄就绪</font>就能够通知到对应应用程序进行相应的读写操作，<font color="red">没有文件句柄就绪时</font>就会阻塞应用程序从而释放CPU资源
    - 多路：多个客户端连接(连接就是套接字描述符，即 socket 或者 channel)
    - 复用：复用一个或几个线程
    - IO多路复用：就是一个或一组线程处理多个TCP连接，使用单进程就能够实现同时处理多个客户端的连接，<font color="red">无需创建或者维护过多的进程/线程</font>
    - 实现IO多路复用的模型有3种: 可以分`select->poll->epoll`三个阶段来描述。



IO多路复用原理: 有请求就响应，没请求不打扰

采用多路/O复用技术可以让单个线程高效的处理多个连接请求一个服务端进程可以同时处理多个套接字描述符。





> `epoll`是什么

> 浅记：你站在讲台上等，谁解答完谁举手。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案然后继续回到讲台上等] 此时E、A又举手，然后去处理E和A。。。这种就是IO复用模型。 Linux下的select、poll和epoll就是干这个的。

工作原理：

- 将用户socket对应的文件描述符(FileDescriptor)注册进epoll，然后epoll帮你监听哪些socket上有消息到达，这样就避免了大量的无用操作。

- 此时的socket应该采用<font color="red">非阻塞模式</font>。这样，整个过程只在调用select、poll、epoll这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的reactor反应模式。

> 多线程下操作Redis不会有线程安全问题

- 对于`网络数据读写、请求协议解析` 是通过多个IO线程的来处理

  而命令的执行依旧是由主线程串行执行的

  因此在多线程下操作Redis不会出现线程安全的问题



## BigKey

- <font color="blue">keys * 这个指令有致命的弊端，在实际环境中最好不要使用</font>

<ul>
<li><p>用<code>Scan</code></p>
<ul>
<li><p>SCAN命令是一个基于<code>游标</code>的迭代器，每次被调用之后，都会向用户<code>返回一个新的游标</code>，<font color="red">用户在下次迭代时需要使用这个新游标作为SCAN命令的游标参数</font>，以此来延续之前的迭代过程。</p>
</li>
<li><p>命令   <code>SCAN cursor [MATCH pattern] [COUNT count]</code></p>
<ul>
<li>cursor - 游标。</li>
<li>pattern - 匹配的模式。</li>
<li>count - 指定从数据集里返回多少元素，默认值为 10 。</li>
</ul>
</li>
<li><p>SCAN的遍历顺序</p>
<font color="red">非常特别，它不是从第一维数组的第零位一直遍历到末尾，而是采用了高位进位加法来遍历。之所以使用这样特殊的方式进行遍历，是考虑到字典的扩容和缩容时避免槽位的遍历重复和遗漏。</font>
</li>
<li><p>返回值<br>SCAN返回一个包含<font color="blue">两个元素的数组</font>，</p>
<p>第一个元素是用于进行下一次迭代的新游标，<br>第二个元素则是一个数组，这个数组中包含了所有被迭代的元素。<font color="red">如果新游标返回零表示迭代已结束。</font></p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>多大算BigKey</p>
</blockquote>
<ul>
<li><p>通常我们说的BigKey，不是在值的Key很大，而是指的Key对应的value很大</p>
</li>
<li><p>list、hash、set和zset，value的实际上个数超过5000就是bigkey</p>
</li>
<li><p>string是value，理论上最大是512MB，但是  实际上 ≥10KB就是bigkey</p>
</li>
<li><p>非字符串的bigkey,不要使用del删除，使用<code>hscan、sscan、zscan</code>方式渐进式删除，同时要注意防止bigkeyi过期时间自动删除问题</p>
</li>
</ul>
<blockquote>
<p>危害</p>
</blockquote>
<ul>
<li>内存不均，集群迁移困难</li>
<li>超时删除，大key删除作梗  ：对元素较多的hash、list、zset等做运算会耗时较旧，使主线程被阻塞</li>
<li>网络流量阻塞 ：对BigKey执行读请求时，少量的QPS就可能导致带宽使用率被占满，导致Redis实例，乃至所在物理机变慢</li>
<li>数据倾斜 ：   BigKey所在的Redis实例内存使用率远超其他实例，无法使数据分片的内存资源达到均衡</li>
</ul>
<blockquote>
<p>发现</p>
</blockquote>
<ul>
<li><font color="red">--bigkeys参数 + （查询大于10kb的所有key）memory usage  [给出一个 `key` 和它的值在 内存 中所占用的字节数。] </font>

</li>
</ul>
<blockquote>
<p>如何删除</p>
</blockquote>
<ul>
<li>String   一般用del，如果<code>过于庞大</code>使用<code>unlink key</code>删除</li>
<li>hash    使用<code>hscan</code>每次获取少量<code>field-value</code>，再使用<code>hdel</code>删除每个<code>field</code></li>
<li>list       使用<code>ltrim</code>渐进式逐步删除   [让列表只保留指定区间内的元素，不在指定区间之内的元素都将被除。]</li>
<li>set      使用<code>sscan</code>每次获取部分元素，在使用<code>srem</code>命令删除每个元素</li>
</ul>
<ul>
<li>zset     使用<code>zscan</code>每次获取部分元素，在使用<code>zremrangebyrank</code>命令删除每个元素</li>
</ul>
<blockquote>
<p>生产调优   — ”惰性释放“</p>
</blockquote>
<p>redis有两种删除的方式</p>
<ul>
<li><p><code>del</code>    阻塞型删除</p>
<blockquote>
<p>这意味着服务器停止处理新命令，以便以同步方式回收与对象关联的所有内存。如果删除的键与一个小对象相关联，则执行DEL命令所需的时间非常短  ，Redis中的O(1)或O(Iog_N)命令。但是，如果键与包含数百万个元素的聚合值相关联，则服务器可能会阻塞很长时间（甚至几秒钟）才能完成操作。</p>
</blockquote>
</li>
<li><p><code>unlink</code> 非阻塞型删除</p>
<blockquote>
<p>基于上述原因，Redis还提供了非阻塞删除原语，例如<code>UNLINK</code>(非阻塞DEL)以及<code>FLUSHALL</code>和<code>FLUSHDB</code>命令的<code>ASYNC</code>选项，以便在后台回收内存。这些命令在恒定时间内执行。另一个线程将尽可能快地逐步释放后台中的对象。<code>FLUSHALL</code>和<code>FLUSHDB</code>的<code>DEL</code>、<code>UNLINK</code>和<code>ASYNC</code>选项是用户控<br>制的。</p>
</blockquote>
</li>
</ul>
<p>优化配置</p>
<blockquote>
<p><code>lazyfree-lazy-server-del        yes</code></p>
<p><code>replica-lazy-flush              yes</code></p>
<p><code>lazyfree-lazy-user-del          yes</code></p>
</blockquote>
<h2 id="缓存双写一致性"><a href="#缓存双写一致性" class="headerlink" title="缓存双写一致性"></a>缓存双写一致性</h2><ul>
<li><p>如果redis中<font color="red">有数据</font>    需要和数据库中的值相同</p>
</li>
<li><p>如果redis中<font color="red">无数据</font>     数据库中的值要是最新值，且准备回写redis</p>
</li>
</ul>
<p>缓存按照操作来分，细分2种</p>
<ul>
<li><p>只读缓存</p>
</li>
<li><p>读写缓存</p>
<ul>
<li><p>同步直写策略<code>[就是只要查到数据库就立刻回写到缓存，保持同步,及时生效]</code></p>
<ul>
<li><p>写数据库之后也同步写redis缓存，缓存和数据库中的数据一致；</p>
</li>
<li><p>对于读写缓存来说，要想保证缓存和数据库中的数据一致，就要采用<code>同步直写策略</code></p>
</li>
</ul>
</li>
<li><p>异步缓写策略<code>[业务上有一定的延时允许]</code></p>
<ul>
<li><p>正常业务中，MySQL数据变了，但是可以在业务上容许出现一定时间后才作用于redis，比如仓库、物流系统</p>
</li>
<li><p>异常情况出现了， 不得不将失败的动作重新修补，有可能需要借助kafka或者RabbitMQ等消息中间件，实现重试重写</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<font color="red">采用双检加锁策略</font>

<blockquote>
<p>没有加锁的隐患：</p>
<ul>
<li>对于mysql的请求会大量增加<code>（mysql会被打爆）</code></li>
<li>对于redis 的回写操作可能会 数据覆盖（不是原子操作，多线程就会并发，引发问题）</li>
</ul>
</blockquote>
<p>多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个<code>互斥锁</code>来锁住它。</p>
<p>其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。</p>
<p>后面的线程进来发现已经有缓存了，就直接走缓存。</p>
<blockquote>
<p>防止打爆<code>mysql</code></p>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305252254716.png" alt="image-20230525225420679" style="zoom: 25%;"></p>
<p>更新策略</p>
</blockquote>
<ul>
<li><p>目的 ： 我们要达到最终一致性</p>
</li>
<li><p>弱一致性：</p>
<ul>
<li>使用redis的内存淘汰机制</li>
<li>过期剔除： <font color="blue">给缓存设置过期时间，定期清理缓存并回写，是保证最终一致性的解决方案。</font></li>
</ul>
</li>
</ul>
<blockquote>
<p>我们可以对存入缓存的数据设置过期时间，所有的<font color="gree">写操作以数据库为准</font>，对缓存操作只是尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存，达到一致性，<font color="gree">切记，要以mysql的数据库写入库为准</font>。</p>
</blockquote>
<ul>
<li><p>强一致性：</p>
<ul>
<li><p>可以停机：停机升级，服务降级</p>
</li>
<li><p>不可以停机：</p>
<ul>
<li><p>四种策略</p>
<ul>
<li><p>先更新数据库，在更新缓存</p>
</li>
<li><p>先更新缓存，再更新数据库</p>
</li>
<li><p>先删除缓存，在更新数据库</p>
</li>
<li><p>先更新数据库，在删除缓存</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><span style="color:red">先更新数据库，再更新缓存</span></p>
</blockquote>
<ul>
<li><p>异常问题1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> 先更新mysql的某商品的库存，当前商品的库存是<span class="number">100</span>，更新为<span class="number">99</span>个。</span><br><span class="line"><span class="number">2</span> 先更新mysql修改为<span class="number">99</span>成功，然后更新redis。</span><br><span class="line"><span class="number">3</span> 此时假设异常出现，更新redis失败了，这导致mysql里面的库存是<span class="number">99</span>而redis里面的还是<span class="number">100</span>。</span><br><span class="line"><span class="number">4</span> 上述情况发生之后，会让数据库里面和缓存redis里面数据不一致，读到redis脏数据</span><br></pre></td></tr></table></figure>
</li>
<li><p>异常问题2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">多线程环境下，A、B两个线程有快有慢，有前有后有并行</span><br><span class="line"><span class="number">1</span> A update mysql <span class="number">100</span></span><br><span class="line"><span class="number">3</span> B update mysql <span class="number">80</span></span><br><span class="line"><span class="number">4</span> B update redis <span class="number">80</span></span><br><span class="line"><span class="number">2</span> A update redis <span class="number">100</span></span><br><span class="line">=============================</span><br><span class="line">最终结果，mysql和lredis数据不一致，  mysql  <span class="number">80</span>,redis   <span class="number">100</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p> <span style="color:red">先更新缓存，再更新数据库</span></p>
 <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[异常逻辑]多线程环境下，A. B两个线程有快有慢有并行</span><br><span class="line"> A update redis 100</span><br><span class="line"> B update redis 80</span><br><span class="line"> B update mysql 80</span><br><span class="line"> A update mysql 100</span><br><span class="line"> mysql 100,redis 80</span><br></pre></td></tr></table></figure>
<p><span style="color:red"> 先删除缓存，再更新数据库 </span></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1 A线程先成功删除了redis里面的数据，然后去更新mysql,此时mysql正在更新中，还没有结束。(比如网络延时)</span><br><span class="line"> B突然出现要来读取缓存数据。</span><br><span class="line"></span><br><span class="line">2 此时redis里面的数据是空的，B线程来读取，先去读redis里数据(已经被A线程delete掉了)，</span><br><span class="line"></span><br><span class="line">此处出来2个问题:</span><br><span class="line">	2.1 B从mysql获得了旧值   B线程发现redis里没有(缓存缺失)马上去mysql里面读取，从数据库里面读取来的是旧值。</span><br><span class="line">	2.2 B会把获得的旧值写回redis  获得旧值数据后返回前台并回写进redis(刚被A线程删除的旧数据有极大可能早被写回了)。</span><br><span class="line"></span><br><span class="line">3 A线程更新完mysql,发现redis里面的缓存是脏数据，</span><br><span class="line">两个并发操作，一个是更新操作，另一个是查询操作，A删除缓存后，B查询操作没有命中缓存，B先把老数据读出来后放到缓存中，然后A更新操作更新了数据库。于是，在缓存中的数据还是老的数据，导致缓存中的数据是脏的，而且还一直这样脏下去了。</span><br><span class="line"></span><br><span class="line">4总结流程:</span><br><span class="line">(1)请求A进行写操作，删除redis缓存后，工作正在进行中，更新mysql..... A还没有彻底更新完mysql,还没commit</span><br><span class="line">(2)请求B开工查询，查询redis发现缓存不存在(被A从redis中删除了)</span><br><span class="line">(3)请求B继续，去数据库查询得到了mysql中的旧值(A还没有更新完)</span><br><span class="line">(4)请求B将旧值写回redis缓存</span><br><span class="line">(5)请求A将新值写入mysql数据库</span><br><span class="line"></span><br><span class="line">上述情况就会导致不一致的情形出现。</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305252316603.png" alt="image-20230525231633568" style="zoom:33%;"></p>
<ul>
<li>问题：如果数据库更新失败或超时或返回不及时，导致B线程请求访问缓存时发现redis里面没数据，缓存缺失，B再去读取mysql时，从数据库中读取到旧值，还写回redis， 导致A白干了</li>
</ul>
</blockquote>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305262244890.png" alt="image-20230526224429842" style="zoom:35%;"></p>
<blockquote>
<p>延时双删</p>
</blockquote>
<p>$\textcolor{blue}{\large 先删除缓存，在更新数据库    的解决方案}$：</p>
<font color="red">采用`延时双删`[ 在第一次删除缓存值后，延迟一段时间再次进行删除]  策略 </font>

<p>主要思想就是： 让一个线程删除前先进行休眠，并且其sleep的时间  需要大于另一个正在进行  <code>读取数据+ 写入缓存</code>的线程 的耗时之和</p>
<font color="red">追问</font>

<ul>
<li><p><strong>这个删除该休眠多久呢</strong>？</p>
<ul>
<li>线程A sleep的时间，就需要大于线程B读取数据再写入缓存的时间。</li>
</ul>
</li>
<li><p><strong>这个时间怎么确定呢</strong>?</p>
<font color="blue">第一种方法：</font>在业务程序运行的时候，统计下线程读数据和写缓存的操作时间，`自行评估`自己的项目的读数据业务逻辑的耗时，以此为基础来进行估算。然后写数据的`休眠时间`则在`读数据业务逻辑的耗时基础上`加`百毫秒`即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。
<font color="blue">第二种方法：</font><font color="blue">新启动一个后台监控程序，比如后面要讲解的WatchDog监控程序，会加时</font>
</li>
<li><p><strong>这种同步淘汰策略，吞吐量降低怎么办？</strong></p>
<ul>
<li>将第二次删除作为异步的，再启动一个线程进行异步删除，就可以不让写请求进行sleep 之后再返回，即可加大吞吐量</li>
</ul>
</li>
</ul>
<blockquote>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305252331399.png" alt="image-20230525233149371" style="zoom:50%;"></p>
</blockquote>
<p>​</p>
<blockquote>
<p><span style="color:red"> 先更新数据库，再删除缓存 </span></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>时间</th>
<th>线程A</th>
<th>线程B</th>
<th>出现的问题</th>
</tr>
</thead>
<tbody>
<tr>
<td>t1</td>
<td>更新数据库中的值……</td>
<td></td>
<td></td>
</tr>
<tr>
<td>t2</td>
<td></td>
<td>缓存立刻命中，此时B读取的是缓存旧值</td>
<td>A还没来得及删除缓存的值，导致B缓存命中读到旧值</td>
</tr>
<tr>
<td>t3</td>
<td>更新缓存的数据，over</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>问题：先更新数据库，在删除缓存，假如缓存删除失败或者来不及删除，导致请求再次访问redis时缓存命中，<font color="red">读取到的是缓存的旧值。</font></p>
<p>解决：</p>
<ul>
<li>使用MQ</li>
<li>订阅MySQL的 binlog程序，使用中间件<code>canal</code></li>
</ul>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305252337738.png" alt="image-20230525233703703" style="zoom:35%;"></p>
<p>使用消息队列的基本思想</p>
<ul>
<li>可以把要删除的缓存值或者是要更新的数据库值<code>暂存</code>到<code>消息队列</code>中（例如使用Kafka/RabbitMQ等)。</li>
<li>当程序没有能够成功地删除缓存值或者是更新数据库值时，可以从消息队列中重新读取这些值，然后再次进行删除或更新。</li>
<li>如果<code>能够成功地删除或更新</code>，我们就要把这些值<code>从消息队列中去除</code>，以免重复操作，此时，我们也可以保证数据库和缓存的数据一致了，否则还需要再次进行重试</li>
<li>如果<code>重试超过的一定次数后还是没有成功</code>，我们就需要向业务层发送报错信息了，通知运维人员。</li>
</ul>
<p>此种模式下严格意义上的 <code>强一致性</code>：</p>
<ul>
<li>如果业务层要求必须读取一致性的数据，那么我们就需要在更新数据库时，先在Redis缓存客户端暂停并发读请求，等数据库更新完、缓存值删除后，再读取数据，从而保证数据一致性</li>
</ul>
</blockquote>
<font color="blue" size="4">只能达到最终一致性!!!!</font>

<p>$\textcolor{red}{总结}$</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>策略</th>
<th>高并发多线程条件下</th>
<th>问题</th>
<th>现象</th>
<th>解决方案</th>
</tr>
</thead>
<tbody>
<tr>
<td>先删除redis缓存，再更新mysql</td>
<td>无</td>
<td>缓存删除成功但数据库更新失败</td>
<td>Java程序从数据库中读到旧值</td>
<td>再次更新数据库，重试</td>
</tr>
<tr>
<td>先删除redis缓存，再更新mysql</td>
<td>有</td>
<td>缓存删除成功但数据库更新中…有并发请求</td>
<td>并发请求从数据库读到旧值并回写到redis，导致后续都是从redis读取到旧值</td>
<td>延迟双删</td>
</tr>
<tr>
<td>先更新mysql，再删除redis缓存</td>
<td>无</td>
<td>数据库更新成功，但缓存删除失败</td>
<td>Java程序从redis中读到旧值</td>
<td>再次删除缓存，重试</td>
</tr>
<tr>
<td>先更新mysql，再删除redis缓存</td>
<td>有</td>
<td>数据库更新成功但缓存删除中……有并发读请求</td>
<td>并发请求从缓存读到旧值</td>
<td>等待redis删除完成，这段时间数据不一致，短暂存在。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>主动更新的三种模式：</p>
<ul>
<li><p>Cache Aside Pattern 旁路缓存模式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案</p>
</li>
<li><p>Read/Write Through Pattern 读写穿透模式: 由系统本身完成，数据库与缓存的问题交由系统本身去处理</p>
</li>
<li><p>Write Behind Caching Pattern 异步缓存写入模式：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致</p>
</li>
</ul>
<p>如何保证缓存与数据库的操作的同时成功或失败</p>
<ul>
<li>单体系统，将缓存与数据库操作放在一个<code>事务</code></li>
<li>分布式系统，利用<code>TCC等分布式事务</code>方案</li>
</ul>
</blockquote>
<hr>
<h2 id="Bitmap-Hyperloglog-GEO"><a href="#Bitmap-Hyperloglog-GEO" class="headerlink" title="Bitmap  Hyperloglog  GEO"></a>Bitmap  Hyperloglog  GEO</h2><blockquote>
<p>常见的四种统计</p>
</blockquote>
<ul>
<li>聚合统计       统计多个集合元素的聚合结果  <font color="red">交差并等集合统计</font></li>
<li><p>排序统计       在面对需要展示最新列表、排行榜等场景时，如果数据更新频繁或者需要分页显示，建议使用ZSet</p>
</li>
<li><p>二值统计       集合元素的取值就只有0和1两种。在钉钉上签到打卡的场景中，我们只用记录有签到(1)或没有签单(0)</p>
</li>
<li><p>基数统计       指统计一个集合中<font color="red">不重复的元素个数</font>，就是对集合去重复后剩余元素的计算</p>
</li>
</ul>
<blockquote>
<p>Hyperloglog</p>
</blockquote>
<ul>
<li><p>什么是UV           Unique Visitor，独立访客，一般理解为客户端IP      <font color="red">需要去重考虑</font></p>
</li>
<li><p>什么是PV            Page View，页面浏览量        不用去重</p>
</li>
<li><p>什么是DAU        Daily Active User，日活跃量用户，<font color="red">登录或者使用了某个产品的用户数（去重复登录的用户）</font>    常用于反映网站、互联网应用或者网络游戏的运营情况</p>
</li>
<li><p>什么是MAU        Monthly Active User，月活跃用户量</p>
</li>
</ul>
<p>引入：</p>
<ul>
<li>去重方式<ul>
<li>HashSet</li>
<li>bitmap： 所占内存巨大；bitmaps还是不适用大数据量下(亿级)的基数计数场景，<font color="red">但是bitmaps方法是精确计算的。</font></li>
</ul>
</li>
</ul>
<p>解决：</p>
<ul>
<li>概率算法<ul>
<li><font color="red">通过牺牲准确率来换取空间</font>，对于不要求<font color="blue">绝对准确率</font>的场景下可以使用，因为<font color="red">概率算法不直接存储数据本身</font>，通过一定的概率统计方法预估基数值，同时保证误差在一定范围内，由于又不储存数据故此可以大大节约内存.</li>
</ul>
</li>
</ul>
<p>原理</p>
<ul>
<li><p>只是进行不重复的基数统计，不是集合也不保存数据，只记录数量而不是具体内容</p>
</li>
<li><p>有误差，但是很低 0.81% （<code>1.04/sqrt(16384)</code>）；HyperLogLog提供不精确的去重计数方案</p>
</li>
</ul>
<blockquote>
<p>亿级UV的Redis设计方案</p>
</blockquote>
<p>不可行的方案：</p>
<ul>
<li>MySQL   高并发下，3000万的数据就需要分库分表了</li>
<li>redis的hash结构存储   太占内存了</li>
</ul>
<p>可行的方案：</p>
<ul>
<li>HyperLogLog   在Redis里面，每个HyperLogLog键只需要花费12KB内存，就可以计算接近2^64^个不同元素的基数</li>
</ul>
<blockquote>
<p>为什么是只需要花费12Kb?</p>
<p>Redist使用了2^14^=16384个桶，按照上面的标准差，误差为0.81%，精度相当高。Redis使用一个log型哈希值的前14个比特用来确定桶编号，剩下的50个比特用来做基数估计。而2^6^=64，所以只需要用6个比特表示下标值，在一般情况下，一个HLL数据结构(每个桶占6位)占用内存的大小为16384*6/8=12kB,Redis将这种情况称为密集(dense)存储。</p>
</blockquote>
<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305262258692.png" alt="image-20230526225827642" style="zoom:43%;"></p>
<blockquote>
<p>面试问题：</p>
<ul>
<li>现有50亿个电话号码，给你10万个电话号码，如何要<code>快速准确</code>的判断这些电话号码是否已经存在？</li>
<li><code>判断是否存在</code>，布隆过滤器了解过吗？</li>
<li>安全连接网址，全球数10亿的网址判断</li>
<li>黑名单校验，识别垃圾邮件</li>
<li>白名单校验，识别出合法用户进行后续处理</li>
</ul>
</blockquote>
<h3 id="textcolor-red-是什么"><a href="#textcolor-red-是什么" class="headerlink" title="$\textcolor{red}{是什么}$"></a>$\textcolor{red}{是什么}$</h3><ul>
<li>由<code>一个初值都为零的bit数组</code>和<code>多个哈希函数构成</code>，用来快速判断集合中是否存在某个元素</li>
</ul>
<h3 id="textcolor-red-目的"><a href="#textcolor-red-目的" class="headerlink" title="$\textcolor{red}{目的}$"></a>$\textcolor{red}{目的}$</h3><ul>
<li>减少内存占用；不保存数据信息，只是在内存中做一个是否存在的标记flag</li>
</ul>
<h3 id="textcolor-red-特点"><a href="#textcolor-red-特点" class="headerlink" title="$\textcolor{red}{特点}$"></a>$\textcolor{red}{特点}$</h3><ul>
<li>可以高效地插入和查询，占用空间少，返回的结果是不确定性</li>
<li>一个元素的判断结果：判断结果为<code>存在</code>时，元素<code>不一定存在</code>，但是判断结果为<code>不存在</code>时，则<code>一定不存在</code></li>
<li>布隆过滤器可以添加元素，但是<font color="red">不能删除元素，</font>由于涉及<code>hashcode</code>判断依据，删除元素会导致误判率增加。</li>
</ul>
<h3 id="textcolor-red-原理"><a href="#textcolor-red-原理" class="headerlink" title="$\textcolor{red}{原理}$"></a>$\textcolor{red}{原理}$</h3><ul>
<li>实质就是<font color="red">一个大型位数组和几个不同的无偏hash函数</font>(无偏表示分布均匀)。由一个初值都为零的bit数组和多个哈希函数构成，用来快速判断某个数据是否存在。但是跟 HyperLogLog 一样，它也一样有那么一点不精确，也存在一定的误判概率</li>
</ul>
<h3 id="textcolor-red-数据结构"><a href="#textcolor-red-数据结构" class="headerlink" title="$\textcolor{red}{数据结构}$"></a>$\textcolor{red}{数据结构}$</h3><ul>
<li><font color="blue">添加key时</font><br>使用<code>多个</code>hash函数对<code>key</code>进行<code>hash</code>运算得到一个整数索引值，对<code>位数组</code>长度进行<code>取模</code>运算得到一个位置，每个<code>hash函数</code>都会得到一个不同的位置，将这<code>几个位置</code>都置<code>1</code>就完成了<code>add</code>操作。</li>
<li><font color="blue">查询key时</font><br>只要有其中一位是零就表示这个key不存在，但如果都是1，则不一定存在对应的值</li>
<li>hash冲突导致数据不精准<ul>
<li>直接原因就在于 <code>哈希函数</code>会导致<code>哈希冲突</code></li>
<li>当有变量被加入集合时，通过<code>N个映射函数</code>将这个变量映射成位图中的<code>N个点</code>,把它们都要置为 1，当查询某个变量的时候我们只要看看这些点是不是都是 <code>1</code>，就可以大概率知道集合中有没有它了；如果这些点，<font color="red">有任何一个为零则被查询变量一定不在;</font>如果都是 1，则被查询变量很<font color="red">可能存在</font>，<font color="red">为什么说是可能存在，而不是一定存在呢?那是因为`映射函数本身就是散列函数`，`散列函数是会有碰撞的`。</font>


</li>
</ul>
</li>
</ul>
<blockquote>
<p>正是基于布隆过滤器的<code>快速检测特性</code>，我们可以在把数据写入数据库时，使用布隆过滤器做个标记。</p>
<p>当缓布缺失后，应用查询数据库时，可以通过查询布隆过滤器快速判断数据是否存在。</p>
<p>如果不存在，就不用再去据库中查询了。</p>
<p>这样一来，即使发生缓存穿透了，大量请求只会查询Redis和布隆过滤器，而不会积压到数据库，也就不会影响数据库的正常运行。</p>
<p>布隆过滤器可以使用Redis实现，本身就能承担较大的并发访问压力</p>
</blockquote>
<h3 id="textcolor-red-如何使用"><a href="#textcolor-red-如何使用" class="headerlink" title="$\textcolor{red}{如何使用}$"></a>$\textcolor{red}{如何使用}$</h3><ul>
<li>初始化bitmap       所有的值均设置为0</li>
<li>添加数据                为了尽量地址不冲突，<font color="red">会使用多个 hash 函数对 key 进行运算</font>，算得一个下标索引值，然后对位数组长度进行<font color="red">取模运算</font>得到一个位置，每个 hash 函数都会算得一个不同的位置。再把位数组的这几个位置都置为 1 就完成了 add 操作。</li>
<li>判断是否存在         先把这个 key 通过相同的<font color="red">多个 hash 函数进行运算</font>，查看对应的位置是否都为 1，<font color="red">只要有一个位为零，那么说明布隆过滤器中这个 key 不存在；</font><font color="red">如果这几个位置全都是 1，那么说明极有可能存在；</font></li>
</ul>
<h3 id="textcolor-red-即使误判也不要删除"><a href="#textcolor-red-即使误判也不要删除" class="headerlink" title="$\textcolor{red}{即使误判也不要删除}$"></a>$\textcolor{red}{即使误判也不要删除}$</h3><ul>
<li>误判的根源在于相同的 bit 位被多次映射且置 1</li>
<li>布隆过滤器的每一个 bit 并不是独占的，很有可能多个元素共享了某一位。如果我们直接删除这一位的话，会影响其他的元素</li>
<li>删掉元素会导致误判率增加。</li>
</ul>
<h3 id="textcolor-red-建议"><a href="#textcolor-red-建议" class="headerlink" title="$\textcolor{red}{建议}$"></a>$\textcolor{red}{建议}$</h3><ul>
<li>使用时最好不要让实际元素数量远大于初始化数量，一次给够避免扩容</li>
<li>当实际元素数量超过初始化数量时，应该对布隆过滤器进行重建，重新分配一个size 更大的过滤器，再将所有的历史元素批量add进行</li>
</ul>
<h3 id="textcolor-red-使用场景"><a href="#textcolor-red-使用场景" class="headerlink" title="$\textcolor{red}{使用场景}$"></a>$\textcolor{red}{使用场景}$</h3><ol>
<li><font color="red"> 解决缓存穿透的问题，和redis结合bitmap使用</font>

<ul>
<li><p>思路</p>
<ul>
<li><p>把已存在数据的key存在布隆过滤器中，相当于redis前面挡着一个布隆过滤器。当有新的请求时，先到布隆过滤器中查询是否存在:</p>
<p>如果布隆过滤器中<code>不存在</code>该条数据则直接返回;如果布隆过滤器中<code>已存在</code>，才去查询缓存redis，如果redis里没查询到则再查询Mysql数据库</p>
</li>
</ul>
</li>
</ul>
</li>
<li><font color="red"> 黑名单校验，识别垃圾邮件</font>

<ul>
<li>思路<ul>
<li>发现存在黑名单中的，就执行特定操作。比如:识别垃圾邮件，只要是邮箱在黑名单中的邮件，就识别为垃圾邮件。把所有黑名单都放在布隆过滤器中，在收到邮件时，判断邮件地址是否在布隆过滤器中即可。</li>
</ul>
</li>
</ul>
</li>
</ol>
<font color="red">优点：</font>

<ul>
<li>高效地插入和查询，内存中占用bit空间小</li>
</ul>
<p>劣</p>
<ul>
<li>不能删除元素[布谷鸟过滤器可以删除]，因为删除元素会导致误判率增加，因为hash冲突同一个位置可能存的东西是多个共有的</li>
<li>存在误差，不能 精准 过滤</li>
</ul>
<h2 id="缓存四问"><a href="#缓存四问" class="headerlink" title="缓存四问"></a>缓存四问</h2><h5 id="预热"><a href="#预热" class="headerlink" title="预热"></a>预热</h5><font color="red">是什么</font>

<ul>
<li>缓存预热就是系统上线后，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</li>
</ul>
<font color="red">怎么做</font>

<ul>
<li>将热点数据提前加载到<code>redis</code>缓存中，可以通过<code>@PostConstruct</code>提前在运行某个程序之前，将其加载到<code>redis</code>中</li>
<li>或者使用 <code>预加载类在程序启动的时候</code>存到<code>redis</code>中</li>
</ul>
<h5 id="雪崩"><a href="#雪崩" class="headerlink" title="雪崩"></a>雪崩</h5><font color="red">是什么</font>

<ul>
<li>缓存雪崩就是同一时段大量的缓存<code>key</code>同时失效或者<code>Redis服务宕机</code>，导致大量请求到达数据库，给数据库带来巨大压力。</li>
</ul>
<font color="red">何时发生</font>

<ul>
<li>Redis主机挂了，Redis全盘崩溃</li>
<li>Redis中有大量<code>key同时</code>过期<code>大面积失效</code>，</li>
</ul>
<font color="red">解决 与 预防</font>

<ul>
<li>Redis中key设置为<code>永不过期</code>或者过期时间为<code>指定时间+随机时间</code>，<code>错开同时过期的概率</code></li>
<li><p>Redis缓存集群实现高可用 [ <code>主从+哨兵</code>   <code>集群</code>  <code>开启Redis持久化机制AOF/RDB，尽快恢复缓存集群</code>]</p>
</li>
<li><p>多级缓存结合预防雪崩   <code>ehcache本地缓存 + Redis缓存</code></p>
</li>
<li><p>服务降级               <code>Hystrix</code>或者阿里<code>sentinel</code>限流&amp;降级</p>
</li>
</ul>
<h5 id="击穿"><a href="#击穿" class="headerlink" title="击穿"></a>击穿<redis 先有后失效></redis></h5><font color="red">是什么</font>

<ul>
<li>大量请求同时查询一个key时，此时这个key正好失效了，就会导致大量的请求都打到数据库，<font color="red">就是热点key突然失效了，MySQL压力增加</font></li>
</ul>
<font color="red">热点key失效可能</font>

<ul>
<li>时间到了自然清除但还是被访问到</li>
<li>delete掉的key，刚好又被访问到</li>
</ul>
<font color="red">解决</font>

<ul>
<li>方案一：差异失效时间，对于访问频繁的热点key，干脆就<code>不设置过期时间</code>   而是设置逻辑过期时间，但是会有一定的数据不一致性</li>
<li><font color="red">方案二：互斥更新，采用双检加锁策略</font>        多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个互斥锁来锁住它。其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存</li>
<li>互斥锁</li>
</ul>
<h5 id="穿透-lt-两库都没-gt"><a href="#穿透-lt-两库都没-gt" class="headerlink" title="穿透&lt;两库都没&gt;"></a>穿透&lt;两库都没&gt;</h5><font color="red">是什么</font>

<ul>
<li>请求去查询一条记录，先查redis，后查mysql，都查询不到，说明数据源是不存在的，但是请求每次都会打到数据库上面去，导致后台数据库压力暴增，这种现象我们称为缓存穿透</li>
</ul>
<font color="red">解决</font>

<ul>
<li>可以空对象缓存<ul>
<li>回写增强: 如果发生了缓存穿透，我们可以针对要查询的数据，在Redis里存一个规定的缺省值(比如,零、负数、defaultNull等)<ul>
<li>第一次来查询一旦 <code>redis</code>和<code>mysql</code>都没有，返回<code>nul</code>给<code>调用者</code>，同时也让<code>redis</code>存入刚刚查不到的<code>key</code>，并对应的填上<code>规定的缺省值</code>，那么第二次来查，此时redis就有值了。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><p>一旦多次穿透，redis就会有很多 垃圾 key ，占用内存（可以设置ttl定期删除），</p>
</li>
<li><p>但是因为这个<code>ttl</code> 可能会导致数据短期的不一致性 [mysql新增数据的时候同时存到redis,同样会有内存问题]</p>
<p>所以没有根本不能解决问题</p>
</li>
</ul>
</blockquote>
<ul>
<li>使用布隆过滤器(<code>Guava</code>)</li>
</ul>
<h5 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h5><p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305261302771.png" alt="image-20230526130227733" style="zoom:33%;"></p>
<hr>
<h2 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h2><blockquote>
<p>Redis 过期键的删除策略</p>
</blockquote>
<ul>
<li><p>立即删除      对CPU不友好，用处理器性能换取存储空间（拿时间换空间）</p>
</li>
<li><p>惰性删除      对memory 不友好，用存储空间换取处理器性能（拿空间换时间）</p>
</li>
<li><p>定期删除    每隔一段时间执行一次删除过期键操作并通过限制删除操作执行时长和频率来减少删除操作对CPU时间的影响。定期抽样key，判断是否过期</p>
<ul>
<li><p>定期清理的两种模式：</p>
<p>SLOW模式执行频率默认为10，每次不超过25ms</p>
<p>FAST模式执行频率不固定，但两次间隔不低于2ms，每次耗时不超过1ms</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>redis 缓存淘汰策略</p>
</blockquote>
<p>主要两类：</p>
<ul>
<li>LRU   最近最少使用的页面置换算法，淘汰最长时间未被使用的页面，看页面最后一次被使用到发生调度的时间长短，首先淘汰最长时间未被使用的页面</li>
<li>LFU   最近最不常用页面置换算法，淘汰一定时期内被访问次数最少的页面，看一定时间段内被访问次数最少的页，看一定时间段内页面被使用的频率，淘汰一定时期内被访问次数最少的页</li>
</ul>
<p>细分8类：</p>
<ul>
<li>noevication ： 不会驱逐任何key，表示即使内存达到上限也不进行置换，所有能引起内存增加的命令都返回 error，<code>默认</code>就是这种策略。</li>
<li><code>allkeys-lru</code>： 对所有key使用 LRU算法进行删除，优先删除掉最近不经常使用的key，用以保存新数据  <code>工作中常用</code></li>
<li>volatie-lru : 对所有设置了过期时间的key使用LRU 算法删除</li>
<li>allkeys-random ：对所有key随机删除</li>
<li>volatie-random ： 对所有设置了过期时间的key随机删除</li>
<li>volatie-ttl ：对所有设置了过期时间的key随即删除</li>
<li>allkeys-lfu：对所有key使用LFU算法进行删除</li>
<li>volatile-lfu：对所有设置了过期时间的key使用LFU算法进行删除</li>
</ul>
<blockquote>
<p>上面8种模式:   2 * 4 得8、2个维度(过期键中筛选、所有键中筛选)、4个方面(LRU、LFU、random、ttl)、8个选项</p>
</blockquote>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305272231603.png" alt="image-20230527223142532" style="zoom:35%;"></p>
<blockquote>
<p>选择原则；</p>
</blockquote>
<ul>
<li><p>在所有的key都是最近最经常使用，那么就需要选择<code>allkeys-lru</code>进行置换最近最不经常使用的key,如果你不确定使用哪种策略，那么推荐使用<code>allkeys-lru</code></p>
</li>
<li><p>如果所有的key的访问概率都是差不多的，那么可以选用<code>allkeys-random</code>策略去置换数据</p>
</li>
<li><p>如果对数据有足够的了解，能够为key指定<code>hint</code>(通过<code>expire/ttl</code>指定)，那么可以选择<code>volatile-ttl</code>进行置换</p>
</li>
</ul>
<blockquote>
<p>使用建议</p>
</blockquote>
<ul>
<li>避免存储bigkey</li>
<li>redis缓存淘汰策略配置性能建议开启橢性淘汰，<code>lazyfree-lazy-eviction=yes</code></li>
</ul>
<hr>
<h2 id="IO多路复用和epoll-黑马-redis-160-171"><a href="#IO多路复用和epoll-黑马-redis-160-171" class="headerlink" title="IO多路复用和epoll[==黑马 redis 160-171==]"></a>IO多路复用和epoll[==黑马 redis 160-171==]</h2><font color="red">是什么</font>
I/O  : 网络 I/O
多路 : 多个客户端连接（连接就是套接字描述符，即socket 或者 channel），指的是多条 TCP 连接
复用:    用一个进程来处理多条的连接，使用单进程就能实现同时处理多个客户端的连接
IO多路复用: 实现了用一个进程来处理大量的用户连接



文件描述符（File Descriptor）：简称FD，是一个从0 开始的无符号整数，用来关联Linux中的一个文件。在Linux中，一切皆文件。

<font color="red">定义</font>

<p>IO多路复用是利用单个线程来同时监听多个FD，并在某个FD可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。不过监听FD的方式、通知的方式又有多种实现，常见的有：</p>
<ul>
<li>select</li>
<li>poll</li>
<li>epoll</li>
</ul>
<p>其中select和pool相当于是当被监听的数据准备好之后，他会把你监听的FD整个数据都发给你，你需要到整个FD中去找，哪些是处理好了的，需要通过遍历的方式，所以性能也并不是那么好</p>
<p>而epoll，则相当于内核准备好了之后，他会把准备好的数据，直接发给你，省去了遍历的动作。</p>
<font color="red">差异</font>

<ul>
<li>select和poll只会通知用户进程有FD就绪，但不确定具体是哪个FD,需要用户进程逐个遍历FD来确认</li>
<li>epol则会在通知用户进程FD就绪的同时，把已就绪的FD写入用户空间</li>
</ul>
<p><code>Select</code></p>
<p>存在的问题：</p>
<ul>
<li>需要将整个fd_set从用户空间拷贝到内核空间，select结束还要再次拷贝回用户空间<code>2次拷贝</code></li>
<li>select无法得知具体是哪个fd就绪，需要遍历整个fd set    <code>知道有几个就绪 但是不知道具体是谁就绪了</code></li>
<li>fd set监听的fd数量不能超过1024  <code>数量上有限制</code></li>
</ul>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305272140038.png" alt="image-20230527214058848" style="zoom:35%;"></p>
<p><code>poll</code></p>
<p>IO流程： &lt;和select差不多,唯一的改进就是 增加了监听的fd 数量，但是  监听FD越多，每次遍历消耗时间也越久，性能反而会下降 &gt;</p>
<ul>
<li>创建pollfd数组，向其中添加关注的fd信息，数组大小自定义</li>
<li>调用poll函数，将pollfd数组拷贝到内核空间，转链表存储，<code>无上限</code></li>
<li>内核遍历fd，判断是否就绪</li>
<li>数据就绪或超时后，拷贝pollfd数组到用户空间，返回就绪fd数量n</li>
<li>用户进程判断n是否大于0,大于0则遍历pollfd数组，找到就绪的fd数量</li>
</ul>
<p><code>epoll</code>  是非阻塞的</p>
<ul>
<li><p>大大减少了fd拷贝的次数，大大减少了fd拷贝的数量</p>
</li>
<li><p>监听的FD理论上无上限</p>
</li>
</ul>
<blockquote>
<p>多路复用快的原因在于，操作系统提供了<code>epoll</code>系统调用，使得原来的whi训e循环里多次系统调用，变成了<code>一次系统调用+内核层遍历这些文件描述符</code></p>
<p>epoll 将拷贝与等待分开了</p>
<p>epoll_ctl:  进行拷贝，只会拷贝一次</p>
<p>epoll_wait:  等待就绪，之后每次只调用<code>epoll_wait</code>进行等待就可以了，无需再次拷贝</p>
</blockquote>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305280012901.jpg" alt="202305272200567"></p>
<p><code>总结</code></p>
<blockquote>
<p>select模式存在的三个问题：</p>
</blockquote>
<ul>
<li>能监听的FD最大不超过1024</li>
<li>每次select都需要把所有要监听的FD都拷贝到内核空间</li>
<li>每次都要遍历所有FD来判断就绪状态</li>
</ul>
<blockquote>
<p>poll模式的问题：</p>
</blockquote>
<ul>
<li>poll利用链表解决了select中监听FD上限的问题，但依然要遍历所有FD，如果监听较多，性能会下降</li>
</ul>
<blockquote>
<p>epoll模式中如何解决这些问题的？</p>
</blockquote>
<ul>
<li>基于epoll实例中的<code>红黑树</code>保存要监听的FD，理论上无上限，而且增删改查效率都非常高</li>
<li>每个FD只需要执行一次<code>epoll_ctl</code>添加到<code>红黑树</code>，以后每次<code>epol_wait</code>无需传递任何参数，无需重复拷贝<code>FD</code>到内核空间</li>
<li>利用<code>ep_poll_callback</code>机制来监听FD状态，无需遍历所有FD，因此性能不会随监听的FD数量增多而下降</li>
</ul>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305280006087.png" alt="image-20230528000644005" style="zoom: 43%;"></p>
<font color="red">事件通知机制</font>

<p>当FD有数据可读时，我们调用epoll_wait（或者select、poll）可以得到通知。但是事件通知的模式有两种：</p>
<ul>
<li>LevelTriggered：简称LT，也叫做水平触发。只要某个FD中有数据可读，每次调用epoll_wait都会得到通知。</li>
<li>EdgeTriggered：简称ET，也叫做边沿触发。只有在某个FD有状态变化时，调用epoll_wait才会被通知。</li>
</ul>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305272209829.png" alt="image-20230527220918750" style="zoom:45%;"></p>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305272214385.png" alt="image-20230527221455305" style="zoom:43%;"></p>
<p><strong>为什么Redis要选择单线程？</strong></p>
<ul>
<li>抛开持久化不谈，Redis是纯  内存操作，执行速度非常快，它的性能瓶颈是网络延迟而不是执行速度，因此多线程并不会带来巨大的性能提升。</li>
<li>多线程会导致过多的上下文切换，带来不必要的开销</li>
<li>引入多线程会面临线程安全问题，必然要引入线程锁这样的安全手段，实现复杂度增高，而且性能也会大打折扣</li>
</ul>
<blockquote>
<p>Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器。</p>
<p>Reactor 模式，是指通过一个或多个输入同时传递给服务处理器的服务请求的事件驱动处理模式。服务端程序处理传入多路请求，并将它们同步分派给请求对应的处理线程，Reactor 模式也叫 Dispatcher 模式</p>
<p><code>redis网络模型</code>[171]</p>
</blockquote>
<hr>
<h2 id="源码-145-164"><a href="#源码-145-164" class="headerlink" title="源码[145-164]"></a>源码[145-164]</h2><blockquote>
<p>redis6 数据结构</p>
</blockquote>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305261720514.png" alt="image-20230526172020470" style="zoom:33%;"></p>
<blockquote>
<p>redis7    数据结构</p>
</blockquote>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305261718238.png" alt="image-20230526171836200" style="zoom:33%;"></p>
<blockquote>
<p>时间复杂度</p>
</blockquote>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305261721602.png" alt="image-20230526172050397" style="zoom:25%;"></p>
<blockquote>
<p>redis数据结构</p>
</blockquote>
<h4 id="动态字符串"><a href="#动态字符串" class="headerlink" title="动态字符串"></a>动态字符串</h4><ul>
<li>获取字符串长度的时间复杂度为O(1)</li>
<li>支持动态扩容</li>
<li>减少内存分配次数</li>
<li>二进制安全</li>
</ul>
<h4 id="intset"><a href="#intset" class="headerlink" title="intset"></a>intset</h4><ul>
<li>Redis会确保Intset中的元素唯一、有序</li>
<li>具备类型升级机制，可以节省内存空间</li>
<li>底层采用二分查找方式来查询</li>
</ul>
<h4 id="Dict"><a href="#Dict" class="headerlink" title="Dict"></a>Dict</h4><p>键与值的映射关系正是通过Dict来实现的</p>
<p>Dict由三部分组成，分别是：哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）</p>
<p>Dict的伸缩：</p>
<ul>
<li>当LoadFactor大于5或者LoadFactor大于1并且没有子进程任务时，Dict扩容</li>
<li>当LoadFactor小于0.1时，Dict收缩</li>
<li>扩容大小为第一个大于等于used + 1的2^n</li>
<li>收缩大小为第一个大于等于used 的2^n</li>
<li>Dict采用渐进式rehash，每次访问Dict时执行一次rehash</li>
<li>rehash时ht[0]只减不增，新增操作只在ht[1]执行，其它操作在两个哈希表</li>
</ul>
<h4 id="ZipList"><a href="#ZipList" class="headerlink" title="ZipList"></a>ZipList</h4><p>一种特殊的“双端链表” ,由一系列特殊编码的连续内存块组成。可以在任意一端进行压入/弹出操作, 并且该操作的时间复杂度为 O(1)。</p>
<p><strong>ZipList特性：</strong></p>
<ul>
<li>压缩列表的可以看做一种连续内存空间的”双向链表”</li>
<li>列表的节点之间不是通过指针连接，而是记录上一节点和本节点长度来寻址，内存占用较低</li>
<li>如果列表数据过多，导致链表过长，可能影响查询性能</li>
<li>增或删较大数据时有可能发生连续更新问题</li>
</ul>
<h4 id="QuickList"><a href="#QuickList" class="headerlink" title="QuickList"></a>QuickList</h4><p>问题1：ZipList虽然节省内存，但申请内存必须是连续空间，如果内存占用较多，申请内存效率很低。怎么办？</p>
<p>​    答：为了缓解这个问题，我们必须限制ZipList的长度和entry大小。</p>
<p>问题2：但是我们要存储大量数据，超出了ZipList最佳的上限该怎么办？</p>
<p>​    答：我们可以创建多个ZipList来分片存储数据。</p>
<p>问题3：数据拆分后比较分散，不方便管理和查找，这多个ZipList如何建立联系？</p>
<p>​    答：Redis在3.2版本引入了新的数据结构QuickList，它是一个双端链表，只不过链表中的每个节点都是一个ZipList。</p>
<p>特点</p>
<ul>
<li>是一个节点为ZipList的双端链表</li>
<li>节点采用ZipList，解决了传统链表的内存占用问题</li>
<li>控制了ZipList大小，解决连续内存空间申请效率问题</li>
<li>中间节点可以压缩，进一步节省了内存</li>
</ul>
<h4 id="SkipList"><a href="#SkipList" class="headerlink" title="SkipList"></a>SkipList</h4><p>SkipList（跳表）首先是链表，但与传统链表相比有几点差异：</p>
<ul>
<li>元素按照升序排列存储</li>
<li>节点可能包含多个指针，指针跨度不同。</li>
</ul>
<p>SkipList的特点：</p>
<ul>
<li>跳跃表是一个双向链表，每个节点都包含score和ele值</li>
<li>节点按照score值排序，score值一样则按照ele字典排序</li>
<li>每个节点都可以包含多层指针，层数是1到32之间的随机数</li>
<li>不同层指针到下一个节点的跨度不同，层级越高，跨度越大</li>
<li>增删改查效率与红黑树基本一致，实现却更简单</li>
</ul>
<h4 id="RedisObject"><a href="#RedisObject" class="headerlink" title="RedisObject"></a>RedisObject</h4><p>Redis中的任意数据类型的键和值都会被封装为一个RedisObject，也叫做Redis对象</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ul>
<li><p>其基本编码方式是RAW，基于简单动态字符串（SDS）实现，存储上限为512mb。</p>
</li>
<li><p>底层实现⽅式：动态字符串sds 或者 long</p>
<ul>
<li>String的内部存储结构⼀般是sds（Simple Dynamic String，可以动态扩展内存），但是如果⼀个String类型的value的值是数字，那么Redis内部会把它转成long类型来存储，从⽽减少内存的使用。</li>
<li>如果存储的字符串是整数值，并且大小在LONG_MAX范围内，则会采用INT编码：直接将数据保存在RedisObject的ptr指针位置（刚好8字节），不再需要SDS了</li>
</ul>
</li>
</ul>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul>
<li>List结构类似一个双端链表，可以从首、尾操作列表中的元素：</li>
</ul>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><ul>
<li><p>底层数据结构： HashTable，也就是Redis中的Dict，不过Dict是双列集合（可以存键、值对）</p>
</li>
<li><p>为了查询效率和唯一性，set采用HT编码（Dict）。Dict中的key用来存储元素，value统一为null。</p>
</li>
<li>当存储的所有数据都是整数，并且元素数量不超过set-max-intset-entries时，Set会采用IntSet编码，以节省内存</li>
</ul>
<h3 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h3><ul>
<li><p>底层数据结构：</p>
<p>SkipList：可以排序，并且可以同时存储score和ele值（member）</p>
<p>HT（Dict）：可以键值存储，并且可以根据key找value</p>
</li>
<li><p>ziplist本身没有排序功能，而且没有键值对的概念，因此需要有zset通过编码实现：</p>
<ul>
<li>ZipList是连续内存，因此score和element是紧挨在一起的两个entry， element在前，score在后</li>
<li>score越小越接近队首，score越大越接近队尾，按照score值升序排列</li>
</ul>
</li>
<li><p>当元素数量不多时，HT和SkipList的优势不明显，而且更耗内存。因此zset还会采用ZipList结构来节省内存，不过需要同时满足两个条件：</p>
<ul>
<li>元素数量小于zset_max_ziplist_entries，默认值128</li>
<li>每个元素都小于zset_max_ziplist_value字节，默认值64</li>
</ul>
</li>
</ul>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><ul>
<li>与Redis中的Zset非常类似：<ul>
<li>都是键值存储</li>
<li>都需求根据键获取值</li>
<li>键必须唯一</li>
</ul>
</li>
<li>区别<ul>
<li>zset的键是member，值是score；hash的键和值都是任意值</li>
<li>zset要根据score排序；hash则无需排序</li>
</ul>
</li>
<li>底层实现方式：压缩列表ziplist 或者 字典dict，当Hash中数据项比较少的情况下，Hash底层才⽤压缩列表ziplist进⾏存储数据，随着数据的增加，底层的ziplist就可能会转成dict</li>
</ul>
<hr>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h4 id="商户查询缓存"><a href="#商户查询缓存" class="headerlink" title="商户查询缓存"></a>商户查询缓存</h4><ul>
<li>先查缓存，没有就去查数据库，并且写回到缓存中(<code>string</code> 存的是 <code>id+商品信息</code>)</li>
<li><code>使用事务+ 先更新数据库再删除缓存</code>  保证数据的一致性</li>
<li>为了解决缓存穿透的问题，在上面查询redis的数据的时候查不到 要将“空值”写到redis中</li>
</ul>
<ul>
<li><p>为了解决缓存击穿的问题：</p>
<ul>
<li>互斥锁：<ul>
<li>使用<code>set del</code>上锁 放锁</li>
<li>获取互斥锁，并判断是否获取成功，一旦获取失败就休眠重试</li>
<li>获取成功就 取查询数据库</li>
<li>最后释放互斥锁</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305262306596.png" alt="image-20230526230647466" style="zoom:55%;"></p>
</li>
</ul>
<ul>
<li>不设置过期时间<ul>
<li>如果<code>redis</code>中查找到数据，就先把<code>json</code>反序列化为对象</li>
<li>随后判断是否过期</li>
<li>未过期，直接返回商品的信息，但是已过期，需要缓存重建</li>
<li>缓存重建<ul>
<li>先进行 获取互斥锁，获取到锁<ul>
<li>一方面  检查redis 缓存是否过期（双检）</li>
<li>另一方面开启独立线程（使用<code>线程池</code> 创建线程） 进行 缓存重建</li>
<li>缓存重建就是 : 再去数据库中查询数据，并写回redis中并设置过期时间</li>
<li>重建完之后释放锁</li>
</ul>
</li>
<li>没有获取到 互斥锁  直接返回</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305262346080.png" alt="image-20230526234618031" style="zoom:33%;"></p>
<p>工具类封装</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CacheClient</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithLogicalExpire</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置逻辑过期</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">        redisData.setData(value);</span><br><span class="line">        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));</span><br><span class="line">        <span class="comment">// 写入Redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R,ID&gt; R <span class="title function_">queryWithPassThrough</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(json, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">        <span class="keyword">if</span> (json != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回一个错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.不存在，根据id查询数据库</span></span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">        <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将空值写入redis</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            <span class="comment">// 返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.存在，写入redis</span></span><br><span class="line">        <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithLogicalExpire</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.命中，需要先把json反序列化为对象</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">        <span class="comment">// 5.判断是否过期</span></span><br><span class="line">        <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 5.1.未过期，直接返回店铺信息</span></span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.2.已过期，需要缓存重建</span></span><br><span class="line">        <span class="comment">// 6.缓存重建</span></span><br><span class="line">        <span class="comment">// 6.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">        <span class="comment">// 6.2.判断是否获取锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">            <span class="comment">// 6.3.成功，开启独立线程，实现缓存重建</span></span><br><span class="line">            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 查询数据库</span></span><br><span class="line">                    <span class="type">R</span> <span class="variable">newR</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">                    <span class="comment">// 重建缓存</span></span><br><span class="line">                    <span class="built_in">this</span>.setWithLogicalExpire(key, newR, time, unit);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放锁</span></span><br><span class="line">                    unlock(lockKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.4.返回过期的商铺信息</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithMutex</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(shopJson, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">        <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回一个错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.实现缓存重建</span></span><br><span class="line">        <span class="comment">// 4.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">            <span class="comment">// 4.2.判断是否获取成功</span></span><br><span class="line">            <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">                <span class="comment">// 4.3.获取锁失败，休眠并重试</span></span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                <span class="keyword">return</span> queryWithMutex(keyPrefix, id, type, dbFallback, time, unit);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4.4.获取锁成功，根据id查询数据库</span></span><br><span class="line">            r = dbFallback.apply(id);</span><br><span class="line">            <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">            <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 将空值写入redis</span></span><br><span class="line">                stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">                <span class="comment">// 返回错误信息</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 6.存在，写入redis</span></span><br><span class="line">            <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7.释放锁</span></span><br><span class="line">            unlock(lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 8.返回</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="击穿-1"><a href="#击穿-1" class="headerlink" title="击穿"></a>击穿</h4><blockquote>
<p>功能 ：</p>
<ul>
<li>定时+高并发+分页</li>
</ul>
</blockquote>
<p>基本实现：</p>
<ul>
<li>查询数据库数据</li>
<li><em>删除<code>redis</code>中对应数据,再写到 <code>redis</code> 中</em> —&gt;<font color="red">优化： 先更新B缓存且让B缓存过期时间超过A缓存，如果A突然失效还有B兜底，防止击穿</font></li>
<li><font color="red">设置缓存B的过期时间</font></li>
<li><font color="red">随后删除缓存A ,再进行更新缓存A</font></li>
<li><p>采用<code>redis</code> <code>list</code>结构里面的<code>range</code>命令来实现<code>加载和分页</code></p>
</li>
<li><p>出异常(一般<code>redis</code>宕机了或者<code>redis</code>网络抖动导致<code>timeout</code>) , 重试机制 再次查询<code>mysql</code></p>
</li>
</ul>
<p>问题：</p>
<p><code>删除redis中对应数据，再写到 redis中</code>  两个操作不是原子命令 ，会存在  <code>热点缓存Key突然失效导致缓存击穿</code>的问题</p>
<p>优化：</p>
<ul>
<li>思路</li>
</ul>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305261319664.png" alt="image-20230526131942584" style="zoom:53%;"></p>
<h4 id="优惠券秒杀"><a href="#优惠券秒杀" class="headerlink" title="优惠券秒杀"></a>优惠券秒杀</h4><ul>
<li>使用<code>全局ID生成器</code>(一种在分布式系统下用来生成全局唯一ID的工具)<ul>
<li>唯一，递增，高可用，安全，高性能</li>
<li>生成策略<ul>
<li>UUID 、Redis自增、snowflake算法 、数据库自增</li>
<li>Redis自增实现方案：<ul>
<li>每天一个key,方便统计订单量</li>
<li>ID构造是  <code>时间戳+计数器</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>此处使用基于redis 的<code>全局ID生成器</code></li>
</ul>
<p>思路：</p>
<ul>
<li>判断时间 是否开始</li>
<li>判断库存是否充足</li>
<li>创建订单（全局id  用户id  代金券id）</li>
</ul>
<blockquote>
<p>解决超卖问题：</p>
</blockquote>
<ul>
<li><p>悲观锁：添加同步锁，想成串行执行</p>
</li>
<li><p>乐观锁的版本号 ，不加锁</p>
<ul>
<li>版本号</li>
<li>cas(用库存代替版本，让库存&gt;0 即可)</li>
</ul>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305270105675.png" alt="image-20230527010538607" style="zoom:53%;"></p>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305270100288.png" alt="image-20230527010033208" style="zoom:45%;"></p>
</li>
</ul>
<blockquote>
<p>解决一人一单</p>
</blockquote>
<ul>
<li>简单加一层逻辑<ul>
<li>在下订单之前 先去查询订单，获取用户<code>id</code>,判断用户<code>id</code>是否存在<ul>
<li>需要使用悲观锁(<code>synchronized</code>)机制进行保护 <code>查询订单  判断订单 创建订单</code> 的逻辑,使其线程安全, 锁的是<code>用户id</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>乐观锁</code>比较适合更新数据，而插入数据则是需要使用<code>悲观锁</code>操作</p>
<ul>
<li>起初为了减少锁的粒度，并不是在方法上加<code>synchronized</code> ，所以锁的是<code>id</code></li>
<li>因此 使用<code>intern()</code>这个方法是<code>从常量池</code>中拿到数据，如果我们直接使用<code>userId.toString()</code>他拿到的对象实际上是不同的对象，<code>new</code>出来的对象，我们使用锁必须保证锁必须是<code>同一把</code>，所以我们需要使用<code>intern()方法</code></li>
<li>另外： 由于当前方法被<code>spring</code>的<code>事务控制</code>，如果你在方法内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放也会导致问题，所以我们选择将当前方法整体包裹起来，确保事务不会出现问题</li>
<li>但是事务想要生效，还得利用<code>代理</code>(<code>AspectJ</code>)来生效，所以这个地方，我们需要获得原始的事务对象， 来操作事务</li>
</ul>
<p>所以完整代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span>  UserHolder.getUser().getId();  <span class="comment">// 获取id</span></span><br><span class="line"><span class="keyword">synchronized</span> (userId.tostring().intern())&#123;    <span class="comment">//加锁</span></span><br><span class="line">    <span class="comment">//获取代理对象（事务）</span></span><br><span class="line">    IVoucherorderService <span class="title function_">proxy</span> <span class="params">(IVoucherorderService)</span>AopContext.currentProxy();</span><br><span class="line">    <span class="keyword">return</span> proxy.createVoucherorder(voucherId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span>  Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line"> <span class="comment">//查询   判断  创建 订单   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><span style="color:red">集群模式下的分布式锁</span></p>
<blockquote>
<p>单机下锁在集群下会产生锁失效</p>
<ul>
<li>由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，</li>
<li>假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的，</li>
<li>但是如果现在是服务器B的tomcat内部，又有两个线程线程3和线程4，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，</li>
<li>所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥，</li>
<li>这就是 集群环境下，syn锁失效的原因，在这种情况下，我们就需要使用分布式锁来解决这个问题。</li>
<li><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202306201521824.png" alt="image-20230620152116636" style="zoom:33%;"></li>
</ul>
</blockquote>
<h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><blockquote>
<p>分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。</p>
<p>分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行</p>
</blockquote>
<font color="blue">分类：</font>

<ul>
<li><p>单机版  ——<code>synchronized</code>或者<code>Lock</code></p>
</li>
<li><p>分布式  ——   分布式锁</p>
</li>
</ul>
<font color="blue">分布式锁的三种实现方式：</font>

<ul>
<li><code>Mysql</code>：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见</li>
<li><code>Redis</code>：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用setnx这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁</li>
<li><code>Zookeeper</code>：zookeeper也是企业级开发中较好的一个实现分布式锁的方案</li>
</ul>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305271058635.png" alt="image-20230527105802579"></p>
<font color="blue">一个靠谱的分布式锁需要具备的条件和刚需：</font>

<ul>
<li><p>独占性     任何时刻有且只能有一个线程持有</p>
</li>
<li><p>高可用     若为redis集群环境下，不能因为某一个节点挂了而出现获取锁和释放锁失败的情况 ，高并发请求下，性能依旧好使</p>
</li>
<li><p>防死锁     杜绝死锁，必须有超时控制机制或者撤销操作，有个兜底终止跳出方案</p>
</li>
<li><p>不乱抢     防止张冠李戴，不能私底下unlock别人的锁，只能自己加锁自己释放</p>
</li>
<li><p>重入性     同一个节点的同一个线程如果获得锁之后，它也可以再次获取这个锁</p>
</li>
</ul>
<blockquote>
<p>无锁版本</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">sale</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">resMessgae</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1 抢锁成功，查询库存信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;inventory01&quot;</span>);</span><br><span class="line">        <span class="comment">// 2 判断库存书否足够</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">inventoryNum</span> <span class="operator">=</span> result == <span class="literal">null</span> ? <span class="number">0</span> : Integer.parseInt(result);</span><br><span class="line">        <span class="comment">// 3 扣减库存，每次减少一个库存</span></span><br><span class="line">        <span class="keyword">if</span> (inventoryNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(<span class="string">&quot;inventory01&quot;</span>, String.valueOf(--inventoryNum));</span><br><span class="line">            resMessgae = <span class="string">&quot;成功卖出一个商品，库存剩余：&quot;</span> + inventoryNum + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;，服务端口号：&quot;</span> + port;</span><br><span class="line">            log.info(resMessgae);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resMessgae = <span class="string">&quot;商品已售罄。&quot;</span> + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;，服务端口号：&quot;</span> + port;</span><br><span class="line">            log.info(resMessgae);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resMessgae;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单机版写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//lock</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;业务逻辑&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;lock.unlock();&#125;</span><br><span class="line"></span><br><span class="line">或者 </span><br><span class="line">    </span><br><span class="line"><span class="comment">//使用synchronized</span></span><br></pre></td></tr></table></figure>
<p>分布式版本</p>
<blockquote>
<p>单机锁还是出现超卖现象，需要分布式锁</p>
<p>原因分析:</p>
<ul>
<li>synchronized和ReentrantLock是单机锁，只能管住当前自己的jvm。</li>
<li>在<font color="red">单机环境</font>下，可以使用synchronized或Lock来实现;但是在分布式系统中，因为竞争的线程可能不在同一个节点上(同一个jvm中)，所以需要一个让所有进程都能访问到的锁来实现<font color="red">(比如redis或者zookeeper来构建)</font></li>
<li>不同进程ivm层面的锁就没用了，那么可以利用第三方的一个组件，来获取锁，未获取到锁，则阻塞当前想要运行的线程</li>
</ul>
</blockquote>
<p>解决问题：</p>
<ul>
<li>跨进程+跨服务      解决超卖     防止缓存击穿</li>
</ul>
<blockquote>
<p> 版本一：  设置暂停时间 进行 判断是否能抢到锁[此处使用 ： set() 和 del()  进行解锁]，抢不到就在暂停时间之后进行   递归重试</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">sale</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">resMessgae</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;luojiaRedisLocak&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">uuidValue</span> <span class="operator">=</span> IdUtil.simpleUUID() + <span class="string">&quot;:&quot;</span> + Thread.currentThread().getId();</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, uuidValue);</span><br><span class="line">    <span class="comment">// 抢不到的线程继续重试</span></span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">        <span class="comment">// 线程休眠20毫秒，进行递归重试</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        sale();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          ....</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            stringRedisTemplate.delete(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resMessgae;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>问题：<font color="red">手工设置5000个线程来抢占锁，压测OK，但是容易导致StackOverflowError，不推荐，需要进一步完善</font></p>
<p>版本二： 还是<code>set()  + del() 加锁解锁</code></p>
<p>为了防止虚假唤醒： <code>用while替代if，用自旋锁代替递归重试</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">sale</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">resMessgae</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;luojiaRedisLocak&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">uuidValue</span> <span class="operator">=</span> IdUtil.simpleUUID() + <span class="string">&quot;:&quot;</span> + Thread.currentThread().getId();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不用递归了，高并发容易出错，我们用自旋代替递归方法重试调用；也不用if，用while代替</span></span><br><span class="line">    <span class="keyword">while</span> (!stringRedisTemplate.opsForValue().setIfAbsent(key, uuidValue)) &#123;</span><br><span class="line">        <span class="comment">// 线程休眠20毫秒，进行递归重试</span></span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resMessgae;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>问题:部署的微服务<code>挂了</code>，代码层面<code>根本没有走到finally</code>这块，没办法保证解锁(无过期时间该key一直存在)，这个key没有被删除，需要<code>加入一个过期时间限定key</code></p>
<p>版本三： <code>加锁和过期时间设置必须同一行，保证原子性</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!stringRedisTemplate.opsForValue().setIfAbsent(key, uuidValue)) &#123;</span><br><span class="line"> ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置过期时间</span></span><br><span class="line">stringRedisTemplate.expire(key, <span class="number">30L</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="keyword">try</span>&#123;...&#125;</span><br><span class="line">...</span><br><span class="line">         ||</span><br><span class="line">         ||</span><br><span class="line">    <span class="comment">//原子性的改进</span></span><br><span class="line"><span class="keyword">while</span> (!stringRedisTemplate.opsForValue().setIfAbsent(key, uuidValue, <span class="number">30L</span>, TimeUnit.SECONDS))&#123;....&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>问题：实际业务中，如果处理时间超过了设置的key的过期时间，那删除key的时候就<font color="blue">删除了别人的锁</font></p>
<p>版本四：只能自己删除自己的，不允许删除别人的锁—<code>判断是否与当前线程标识[uuidValue]一致</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;	</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 判断加锁与解锁是不同客户端，自己只能删除自己的锁，不误删别人的锁</span></span><br><span class="line">        <span class="keyword">if</span> (stringRedisTemplate.opsForValue().get(key).equalsIgnoreCase(uuidValue)) &#123;</span><br><span class="line">            stringRedisTemplate.delete(key);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>问题：finally代码块的<code>判断是否是自己的锁+del删除</code>不是<code>原子性</code>的,极端情况下还是会误删</p>
<ul>
<li>做法一：redis的事务不能保证一致性，事务的操作是最终一次性执行，要加上乐观锁判断自己线程释放的时候没有别的线程在进行执行修改</li>
<li>做法二： lua脚本</li>
</ul>
<p>版本五：lua脚本</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 改进点，修改为Lua脚本的Redis分布式锁调用，必须保证原子性，参考官网脚本案例</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">luaScript</span> <span class="operator">=</span></span><br><span class="line">            <span class="string">&quot;if redis.call(&#x27;get&#x27;,KEYS[1]) == ARGV[1] then &quot;</span> +</span><br><span class="line">            <span class="string">&quot;return redis.call(&#x27;del&#x27;,KEYS[1]) &quot;</span> +</span><br><span class="line">            <span class="string">&quot;else &quot;</span> +</span><br><span class="line">            <span class="string">&quot;return 0 &quot;</span> +</span><br><span class="line">            <span class="string">&quot;end&quot;</span>;</span><br><span class="line">        stringRedisTemplate.execute(<span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>(luaScript, Boolean.class), Arrays.asList(key), uuidValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>小总结：</p>
<ul>
<li>利用<code>set nx ex</code>获取锁，并设置过期时间，保存线程标识</li>
<li>释放锁时先判断线程标示是否与自己一致，一致则删除锁<ul>
<li>特性：<ul>
<li>利用set nx满足互斥性</li>
<li>利用set ex保证故障时锁依然能释放，避免死锁，提高安全性</li>
<li>利用Redis集群保证高可用和高并发特性</li>
</ul>
</li>
<li>缺陷：<ul>
<li><strong>重入问题</strong>：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁</li>
<li><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</li>
<li><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</li>
<li><strong>主从一致性：</strong> 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>问题：可重入性未能满足</p>
<p>可重入锁</p>
<ul>
<li>可重入锁又名递归锁；是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁(前提，锁对象需要是同一个对象)，不会因为之前已经获取过还没释放而阻塞。可重入锁的一个优点是可以一定程度避免死锁。</li>
<li>就是说：一个线程中的多个流程可以获取同一把锁，持有这把同步锁可以再次进入。自己可以获取自己的内部锁</li>
</ul>
<p>可重入锁种类</p>
<ul>
<li><p>隐式锁(即synchronized关键字使用的锁)</p>
<p>一个Synchronized修饰的方法或代码块的内部调用本类的其他Synchronized修饰的方法或代码块时，是永远可以得到锁</p>
<ul>
<li>Synchronized的重入的实现原理：<ul>
<li>每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针。</li>
<li>当执行monitorenter时，如果目标锁对象的计数器为零，那么说明它没有被其他线程所持有，Java虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器加1。</li>
<li>在目标锁对象的计数器不为零的情况下，如果锁对象的持有线程是当前线程，那么 Java 虚拟机可以将其计数器加1，否则需要等待直至持有线程释放该锁。</li>
<li>当执行monitorexit时，Java虚拟机则需将锁对象的计数器减1。计数器为零代表锁已被释放。</li>
</ul>
</li>
</ul>
</li>
<li><p>显式锁(即Lock)&lt;也有ReentrantLock这样的可重入锁&gt;</p>
</li>
</ul>
</blockquote>
<p>对比：</p>
<ul>
<li><p>setnx只能解决有无的问题，够用但是不完美</p>
</li>
<li><p>hset，不但解决有无，还能解决可重入问题</p>
</li>
</ul>
<blockquote>
<p>版本 六： 考虑<code>可重入性</code>的实现方案：    使用 ： <code>hash</code>的数据结构  用lua 脚本代替  lock   unlock</p>
</blockquote>
<ul>
<li><code>工厂设计模式</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DistributedLockFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> String lockName;</span><br><span class="line">    <span class="keyword">private</span> String uuidValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DistributedLockFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.uuidValue = IdUtil.simpleUUID();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Lock <span class="title function_">getDistributedLock</span><span class="params">(String lockType)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lockType == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lockType.equalsIgnoreCase(<span class="string">&quot;REDIS&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.lockName = <span class="string">&quot;RedisLock&quot;</span>;</span><br><span class="line">            <span class="comment">// 每次都是 new 的  注入uuidValue 保证每个线程的id是一样的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RedisDistributedLock</span>(stringRedisTemplate, lockName, uuidValue);   </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (lockType.equalsIgnoreCase(<span class="string">&quot;ZOOKEEPER&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.lockName = <span class="string">&quot;ZookeeperLock&quot;</span>;</span><br><span class="line">            <span class="comment">// TODO zoookeeper 版本的分布式锁</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (lockType.equalsIgnoreCase(<span class="string">&quot;MYSQL&quot;</span>))&#123;</span><br><span class="line">            <span class="built_in">this</span>.lockName = <span class="string">&quot;MysqlLock&quot;</span>;</span><br><span class="line">            <span class="comment">// TODO MYSQL 版本的分布式锁</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自研的分布式锁，实现了Lock接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisDistributedLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lockName; <span class="comment">// KEYS[1]</span></span><br><span class="line">    <span class="keyword">private</span> String uuidValule; <span class="comment">// ARGV[1]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> expireTime; <span class="comment">// ARGV[2]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//String uuid 的作用就是：</span></span><br><span class="line">    <span class="comment">//testReEntry方法中，会创建一个新的锁Key，因为ThreadID一致了，但是UUID不OK</span></span><br><span class="line">    <span class="comment">//使用@Autowired创建的工厂类是一个单例的，在spring进行注入的时候已经初始化好了，所以所有线程产生的UUID都应该是一样的</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">RedisDistributedLock</span><span class="params">(StringRedisTemplate stringRedisTemplate, String lockName, String uuid)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    <span class="built_in">this</span>.lockName = lockName;</span><br><span class="line">    <span class="built_in">this</span>.uuidValule = uuid + <span class="string">&quot;:&quot;</span> + Thread.currentThread().getId();</span><br><span class="line">    <span class="built_in">this</span>.expireTime = <span class="number">50L</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;tryLock();&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;tryLock(-<span class="number">1L</span>, TimeUnit.SECONDS);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  <span class="comment">//Lock</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (-<span class="number">1</span> == time) &#123;</span><br><span class="line">            <span class="comment">//在redis中，给Key键设置一个值，为避免死锁，并给定一个过期时间</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span></span><br><span class="line">                    <span class="string">&quot;if redis.call(&#x27;exists&#x27;, KEYS[1]) == 0 or redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1 then &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], 1) &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[2]) &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;return 1 &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;else &quot;</span> +</span><br><span class="line">                         <span class="string">&quot;return 0 &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;end&quot;</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;lockName:&quot;</span> + lockName + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;uuidValue:&quot;</span> + uuidValule);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 加锁失败需要自旋一直获取锁</span></span><br><span class="line">            <span class="keyword">while</span> (!stringRedisTemplate.execute(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class),</span><br><span class="line">                    Arrays.asList(lockName),</span><br><span class="line">                    uuidValule,</span><br><span class="line">                    String.valueOf(expireTime))) &#123;</span><br><span class="line">                <span class="comment">// 休眠60毫秒再来重试</span></span><br><span class="line">                <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">60</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  <span class="comment">//unlock</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//将 Key 键删除，但是也不能乱删，只能自己删自己的锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;if redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 0 then &quot;</span> +</span><br><span class="line">                <span class="string">&quot;return nil &quot;</span> +</span><br><span class="line">                <span class="string">&quot;elseif redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], -1) == 0 then &quot;</span> +</span><br><span class="line">                <span class="string">&quot;return redis.call(&#x27;del&#x27;, KEYS[1]) &quot;</span> +</span><br><span class="line">                <span class="string">&quot;else &quot;</span> +</span><br><span class="line">                <span class="string">&quot;return 0 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;end&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;lockName:&quot;</span> + lockName + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;uuidValue:&quot;</span> + uuidValule);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// LUA脚本由C语言编写，nil -&gt; false; 0 -&gt; false; 1 -&gt; true;</span></span><br><span class="line">        <span class="comment">// 所以此处DefaultRedisScript构造函数返回值不能是Boolean，Boolean没有nil</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, Long.class),</span><br><span class="line">                Arrays.asList(lockName),</span><br><span class="line">                uuidValule);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == flag) &#123;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;this lock does not exists.&quot;</span>);&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面两个暂时用不到，不用重写</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="literal">null</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DistributedLockFactory distributedLockFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">sale</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">resMessgae</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">redisLock</span> <span class="operator">=</span> distributedLockFactory.getDistributedLock(<span class="string">&quot;REDIS&quot;</span>, <span class="string">&quot;luojiaRedisLock&quot;</span>);</span><br><span class="line">    redisLock.lock();</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        redisLock.unlock();</span><br><span class="line">   .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>给锁进行<code>自动续期</code>  ： 保证RedisLock过期时间大于业务执行时间的问题,如果规定时间内没有完成业务逻辑，会调用加钟自动续期的脚本</p>
</blockquote>
<p>lua脚本的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       ......</span><br><span class="line">        <span class="comment">// 新建一个后台扫描程序，来检查Key目前的ttl，是否到我们规定的剩余时间来实现锁续期</span></span><br><span class="line">        resetExpire();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动续期</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resetExpire</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span></span><br><span class="line">        <span class="string">&quot;if redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1 then &quot;</span> +</span><br><span class="line">        <span class="string">&quot;return redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[2]) &quot;</span> +</span><br><span class="line">        <span class="string">&quot;else &quot;</span> +</span><br><span class="line">        <span class="string">&quot;return 0 &quot;</span> +</span><br><span class="line">        <span class="string">&quot;end&quot;</span>;</span><br><span class="line">    <span class="comment">// 起一个定时任务Timer()</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Timer</span>().schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (stringRedisTemplate.execute(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class),</span><br><span class="line">                Arrays.asList(lockName),</span><br><span class="line">                uuidValule,</span><br><span class="line">                String.valueOf(expireTime))) &#123;</span><br><span class="line">                <span class="comment">// 续期成功，继续监听</span></span><br><span class="line">                System.out.println(<span class="string">&quot;resetExpire() lockName:&quot;</span> + lockName + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;uuidValue:&quot;</span> + uuidValule);</span><br><span class="line">                resetExpire();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, (<span class="built_in">this</span>.expireTime * <span class="number">1000</span> / <span class="number">3</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// unlock</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><ul>
<li><p>lock()加锁关键逻辑</p>
<ul>
<li><p>加锁：加锁实际上就是在redis中，给key设置一个值，为了避免死锁，并给定一个过期时间</p>
</li>
<li><p>可重入：加锁的LUA脚本，通过redis里面的hash数据模型，加锁和可重入性都要保证</p>
</li>
<li><p>自旋：加锁不成，需要while进行重试并自旋，AQS</p>
</li>
<li><p>续期：在过期时间内，一定时间内业务还未完成，自动给锁续期</p>
</li>
</ul>
</li>
<li><p>unlock()解锁关键逻辑</p>
<ul>
<li><p>将redis的key删除，但是也不能乱删，不能说客户端1的请求将客户端2的锁给删除掉了，只能自己删自己的锁</p>
</li>
<li><p>考虑可重入性的递减，加锁几次就需要删除几次</p>
</li>
<li><p>最后到零了，直接del删除</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>此时最终版本的问题</p>
</blockquote>
<ul>
<li>当<code>redis</code>宕机了，也就是单点故障,但是并不能直接添加一个从机，作为主机的副本，当主机出现问题是使用它，这是因为redis复制是 异步的，这么做会产生竞争的关系.</li>
</ul>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305261621454.png" alt="image-20230526162135416" style="zoom:33%;"></p>
<blockquote>
<p>解决： 使用 <code>redlock</code></p>
</blockquote>
<h5 id="Redission"><a href="#Redission" class="headerlink" title="Redission"></a>Redission</h5><h5 id="redlock"><a href="#redlock" class="headerlink" title="redlock"></a>redlock</h5><blockquote>
<p>设计理念</p>
</blockquote>
<p>该方案也是基于(set加锁、Lua脚本解锁）进行改良的,底层也是lua脚本实现<code>加锁、解锁、续期</code></p>
<p>假设我们有N个Redis主节点，例如 N = 5这些节点是完全独立的，我们不使用复制或任何其他隐式协调系统，为了取到锁客户端执行以下操作：</p>
<p>&lt;为了解决数据不一致的问题，直接舍弃了异步复制只使用 master 节点，同时由于舍弃了 slave，为了保证可用性，引入了 N 个节点，官方建议是 5。&gt;</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>1</th>
<th>获取当前时间，以毫秒为单位；</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>依次尝试从5个实例，使用相同的 key 和随机值（例如 UUID）获取锁。当向Redis 请求获取锁时，客户端应该设置一个超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为 10 秒，则超时时间应该在 5-50 毫秒之间。这样可以防止客户端在试图与一个宕机的 Redis 节点对话时长时间处于阻塞状态。如果一个实例不可用，客户端应该尽快尝试去另外一个 Redis 实例请求获取锁；</td>
</tr>
<tr>
<td>3</td>
<td>客户端通过当前时间减去步骤 1 记录的时间来计算获取锁使用的时间。当且仅当从大多数（N/2+1，这里是 3 个节点）的 Redis 节点都取到锁，并且获取锁使用的时间小于锁失效时间时，锁才算获取成功</td>
</tr>
<tr>
<td>4</td>
<td>如果取到了锁，其真正有效时间等于初始有效时间减去获取锁所使用的时间（步骤 3 计算的结果）。</td>
</tr>
<tr>
<td>5</td>
<td>如果由于某些原因未能获得锁（无法在至少 N/2 + 1 个 Redis 实例获取锁、或获取锁的时间超过了有效时间），客户端应该在所有的 Redis 实例上进行解锁（即便某些Redis实例根本就没有加锁成功，防止某些节点获取到锁但是客户端没有得到响应而导致接下来的一段时间不能被重新获取锁）。</td>
</tr>
</tbody>
</table>
</div>
<font color="blue">客户端只有在满足下面的这两个条件时，才能认为是加锁成功。</font>

<font color="blue">条件1:客户端从超过半数（大于等于N/2+1）的Redis实例上成功获取到了锁;</font>

<font color="blue">条件2:客户端获取锁的总耗时没有超过锁的有效时间。</font>

<blockquote>
<p>容错公式：</p>
<ul>
<li><code>N = 2X + 1</code>（N是最终部署机器数，X是容错机器数）</li>
</ul>
</blockquote>
<p>Redis分布式锁过期了，但是业务逻辑还没有处理完怎么办</p>
<ul>
<li>需要给对应的key续期</li>
</ul>
<p>守护线程“续命”</p>
<ul>
<li><font color="red">额外起一个线程，定期检查线程是否还持有锁，如果有则延长过期时间</font>；Redisson里面就实现了这个方案，使用“看门狗”定期检查（每1/3的锁时间检查1次），如果线程还持有锁，则刷新过期时间。</li>
<li>在获取锁成功后，给锁加一个watchdog，watchdog会起一个<code>定时任务</code>，在锁没有被释放且快要过期的时候会续期</li>
</ul>
<blockquote>
<p>单机版</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Redisson <span class="title function_">redisson</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">    	<span class="comment">//也可以使用config.useclusterServers()添加集群地址</span></span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis: ip:port&quot;</span>).setDatabase(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> (Redisson) Redisson.create(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> Redission redisson;</span><br><span class="line"></span><br><span class="line"><span class="type">RLock</span> <span class="variable">redissonLock</span> <span class="operator">=</span> redisson.getLock(<span class="string">&quot;RedisLock&quot;</span>+UserId);</span><br><span class="line">redissonLock.lock();</span><br><span class="line">....</span><br><span class="line"><span class="comment">// 改进点，只能删除属于自己的 key，不能删除别人的</span></span><br><span class="line"> <span class="keyword">finally</span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (redissonLock.isLocked() &amp;&amp; redissonLock.isHeldByCurrentThread())&#123;</span><br><span class="line">     redissonLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>集群版</p>
</blockquote>
<p>问题引出：</p>
<ul>
<li>当我们去写命令，写在主机上， 主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了，导致了锁失效</li>
</ul>
<p>解决思路：</p>
<ul>
<li>为了解决这个问题，redission提出来了MutiLock锁，就是不使用主从了，每个节点的地位都是一样的， 这把锁加锁的逻辑需要写入到<code>每一个</code>主从节点上，只有所有的服务器都写入成功，此时才是加锁成功，假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Redisson <span class="title function_">redisson1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">    	<span class="comment">//也可以使用config.useclusterServers()添加集群地址</span></span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis: ip1:port1&quot;</span>).setDatabase(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (Redisson) Redisson.create(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Redisson <span class="title function_">redisson2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">    	<span class="comment">//也可以使用config.useclusterServers()添加集群地址</span></span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis: ip1:port1&quot;</span>).setDatabase(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (Redisson) Redisson.create(config);</span><br><span class="line">&#125;</span><br><span class="line">重复多次...</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Redission1 redisson1;</span><br><span class="line"><span class="keyword">private</span> Redission2 redisson2;</span><br><span class="line"><span class="keyword">private</span> Redission3 redisson3;</span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock1</span> <span class="operator">=</span> redisson1.getLock(CACHE_KEY_REDLOCK);</span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock2</span> <span class="operator">=</span> redisson2.getLock(CACHE_KEY_REDLOCK);</span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock3</span> <span class="operator">=</span> redisson3.getLock(CACHE_KEY_REDLOCK);</span><br><span class="line"><span class="type">RedissonMultiLock</span> <span class="variable">redLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedissonMultiLock</span>(lock1, lock2, lock3);</span><br><span class="line"></span><br><span class="line">redLock.lock();</span><br><span class="line">....</span><br><span class="line"><span class="comment">// 改进点，只能删除属于自己的 key，不能删除别人的</span></span><br><span class="line"> <span class="keyword">finally</span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (redissonLock.isLocked() &amp;&amp; redissonLock.isHeldByCurrentThread())&#123;</span><br><span class="line">     redLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>redisson锁可重入原理  [原理 黑马 66 -68</code> ]</p>
<ul>
<li><p>redis采用<code>hash</code>结构用来记录线程id  和 重入次数，其中大key表示表示这把锁是否存在，用小key表示当前这把锁被哪个线程持有  并  根据重入次数记录可重入锁</p>
</li>
<li><p>每一次获取锁的时候先判断锁是否存在，不存在就直接获取并设置过期时间，存在就判断线程标识是否是自己的，是的话可以继续获取，锁计数+1；并设置过期时间，不是自己的才会失败，释放锁的时候，计数-1即可，直到重入次数为0 才真正的释放锁</p>
</li>
<li><p>流程</p>
</li>
</ul>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305271142908.png" alt="image-20230527114259849" style="zoom:33%;"></p>
<p><code>redission 可重试原理</code></p>
<ul>
<li>利用信号量 和 PubSub  功能实现等待、唤醒，获取锁失败的重试机制</li>
<li>第一次尝试获取锁失败之后，会进行一个等待，等待释放锁的消息，利用redis 的<code>PubSub</code> 机制，释放锁的时候会发布这样的消息，从而被redis 的<code>PubSub</code> 机制捕获，当得到这样的消息就会重新获取锁了，再次获取失败，就会再次等待，重试，但是会有一个等待的时间，超过这个时间就不会再重试了</li>
</ul>
<p><code>redission 超时释放（看门狗）</code></p>
<ul>
<li>利用watchDog,每隔一段时间（releaseTime/3),重置超时时间</li>
<li>在获取锁成功之后，会开启一个超时任务，每隔一段时间就会重置锁的超时时间，那么锁的超时时间就会重新计时</li>
</ul>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305271155304.png" alt="image-20230527115537163" style="zoom:33%;"></p>
<p><code>redission锁的MutiLock[连锁]原理</code></p>
<p>当我们去设置了多个锁时，redission会将多个锁添加到一个集合中，然后用while循环去不停去尝试拿锁，但是会有一个总共的加锁时间，这个时间是用需要加锁的个数 * 1500ms ，假设有3个锁，那么时间就是4500ms，假设在这4500ms内，所有的锁都加锁成功， 那么此时才算是加锁成功，如果在4500ms有线程加锁失败，则会再次去进行重试.</p>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305271224013.png" alt="image-20230527122406953" style="zoom:53%;"></p>
<p>加锁有性能降低，现在优化提升性能</p>
</blockquote>
<p>优化方案：</p>
<ul>
<li>我们将耗时比较短的逻辑判断放入到redis中，比如是否库存足够，比如是否一人一单，这样的操作，只要这种逻辑可以完成，就意味着我们是一定可以下单完成的，我们只需要进行快速的逻辑判断，根本就不用等下单逻辑走完，我们直接给用户返回成功， 再在后台开一个线程，后台线程慢慢的去执行queue里边的消息，这样程序不就超级快了吗？而且也不用担心线程池消耗殆尽的问题，因为这里我们的程序中并没有手动使用任何线程池，当然这里边有两个难点<ul>
<li>第一个难点是我们怎么在redis中去快速校验一人一单&lt;<code>set</code>&gt;，还有库存判断&lt;<code>string</code>&gt;</li>
<li>第二个难点是由于我们校验和tomct下单是两个线程，那么我们如何知道到底哪个单他最后是否成功，或者是下单完成，为了完成这件事我们在redis操作完之后，我们会将一些信息返回给前端，同时也会把这些信息丢到异步queue中去，后续操作中，可以通过这个id来查询我们tomcat中的下单逻辑是否完成了。</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305271232668.png" alt="image-20230527123253611" style="zoom:25%;"></p>
<p>整体思路：</p>
<ul>
<li><p>当用户下单之后，判断库存是否充足只需要导redis中去根据key找对应的value是否大于0即可，如果不充足，则直接结束，如果充足，继续在redis中判断用户是否可以下单，如果set集合中没有这条数据，说明他可以下单，如果set集合中没有这条记录，则将userId和优惠卷存入到redis中，并且返回0，整个过程需要保证是<code>原子性</code>的，我们可以使用<code>lua</code>来操作</p>
</li>
<li><p>当以上判断逻辑走完之后，我们可以判断当前redis中返回的结果是否是0 ，如果是0，则表示可以下单，则将之前说的信息存入到到<code>queue</code>中去，然后返回，然后再来个线程<code>异步的下单</code>，前端可以通过返回的订单id来判断是否下单成功。</p>
</li>
</ul>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305271233460.png" alt="image-20230527123353395" style="zoom:45%;"></p>
<ul>
<li>新增秒杀优惠券的同时，将优惠券信息保存到Redis中<ul>
<li>保存秒杀库存到Redis中<code>stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());</code></li>
</ul>
</li>
<li>执行Lua脚本<ul>
<li>判断秒杀库存是否充足</li>
<li>保存用户id，决定用户是否抢购成功（判断购买资格），确保一人一单</li>
<li><code>发送消息（用户id, 订单id ,优惠券id）到队列中</code></li>
</ul>
</li>
<li><p>如果抢购成功（结果为0：脚本规定的）</p>
<ul>
<li><span style="color:orange">将用户id, 订单id ,优惠券id封装后存入阻塞队列</span><ul>
<li><span style="color:orange"><em>阻塞队列创建：private BlockingQueue<VoucherOrder> orderTasks =new  ArrayBlockingQueue&lt;&gt;(1024 \</VoucherOrder></em> 1024);*</span><ul>
<li><span style="color:orange"><em>JDK 的阻塞队列，所以会进行初始化，一旦初始化的大小用完了，就会有内存问题</em></span></li>
</ul>
</li>
<li>使用消息队列：&lt;在lua脚本发送消息就可以了&gt;<ul>
<li>rabbitmq、kafka</li>
<li>redis提供的队列</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>开启线程任务[创建线程：<code>Executors.newSingleThreadExecutor()</code>]，不断从消息队列中获取信息，创建订单，实现异步下单功能</p>
<ul>
<li>获取消息队列中的订单信息&lt;<code>Stream</code>&gt;</li>
<li>判断订单信息是否为空,如果为null，说明没有消息，继续下一次循环，不为null，就对消息中数据 进行解析 并 创建订单 最后进行消息ACK确认，之后将不再处理这个消息</li>
<li>如果处理消息的时候出现异常，那么就进入<code>pending-list</code> 的消息队列中进行处理异常消息</li>
<li><code>pending-list</code> 的消息处理异常 的逻辑和 消息队列的一样的，只是在出现异常的时候直接打印错误消息退出即可，会自行while循环</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line"><span class="keyword">private</span> IVoucherOrderService proxy;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.执行lua脚本</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">                SECKILL_SCRIPT,</span><br><span class="line">                Collections.emptyList(),</span><br><span class="line">                voucherId.toString(), userId.toString(), String.valueOf(orderId)</span><br><span class="line">        );</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> result.intValue();</span><br><span class="line">        <span class="comment">// 2.判断结果是否为0</span></span><br><span class="line">        <span class="keyword">if</span> (r != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.1.不为0 ，代表没有购买资格</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(r == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.获取代理对象</span></span><br><span class="line">         proxy = (IVoucherOrderService)AopContext.currentProxy();</span><br><span class="line">        <span class="comment">//4.返回订单id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//异步处理线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">SECKILL_ORDER_EXECUTOR</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line"><span class="comment">//在类初始化之后执行线程池</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">   SECKILL_ORDER_EXECUTOR.submit(<span class="keyword">new</span> <span class="title class_">VoucherOrderHandler</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于线程池处理的任务    </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 1.获取消息队列中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;</span></span><br><span class="line">                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                    Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                    StreamReadOptions.empty().count(<span class="number">1</span>).block(Duration.ofSeconds(<span class="number">2</span>)),</span><br><span class="line">                    StreamOffset.create(<span class="string">&quot;stream.orders&quot;</span>, ReadOffset.lastConsumed())</span><br><span class="line">                );</span><br><span class="line">                <span class="comment">// 2.判断订单信息是否为空</span></span><br><span class="line">                <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 如果为null，说明没有消息，继续下一次循环</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 解析数据</span></span><br><span class="line">                MapRecord&lt;String, Object, Object&gt; record = list.get(<span class="number">0</span>);</span><br><span class="line">                Map&lt;Object, Object&gt; value = record.getValue();</span><br><span class="line">                <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(value, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                <span class="comment">// 3.创建订单</span></span><br><span class="line">                createVoucherOrder(voucherOrder);</span><br><span class="line">                <span class="comment">// 4.确认消息 XACK</span></span><br><span class="line">                stringRedisTemplate.opsForStream().acknowledge(<span class="string">&quot;s1&quot;</span>, <span class="string">&quot;g1&quot;</span>, record.getId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;处理订单异常&quot;</span>, e);</span><br><span class="line">                <span class="comment">//处理异常消息</span></span><br><span class="line">                handlePendingList();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handlePendingList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 1.获取pending-list中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 0</span></span><br><span class="line">                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                    Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                    StreamReadOptions.empty().count(<span class="number">1</span>),</span><br><span class="line">                    StreamOffset.create(<span class="string">&quot;stream.orders&quot;</span>, ReadOffset.from(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">                );</span><br><span class="line">                <span class="comment">// 2.判断订单信息是否为空</span></span><br><span class="line">                <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 如果为null，说明没有异常消息，结束循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 解析数据</span></span><br><span class="line">                MapRecord&lt;String, Object, Object&gt; record = list.get(<span class="number">0</span>);</span><br><span class="line">                Map&lt;Object, Object&gt; value = record.getValue();</span><br><span class="line">                <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(value, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                <span class="comment">// 3.创建订单</span></span><br><span class="line">                createVoucherOrder(voucherOrder);</span><br><span class="line">                <span class="comment">// 4.确认消息 XACK</span></span><br><span class="line">                stringRedisTemplate.opsForStream().acknowledge(<span class="string">&quot;s1&quot;</span>, <span class="string">&quot;g1&quot;</span>, record.getId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;处理pendding订单异常&quot;</span>, e);</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取锁，调用创建订单</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class="line">            <span class="comment">//1.获取用户</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">            <span class="comment">// 2.创建锁对象</span></span><br><span class="line">            <span class="type">RLock</span> <span class="variable">redisLock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order:&quot;</span> + userId);</span><br><span class="line">            <span class="comment">// 3.尝试获取锁</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> redisLock.lock();</span><br><span class="line">            <span class="comment">// 4.判断是否获得锁成功</span></span><br><span class="line">            <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">                <span class="comment">// 获取锁失败，直接返回失败或者重试</span></span><br><span class="line">                log.error(<span class="string">&quot;不允许重复下单！&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//注意：由于是spring的事务是放在threadLocal中，此时的是多线程，事务会失效</span></span><br><span class="line">                proxy.createVoucherOrder(voucherOrder);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 释放锁</span></span><br><span class="line">                redisLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//真正的创建订单</span></span><br><span class="line">   <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">createVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">        <span class="comment">// 5.1.查询订单</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()).count();</span><br><span class="line">        <span class="comment">// 5.2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 用户已经购买过了</span></span><br><span class="line">           log.error(<span class="string">&quot;用户已经购买过了&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>) <span class="comment">// where id = ? and stock &gt; 0</span></span><br><span class="line">                .update();</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// 扣减失败</span></span><br><span class="line">            log.error(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        save(voucherOrder);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>基于List的消息队列有哪些优缺点？</p>
<ul>
<li>优点<ul>
<li>利用Redis存储，不受限于JVM内存上限</li>
<li>基于Redis的持久化机制，数据安全性有保证</li>
<li>可以满足消息有序性</li>
</ul>
</li>
<li>缺点<ul>
<li>无法避免消息丢失</li>
<li>只支持单消费者</li>
</ul>
</li>
</ul>
<p>基于PubSub的消息队列有哪些优缺点？</p>
<ul>
<li><p>优点：</p>
<ul>
<li>采用发布订阅模型，支持多生产、多消费</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li><p>不支持数据持久化</p>
</li>
<li><p>无法避免消息丢失</p>
</li>
<li><p>消息堆积有上限，超出时数据丢失</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305271320979.png" alt="image-20230527132059880" style="zoom:25%;"></p>
</blockquote>
<h4 id="达人探店"><a href="#达人探店" class="headerlink" title="达人探店"></a>达人探店</h4><ul>
<li><p>基本需求</p>
<ul>
<li>图片上传到 oos 上</li>
<li>发布文章</li>
<li>查看文章</li>
</ul>
</li>
<li><p>点赞功能  和 前面几个点赞的会进行头像的显示</p>
<blockquote>
<p>直接<code>操作数据库</code>  的 <code>点赞数量的值</code>;这种方式会导致一个用户无限点赞，明显是不合理的</p>
<p>造成这个问题的原因是，我们现在的逻辑，发起请求只是给数据库+1，所以才会出现这个问题</p>
</blockquote>
<ul>
<li>同一个用户只能点赞一次，再次点击则 取消点赞<ul>
<li>给Blog类中添加一个isLike字段，标示是否被当前用户点赞</li>
<li>修改点赞功能，<code>&lt;使用sortset&gt;</code>    <code>opsForZSet</code>  ，判断条件是查分数是否存在<ul>
<li>不存在，表示未点赞过则点赞数+1,数据库实时+1，并将用户id保存到redis的set集合中 <code>opsForSet</code></li>
<li>存在，表示已点赞过则点赞数-1,取消点赞，从Redis的set集合移除用户id</li>
</ul>
</li>
<li>修改根据id查询Blog的业务，判断当前登录用户是否点赞过，赋值给isLike字段</li>
<li>修改分页查询Blog业务，判断当前登录用户是否点赞过，赋值给isLike字段</li>
</ul>
</li>
<li>如果当前用户已经点赞，则点赞按钮高亮显示（前端已实现，判断字段Blog类的isLike属性）</li>
<li>随后进行查询<code>top5</code>的点赞用户 <code>opsForZSet.range(key, 0, 4)</code><ul>
<li>此处注意的是数据库会有问题，查询语句需要改进  使用 <code>IN(5,1)</code>会按照id排序，而不是给定的顺序</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解析出其中的用户id</span></span><br><span class="line">   List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">   <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">   <span class="comment">// 根据用户id查询用户 WHERE id IN ( 5 , 1 ) ORDER BY FIELD(id, 5, 1)</span></span><br><span class="line">   List&lt;UserDTO&gt; userDTOS = userService.query()</span><br><span class="line">           .in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list()</span><br><span class="line">           .stream()</span><br><span class="line">           .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))</span><br><span class="line">           .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<h4 id="好友关注"><a href="#好友关注" class="headerlink" title="好友关注"></a>好友关注</h4><p>思路：</p>
<ul>
<li>关注是User之间的关系，是博主与粉丝的关系，一张关联表</li>
</ul>
<p><span style="color:red">关注取关[<code>mysql</code>]   共同关注(求交集<code>set</code>)</span></p>
<ul>
<li>获取登录用户</li>
<li>判断是否关注   —根据登录的用户的id，查询(<code>查关联表</code>)是否关注</li>
<li>没关注就去新增数据，随后   将 用户的id，放入redis的<code>set</code>集合</li>
<li><p>关注过就删除,随后  将 用户的id，从redis的<code>set</code>集合 删除</p>
</li>
<li><p>随后 获取当前用户和目标用户的交集</p>
<ul>
<li>没有交集返回 null</li>
<li>有的话就 解析数据查询用户，返回结果</li>
</ul>
</li>
</ul>
<p><span style="color:red">推送到粉丝收件箱</span></p>
<ul>
<li><p>在保存blog到数据库之后，去数据库中获取博主的所有粉丝，逐个推送笔记到粉丝的收件箱，就是设置到redis中，值：<code>zset</code>,键： 粉丝id ，推送的内容： 文章id, 设置 过期时间</p>
</li>
<li><p>收件箱可以根据时间戳排序</p>
</li>
<li>查询收件箱数据时<ul>
<li>获取当前用户的key ，从而得到当前用户的收件箱，进行滚动分页  查询<ul>
<li><code>Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate.opsForZSet()
.reverseRangeByScoreWithScores(key, 0, max, offset, 2);</code> //2 <code>每页2条</code></li>
</ul>
</li>
<li>每次查询完成后，我们要分析出查询出数据的最小时间戳，这个值会作为下一次查询的条件<ul>
<li>如果查询 结果非空 ，解析数据，得到对应的id,（score）时间戳，偏移量，</li>
<li>遍历判断，找到相同的<code>score</code>值，就++；找不到就进行替换，并将<code>偏移量</code>定为1；</li>
<li>从而：我们就能找到与上一次查询相同的查询个数作为<code>偏移量</code>，下次查询时，跳过这些查询过的数据，拿到我们需要的数据</li>
</ul>
</li>
<li>最后 由 id 查询数据博文 和 博文 的用户与是否点赞的信息</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：</p>
<ul>
<li>Feed流中的数据会不断更新，所以数据的角标也在变化，因此不能采用传统的分页模式。</li>
<li>传统了分页在feed流是不适用的，因为我们的数据会随时发生变化</li>
<li>假设在t1 时刻，我们去读取第一页，此时page = 1 ，size = 5 ，那么我们拿到的就是10~6 这几条记录，假设现在t2时候又发布了一条记录，此时t3 时刻，我们来读取第二页，读取第二页传入的参数是page=2 ，size=5 ，那么此时读取到的第二页实际上是从6 开始，然后是6~2 ，那么我们就读取到了重复的数据，所以feed流的分页，不能采用原始方案来做。</li>
</ul>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305271605923.png" alt="image-20230527160511761" style="zoom:25%;"></p>
<p>解决：</p>
<ul>
<li>Feed流的滚动分页   <code>每次查询都 记录  上一次查询的最小值   并 从上一次查询的最小值开始查询</code></li>
<li>我们需要记录每次操作的最后一条，然后从这个位置开始去读取数据</li>
<li>举个例子：我们从t1时刻开始，拿第一页数据，拿到了10~6，然后记录下当前最后一次拿取的记录，就是6，t2时刻发布了新的记录，此时这个11放到最顶上，但是不会影响我们之前记录的6，此时t3时刻来拿第二页，第二页这个时候拿数据，还是从6后一点的5去拿，就拿到了5-1的记录。我们这个地方可以采用sortedSet来做，可以进行范围查询，并且还可以记录当前获取数据时间戳最小值，就可以实现滚动分页了</li>
</ul>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305271605036.png" alt="image-20230527160558969" style="zoom:25%;"></p>
<p>使用的数据结果：<code>zset</code></p>
<p>当我们关注了用户后，这个用户发了动态，那么我们应该把这些数据推送给用户，这个需求，其实我们又把他叫做Feed流，关注推送也叫做Feed流，直译为投喂。为用户持续的提供“沉浸式”的体验，通过无限下拉刷新获取新的信息。</p>
<p>对于新型的<code>Feed流</code>的的效果：不需要我们用户再去推送信息，而是系统分析用户到底想要什么，然后直接把内容推送给用户，从而使用户能够更加的节约时间，不用主动去寻找。</p>
<p>Feed流的实现有两种模式：</p>
</blockquote>
<p>Feed流产品有两种常见模式：<br>Timeline：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注。例如朋友圈</p>
<ul>
<li>优点：信息全面，不会有缺失。并且实现也相对简单</li>
<li>缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低</li>
</ul>
<p>智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容。推送用户感兴趣信息来吸引用户</p>
<ul>
<li>优点：投喂用户感兴趣信息，用户粘度很高，容易沉迷</li>
<li>缺点：如果算法不精准，可能起到反作用<br>本例中的个人页面，是基于关注的好友来做Feed流，因此采用Timeline的模式。该模式的实现方案有三种：</li>
</ul>
<blockquote>
<p>我们本次针对好友的操作，采用的就是<code>Timeline</code>的方式，只需要拿到我们关注用户的信息，然后按照时间排序即可，因此采用Timeline的模式。该模式的实现方案有三种：</p>
</blockquote>
<ul>
<li>拉模式</li>
<li>推模式</li>
<li>推拉结合</li>
</ul>
<blockquote>
<p><strong>拉模式</strong>：也叫做读扩散</p>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305271557654.png" alt="image-20230527155629693" style="zoom:25%;"></p>
</blockquote>
<p>该模式的核心含义就是：当张三和李四和王五发了消息后，都会保存在自己的邮箱中，假设赵六要读取信息，那么他会从读取他自己的收件箱，此时系统会从他关注的人群中，把他关注人的信息全部都进行拉取，然后在进行排序</p>
<p>优点：比较节约空间，因为赵六在读信息时，并没有重复读取，而且读取完之后可以把他的收件箱进行清楚。</p>
<p>缺点：比较延迟，当用户读取数据时才去关注的人里边去读取数据，假设用户关注了大量的用户，那么此时就会拉取海量的内容，对服务器压力巨大。</p>
<blockquote>
<p><strong>推模式</strong>：也叫做写扩散。</p>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305271558003.png" alt="image-20230527155703838" style="zoom:25%;"></p>
</blockquote>
<p>推模式是没有写邮箱的，当张三写了一个内容，此时会主动的把张三写的内容发送到他的粉丝收件箱中去，假设此时李四再来读取，就不用再去临时拉取了</p>
<p>优点：时效快，不用临时拉取</p>
<p>缺点：内存压力大，假设一个大V写信息，很多人关注他， 就会写很多分数据到粉丝那边去</p>
<blockquote>
<p><strong>推拉结合模式</strong>：也叫做读写混合，兼具推和拉两种模式的优点。</p>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305271557979.png" alt="image-20230527155713821" style="zoom:25%;"></p>
</blockquote>
<p>推拉模式是一个折中的方案，站在发件人这一段，如果是个普通的人，那么我们采用写扩散的方式，直接把数据写入到他的粉丝中去，因为普通的人他的粉丝关注量比较小，所以这样做没有压力，如果是大V，那么他是直接将数据先写入到一份到发件箱里边去，然后再直接写一份到活跃粉丝收件箱里边去，现在站在收件人这端来看，如果是活跃粉丝，那么大V和普通的人发的都会直接写入到自己收件箱里边来，而如果是普通的粉丝，由于他们上线不是很频繁，所以等他们上线时，再从发件箱里边去拉信息。</p>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305271559390.png" alt="image-20230527155921137" style="zoom:25%;"></p>
<h4 id="附近的商户"><a href="#附近的商户" class="headerlink" title="附近的商户"></a>附近的商户</h4><p>思路：<code>&lt;geo&gt;</code></p>
<ul>
<li><p>将数据库表中的数据导入到redis中去，redis中的GEO，GEO在redis中就一个menber和一个经纬度，</p>
</li>
<li><p>我们把x和y轴传入到redis做的经纬度位置去，但我们不能把所有的数据都放入到menber中去，</p>
<p>但是毕竟作为redis是一个内存级数据库，如果存海量数据，redis还是力不从心，所以我们在这个地方<code>存储他的id</code>即可。</p>
</li>
<li><p>但是这个时候还有一个问题，就是在redis中并没有存储type，所以我们无法根据type来对数据进行筛选</p>
<p>所以我们可以按照<code>商户类型做分组</code>，类型相同的商户作为同一组，以<code>typeId为key</code>存入同一个GEO集合中即可</p>
</li>
</ul>
<p>实现</p>
<ul>
<li><p>判断是否需要根据坐标查询</p>
<ul>
<li><p>不需要坐标查询，按数据库查询并返回数据</p>
</li>
<li><p>查询redis、按照距离排序、分页。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> SHOP_GEO_KEY + typeId;</span><br><span class="line">        GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = stringRedisTemplate.opsForGeo() <span class="comment">// GEOSEARCH key BYLONLAT x y BYRADIUS 10 WITHDISTANCE</span></span><br><span class="line">                .search(</span><br><span class="line">                        key,</span><br><span class="line">                        GeoReference.fromCoordinate(x, y),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Distance</span>(<span class="number">5000</span>),           RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end)</span><br><span class="line">                );</span><br></pre></td></tr></table></figure>
</li>
<li><p>随后解析数据[ 获取 店铺id 、获取距离]   分页展示</p>
<ul>
<li><p><code>手动的截取分页</code>和<code>数据解析</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list.size());</span><br><span class="line">Map&lt;String, Distance&gt; distanceMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(list.size());</span><br><span class="line">list.stream().skip(from).forEach(result -&gt; &#123;</span><br><span class="line">            <span class="comment">// 4.2.获取店铺id</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">shopIdStr</span> <span class="operator">=</span> result.getContent().getName();</span><br><span class="line">            ids.add(Long.valueOf(shopIdStr));</span><br><span class="line">            <span class="comment">// 4.3.获取距离</span></span><br><span class="line">            <span class="type">Distance</span> <span class="variable">distance</span> <span class="operator">=</span> result.getDistance();</span><br><span class="line">            distanceMap.put(shopIdStr, distance);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>最后 由 id  查询 <code>Shop</code></p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p> <code>es+mq</code>的写法：</p>
</blockquote>
<p>Es   的基本步骤：</p>
<blockquote>
<ul>
<li>准备Request</li>
<li>准备DSL  &lt;进行封装得到各种<code>XXXQuery()</code>&gt;</li>
<li>发送请求</li>
<li>解析响应</li>
</ul>
<p>搜索  分页</p>
</blockquote>
<ul>
<li><p>准备<code>request</code></p>
</li>
<li><p>准备 <code>DSL</code></p>
<ul>
<li><p>利用<code>QueryBuilders.matchAllQuery()</code>进行全文检索</p>
</li>
<li><p>分页查询</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">page</span> <span class="operator">=</span> params.getPage();</span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> params.getSize();</span><br><span class="line">request.source().from((page - <span class="number">1</span>) * size).size(size);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>进行查询，发送请求</p>
</li>
<li><p>解析响应</p>
<ul>
<li>获取总共的数目 ；生成文档数组，遍历文档数组，获取文档，反序列化之后放入集合中，封装返回即可</li>
</ul>
</li>
</ul>
<blockquote>
<p>结果过滤</p>
</blockquote>
<ul>
<li>使用<code>QueryBuilders.boolQuery()</code>进行过滤，随后进行<code>关键字搜索</code> <code>boolQuery.must()</code></li>
<li>进行条件过滤<code>boolQuery.filter()</code></li>
</ul>
<blockquote>
<p>周边的酒店</p>
</blockquote>
<ul>
<li>在上述代码的基础上 添加<code>排序</code>逻辑</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">location</span> <span class="operator">=</span> params.getLocation();</span><br><span class="line">      <span class="keyword">if</span> (location != <span class="literal">null</span> &amp;&amp; !location.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">          request.source().sort(SortBuilders</span><br><span class="line">                                .geoDistanceSort(<span class="string">&quot;location&quot;</span>, <span class="keyword">new</span> <span class="title class_">GeoPoint</span>(location))</span><br><span class="line">                                .order(SortOrder.ASC)</span><br><span class="line">                                .unit(DistanceUnit.KILOMETERS)</span><br><span class="line">                               );</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解析响应<code>handleResponse</code>的时候除了解析source部分以外，还要得到sort部分，也就是排序的距离，然后放到响应结果中。</li>
</ul>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305271810318.png" alt="image-20230527181011248" style="zoom:25%;"></p>
<blockquote>
<p>自动补全</p>
</blockquote>
<ul>
<li><p>在实体类中需要进行切割 获取多个不同可能分词</p>
</li>
<li><p>还是还上面四步的基础上在解析响应的时候，</p>
</li>
<li><p>要先根据补全查询名称，获取补全结果</p>
</li>
<li><p>并得到补全的选项，随后遍历添加到集合中</p>
</li>
</ul>
<blockquote>
<p>结合<code>mq</code>实现 <code>es 和 mysql</code> 的消息同步</p>
</blockquote>
<ul>
<li>声明交换机和队列  以及之间的绑定关系</li>
<li>每当<code>数据库</code>进行  增删 等操作就 让 进行  发送消息</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rabbitTemplate.convertAndSend(MqConstants.HOTEL_EXCHANGE,MqConstants.HOTEL_INSERT_KEY,hotel.getId());</span><br><span class="line">							<span class="comment">// 交换机                  // rountyKey                     //消息内容</span></span><br></pre></td></tr></table></figure>
<ul>
<li>监听 和接收消息,随后进行 对<code>es</code>的 删除和新增等操作<ul>
<li>根据id查询酒店数据</li>
<li>转换为文档类型</li>
<li>准备Request对象</li>
<li>准备Json文档</li>
<li>发送请求</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = MqConstants.HOTEL_INSERT_QUEUE)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenHotelInsertOrUpdate</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">        hotelService.insertById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@RabbitListener(queues = MqConstants.HOTEL_DELETE_QUEUE)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenHotelDelete</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">        hotelService.deleteById(id);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 0.根据id查询酒店数据</span></span><br><span class="line">        <span class="type">Hotel</span> <span class="variable">hotel</span> <span class="operator">=</span> getById(id);</span><br><span class="line">        <span class="comment">// 转换为文档类型</span></span><br><span class="line">        <span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HotelDoc</span>(hotel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.准备Request对象</span></span><br><span class="line">        <span class="type">IndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;hotel&quot;</span>).id(hotel.getId().toString());</span><br><span class="line">        <span class="comment">// 2.准备Json文档</span></span><br><span class="line">        request.source(JSON.toJSONString(hotelDoc), XContentType.JSON);</span><br><span class="line">        <span class="comment">// 3.发送请求</span></span><br><span class="line">        client.index(request, RequestOptions.DEFAULT);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.准备Request</span></span><br><span class="line">        <span class="type">DeleteRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteRequest</span>(<span class="string">&quot;hotel&quot;</span>, id.toString());</span><br><span class="line">        <span class="comment">// 2.发送请求</span></span><br><span class="line">        client.delete(request, RequestOptions.DEFAULT);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>产生的效果就是： 当后台数据发生修改的时候，会使得消息队列 能接受到消息，随即es中的数据也发生了变化</code></p>
</blockquote>
<h4 id="用户签到"><a href="#用户签到" class="headerlink" title="用户签到"></a>用户签到</h4><p><code>bitmap</code>     <code>签到记录为1，未签到则记录为0.</code></p>
<p>用户签到-实现签到功能</p>
<ul>
<li>获取当前登录用户</li>
<li>获取今天的日期  并  拼接key  计算   今天是本月的第几天</li>
<li>写入<code>Redis</code> <code>SETBIT key offset 1</code>       <code>stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - 1, true);</code></li>
</ul>
<p>用户签到-连续签到的统计</p>
<ul>
<li><p>获取当前登录用户</p>
</li>
<li><p>获取今天的日期  并  拼接key  计算   今天是本月的第几天</p>
</li>
<li><p>写入<code>Redis</code> <code>SETBIT key offset 1</code>       <code>stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - 1, true);</code></p>
</li>
<li><p>获取本月截止今天为止的所有的签到记录，返回的是一个十进制的数字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(</span><br><span class="line">            key,</span><br><span class="line">            BitFieldSubCommands.create()</span><br><span class="line">           .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class="number">0</span>)</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取结果  并   循环遍历</p>
<ul>
<li>让这个数字与1做与运算，得到数字的最后一个bit位  判断这个bit位是否为0<ul>
<li>如果为0，说明未签到，结束</li>
<li>如果不为0，说明已签到，计数器+1</li>
</ul>
</li>
<li>把数字右移一位，抛弃最后一个bit位，继续下一个bit位</li>
</ul>
</li>
</ul>
<blockquote>
<p>什么叫做连续签到天数？</p>
<ul>
<li>从最后一次签到开始向前统计，直到遇到第一次未签到为止，计算总的签到次数，就是连续签到天数。</li>
</ul>
<p>如何得到本月到今天为止的所有签到数据？</p>
<ul>
<li><code>BITFIELD key GET u[dayOfMonth] 0</code></li>
</ul>
<p>如何从后向前遍历每个bit位</p>
<ul>
<li>我们只需要让得到的10进制数字和1做与运算就可以了，因为1只有遇见1 才是1，其他数字都是0 ，我们把签到结果和1进行与操作，每与一次，就把签到结果向右移动一位，依次内推，我们就能完成逐个遍历的效果了</li>
</ul>
</blockquote>
<h4 id="UV统计"><a href="#UV统计" class="headerlink" title="UV统计"></a>UV统计</h4><p><code>hyperloglog</code></p>
<p>简单的单元测试： 内存占用极小</p>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305271736460.png" alt="image-20230527173645389"></p>
<h4 id="双写一致性"><a href="#双写一致性" class="headerlink" title="双写一致性"></a>双写一致性</h4><p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305271743480.png" alt="image-20230527174335410" style="zoom:33%;"></p>
<p>前置：</p>
<ul>
<li><code>canal</code>工作原理<ul>
<li>canal 模拟<code>MySQL slave</code>的交互协议，伪装自己为<code>MySQL slave</code>，向<code>MySQL master</code>发送<code>dump</code>协议</li>
<li><code>MySQL master</code>收到<code>dump</code>请求，开始推送<code>binary log</code>给<code>slave</code> (即canal )</li>
<li>canal<code>解析</code>binary log<code>对象(原始为</code>byte流)</li>
</ul>
</li>
</ul>
<p><code>优于MQ</code>  — <code>代码0侵入</code></p>
<p>思路：我们可以利用Canal提供的Java客户端，监听Canal通知消息。当收到变化的消息时，完成对缓存的更新。</p>
<p>写法：参考官网[<a href="https://github.com/alibaba/canal/wiki/ClientExample">https://github.com/alibaba/canal/wiki/ClientExample</a>] +对应笔记  ==代码库==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.luojia.canaldemo.biz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.client.CanalConnector;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.client.CanalConnectors;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.common.utils.AddressUtils;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.protocol.CanalEntry.*;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.protocol.Message;</span><br><span class="line"><span class="keyword">import</span> com.luojia.canaldemo.utils.RedisUtils;</span><br><span class="line"><span class="keyword">import</span> io.lettuce.core.RedisClient;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisCanalClientExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">_60SECONDS</span> <span class="operator">=</span> <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REDIS_IP_ADDR</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">redisInsert</span><span class="params">(List&lt;Column&gt; columns)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">        <span class="keyword">for</span> (Column column : columns) &#123;</span><br><span class="line">            System.out.println(column.getName() + <span class="string">&quot;: &quot;</span> + column.getValue() + <span class="string">&quot; insert = &quot;</span> + column.getUpdated());</span><br><span class="line">            jsonObject.put(column.getName(), column.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (columns.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> RedisUtils.getJedis()) &#123;</span><br><span class="line">                jedis.set(columns.get(<span class="number">0</span>).getValue(), jsonObject.toJSONString());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">redisDelete</span><span class="params">(List&lt;Column&gt; columns)</span> &#123;</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">        <span class="keyword">for</span> (Column column : columns) &#123;</span><br><span class="line">            System.out.println(column.getName() + <span class="string">&quot;: &quot;</span> + column.getValue() + <span class="string">&quot; delete = &quot;</span> + column.getUpdated());</span><br><span class="line">            jsonObject.put(column.getName(), column.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (columns.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> RedisUtils.getJedis()) &#123;</span><br><span class="line">                jedis.del(columns.get(<span class="number">0</span>).getValue());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">redisUpdate</span><span class="params">(List&lt;Column&gt; columns)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">        <span class="keyword">for</span> (Column column : columns) &#123;</span><br><span class="line">            System.out.println(column.getName() + <span class="string">&quot;: &quot;</span> + column.getValue() + <span class="string">&quot; update = &quot;</span> + column.getUpdated());</span><br><span class="line">            jsonObject.put(column.getName(), column.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (columns.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> RedisUtils.getJedis()) &#123;</span><br><span class="line">                jedis.set(columns.get(<span class="number">0</span>).getValue(), jsonObject.toJSONString());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printEntry</span><span class="params">(List&lt;Entry&gt; entrys)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry entry : entrys) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getEntryType() == EntryType.TRANSACTIONBEGIN || entry.getEntryType() == EntryType.TRANSACTIONEND) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">RowChange</span> <span class="variable">rowChage</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rowChage = RowChange.parseFrom(entry.getStoreValue());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;ERROR ## parser of eromanga-event has an error , data:&quot;</span> + entry.toString(),</span><br><span class="line">                        e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">EventType</span> <span class="variable">eventType</span> <span class="operator">=</span> rowChage.getEventType();</span><br><span class="line">            System.out.println(String.format(<span class="string">&quot;================&amp;gt; binlog[%s:%s] , name[%s,%s] , eventType : %s&quot;</span>,</span><br><span class="line">                    entry.getHeader().getLogfileName(), entry.getHeader().getLogfileOffset(),</span><br><span class="line">                    entry.getHeader().getSchemaName(), entry.getHeader().getTableName(),</span><br><span class="line">                    eventType));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (RowData rowData : rowChage.getRowDatasList()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (eventType == EventType.DELETE) &#123;</span><br><span class="line">                    redisDelete(rowData.getBeforeColumnsList());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (eventType == EventType.INSERT) &#123;</span><br><span class="line">                    redisInsert(rowData.getAfterColumnsList());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;-------&amp;gt; before&quot;</span>);</span><br><span class="line">                    redisUpdate(rowData.getBeforeColumnsList());</span><br><span class="line">                    System.out.println(<span class="string">&quot;-------&amp;gt; after&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建链接</span></span><br><span class="line">        <span class="type">CanalConnector</span> <span class="variable">connector</span> <span class="operator">=</span> CanalConnectors.newSingleConnector(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(AddressUtils.getHostIp(),</span><br><span class="line">                <span class="number">11111</span>), <span class="string">&quot;example&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">batchSize</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">emptyCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connector.connect();</span><br><span class="line">            <span class="comment">// 监听当前库的所有表</span></span><br><span class="line">            <span class="comment">// connector.subscribe(&quot;.*\\..*&quot;);  .*\\..* 所有库所有表</span></span><br><span class="line">            connector.subscribe(<span class="string">&quot;jmall.t_user&quot;</span>);  <span class="comment">// 指定库指定表 速度更快</span></span><br><span class="line">            connector.rollback();</span><br><span class="line">            <span class="type">int</span> <span class="variable">totalEmptyCount</span> <span class="operator">=</span> <span class="number">10</span> * _60SECONDS;<span class="comment">//指定监听时间</span></span><br><span class="line">            <span class="keyword">while</span> (emptyCount &lt; totalEmptyCount) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我是canal，每秒监听一次：&quot;</span> + UUID.randomUUID().toString());</span><br><span class="line">                <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> connector.getWithoutAck(batchSize); <span class="comment">// 获取指定数量的数据</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">batchId</span> <span class="operator">=</span> message.getId();</span><br><span class="line">                <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> message.getEntries().size();</span><br><span class="line">                <span class="keyword">if</span> (batchId == -<span class="number">1</span> || size == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// MySQL数据没有变动</span></span><br><span class="line">                    emptyCount++;</span><br><span class="line">                    System.out.println(<span class="string">&quot;empty count : &quot;</span> + emptyCount);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);  <span class="comment">// 监听，一秒一次</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    emptyCount = <span class="number">0</span>; <span class="comment">// 计数器</span></span><br><span class="line">                    <span class="comment">// System.out.printf(&quot;message[batchId=%s,size=%s] \n&quot;, batchId, size);</span></span><br><span class="line">                    printEntry(message.getEntries());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                   connector.ack(batchId); <span class="comment">// 提交确认</span></span><br><span class="line">                <span class="comment">// connector.rollback(batchId); // 处理失败, 回滚数据</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;empty too many times, exit&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            connector.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="短信验证码的点击次数"><a href="#短信验证码的点击次数" class="headerlink" title="短信验证码的点击次数"></a>短信验证码的点击次数</h4><ul>
<li><p>连接jedis</p>
</li>
<li><p>使用redis 对 <code>key-&gt;手机号</code>，时间，<code>value -&gt;次数</code>进行缓存</p>
</li>
<li>由key 拿到对应的 value 并进行次数判断</li>
<li>次数没到就继续发送并对对应的 key +1;</li>
<li>次数到 不再发送，并且关闭jedis</li>
<li>将验证码也放入jedis中，进行缓存，并随后进行判断校验即可</li>
</ul>
<h4 id="手写布隆过滤器"><a href="#手写布隆过滤器" class="headerlink" title="手写布隆过滤器"></a>手写布隆过滤器</h4><ul>
<li>思路架构</li>
</ul>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305261116008.png" alt="image-20230526111610941" style="zoom: 25%;"></p>
<blockquote>
<p><code>布隆过滤器</code>到 <code>redis</code> 的过程</p>
</blockquote>
<ul>
<li>建立<code>布隆过滤器</code>白/黑名单初始化工具类，一开始就设置一部分数据为白/黑名单所有<ul>
<li>白/黑名单客户加载到布隆过滤器</li>
<li>计算<code>hashValue</code>，由于存在计算出来负数的可能，取绝对值</li>
<li>通过<code>hashValue</code> 和 2的32次方后取余，获得对应的下标位置</li>
<li>设置<code>redis</code>里面的<code>bitmap</code>对应类型的位置，并在<code>redis</code>中将该值设置<code>setBit</code>为1</li>
</ul>
</li>
<li>检查是否在白/黑名单内<ul>
<li>将<code>key</code> 进行<code>hash</code>计算  后  得到 <code>hashValue</code>并进行转化为下标位置，判断是否存在</li>
<li>无则必无，有则能有</li>
</ul>
</li>
</ul>
<blockquote>
<p>说明:</p>
<ul>
<li>布隆过滤器有，Redis有，一切都能正常访问</li>
<li>布隆过滤器有，Redis无，可以正常访问并会写Redis</li>
<li>布隆过滤器无，直接返回数据，不再继续走下去</li>
</ul>
<p><code>redis</code> 到 <code>mysql</code>  的过程</p>
</blockquote>
<ul>
<li><p>写操作： 低QPS的实现代码思路&lt;<code>没有布隆过滤器的一般思路</code>&gt;</p>
<ul>
<li>向 <code>mysql</code> 插入数据<ul>
<li>当 <code>mysql</code> 插入成功就重新查新一次并将 查询结果 写到 <code>redis</code> 中</li>
</ul>
</li>
<li>去<code>redis</code>上查询<ul>
<li>如果<code>redis</code>有，直接返回  如果<code>redis</code>没有，在<code>mysql</code>上查询</li>
<li><code>redis</code>无，再去查询我们的<code>mysql</code>  并 回写 到<code>redis</code>中</li>
</ul>
</li>
</ul>
</li>
<li><p>读操作： 高QPS的实现代码思路  【<code>双检加锁</code>】</p>
<ul>
<li>去<code>redis</code>上查询<ul>
<li><code>redis</code>有，直接返回  如果<code>redis</code>没有，在<code>mysql</code>上查询</li>
<li>去<code>mysql</code>查询的时候会先加锁，保证一个请求操作，让外面的<code>redis</code>等待一下，避免击穿<code>mysql</code>（大公司的操作 ）</li>
</ul>
</li>
<li>加锁后，第二次查询<code>redis</code><ul>
<li><code>mysql</code>有，<code>redis</code>无，再去查询<code>mysql</code><ul>
<li>都没有就缓存一个规定的空值（防止穿透）</li>
<li>否则就 把<code>mysql</code>查询到的数据会写到<code>redis</code>并设置过期时间</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Guava布隆过滤器-—穿透"><a href="#Guava布隆过滤器-—穿透" class="headerlink" title="Guava布隆过滤器 —穿透"></a>Guava布隆过滤器 —穿透</h4><blockquote>
<p>和<code>redis</code> 是<code>解耦</code>的，所以优于 手写的 <code>布隆过滤器</code></p>
<p><code>private static BloomFilter&lt;Integer&gt; bloomFilter = BloomFilter.create(Funnels.integerFunnel(), SIZE, fpp);</code></p>
<p><strong>+</strong></p>
<p>调用<code>api</code></p>
</blockquote>
<ul>
<li>思路架构</li>
</ul>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305261243415.png" alt="image-20230526124311334" style="zoom:43%;"></p>
<ul>
<li>流程</li>
</ul>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305261253961.png" alt="image-20230526125309880" style="zoom:33%;"></p>
<ul>
<li>黑名单</li>
</ul>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305261256361.png" alt="image-20230526125602973" style="zoom:33%;"></p>
<h4 id="抢红包"><a href="#抢红包" class="headerlink" title="抢红包"></a>抢红包</h4><p>需求：</p>
<ul>
<li><p>不加锁保证原子性，支持高并发</p>
</li>
<li><p>红包算法（二倍均值法）</p>
<ul>
<li>所有人抢到的金额之和 必须要 等于红包金额</li>
<li>每个人至少抢到一分钱</li>
<li>要保证所有人抢到金额的几率相等</li>
<li>公式： <code>每次抢到的金额 = 随机取件（0，（剩余红包金额 ÷ 剩余人数N）× 2）</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>分析：</p>
<ul>
<li><p>发红包 抢红包  ：使用的数据结构： <code>list</code></p>
</li>
<li><p>记录红包：<code>hash</code></p>
</li>
<li><p>redis 每个命令都是<code>单线程</code> <code>原子性</code></p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RED_PACKAGE_KEY</span> <span class="operator">=</span> <span class="string">&quot;redpackage:&quot;</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RED_PACKAGE_CONSUME_KEY</span> <span class="operator">=</span> <span class="string">&quot;redpackage:consume&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 拆红包的算法 ---&gt;  二倍均值算法</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> totalMoney</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> redpackageNumber</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> Integer[] splitRedPackageAlgorithm(<span class="type">int</span> totalMoney, <span class="type">int</span> redpackageNumber) &#123;</span><br><span class="line">       Integer[] redPackageNums = <span class="keyword">new</span> <span class="title class_">Integer</span>[redpackageNumber];</span><br><span class="line">       <span class="comment">// 已经被抢夺的红包金额</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">useMoney</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; redpackageNumber; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (i == redpackageNumber - <span class="number">1</span>) &#123;</span><br><span class="line">               redPackageNums[i] = totalMoney - useMoney;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 二倍均值算法，每次拆分后塞进子红包的金额</span></span><br><span class="line">               <span class="comment">// 金额 = 随机取件（0，（剩余红包金额 / 未被抢的剩余红包数 N ）* 2 ）</span></span><br><span class="line">               <span class="type">int</span> <span class="variable">avgMoney</span> <span class="operator">=</span> ((totalMoney - useMoney) / (redpackageNumber - i)) * <span class="number">2</span>;</span><br><span class="line">               redPackageNums[i] = <span class="number">1</span> + <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(avgMoney - <span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           useMoney = useMoney + redPackageNums[i];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> redPackageNums;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 发红包</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> totalMoney</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> redPackageNumber</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">sendRedPackage</span><span class="params">(<span class="type">int</span> totalMoney, <span class="type">int</span> redPackageNumber)</span> &#123;</span><br><span class="line">       <span class="comment">// 1. 拆红包，将总金额totalMoney拆分成 redpackageNumber 个子红包</span></span><br><span class="line">       Integer[] splitRedPackages = splitRedPackageAlgorithm(totalMoney, redPackageNumber);     <span class="comment">// 拆分红包算法（二倍均值算法）通过后获得的多个子红包数组</span></span><br><span class="line">       <span class="comment">// 2. 发红包并保存进 list 结构 并且设置过期时间</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RED_PACKAGE_KEY + IdUtil.simpleUUID();</span><br><span class="line">       redisTemplate.opsForList().leftPushAll(key, splitRedPackages);</span><br><span class="line">       redisTemplate.expire(key, <span class="number">1</span>, TimeUnit.DAYS);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3.发红包ok，返回前台显示</span></span><br><span class="line">       <span class="keyword">return</span> key + <span class="string">&quot;\t&quot;</span> + Ints.asList(Arrays.stream(splitRedPackages).mapToInt(Integer::valueOf).toArray());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">robRedPackage</span><span class="params">(String redPackageKey, String userId)</span> &#123;</span><br><span class="line">       <span class="comment">// 1.验证某个用户是否抢过红包，不可以多抢</span></span><br><span class="line">       <span class="type">Object</span> <span class="variable">redPackage</span> <span class="operator">=</span> redisTemplate.opsForHash().get(RED_PACKAGE_CONSUME_KEY + redPackageKey, userId);</span><br><span class="line">       <span class="comment">// 2.没有抢过红包可以抢，如果抢过返回 -2 表示抢过</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="literal">null</span> == redPackage) &#123;</span><br><span class="line">           <span class="comment">// 2.1 从 list 结构中出队一个作为抢的红包</span></span><br><span class="line">           <span class="type">Object</span> <span class="variable">partRedPackage</span> <span class="operator">=</span> redisTemplate.opsForList().leftPop(RED_PACKAGE_KEY + redPackageKey);</span><br><span class="line">           <span class="keyword">if</span> (partRedPackage != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="comment">// 2.2 抢到红包后 需要记录到hash结构中 记录每人抢到的红包</span></span><br><span class="line">               redisTemplate.opsForHash().put(RED_PACKAGE_CONSUME_KEY + redPackageKey, userId, partRedPackage);</span><br><span class="line">               System.out.println(<span class="string">&quot;用户&quot;</span> + userId + <span class="string">&quot;\t 抢到了多少钱的红包：&quot;</span> + partRedPackage);</span><br><span class="line">               <span class="comment">// TODO  后续异步进mysql或者MQ进一步做统计处理，每一年你发出多少红包，抢到了多少红包</span></span><br><span class="line">               <span class="keyword">return</span> String.valueOf(partRedPackage);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 2. 抢完了</span></span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;errorCode: -1, 红包抢完了&quot;</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 3. 抢过了红包</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">myRedPackage</span> <span class="operator">=</span> (<span class="type">int</span>) redisTemplate.opsForHash().get(RED_PACKAGE_CONSUME_KEY + redPackageKey, userId);</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;errorCode: -2,  message:&quot;</span> + userId + <span class="string">&quot;\t  你已经抢过了红包，不能在抢了,你抢的金额是&quot;</span> + myRedPackage;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>拆红包—目标:将总金额拆分为n 个子红包</p>
<ul>
<li>使用 <code>2倍均值算法</code> 分配不同的红包金额</li>
</ul>
</li>
<li><p>发红包</p>
<ul>
<li>将红包存放到<code>list</code>中，并设置<code>过期时间</code></li>
<li>发完之后进行回显</li>
</ul>
</li>
<li>抢红包<ul>
<li>先验证用户是否抢过红包，就是 判断 get能不能取到值</li>
<li>取不到，就是没抢过红包，可以从<code>list</code>中取出来，并将用户id 和抢到的金额 存到 <code>hash</code>中</li>
<li>否则不能抢</li>
</ul>
</li>
</ul>
<p>批量删除</p>
<blockquote>
<p><code>redis-cli keys &quot;***&quot; | xargs redis-cli del</code>        <code>“***” 代表 key前缀</code></p>
</blockquote>
<hr>
<h2 id="Redis的最佳实践"><a href="#Redis的最佳实践" class="headerlink" title="Redis的最佳实践"></a>Redis的最佳实践</h2><p>键值设计</p>
<ul>
<li><p>优雅的key结构</p>
<ul>
<li><p>Redis的Key虽然可以自定义，但最好遵循下面的几个最佳实践约定：</p>
<ul>
<li>遵循基本格式：[业务名称]:[数据名]:[id]</li>
<li>长度不超过44字节</li>
<li>不包含特殊字符</li>
</ul>
</li>
<li><p>这样设计的好处：</p>
<ul>
<li>可读性强</li>
<li>避免key冲突</li>
<li>方便管理</li>
<li>更节省内存： key是string类型，底层编码包含int、embstr和raw三种。<ul>
<li>embstr在小于44字节使用，采用连续内存空间，内存占用更小。</li>
<li>当字节数大于44字节时，会转为raw模式存储，在raw模式下，内存空间不是连续的，而是采用一个指针指向了另外一段内存空间，在这段空间里存储SDS内容，这样空间不连续，访问的时候性能也就会收到影响，还有可能产生内存碎片</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>拒绝BigKey</p>
<ul>
<li>BigKey通常以Key的大小和Key中成员的数量来综合判定</li>
</ul>
<p>恰当的数据结构例题</p>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305272018632.png" alt="image-20230527201830448" style="zoom:33%;"></p>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305272019941.png" alt="image-20230527201908854" style="zoom:33%;"></p>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305272020140.png" alt="image-20230527202048068" style="zoom:33%;"></p>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202305272021214.png" alt="image-20230527202148144" style="zoom:33%;"></p>
<ul>
<li>Key的最佳实践<ul>
<li>固定格式：[业务名]:[数据名]:[id]</li>
<li>足够简短：不超过44字节</li>
<li>不包含特殊字符</li>
</ul>
</li>
<li>Value的最佳实践：<ul>
<li>合理的拆分数据，拒绝BigKey</li>
<li>选择合适数据结构</li>
<li>Hash结构的entry数量不要超过1000</li>
<li>设置合理的超时时间</li>
</ul>
</li>
</ul>
<h3 id="相关建议"><a href="#相关建议" class="headerlink" title="相关建议"></a>相关建议</h3><blockquote>
<p>持久化配置相关建议</p>
</blockquote>
<ul>
<li>用来做缓存的Redis实例尽量不要开启持久化功能</li>
<li>建议关闭RDB持久化功能，使用AOF持久化</li>
<li>利用脚本定期在slave节点做RDB，实现数据备份</li>
<li>设置合理的rewrite阈值，避免频繁的bgrewrite</li>
<li>配置no-appendfsync-on-rewrite = yes，禁止在rewrite期间做aof，避免因AOF引起的阻塞</li>
<li>部署有关建议：<ul>
<li>Redis实例的物理机要预留足够内存，应对fork和rewrite</li>
<li>单个Redis实例内存上限不要太大，例如4G或8G。可以加快fork的速度、减少主从同步、数据迁移压力</li>
<li>不要与CPU密集型应用部署在一起</li>
<li>不要与高硬盘负载应用一起部署。例如：数据库、消息队列</li>
</ul>
</li>
</ul>
<blockquote>
<p>慢查询优化 建议</p>
</blockquote>
<p>注意此处的慢查询指的是：  <font color="red">在Redis执行时耗时超过某个阈值的命令，称为慢查询</font></p>
<p>危害</p>
<ul>
<li>会导致大量请求阻塞，从而引起报错</li>
</ul>
<p>配置</p>
<ul>
<li><code>slowlog-log-slower-than：慢查询阈值，单位是微秒。默认是10000，建议1000</code></li>
<li><code>slowlog-max-len：慢查询日志（本质是一个队列）的长度。默认是128，建议1000</code></li>
</ul>
<p>查看慢查询</p>
<ul>
<li>slowlog len：查询慢查询日志长度</li>
<li>slowlog get [n]：读取n条慢查询日志</li>
<li>slowlog reset：清空慢查询列表</li>
</ul>
<h3 id="命令及安全配置"><a href="#命令及安全配置" class="headerlink" title="命令及安全配置"></a>命令及安全配置</h3><p>漏洞出现的核心的原因有以下几点：</p>
<ul>
<li>Redis未设置密码</li>
<li>利用了Redis的config set命令动态修改Redis配置</li>
<li>使用了Root账号权限启动Redis</li>
</ul>
<p>解决：</p>
<ul>
<li>Redis一定要设置密码</li>
<li>禁止线上使用下面命令：keys、flushall、flushdb、config set等命令。可以利用rename-command禁用。</li>
<li>bind：限制网卡，禁止外网网卡访问</li>
<li>开启防火墙</li>
<li>不要使用Root账户启动Redis</li>
<li>尽量不使用默认的端口</li>
</ul>
<h3 id="Redis内存划分和内存配置"><a href="#Redis内存划分和内存配置" class="headerlink" title="Redis内存划分和内存配置"></a>Redis内存划分和内存配置</h3><p>危害</p>
<ul>
<li>当Redis内存不足时，可能导致Key频繁被删除、响应时间变长、QPS不稳定等问题。当内存使用率达到90%以上时就需要我们警惕，并快速定位到内存占用的原因。</li>
</ul>
<p>碎片问题的产生：</p>
<ul>
<li>Redis底层分配并不是这个key有多大，他就会分配多大，而是有他自己的分配策略，比如8,16,20等等，假定当前key只需要10个字节，此时分配8肯定不够，那么他就会分配16个字节，多出来的6个字节就不能被使用，这就是我们常说的 碎片问题</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>内存占用</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>数据内存</td>
<td>是Redis最主要的部分，存储Redis的键值信息。主要问题是BigKey问题、内存碎片问题</td>
</tr>
<tr>
<td>进程内存</td>
<td>Redis主进程本身运⾏肯定需要占⽤内存，如代码、常量池等等；这部分内存⼤约⼏兆，在⼤多数⽣产环境中与Redis数据占⽤的内存相⽐可以忽略。</td>
</tr>
<tr>
<td>缓冲区内存</td>
<td>一般包括客户端缓冲区、AOF缓冲区、复制缓冲区等。客户端缓冲区又包括输入缓冲区和输出缓冲区两种。这部分内存占用波动较大，不当使用BigKey，可能导致内存溢出。</td>
</tr>
</tbody>
</table>
</div>
<p>查看到Redis目前的内存分配状态</p>
<ul>
<li>info memory：查看内存分配的情况</li>
<li>memory xxx：查看key的主要占用情况</li>
</ul>
<p>缓冲区内存常见的有三种：</p>
<ul>
<li>复制缓冲区：主从复制的repl_backlog_buf，如果太小可能导致频繁的全量复制，影响性能。通过replbacklog-size来设置，默认1mb</li>
<li>AOF缓冲区：AOF刷盘之前的缓存区域，AOF执行rewrite的缓冲区。无法设置容量上限</li>
<li><code>客户端缓冲区</code>：分为输入缓冲区和输出缓冲区，输入缓冲区最大1G且不能设置。输出缓冲区可以设置</li>
</ul>
<p>以上复制缓冲区和AOF缓冲区 不会有问题，最关键就是<code>客户端缓冲区</code>的问题</p>
<p>客户端缓冲区：指的就是我们发送命令时，客户端用来缓存命令的一个缓冲区，也就是我们向redis输入数据的输入端缓冲区和redis向客户端返回数据的响应缓存区，输入缓冲区最大1G且不能设置，所以这一块我们根本不用担心，如果超过了这个空间，redis会直接断开，因为本来此时此刻就代表着redis处理不过来了，我们需要担心的就是输出端缓冲区</p>
<p>在处理大量的big value，解决方案有两个</p>
<p>1、设置一个大小</p>
<p>2、增加我们带宽的大小，避免我们出现大量数据从而直接超过了redis的承受能力</p>
<h3 id="集群的一系列问题"><a href="#集群的一系列问题" class="headerlink" title="集群的一系列问题"></a>集群的一系列问题</h3><p>集群虽然具备高可用特性，能实现自动故障恢复，但是如果使用不当，也会存在一些问题：</p>
<ul>
<li>集群完整性问题</li>
<li>集群带宽问题</li>
<li>数据倾斜问题</li>
<li>客户端性能问题</li>
<li>命令的集群兼容性问题</li>
<li>lua和事务问题[<code>如果key不在一个节点，那么是无法保证lua的执行和事务的特性的，所以在集群模式是没有办法执行lua和事务的</code>]</li>
</ul>
<blockquote>
<p>单体Redis（主从Redis）已经能达到万级别的QPS，并且也具备很强的高可用特性。如果主从能满足业务需求的情况下，所以如果不是在万不得已的情况下，尽量不搭建Redis集群</p>
</blockquote>
<h3 id="redis的其他用法"><a href="#redis的其他用法" class="headerlink" title="redis的其他用法"></a>redis的其他用法</h3><ul>
<li><p>数据共享，分布式Session</p>
</li>
<li><p>分布式锁</p>
</li>
<li><p>全局ID</p>
</li>
<li><p>计算器、点赞</p>
</li>
<li><p>位统计</p>
</li>
<li><p>购物车</p>
</li>
<li><p>轻量级消息队列     list  &amp;   stream</p>
</li>
<li><p>抽奖</p>
</li>
<li><p>点赞、签到、打卡</p>
</li>
<li><p>交集差集并集，用户关注，可能认识的人</p>
</li>
<li><p>热点新闻、热搜排行</p>
</li>
</ul>
<blockquote>
<p>CAP 中</p>
<ul>
<li>redis <code>集群</code>是<code>AP</code>  redis <code>单机</code> 是 <code>C</code></li>
</ul>
</blockquote>
</和服务器数量有关>]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>算法的手记</title>
    <url>/post/7608.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h2 id="ACM题解注意"><a href="#ACM题解注意" class="headerlink" title="ACM题解注意"></a>ACM题解注意</h2><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scanner.nextLine();   整行读入</span><br><span class="line"> String[] s = str.split(<span class="string">&quot; &quot;</span>);    将读入的行按“ ”分割</span><br><span class="line"> Integer.parseInt(c);   将字符串c  转为  整数</span><br><span class="line"> System.out.println(String.join(<span class="string">&quot; &quot;</span>,s1));    在s1中加上空格</span><br><span class="line"></span><br><span class="line">Q:</span><br><span class="line"></span><br><span class="line">输入数据有多组, 每行表示一组输入数据。</span><br><span class="line">每行不定有n个整数，空格隔开。(<span class="number">1</span> &lt;= n &lt;= <span class="number">100</span>)。</span><br><span class="line">    </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A:</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">                <span class="type">String</span> <span class="variable">num</span> <span class="operator">=</span> scanner.nextLine();  <span class="comment">//Line</span></span><br><span class="line">                String[] s = num.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                <span class="keyword">for</span>(String c:s)&#123;</span><br><span class="line">                    sum += Integer.parseInt(c);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(sum);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Q:</span><br><span class="line">输入有两行，第一行n</span><br><span class="line">第二行是n个字符串，字符串之间用空格隔开</span><br><span class="line">    </span><br><span class="line"><span class="number">5</span></span><br><span class="line">c d a bb e</span><br><span class="line"></span><br><span class="line">a bb c d e</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A:</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        String s[] = <span class="keyword">new</span> <span class="title class_">String</span>[a];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a; i++) &#123;</span><br><span class="line">                <span class="type">String</span>  <span class="variable">num</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">                 s[i] = num;</span><br><span class="line">            &#125;</span><br><span class="line">            Arrays.sort(s);</span><br><span class="line">            <span class="keyword">for</span> (String c : s) &#123;</span><br><span class="line">                System.out.print(c+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Q:</span><br><span class="line">多个测试用例，每个测试用例一行。</span><br><span class="line">每行通过空格隔开，有n个字符，n＜<span class="number">100</span></span><br><span class="line">    </span><br><span class="line">a c bb</span><br><span class="line">f dddd</span><br><span class="line">nowcoder</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">a bb c</span><br><span class="line">dddd f</span><br><span class="line">nowcoder</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">A:</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            String[] s = str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            Arrays.sort(s);</span><br><span class="line">            System.out.println(String.join(<span class="string">&quot; &quot;</span>,s));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Q: 两数之和     输入有多组测试用例，每组空格隔开两个整数</span><br><span class="line"><span class="number">0</span>&lt;a,</span><br><span class="line">b&lt;<span class="number">2</span>×<span class="number">10</span>的<span class="number">10</span>次方</span><br><span class="line">     </span><br><span class="line">A:</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            String[] s = str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="type">int</span> n= s.length;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">                sum += Long.parseLong(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//res   转为   String数组</span></span><br><span class="line">String[] strings = res.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[res.size()]);</span><br></pre></td></tr></table></figure>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h4 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先创建HeroNode结点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HeroNode left;.<span class="comment">//默认null</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode right;<span class="comment">//默认null</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode</span><span class="params">(<span class="type">int</span> no,String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.no=no;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNo</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">getLeft</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(HeroNode left)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.left=left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> HeroNode getRightO&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(HeroNode right)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.right right;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode [no=&quot;</span>no <span class="string">&quot;name=&quot;</span>name <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);<span class="comment">//先输出父结点</span></span><br><span class="line">        <span class="comment">//递归向左子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left !<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归向右子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.right !=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.right.preOrderO;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//递归向左子树中序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left !<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出父结点</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//递归向右子树中序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.right !<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.right.infixOrderO;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left !<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.left.postOrderO);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.right !<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.right.postOrderO;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);<span class="comment">//先输出父结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="建树："><a href="#建树：" class="headerlink" title="建树："></a>建树：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一颗二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span>&#123;	</span><br><span class="line">    <span class="keyword">private</span> HeroNode root;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(HeroNode root)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.root=root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.root !=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.root.preOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.root !=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.root.infixOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.root !=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.root.postOrderO;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用树"><a href="#使用树" class="headerlink" title="使用树"></a>使用树</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">    <span class="comment">//先需要创建一颗二叉树</span></span><br><span class="line">    BinaryTree binaryTree <span class="keyword">new</span> <span class="title class_">BinaryTree</span>();</span><br><span class="line">    <span class="comment">//创建需要的结点</span></span><br><span class="line">    HeroNode root=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>,<span class="string">&quot;宋江&quot;</span>);</span><br><span class="line">    HeroNode node2=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>,<span class="string">&quot;吴用&quot;</span>);</span><br><span class="line">    HeroNode node<span class="number">.3</span>=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>,<span class="string">&quot;卢俊义&quot;</span>);</span><br><span class="line">    HeroNode node4=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>,<span class="string">&quot;林冲&quot;</span>);</span><br><span class="line">	HeroNode node5=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">5</span>,<span class="string">&quot;关胜&quot;</span>)；</span><br><span class="line">	<span class="comment">//我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树</span></span><br><span class="line">    root.setLeft(node2);</span><br><span class="line">    root.setRight(node3);</span><br><span class="line">    node3.setRight(node4);</span><br><span class="line">    node3.setLeft(node5);</span><br><span class="line">    binary Tree.setRoot(root);</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line">    System.out.printlne(<span class="string">&quot;前序遍历&quot;</span>);<span class="comment">//1,2,3,5,4</span></span><br><span class="line">    binaryTree.preOrder();</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line">    System.out.println(<span class="string">&quot;中序遍历&quot;</span>);</span><br><span class="line">    binaryTree.infixOrder();<span class="comment">//2,1,5,3,4</span></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line">    System.out.println(<span class="string">&quot;后序遍历&quot;</span>);</span><br><span class="line">    binaryTree.postOrder();<span class="comment">//2,5,4,3,1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="力扣解题时注意"><a href="#力扣解题时注意" class="headerlink" title="力扣解题时注意"></a>力扣解题时注意</h2><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h4 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h4><blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="type">boolean</span> <span class="title function_">isPrim</span><span class="params">(<span class="type">int</span> x)</span> &#123; <span class="comment">/* 质数判断 */</span></span><br><span class="line">  <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= Math.sqrt(x); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a>回文数</h4><blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(x&lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> x;</span><br><span class="line">  <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(tmp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">last_num</span> <span class="operator">=</span> tmp%<span class="number">10</span>;</span><br><span class="line">      tmp = tmp/<span class="number">10</span>;</span><br><span class="line">      y= y * <span class="number">10</span> + last_num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> y == x;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="lt-递归-gt-三步分析法"><a href="#lt-递归-gt-三步分析法" class="headerlink" title="&lt;递归&gt;三步分析法"></a>&lt;递归&gt;三步分析法</h3><h5 id="确定递归函数的参数和返回值："><a href="#确定递归函数的参数和返回值：" class="headerlink" title="确定递归函数的参数和返回值："></a><strong>确定递归函数的参数和返回值：</strong></h5><p>确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</p>
<blockquote>
<p>二叉树的参数一般都是   ==根节点  +   数组== （存放遍历的元素）</p>
</blockquote>
<h5 id="确定终止条件："><a href="#确定终止条件：" class="headerlink" title="确定终止条件："></a><strong>确定终止条件：</strong></h5><p>写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</p>
<h5 id="确定单层递归的逻辑："><a href="#确定单层递归的逻辑：" class="headerlink" title="确定单层递归的逻辑："></a><strong>确定单层递归的逻辑：</strong></h5><p>确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</p>
<h3 id="纲领："><a href="#纲领：" class="headerlink" title="纲领："></a>纲领：</h3><p>两种思维：&lt;都是递归&gt;</p>
<ul>
<li>遍历—— 回溯   使用 <strong>traverse函数</strong> 的遍历递归      traverse + 外部变量</li>
<li>分解问题——dp/分治   使用<strong>非traverse函数</strong> 递归       函数 + 返回值</li>
</ul>
<p>二叉树<strong>遍历框架</strong>都是 递归 的</p>
<p>三个特殊时间点</p>
<blockquote>
<p>前序位置的代码在==刚刚进入==一个二叉树节点的时候执行</p>
<blockquote>
<p><strong>前序位置的代码 只能 从函数参数中获取父节点传递来的数据</strong></p>
</blockquote>
<p>后序位置的代码在==将要离开==一个二叉树节点的时候执行</p>
<blockquote>
<p><strong>后序位置的代码  不仅  可以获取参数数据，还可以  获取到子树通过函数返回值传递回来的数据</strong></p>
</blockquote>
<p>中序位置的代码在一个二叉树节点左子树都遍历完，==即将开始==遍历右子树的时候执行</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">104</span> 最大深度和</span><br><span class="line"><span class="comment">// 递归，分解子问题最为简单 </span></span><br><span class="line">    </span><br><span class="line">----子问题    <span class="number">1</span>、因为需要 左右函数的递归值，所以要在递归时进行变量赋值 (不一定有)  （此处有） <span class="type">int</span> XX= XXmethod();</span><br><span class="line">			 <span class="number">2</span>、所有利用子问题求解的函数经过多次递归最终会得到答案，所以直接就都视为  已经得出答案的函数，这样在调动用的时候就不用想太多</span><br><span class="line">    <span class="comment">//求深度所以结果加1</span></span><br><span class="line">    </span><br><span class="line"><span class="number">144</span> 前序遍历</span><br><span class="line"><span class="comment">// traverse 函数不会有问题，在前序遍历的位置上有add操作</span></span><br><span class="line">    </span><br><span class="line"><span class="number">543</span> 直径</span><br><span class="line">    <span class="comment">// 利用104求深度的函数，104结果未+1时，所求的就是所谓的直径，所以在这时候直接求和进行对比替换</span></span><br><span class="line"></span><br><span class="line"> ----子问题    <span class="number">1</span>、因为需要 左右函数的递归值，所以要在递归时进行变量赋值 (不一定有)  （此处有） <span class="type">int</span> XX= XXmethod();</span><br><span class="line">			 <span class="number">2</span>、所有利用子问题求解的函数经过多次递归最终会得到答案，所以直接就都视为  已经得出答案的函数，这样在调动用的时候就不用想太多</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 分解子问题的时候要进行比较，</span></span><br><span class="line">    也就是说</span><br><span class="line">    	要求直径必先求深度，因为就单边而言 直径的距离是小于深度的</span><br><span class="line">    此处就是在求深度的时候加上了两行代码</span><br><span class="line">    	<span class="comment">// 求直径</span></span><br><span class="line">    	<span class="type">int</span> <span class="variable">lfsum</span> <span class="operator">=</span>  leftdepth+rightdepth;</span><br><span class="line">        <span class="comment">// 计算左右之和最大值并进行替换结果值</span></span><br><span class="line">        maxdis = Math.max(lfsum,maxdis);</span><br><span class="line">		其中leftdepth 和 rightdepth的大小就是由调用自己的深度而来</span><br><span class="line">         但是这个+<span class="number">1</span>才是深度，此处没有在最终结果中 +<span class="number">1</span> ，所以就是直径，直径之和  和  maxdis 比较得到结果，随后递归即可 </span><br></pre></td></tr></table></figure>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="number">226</span> 反转二叉树  </span><br><span class="line">----子问题    <span class="number">1</span>、因为需要 左右函数的递归值，所以要在递归时进行变量赋值   (不一定有)  （此处有）</span><br><span class="line">			 <span class="number">2</span>、所有利用子问题求解的函数经过多次递归最终会得到答案，所以直接就都视为  已经得出答案的函数，这样在调动用的时候就不用想太多   </span><br><span class="line">   	<span class="comment">//这里也是，子问题视为已经将所有子树进好了反转，现在需要对 root 进行翻转就可以了，所以就是</span></span><br><span class="line">        root.right = leftnode;  </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"><span class="comment">// 但是这里调换显然是要用到左右子树 调换的 结果 才能进行左右子树调换，所以也要对递归函数进行赋值才能调用    需要  利用子问题的返回值</span></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="number">116</span> 填充节点的右侧指针 </span><br><span class="line">    </span><br><span class="line">        <span class="comment">//该判空就判空，改为 三叉树 </span></span><br><span class="line">        <span class="comment">// 使用next进行连接</span></span><br><span class="line">        <span class="comment">// 直接就是一个遍历，traverse </span></span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">   </span><br><span class="line">   <span class="number">114</span> 二叉树展开为链表</span><br><span class="line">----子问题    <span class="number">1</span>、因为需要 左右函数的递归值，所以要在递归时进行变量赋值 (不一定有)  【不可赋值】</span><br><span class="line">			 <span class="number">2</span>、所有利用子问题求解的函数经过多次递归最终会得到答案，所以直接就都视为  已经得出答案的函数，这样在调动用的时候就不用想太多   </span><br><span class="line">       在这里的给定函数 <span class="keyword">void</span>  <span class="title function_">flatten</span><span class="params">()</span>&#123;&#125;  就是经过拉直之后得到的结果，所以皆可以直接将其视为最终结果，</span><br><span class="line">       在root.left   root.right  之后就可以直接对 根节点 进行模拟合并操作，其对于所有的其他节点一样适用，但是函数返回值是  <span class="keyword">void</span> 所以不可以赋值   只能另外 赋值给临时变量，值为对 root.left，root.right 之后就可以直接在   root.left，root.right   进行操作了</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">     </span><br><span class="line">       注意：子问题和源问题的思路 目标 是一样的 ，甚至结果也只是缩小化原问题的结果</span><br><span class="line">        		<span class="comment">// 所以可以直接对得到子问题的结果进行操作，交换，重排序等等</span></span><br><span class="line">      	<span class="comment">// 就像是这里，子问题的结果 是将 左右子树的 结果拉成一条链， 原问题是将所有节点拉成一条链</span></span><br><span class="line">		<span class="comment">// 所以当然就直接对两个子结果及操作就可以了，左边移动过去，右边的结果接到左边最后的位置</span></span><br><span class="line">        <span class="comment">// 别忘了要对树的 左边置 null </span></span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<h3 id="构造问题"><a href="#构造问题" class="headerlink" title="构造问题"></a>构造问题</h3><p><strong>构造整棵树 = 根节点 + 构造左子树 + 构造右子树</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">654</span> 由数组构造最大二叉树</span><br><span class="line">----子问题    <span class="number">1</span>、因为需要 左右函数的递归值，所以要在递归时进行变量赋值 (不一定有)  【赋值】</span><br><span class="line">			 <span class="number">2</span>、所有利用子问题求解的函数经过多次递归最终会得到答案，所以直接就都视为  已经得出答案的函数，这样在调动用的时候就不用想太多  </span><br><span class="line">     </span><br><span class="line"> 思考<span class="number">1</span>--自己构建函数需要的参数？   已知的只有数组   那就是  nums 数组的起始坐标</span><br><span class="line">	如此一来，就可以不断地递归从而缩小数组的大小，就能够构建出值</span><br><span class="line">   给定函数：TreeNode constructMaximumBinaryTree  ，所以设置的函数也是 TreeNode 返回值类型的</span><br><span class="line">     <span class="comment">//找到根节点    </span></span><br><span class="line">     此处就是maxVal 辅助变量  Integer.MIN_VALUE,对数组循环比较得到根节点值，并由此值 构建出树。</span><br><span class="line">思考<span class="number">2</span>---   <span class="comment">//构造左子树，右子树   // 显然是两个遍历。  重点就是 填参数-----起始坐标 就是取得最大值时遍历的数组下标  所以还需要对数组下标 设置对应变量   进行返回</span></span><br><span class="line">思考<span class="number">1</span>-    显然方法要有返回值的，这里的返回值就是 TreeNode 型的 ，而且再结果返回的还是 root&lt;自定义的树的变量&gt;   所以便利的时候返回值就设置为  .left   .right </span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">     -- 下面三题考虑 子问题的 思路与这里近乎一致只是在细节上有优化   【下面三个全赋值】</span><br><span class="line">     优化一： HashMap&lt;Integer, Integer&gt; inmap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">             <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">                        inmap.put(inorder[i], i);</span><br><span class="line">                    &#125;</span><br><span class="line">				双数组， hashMap 便于取下标值 （所以put的时候  k:数组的值， v:下标）</span><br><span class="line">      区别：上面的是找max    下面的是努力找根节点。</span><br><span class="line">                    </span><br><span class="line">      下面流程都是近乎一致的：</span><br><span class="line">                    <span class="comment">// 这里找根节点的值和位置   注意这两个操作 是要在两个数组中进行的</span></span><br><span class="line">        --注意 <span class="number">889</span>  这里是有些区别，这里的根节点值很好确定，所以并不能由此获得位置，需要再在先序遍历中找到左边的第一个节点，根左右  ，第一个就是根，在后序中，左右根，根恰好就是分隔点，所以应该找 preorder 里面的左子树的根，然后去 postorder 中找位置， 反之，从postorder 找值 preorder 中找位置  是无法得到左子树准备的数量的</span><br><span class="line">                    <span class="comment">// 左子树长度</span></span><br><span class="line">                    <span class="comment">// new 一棵树 root（根据根节点的值）</span></span><br><span class="line">                    <span class="comment">// 递归      --  也要赋值的</span></span><br><span class="line">                    <span class="comment">//return       root</span></span><br><span class="line">                    </span><br><span class="line">            除此之外就是细节问题，递归时索引的值，左子树长度  需要格外注意 </span><br><span class="line"><span class="number">105</span> 通过前序和中序遍历结果构造二叉树</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">        </span><br><span class="line"><span class="number">106</span> 通过后序和中序遍历结果构造二叉树</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"><span class="number">889</span> 通过后序和前序遍历结果构造二叉树（**）</span><br><span class="line">    </span><br><span class="line">     </span><br><span class="line">     </span><br></pre></td></tr></table></figure>
<h3 id="BST"><a href="#BST" class="headerlink" title="BST"></a>BST</h3><p>二叉搜索树「中序遍历有序」</p>
<p>BST 相关的问题</p>
<p>​    要么利用 BST 左小右大的特性提升算法效率</p>
<p>​    要么利用中序遍历的特性满足题目的要求</p>
<ul>
<li><p>如果当前节点会对下面的子节点有整体影响，可以通过辅助函数增长参数列表，借助参数传递信息。</p>
</li>
<li><p>通过使用辅助函数，增加函数参数列表，在参数中携带额外信息，将这种约束传递给子树的所有节点，这也是二叉树算法的一个小技巧吧。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  利用中序排序的特点， 有序的 ，所以大部分代码应该写在中序位置上的</span><br><span class="line"></span><br><span class="line"><span class="number">230</span> 「 二叉搜索树中第 K 小的元素」 -- 显然是要排序的 </span><br><span class="line">      </span><br><span class="line"> traverser函数 ，在中序位置上进行检索就OK了  </span><br><span class="line">    </span><br><span class="line"><span class="number">538</span>   <span class="number">1038</span>  BST 转化累加树</span><br><span class="line">    </span><br><span class="line">traverser函数 ，对逆序的序列进行加值赋值操作   还是在中序位置上进行操作 就OK了  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">BST 框架</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">BST</span><span class="params">(TreeNode root, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root.val == target)</span><br><span class="line">        <span class="comment">// 找到目标，做点什么</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; target) </span><br><span class="line">        BST(root.right, target);</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; target)</span><br><span class="line">        BST(root.left, target);</span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line"><span class="number">700</span>   搜索子树</span><br><span class="line"> ---子问题：  <span class="number">1</span>、因为需要 左右函数的递归值，所以要在递归时进行变量赋值 (不一定有)  【赋值】</span><br><span class="line">			 <span class="number">2</span>、所有利用子问题求解的函数经过多次递归最终会得到答案，所以直接就都视为  已经得出答案的函数，这样在调动用的时候就不用想太多  </span><br><span class="line">    返回值： TreeNode   ，要赋值  利用bst 模版  直接将分类的搜索遍历结果<span class="comment">/**视为最终结果 */</span>返回（也可以赋值，返回赋值的值）</span><br><span class="line">    </span><br><span class="line">      </span><br><span class="line"><span class="number">701</span>  插入操作。</span><br><span class="line">      同理 </span><br><span class="line"> ---子问题：  <span class="number">1</span>、因为需要 左右函数的递归值，所以要在递归时进行变量赋值 (不一定有)  【赋值】</span><br><span class="line">			 <span class="number">2</span>、所有利用子问题求解的函数经过多次递归最终会得到答案，所以直接就都视为  已经得出答案的函数，这样在调动用的时候就不用想太多  </span><br><span class="line">    返回值： TreeNode   ，要赋值  利用bst 模版、</span><br><span class="line">    但是这是不能直接返回，此时的左右子树只是一棵树的一部分，要得到最终完好的树，还是需要进行赋值给 root.left  root.right 的，最后 <span class="keyword">return</span> root  这样就能直接得到一棵插好元素的树了</span><br><span class="line">    </span><br><span class="line"><span class="number">450</span> 删除</span><br><span class="line"> ---子问题：  <span class="number">1</span>、因为需要 左右函数的递归值，所以要在递归时进行变量赋值 (不一定有)  【赋值】</span><br><span class="line">			 <span class="number">2</span>、所有利用子问题求解的函数经过多次递归最终会得到答案，所以直接就都视为  已经得出答案的函数，这样在调动用的时候就不用想太多  </span><br><span class="line">    返回值： TreeNode   ，要赋值  还是要利用bst 模版</span><br><span class="line">      同样：但是这是不能直接返回，此时的左右子树只是一棵树的一部分，要得到最终完好的树，还是需要进行赋值给 root.left  root.right 的，最后 <span class="keyword">return</span> root  这样就能直接得到一棵 删完 元素的树了</span><br><span class="line">      但是区别是：</span><br><span class="line">      与搜索插入不同的是：这里的删除是要分类讨论的，root.val == val 时分三种情况讨论，其中讨论的时候还是会进行调用的   ---- 可以细品</span><br><span class="line">      </span><br><span class="line">      另外还调用了 最小值得函数（非递归） </span><br><span class="line">      </span><br><span class="line">    </span><br><span class="line"><span class="number">98</span> 判定</span><br><span class="line">      通过 <span class="number">450</span> 给予的启发  直接定义最大 最小函数，由此获得左子树的最根节点，右子树的最左根节点  随后对给定函数进行判定 </span><br><span class="line">    	判定条件就是左非空就要左小根  右非空就要右大根《这里的左右根节点的值 就是通过上述函数 .val 获得的》 否则<span class="literal">false</span>;   = 也是<span class="literal">false</span></span><br><span class="line">      <span class="type">boolean</span> 可以赋值也可以直接返回。</span><br><span class="line">      </span><br><span class="line">    </span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>1、<strong>子问题（后面这部分链表）和原问题（整条链表）的结构完全相同，这就是所谓的递归性质</strong></p>
<p>2、<strong>递归函数都有个 base case</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">206</span>     反转链表</span><br><span class="line">    </span><br><span class="line">    就用<span class="keyword">while</span>循环写</span><br><span class="line">    ListNode pre,cur,nxt;</span><br><span class="line">          pre = <span class="literal">null</span>;</span><br><span class="line">          cur = nxt = head;</span><br><span class="line">             <span class="keyword">while</span>(cur!= <span class="literal">null</span>)&#123;</span><br><span class="line">                 nxt = cur.next;</span><br><span class="line">                 cur.next = pre;</span><br><span class="line">                  pre = cur;</span><br><span class="line">                  cur = nxt;              </span><br><span class="line">             &#125;</span><br><span class="line">	<span class="keyword">return</span> pre ;</span><br><span class="line">    </span><br><span class="line"><span class="number">92</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//206 92  递归的区别：  1 basecase  前者：if (head == null || head.next == null) &#123;return head;&#125;  </span></span><br><span class="line">							<span class="comment">//后者：base case 变为 n == 1，反转一个元素，就是它本身，同时要记录后驱节点。</span></span><br><span class="line">    				<span class="comment">//2、前者不要链接未反转的点， 直接把 head.next 设置为 null</span></span><br><span class="line">    				<span class="comment">//   后者需要  要记录后驱 successor（第 n + 1 个节点），反转之后将 head 连接上。</span></span><br><span class="line"><span class="number">1</span>、当  left =<span class="number">1</span> 时要分开讨论。</span><br><span class="line">    <span class="keyword">while</span> 循环</span><br><span class="line">   ListNode <span class="title function_">reverse</span><span class="params">(ListNode head, <span class="type">int</span> right)</span>&#123;   <span class="comment">// 这里给的是第几个接点</span></span><br><span class="line">        ListNode pre,cur,b,nxt;</span><br><span class="line">        b=cur = nxt= head;</span><br><span class="line">        pre = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//得到第right个节点的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i&lt;right;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(b == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">            b = b.next;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">while</span>(cur != b)&#123;</span><br><span class="line">            nxt = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 头指针指向尾部</span></span><br><span class="line">        head.next = b;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、 left != <span class="number">1</span> 时就进行递归</span><br><span class="line">  		<span class="comment">// 开始递归</span></span><br><span class="line">       a.next = reverseBetween(head.next,left-<span class="number">1</span>,right-<span class="number">1</span>);   </span><br><span class="line">			<span class="comment">// 这里的a.next 就是将 进行将指针进行翻转遍历的</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line">    每 k 个节点一组进行翻转</span><br><span class="line">                </span><br><span class="line">    <span class="number">1</span>、找到对应的节点</span><br><span class="line">                 ListNode a,  b;  </span><br><span class="line">          a =b = head;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ;i&lt;k;i++)&#123;</span><br><span class="line">              <span class="keyword">if</span>( b == <span class="literal">null</span>)  <span class="keyword">return</span> head;</span><br><span class="line">              b=b.next;</span><br><span class="line">          &#125;</span><br><span class="line">      </span><br><span class="line">	<span class="number">2</span>、还是调用 <span class="keyword">while</span>  循环进行遍历 此时遍历得到对应的节点，下进行稍微改动</span><br><span class="line">         ListNode <span class="title function_">reverse</span><span class="params">(ListNode head,ListNode node)</span> &#123;</span><br><span class="line">            ListNode pre=node,nxt=head,cur=head;</span><br><span class="line">            <span class="keyword">while</span>(cur != node)&#123;</span><br><span class="line">                nxt = cur.next;</span><br><span class="line">                cur.next = pre;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = nxt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pre;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="number">3</span>、  </span><br><span class="line">         <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> reverse(a,b);  <span class="comment">// 先反转从头开始的前面几个节点</span></span><br><span class="line">			<span class="comment">//再进行下面的递归,每次递归就又是上一次的b为头，开始新的一轮递归 并将a.next (head的下一个 指向新的反转链表的指针)</span></span><br><span class="line">		<span class="comment">//此处的 a.next 很关键。a此时是将 头结点指向下一个要反转的头节点</span></span><br><span class="line">         a.next = reverseKGroup(b, k); </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//其实这里的1 2 两步骤  和上一问的while 循环其实是一样的  ，可以随意替换</span></span><br><span class="line">    </span><br><span class="line"><span class="number">234</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//首先先找到中点，然后将中间点开始将后面的字符串进行翻转最后进行比较、</span></span><br><span class="line">    找中间节点      双指针</span><br><span class="line">    反转：   <span class="keyword">while</span> 循环</span><br><span class="line">    比较    指针向中间移动</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h4 id="回文串"><a href="#回文串" class="headerlink" title="回文串"></a>回文串</h4><blockquote>
<p>==中心扩展法：==</p>
<p>实质的思路和动态规划的思路类似。</p>
<ul>
<li>比如对一个字符串<code>ababa</code>，选择最中间的 <code>a</code>作为<code>中心点</code>，往两边扩散，</li>
<li>第一次扩散发现 left 指向的是 b，right 指向的也是 b，所以是回文串，继续扩散，同理 ababa 也是回文串。</li>
</ul>
<p>这个是确定了一个中心点后的寻找的路径，然后我们<code>只要寻找到所有的中心点，问题就解决了</code>。</p>
<ul>
<li>中心点一共有多少个呢？</li>
<li>看起来像是和字符串长度相等，但你会发现，如果是这样，上面的例子永远也搜不到 abab，<ul>
<li>想象一下单个字符的哪个中心点扩展可以得到这个子串？似乎不可能。</li>
</ul>
</li>
<li>所以中心点不能只有单个字符构成，还要包括两个字符，<ul>
<li>比如上面这个子串 abab，就可以有中心点 ba 扩展一次得到，所以最终的中心点由<code>2 * len - 1</code> 个，分别是 <code>len 个单字符</code>和 <code>len - 1 个双字符</code>。</li>
</ul>
</li>
</ul>
<p>如果上面看不太懂的话，还可以看看下面几个问题：</p>
<ul>
<li>为什么有 2 * len - 1 个中心点？</li>
<li>aba 有5个中心点，分别是 a、b、c、ab、ba</li>
<li><p>abba 有7个中心点，分别是 a、b、b、a、ab、bb、ba</p>
</li>
<li><p>什么是中心点？</p>
</li>
<li>中心点即 left 指针和 right 指针初始化指向的地方，可能是一个也可能是两个</li>
<li>为什么不可能是三个或者更多？<br>因为 3 个可以由 1 个扩展一次得到，4 个可以由 2 个扩展一次得到</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">//5  最长回文子串</span></span><br><span class="line"></span><br><span class="line">&gt;String res= <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">         String oddString= substr(s,i,i);</span><br><span class="line">         <span class="type">String</span> <span class="variable">evenString</span> <span class="operator">=</span> substr(s,i,i+<span class="number">1</span>);</span><br><span class="line">         res = res.length()&lt;oddString.length() ? oddString:res;</span><br><span class="line">         res = res.length()&lt;evenString.length()? evenString:res;</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="keyword">return</span>  res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//      回文串        左边中点   右边中点</span></span><br><span class="line">  <span class="keyword">private</span> String <span class="title function_">substr</span><span class="params">(String s, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; j&lt;s.length() &amp;&amp; s.charAt(i)==s.charAt(j))&#123;</span><br><span class="line">          i--;</span><br><span class="line">          j++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//因为上面已经 ++  -- 过了</span></span><br><span class="line">      <span class="keyword">return</span> s.substring(i+<span class="number">1</span>,j);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 647 回文子串   </span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">          count += substr(s,i,i);</span><br><span class="line">          count += substr(s,i,i+<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line">              <span class="comment">//      回文串      左边中点  右边中点</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">substr</span><span class="params">(String s, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">      <span class="type">int</span> res= <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; j&lt;s.length() &amp;&amp; s.charAt(i)==s.charAt(j))&#123;</span><br><span class="line">         <span class="comment">// System.out.println(s.substring(i,j+1));</span></span><br><span class="line">          i--;</span><br><span class="line">          j++;</span><br><span class="line">          res++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>推荐还是中心扩散法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;DP 的写法</span><br><span class="line">&gt;<span class="comment">//5</span></span><br><span class="line">&gt;<span class="comment">//动态规划</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">      <span class="comment">//特殊情况  ,空串  就返回空</span></span><br><span class="line">      <span class="keyword">if</span> (s == <span class="literal">null</span> || length == <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="keyword">if</span> (length == <span class="number">1</span>)</span><br><span class="line">          <span class="keyword">return</span> s;</span><br><span class="line">      <span class="comment">//定义下列变量，分别表示开始位置 结束位置 的变量 以及 最大长度。</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>, end = <span class="number">0</span>,subLen = <span class="number">1</span>;</span><br><span class="line">      <span class="comment">//定义动态二维数组</span></span><br><span class="line">      <span class="type">boolean</span> [][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[length][length];</span><br><span class="line"></span><br><span class="line">      <span class="comment">//动态规划的数组是从列开始填写表格的</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length()-<span class="number">1</span>; i &gt;=<span class="number">0</span> ; i--) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; s.length(); j++) &#123;</span><br><span class="line">              <span class="keyword">if</span> (s.charAt(i)==s.charAt(j)  &amp;&amp; (j-i &lt;= <span class="number">2</span> || dp[i+<span class="number">1</span>][j-<span class="number">1</span>]))&#123;</span><br><span class="line">                 dp[i][j] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">if</span>(j-i+<span class="number">1</span>&gt; subLen)&#123;</span><br><span class="line">                  subLen = j-i+<span class="number">1</span>;</span><br><span class="line">                  begin = i;</span><br><span class="line">                 &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//返回子串的，开始位置以及结束位置</span></span><br><span class="line">      <span class="keyword">return</span> s.substring(begin,begin+subLen);</span><br><span class="line">  &#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 647   </span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">      <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">      <span class="comment">//dp[][]</span></span><br><span class="line">      <span class="type">boolean</span> dp[][] = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length()][s.length()];</span><br><span class="line">      <span class="comment">//递推公式s[i] ==s[j] ①j-i=0  ②j-i=1 ③dp[i+1][j-1]    VS  s[i] !=s[j]</span></span><br><span class="line">      <span class="comment">//初始化dp[][]</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">          dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//遍历顺序</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length()-<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; s.length(); j++) &#123;</span><br><span class="line">              <span class="keyword">if</span>(s.charAt(j) == s.charAt(i) &amp;&amp; (j-i&lt;<span class="number">2</span> || dp[i+<span class="number">1</span>][j-<span class="number">1</span>]))&#123;      <span class="comment">// j-i&lt;2 必须要写在前面</span></span><br><span class="line">                      res++;</span><br><span class="line">                      dp[i][j] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">      <span class="comment">//打印dp数组</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="一般串"><a href="#一般串" class="headerlink" title="一般串"></a>一般串</h4><blockquote>
<p>43 : 给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">&gt;<span class="keyword">public</span> String <span class="title function_">multiply</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="string">&quot;0&quot;</span>.equals(num1) || <span class="string">&quot;0&quot;</span>.equals(num2)) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">  <span class="comment">//结果集的接收</span></span><br><span class="line">  <span class="type">int</span> res[]=<span class="keyword">new</span> <span class="title class_">int</span>[num1.length()+num2.length()];</span><br><span class="line">  <span class="comment">//从最低位开始相乘， -&#x27;0&#x27;是 Char字符 转为数字的方式</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> num1.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">t1</span> <span class="operator">=</span>  num1.charAt(i)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> num2.length()-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">t2</span> <span class="operator">=</span> num2.charAt(j)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">           <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> res[i+j+<span class="number">1</span>]+t1*t2;</span><br><span class="line">           <span class="comment">// 低位是取余的结果</span></span><br><span class="line">           res[i+j+<span class="number">1</span>] = sum % <span class="number">10</span>;</span><br><span class="line">           <span class="comment">// 高位进行 取模</span></span><br><span class="line">          res[i+j] += sum / <span class="number">10</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">   <span class="comment">// 去除前面几位的0</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.length;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(i==<span class="number">0</span> &amp;&amp; res[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">      stringBuilder.append(res[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="数字与串"><a href="#数字与串" class="headerlink" title="数字与串"></a>数字与串</h4><blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;8264&quot;</span>;</span><br><span class="line">&gt;<span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">&gt;<span class="comment">// 将字符转化成数字</span></span><br><span class="line">&gt;number = <span class="number">10</span> * number + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&gt;print(number);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// 打印输出：</span></span><br><span class="line">&gt;<span class="comment">// 8</span></span><br><span class="line">&gt;<span class="comment">// 82</span></span><br><span class="line">&gt;<span class="comment">// 826</span></span><br><span class="line">&gt;<span class="comment">// 8264</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="双指针对链表"><a href="#双指针对链表" class="headerlink" title="双指针对链表:"></a>双指针对链表:</h2><h4 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h4><p>技巧一</p>
<ul>
<li><p>合并分解双指针</p>
<ul>
<li><p>当你需要创造一条新链表的时候，可以使用虚拟头结点简化边界情况的处理、防止空指针的的情况</p>
</li>
<li><p>让你把两条有序链表合并成一条新的有序链表（合并两个有序链表）、把一条链表分解成两条链表时(单链表分解)</p>
</li>
</ul>
</li>
</ul>
<p>技巧二：快慢指针</p>
<ul>
<li><p>一条链表的间隔双指针（找到倒数第K个节点，删除第n个节点）</p>
</li>
<li><p>n倍速快慢指针（中间节点 是否有换  是否是环  环的交点在哪   是否相交  ）</p>
</li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">23</span> 合并多个升序列表&lt;难题&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">            <span class="comment">//难题：</span></span><br><span class="line">        <span class="keyword">if</span>(lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span>  <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> list;</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(</span><br><span class="line">            lists.length,</span><br><span class="line">            (a,b)-&gt;(a.val-b.val)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(ListNode list1:lists)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1!=<span class="literal">null</span>)&#123;</span><br><span class="line">                pq.add(list1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">            p.next = node;</span><br><span class="line">            <span class="keyword">if</span>(node.next != <span class="literal">null</span>)&#123;</span><br><span class="line">                pq.add(node.next);</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="大致核心模块"><a href="#大致核心模块" class="headerlink" title="大致核心模块"></a>大致核心模块</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义双指针</span></span><br><span class="line"><span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line"><span class="comment">// 一者</span></span><br><span class="line"><span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span> )&#123;</span><br><span class="line">   fast = fast.next.next;</span><br><span class="line">   slow = slow.next;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 再者</span></span><br><span class="line">	<span class="keyword">while</span>( q!=<span class="literal">null</span>)&#123;       <span class="comment">//while(p1!= null &amp;&amp; p2 != null)</span></span><br><span class="line">           <span class="keyword">if</span>(q.val &lt; x)&#123;</span><br><span class="line">               s.next = q;</span><br><span class="line">               s= s.next;              </span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               b.next = q;</span><br><span class="line">               b=b.next;</span><br><span class="line">           &#125; </span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快慢指针 链表</span></span><br><span class="line"></span><br><span class="line"><span class="number">141</span> 链表是否有环</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回值 boolean</span></span><br><span class="line">    <span class="comment">// 定义快慢指针,初始值为head; ---唯二的变量</span></span><br><span class="line">    <span class="comment">//  while(fast != null &amp;&amp; fast.next != null  &amp;&amp; fast.next.next != null)循环条件</span></span><br><span class="line">    </span><br><span class="line"><span class="number">142</span> 环的节点在哪</span><br><span class="line">    <span class="comment">// 返回值 ListNode</span></span><br><span class="line">    <span class="comment">// 定义快慢指针,初始值为head; ---唯二的变量</span></span><br><span class="line">    <span class="comment">//  while(fast != null &amp;&amp; fast.next != null  &amp;&amp; fast.next.next != null)循环条件1 </span></span><br><span class="line">    <span class="comment">// 单独判断一下 if(fast == null || fast.next == null) return null;</span></span><br><span class="line">    <span class="comment">// 慢指针从头开始，再一次  while(slow != fast) 循环</span></span><br><span class="line"><span class="number">876</span> 找中间点</span><br><span class="line">    <span class="comment">//// 返回值 ListNode</span></span><br><span class="line">    <span class="comment">// 定义快慢指针,初始值为head; ---唯二的变量</span></span><br><span class="line">    <span class="comment">//  while(fast != null &amp;&amp; fast.next != null)循环条件</span></span><br><span class="line">    </span><br><span class="line">---- 上面的 三题均是在 循环条件一 中进行  fast = fast.next.next;  slow = slow.next; 操作  其他操作是细致末节的变化</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="number">160</span> 两个链表相交的点</span><br><span class="line">    <span class="comment">// 两个链表，所以要有两个指针   ---唯二的变量</span></span><br><span class="line">    <span class="comment">// 两个链表长短不一，依次一次遍历，重合即为交点</span></span><br><span class="line">    <span class="comment">//循环条件 while(p1 != p2)</span></span><br><span class="line">    </span><br><span class="line">---  创建虚拟链表头结点</span><br><span class="line"></span><br><span class="line"><span class="number">19</span> 删除倒数第n个节点</span><br><span class="line">    <span class="comment">//创建辅助链表,虚拟链表头结点demo （-1）     一个变量 </span></span><br><span class="line">    <span class="comment">//demo.next =head;</span></span><br><span class="line">    <span class="comment">//调用找第k个元素的方法找到第len-n+1个元素  传的参数就要是 定义的虚链表</span></span><br><span class="line">    	<span class="comment">//定义快慢指针  ---唯二的变量</span></span><br><span class="line">    	<span class="comment">//for(int i=1;i&lt;k;i++)   fast 先跑的间隔</span></span><br><span class="line">    	<span class="comment">//循环条件 while(fast.next != null)</span></span><br><span class="line"> 	<span class="comment">// 删除找到节点的下一个节点</span></span><br><span class="line">	<span class="comment">// demo 全程不参加工作，只有在创建的时候指向原链表，所以输出的返回值就是：demo.next</span></span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line"><span class="number">86</span> 分隔链表</span><br><span class="line">    <span class="comment">// 一分为2   2个虚拟链表头结点  small  big   原链表还是用head   换做变量 p对原链表操作  进行获取      --- 3 变量 + 1 临时变量</span></span><br><span class="line">    <span class="comment">//虚拟节点不参与工作，所以对这两个表头结点再次进行创建对应的 操作节点 s b</span></span><br><span class="line">    <span class="comment">//循环条件中  while( q!=null)    q 置为head,表示让q对该链表进行循环获取      --  只比较当前值</span></span><br><span class="line">    		<span class="comment">//中比较大小，小的进 s ，s继续后移    大的进 b   b继续后移    </span></span><br><span class="line">    		<span class="comment">//重点:断开原链表中的每个节点的 next 指针,否则会成环	</span></span><br><span class="line">    			<span class="comment">// ----- 怎么断 --&gt;  临时变量存储p 当前值p.next      p置为 null      p进行赋值保证循环继续执行</span></span><br><span class="line">   <span class="comment">// big  就是	b对应的结果集，但是big 为虚拟的，也就是说   big.next才是b   </span></span><br><span class="line">   <span class="comment">// s 是一直后移的 所以s.next = big.next   将 big.next 赋值给s</span></span><br><span class="line">   <span class="comment">//同理 返回的就是small.next</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="number">21</span> 合并链表</span><br><span class="line">	<span class="comment">//二合一   两个原链表  list1 list2  一个新链表  list 但是都不能直接操作，所以  要2个虚拟链表头结点  small  big对老链表进行操作 以及一个 p 对新建的链表进行操作 </span></span><br><span class="line">    		<span class="comment">// 3变量</span></span><br><span class="line">    <span class="comment">//while(big!= null &amp;&amp; small != null) 比较大小，  -- 只比较当前值</span></span><br><span class="line">    			<span class="comment">//值小的 就进新链表，small 后移  /big后移      并将当前值存到 p的下一个值    比完大小  -------&gt; 特色：p持续后移  -- 否则值将被覆盖</span></span><br><span class="line">    <span class="comment">//比完必有一个且只有一个（只比较当前值） ，所以分开判断  逻辑都是，直接加到新链表，p.next = small /big;</span></span><br><span class="line">    <span class="comment">//同理 返回的就是list.next</span></span><br><span class="line">    </span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h2 id="双指针对数组"><a href="#双指针对数组" class="headerlink" title="双指针对数组"></a>双指针对数组</h2><h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快慢指针 数组</span></span><br><span class="line"><span class="comment">// 此处的数组全是原地操作，不能new 新的</span></span><br><span class="line"><span class="number">26</span> 数组原地去重   --不能<span class="keyword">new</span> 一个新的数组            第一个值肯定是保留的  </span><br><span class="line"><span class="comment">//分析：已经排好序的，删除会涉及 索引的变化</span></span><br><span class="line"><span class="comment">// fast slow  两个指针，</span></span><br><span class="line">    <span class="comment">//特点：先++ 再赋值，fast 初始值= 1 /0 都可以</span></span><br><span class="line">    		<span class="comment">// 因为此时slow是有值的，第一个值肯定是保留的</span></span><br><span class="line">	<span class="comment">//while(fast&lt;nums.length)&#123;循环</span></span><br><span class="line">            <span class="comment">//if(nums[fast] != nums[slow])&#123; 原地操作的判定</span></span><br><span class="line">    </span><br><span class="line"><span class="number">83</span>  删除排序列表中重复元素                          第一个值肯定是保留的</span><br><span class="line"><span class="comment">//链表  值得比较 是  .val</span></span><br><span class="line">    <span class="comment">// fast slow  两个指针，</span></span><br><span class="line">    <span class="comment">//while(fast!= null)&#123;循环</span></span><br><span class="line">          <span class="comment">//if(fast.val != slow.val)&#123; 原地操作的判定</span></span><br><span class="line">    <span class="comment">// 先链接再后移指针</span></span><br><span class="line">----------<span class="comment">//重点: 断开与重复元素的链接</span></span><br><span class="line">        <span class="comment">//slow.next = null;</span></span><br><span class="line"><span class="number">27</span> 数组中的某些元素进行「原地删除」                第一个值不一定是保留的</span><br><span class="line">    <span class="comment">// fast slow  两个指针</span></span><br><span class="line">    <span class="comment">//while(fast&lt;nums.length)&#123;循环</span></span><br><span class="line">            <span class="comment">//if(nums[fast] != val )&#123; 原地操作的判定   -- 特定值val</span></span><br><span class="line">   <span class="comment">// 后++  先赋值    因为第一个值不一定是保留的   此时的slow是不一定有值的</span></span><br><span class="line"><span class="number">283</span> 移动<span class="number">0</span></span><br><span class="line">    <span class="comment">// fast slow  两个指针</span></span><br><span class="line">    <span class="comment">//while(fast&lt;nums.length)&#123;循环</span></span><br><span class="line">            <span class="comment">//if(nums[fast] != 0 )&#123; 原地操作的判定   -- 特定值     0</span></span><br><span class="line">   <span class="comment">// 后++  先赋值    因为第一个值不一定是保留的   此时的slow是不一定有值的</span></span><br><span class="line">   <span class="comment">//后面的值全为0  就是要从 slow+1 （位置）/    -1（角标） 到 fast  角标【low,fast)全置为 0</span></span><br><span class="line">         <span class="comment">//if(fast&gt;slow)&#123;</span></span><br><span class="line">            <span class="comment">// for(int i=slow; i &lt;fast;i++)&#123;</span></span><br><span class="line">            <span class="comment">//    nums[i] =0;</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 左右指针 数组</span></span><br><span class="line"><span class="number">167</span> 两数和</span><br><span class="line">   <span class="comment">// left right 左右两指针，&gt; target 就right-- 否则++ 直到 else (不能丢)   return</span></span><br><span class="line">    </span><br><span class="line"><span class="number">344</span> 反转数组</span><br><span class="line">    <span class="comment">//left right 左右两指针  经由辅助变量（设立辅助变量）进行交换   随后指针++  -- </span></span><br><span class="line">    </span><br><span class="line"><span class="number">5</span> 最长回文串</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归</span></span><br><span class="line">    <span class="comment">// 递归函数：</span></span><br><span class="line">    <span class="comment">//  中间向两边扩展   ++    --</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">Palindrome</span><span class="params">(String s, <span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start&gt; -<span class="number">1</span> &amp;&amp; end&lt;s.length()</span><br><span class="line">                &amp;&amp; s.charAt(start)==s.charAt(end))&#123;</span><br><span class="line">            start--;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 返回子串</span></span><br><span class="line">        <span class="keyword">return</span> s.substring(start+<span class="number">1</span>,end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用递归</span></span><br><span class="line">	 <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">String</span> <span class="variable">nowStr</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">odd</span> <span class="operator">=</span>  Palindrome(s,i,i);</span><br><span class="line">            <span class="type">String</span> <span class="variable">even</span> <span class="operator">=</span>  Palindrome(s,i,i+<span class="number">1</span>);</span><br><span class="line">		<span class="comment">//这里断点调试之后发现  要判定  不然会出现bug ,否则会使nowStr 的较大的值被替换成为新的小值 </span></span><br><span class="line">        <span class="keyword">if</span>(nowStr.length()&lt; even.length()  || nowStr.length()&lt; odd.length() )</span><br><span class="line">            nowStr = even.length() &gt; odd.length()?even:odd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nowStr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="原地处理数组大致模版"><a href="#原地处理数组大致模版" class="headerlink" title="原地处理数组大致模版"></a>原地处理数组大致模版</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(fast&lt;nums.length)&#123;</span><br><span class="line">           <span class="keyword">if</span>(nums[fast] != nums[slow])&#123;</span><br><span class="line">               <span class="comment">//先++ 再赋值，因为此时slow是有值的，第一个值肯定是保留的</span></span><br><span class="line">                slow++;        <span class="comment">//①</span></span><br><span class="line">               nums[slow] = nums[fast];      <span class="comment">//②</span></span><br><span class="line">               </span><br><span class="line">               <span class="comment">// 第一个值如果是要保留的，那么顺序就是①②</span></span><br><span class="line">               <span class="comment">// 第一个值如果是不一定保留的，那么顺序就是②①</span></span><br><span class="line">               </span><br><span class="line">           &#125;</span><br><span class="line">           fast++;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h2 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h2><p>子问题：</p>
<p>最优子结构：</p>
<p>​    <strong>要符合「最优子结构」，子问题间必须互相独立</strong></p>
<p>​            你只需要把子问题的答案加一，求个最小值，就是原问题的答案。</p>
<p>状态转移方程：</p>
<p>​    <strong>确定 base case</strong></p>
<p>​    <strong>确定「状态」，也就是原问题和子问题中会变化的</strong>    ==变量==</p>
<p>​    <strong>确定「选择」，也就是导致「状态」产生变化的行为</strong>    所谓的选择就是目前可以选的变量的范围  取值;</p>
<p>​    <strong>明确 <code>dp</code> 函数(自顶向下)/数组(自底向上)的定义</strong></p>
<p>​                一般来说函数的==参数==就是状态转移中会变化的量，也就是上面说到的==「状态」==</p>
<blockquote>
<p>==注：==</p>
<p>子串一定是连续的，而子序列不一定是连续的</p>
</blockquote>
<h3 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h3><p>动态规划的核心设计思想是<strong>数学归纳法</strong>。</p>
<p>可以假设 <code>dp[0...i-1]</code> 都已经被算出来了，然后问自己：怎么通过这些结果算出 <code>dp[i]</code></p>
<p>思考状态转移方程的一个基本方法是数学归纳法，即明确 <code>dp</code> 函数或数组的定义，然后使用这个定义，从已知的「状态」中推导出未知的「状态」。</p>
<p>动态规划的状态转移关系：</p>
<p>1、明确 <code>dp</code> 数组的定义。</p>
<p>2、根据 <code>dp</code> 数组的定义，运用数学归纳法的思想，假设 <code>dp[0...i-1]</code> 都已知，想办法求出 <code>dp[i]</code>，一旦这一步完成，整个题目基本就解决了</p>
<p>但如果无法完成这一步，很可能就是 <code>dp</code> 数组的定义不够恰当，需要重新定义 <code>dp</code> 数组的含义；或者可能是 <code>dp</code> 数组存储的信息还不够，不足以推出下一步的答案，需要把 <code>dp</code> 数组扩大成二维数组甚至三维数组。</p>
<blockquote>
<p>1、到底什么才叫「最优子结构」，和动态规划什么关系</p>
<p>​                可以从子问题的最优结果推出更大规模问题的最优结果  之前的子问题就是最优子结构</p>
<p>​                最优子结构并不是动态规划独有的一种性质，能求最值的问题大部分都具有这个性质；<strong>但反过来，最优子结构性质作为动态规划问题的必要条件，一定是让你求最值的</strong>，以后碰到那种恶心人的最值题，思路往动态规划想就对了，这就是套路</p>
<p>​                动态规划不就是从最简单的 base case 往后推导吗，可以想象成一个链式反应，以小博大。但只有符合最优子结构的问题，才有发生这种链式反应的性质</p>
<p>​                找最优子结构的过程，其实就是证明状态转移方程正确性的过程，方程符合最优子结构就可以写暴力解了，写出暴力解就可以看出有没有重叠子问题了，有则优化，无则 OK。这也是套路，经常刷题的读者应该能体会。</p>
<p>2、如何判断一个问题是动态规划问题，即如何看出是否存在重叠子问题</p>
<p>​                <strong>首先，最简单粗暴的方式就是画图，把递归树画出来，看看有没有重复的节点</strong>。</p>
<p>​                    实际的动态规划问题比较复杂，比如二维甚至三维的动态规划，当然也可以画递归树，但不免有些复杂</p>
<p>​                <strong>可以通过递归框架直接判断是否存在重叠子问题</strong>。</p>
<p>​                    从状态 <code>(i, j)</code> 转移到 <code>(i+2, j+2)</code>，有几种路径？从状态 <code>(i, j)</code> 转移到 <code>(i-1, j-1)</code>，有几种路径？</p>
<p>3、为什么经常看到将 <code>dp</code> 数组的大小设置为 <code>n + 1</code> 而不是 <code>n</code></p>
<p>为什么迭代解法中的 <code>dp</code> 数组初始化大小要设置为 <code>int[m+1][n+1]</code>？</p>
<p>为什么 <code>s1[0..i]</code> 和 <code>s2[0..j]</code> 的最小编辑距离要存储在 <code>dp[i+1][j+1]</code> 中，有一位索引偏移？</p>
<p>再看 <code>dp</code> 数组，你当然也可以定义 <code>dp[i][j]</code> 存储 <code>s1[0..i]</code> 和 <code>s2[0..j]</code> 的编辑距离，但问题是 base case 怎么搞？索引怎么能是 -1 呢？</p>
<p>4、为什么动态规划遍历 <code>dp</code> 数组的方式五花八门，有的正着遍历，有的倒着遍历，有的斜着遍历</p>
<p><strong>1、遍历的过程中，所需的状态必须是已经计算出来的</strong>。</p>
<p><strong>2、遍历结束后，存储结果的那个位置必须已经被计算出来</strong>。</p>
<p>​    主要就是看 base case 和最终结果的存储位置，保证遍历过程中使用的数据都是计算完毕的就行，有时候确实存在多种方法可以得到正确答案，可根据个人口味自行选择。</p>
<p>5、 BASE CASE 和备忘录的初始值怎么定？</p>
<p>base case 的返回值    <strong>起始条件决定的</strong></p>
<p>备忘录的初始值          <strong>由题目给出的数据范围决定的</strong></p>
<p>索引越界情况的返回值</p>
<p>5.1、对于不合法的索引，返回值应该如何确定</p>
<p>​        <strong>根据我们状态转移方程的逻辑确定</strong>。对于索引越界的 <code>dp</code> 函数，应该返回一个不可能被取到的值。</p>
<p>5.2、base case 为什么是 <code>i == 0</code>？</p>
<p>​        <strong>根据 <code>dp</code> 函数的定义所决定的</strong>。</p>
<p>5.3、备忘录 <code>memo</code> 的初始值为什么是 66666？其他值行不行？</p>
<p>​        <strong>题目给出的数据范围决定的</strong>。<code>memo</code>的初始值一定得是特殊值，和合法的答案区间有所区分</p>
<p>注：</p>
<p>​        <strong>不要忽视题目给定的其他信息</strong></p>
</blockquote>
<h3 id="动态规划解题组合拳"><a href="#动态规划解题组合拳" class="headerlink" title="动态规划解题组合拳"></a>动态规划解题组合拳</h3><p><strong>就算 <code>dp</code> 函数/数组的定义相同，如果你使用不同的「视角」进行穷举，效率也不见得是相同的</strong>。</p>
<p>两种完全不同但都是正确的状态转移逻辑，不过两种逻辑在代码实现上有效率的差异</p>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、basecase            </span><br><span class="line"> 		起始条件决定，也是由dp[i]的定义决定      要是使用备忘录：则其初始条件就由题目范围决定 </span><br><span class="line"></span><br><span class="line">   <span class="number">2</span>、状态—变量</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、选择—变量发生变化的行为 可能是变量的取值范围</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、dp[i] / dp[m][n]  的定义/含义    dp 参数就是状态—变量</span><br><span class="line"></span><br><span class="line"> 解题思路： </span><br><span class="line"></span><br><span class="line"> 数学归纳法：</span><br><span class="line"> 					<span class="number">1</span>、dp[i] 的定义/含义</span><br><span class="line">					<span class="number">2</span>、假设dp[<span class="number">0</span>…i-<span class="number">1</span>] 已知，求dp[i]     从已知推未知</span><br><span class="line"></span><br><span class="line"> 是否具有重叠子问题：</span><br><span class="line">                   <span class="number">1</span>、画递归数的图</span><br><span class="line">                   <span class="number">2</span>、抽象出 递归框架 进行判断				</span><br><span class="line"></span><br><span class="line"> 解题注意点：</span><br><span class="line"></span><br><span class="line">               dp[]    数组大小是 n+<span class="number">1</span>			dp[][]设置为： [m+<span class="number">1</span>][n+<span class="number">1</span>]		</span><br></pre></td></tr></table></figure>
<h3 id="五步走："><a href="#五步走：" class="headerlink" title="五步走："></a>五步走：</h3><h6 id="1、确定dp数组（dp-table）以及下标的含义"><a href="#1、确定dp数组（dp-table）以及下标的含义" class="headerlink" title="1、确定dp数组（dp table）以及下标的含义"></a>1、确定dp数组（dp table）以及下标的含义</h6><h6 id="2、确定递推公式【其在前的原因：-⼀些情况是递推公式决定了dp数组要如何初始化】"><a href="#2、确定递推公式【其在前的原因：-⼀些情况是递推公式决定了dp数组要如何初始化】" class="headerlink" title="2、确定递推公式【其在前的原因： ⼀些情况是递推公式决定了dp数组要如何初始化】"></a>2、确定递推公式【其在前的原因： ⼀些情况是递推公式决定了<strong>dp</strong>数组要如何初始化】</h6><h6 id="3、dp数组如何初始化"><a href="#3、dp数组如何初始化" class="headerlink" title="3、dp数组如何初始化"></a>3、dp数组如何初始化</h6><h6 id="4、确定遍历顺序"><a href="#4、确定遍历顺序" class="headerlink" title="4、确定遍历顺序"></a>4、确定遍历顺序</h6><h6 id="5、举例推导dp数组"><a href="#5、举例推导dp数组" class="headerlink" title="5、举例推导dp数组"></a>5、举例推导dp数组</h6><h3 id="基础问题"><a href="#基础问题" class="headerlink" title="基础问题"></a>基础问题</h3><blockquote>
<h6 id="爬楼梯的消费最少"><a href="#爬楼梯的消费最少" class="headerlink" title="爬楼梯的消费最少"></a>爬楼梯的消费最少</h6><blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;  dp[i] = Math.min(dp[i-<span class="number">1</span>]+cost[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]+cost[i-<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>
<h6 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h6></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;dp[i][j] = dp[i-<span class="number">1</span>][j]+ dp[i][j-<span class="number">1</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="不同路径II"><a href="#不同路径II" class="headerlink" title="不同路径II"></a>不同路径II</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">if</span>(obstacleGrid[i][j] == <span class="number">1</span>)  <span class="keyword">continue</span>;</span><br><span class="line">&gt;dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>];  </span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="困难问题"><a href="#困难问题" class="headerlink" title="困难问题"></a>困难问题</h6><blockquote>
<h6 id="不同的搜索二叉树"><a href="#不同的搜索二叉树" class="headerlink" title="不同的搜索二叉树"></a>不同的搜索二叉树</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;找规律</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 以 j 为头节点的，左子树有 j-1 个节点   右子树有 i-j 个节点</span></span><br><span class="line">&gt;dp[i] += dp[j-<span class="number">1</span>]*dp[i-j];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">// 拆 i, i-j,循环拆  </span></span><br><span class="line">&gt;dp[i] = max(j*(i-j),j*dp[i-j],dp[i]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="背包问题总结大全"><a href="#背包问题总结大全" class="headerlink" title="背包问题总结大全"></a>背包问题总结大全</h3><ul>
<li><p>基础题</p>
</li>
<li><p>背包</p>
<p>01  背包：</p>
</li>
</ul>
<blockquote>
<p>二维数组：</p>
<ul>
<li>dp数组含义：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">即dp[i][j] 表⽰从下标为[<span class="number">0</span>-i]的物品⾥任意取，放进容量为j的背包，价值总和最⼤是多少</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要时刻记着这个<strong>dp</strong>数组的含义，下⾯的⼀些步骤都围绕这<strong>dp</strong>数组的含义进⾏的，如果哪⾥看懵了，就来回顾⼀下i代表什么，j又代表什么。</p>
</blockquote>
<ul>
<li>递推公式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">			不放的时候			放的时候</span><br></pre></td></tr></table></figure>
<ul>
<li><p>数组初始化</p>
</li>
<li><p>遍历顺序</p>
<p>先遍历 物品还是先遍历背包重量都可以</p>
</li>
</ul>
<p><code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</code> 递归公式中可以看出<code>dp[i][j]</code>是靠</p>
<p><code>dp[i-1][j]和dp[i - 1][j - weight[i]]</code>推导出来的。<code>dp[i-1][j]和dp[i - 1][j - weight[i]]</code>都在<code>dp[i][j]</code>的左上⾓⽅向</p>
<ul>
<li><p>动⼿推导⼀下dp数组</p>
<p>自己推导 和 程序打印</p>
</li>
</ul>
<p>一维数组：</p>
<blockquote>
<p>滚动数组的由来，需要满⾜的条件是上⼀层可以重复利⽤，直接拷贝到当前层<br>其实可以发现如果把dp[i - 1]那⼀层拷贝到dp[i]上，表达式可以是：<br><code>dp[i][j] =max(dp[i][j], dp[i][j - weight[i]] + value[i])</code>; i是物品，j是背包容量</p>
<ul>
<li>⼀维dp数组中，dp[j]表⽰：容量为j的背包，所背的物品价值可以最⼤为dp[j]。</li>
<li><code>dp[j - weight[i]]</code>表⽰容量为j-weight[i]的背包所背的最⼤价值<br><code>dp[j - weight[i]] + value[i]</code> 表⽰ 容量为 <code>j - 物品i重量</code> 的背包 + <code>物品i的价值</code></li>
<li><code>dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</code>相对于⼆维dp数组的写法，就是把<code>dp[i][j]</code>中<code>i</code>的维度去掉了</li>
<li>dp[0] = 0，又因为 是 取价值最⼤的数   所以都初始为0就可以了</li>
<li>倒序 遍历，就可以保证物品只放⼊⼀次呢  而且必须 先遍历物品嵌套遍历背包容量</li>
<li>自己推导 和 程序打印</li>
</ul>
</blockquote>
<p>分割等和子集   /  石头相撞   /</p>
<p>价值  和重量都看做数组中   值的大小</p>
</blockquote>
<h4 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h4><h6 id="1、确定dp数组（dp-table）以及下标的含义-1"><a href="#1、确定dp数组（dp-table）以及下标的含义-1" class="headerlink" title="1、确定dp数组（dp table）以及下标的含义"></a>1、确定dp数组（dp table）以及下标的含义</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[j]  表示   总容量为 j的  背包  最大值为  dp[j];</span><br></pre></td></tr></table></figure>
<h6 id="2、确定递推公式【其在前的原因：-⼀些情况是递推公式决定了dp数组要如何初始化】-1"><a href="#2、确定递推公式【其在前的原因：-⼀些情况是递推公式决定了dp数组要如何初始化】-1" class="headerlink" title="2、确定递推公式【其在前的原因： ⼀些情况是递推公式决定了dp数组要如何初始化】"></a>2、确定递推公式【其在前的原因： ⼀些情况是递推公式决定了dp数组要如何初始化】</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">绝大多数是：</span><br><span class="line">    </span><br><span class="line">dp[j] = Math.max(dp[j],dp[j-i的重量]+i的价值);</span><br><span class="line">或者</span><br><span class="line">dp[j] += dp[j-i的重量];</span><br></pre></td></tr></table></figure>
<h6 id="3、dp数组如何初始化-1"><a href="#3、dp数组如何初始化-1" class="headerlink" title="3、dp数组如何初始化"></a>3、dp数组如何初始化</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>; ----dp[j] = Math.max(dp[j],dp[j-nums[i]]+nums[i]); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>; ----dp[j] += dp[j-nums[i]];</span><br></pre></td></tr></table></figure>
<h6 id="4、确定遍历顺序-1"><a href="#4、确定遍历顺序-1" class="headerlink" title="4、确定遍历顺序"></a>4、确定遍历顺序</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i &lt; nums.length;i++ )&#123; <span class="comment">//物品  顺序</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j（j表示当前背包剩余重量）= 背包容量;j&gt;= i的重量;j-- )&#123;  <span class="comment">// 背包     倒序  保证物品只遍历一次</span></span><br><span class="line">      </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="5、举例推导dp数组-1"><a href="#5、举例推导dp数组-1" class="headerlink" title="5、举例推导dp数组"></a>5、举例推导dp数组</h6><h6 id="6、总结："><a href="#6、总结：" class="headerlink" title="6、总结："></a>6、总结：</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">模版框架</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> dp[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="comment">/** 根据题意来设 */</span>];</span><br><span class="line"> dp[<span class="number">0</span>]=  <span class="number">0</span>（max）  (或者是)  <span class="number">1</span>（+=）;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;stones.length;i++)&#123;					<span class="comment">// 物品取值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> target ;j&gt;=stones[i];j--)&#123;       <span class="comment">//背包容量</span></span><br><span class="line">                dp[j] = Math.max (dp[j],dp[j-stones[i]]+stones[i]);</span><br><span class="line">            <span class="comment">//或者</span></span><br><span class="line">            	dp[j] += dp[j-nums[i]];</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dp[target]  /sum-<span class="number">2</span>*dp[target]/......</span><br><span class="line"></span><br><span class="line">剩下的就是根据 题目 进行 数据预处理 返回值变化等 的填充</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：</p>
<p><code>dp[j] = Math.max(dp[j],dp[j-stones[i]]+stones[i]);</code></p>
<p><code>dp[j] += dp[j-nums[i]];</code></p>
<p>​    i  、 j 等变量  本质应该为</p>
<p><code>dp[背包容量] = Math.max(dp[背包容量],dp[当前背包容量-物品[i]重量] + 物品[i]价值);</code></p>
<p><code>dp[背包容量] += dp[背包容量-物品[i]重量];</code></p>
</blockquote>
<h4 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h4><blockquote>
<p>排列：   先背包   后物品    1,2    2,1   各算一种</p>
<p>组合：     先物品  后背包    1,2    2,1   只算一种</p>
<p>求最少个数   两种遍历方式  都可以</p>
</blockquote>
<h6 id="1、确定dp数组（dp-table）以及下标的含义-2"><a href="#1、确定dp数组（dp-table）以及下标的含义-2" class="headerlink" title="1、确定dp数组（dp table）以及下标的含义"></a>1、确定dp数组（dp table）以及下标的含义</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[i]: 凑成⽬标正整数为i的排列个数为dp[i]</span><br><span class="line">dp[j]: 凑⾜总额为j所需钱币的最少个数为dp[j]</span><br><span class="line">dp[i]: 字符串长度为i的话，dp[i]为<span class="literal">true</span>，表⽰可以拆分为⼀个或多个在字典中出现的单词。</span><br><span class="line">    ...</span><br><span class="line">一般就是题目问什么你设什么  类比数学归纳法</span><br></pre></td></tr></table></figure>
<h6 id="2、确定递推公式【其在前的原因：-⼀些情况是递推公式决定了dp数组要如何初始化】-2"><a href="#2、确定递推公式【其在前的原因：-⼀些情况是递推公式决定了dp数组要如何初始化】-2" class="headerlink" title="2、确定递推公式【其在前的原因： ⼀些情况是递推公式决定了dp数组要如何初始化】"></a>2、确定递推公式【其在前的原因： ⼀些情况是递推公式决定了dp数组要如何初始化】</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">绝大多数是：</span><br><span class="line">dp[j] = Math.min (dp[j],dp[j-nums[i]]+nums[i]);</span><br><span class="line">或者</span><br><span class="line">dp[j] += dp[j-nums[i]];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>==注：这里和01背包问题是一样的==</p>
<p>说明：</p>
<p><code>dp[j] = Math.min  (dp[j],dp[j-stones[i]]+stones[i]);</code>     min</p>
<p><code>dp[j] += dp[j-nums[i]];</code></p>
<p>​    i  、 j 等变量  本质应该为</p>
<p><code>dp[背包容量] = Math.min(dp[背包容量],dp[背包容量-物品[]] + 价值[])（求min 的时候价值很可能为1的）;</code>   min</p>
<p><code>dp[背包容量] += dp[背包容量-物品[]];</code></p>
</blockquote>
<h6 id="3、dp数组如何初始化-2"><a href="#3、dp数组如何初始化-2" class="headerlink" title="3、dp数组如何初始化"></a>3、dp数组如何初始化</h6><blockquote>
<p>==注：这里和01背包问题是不太一样的==</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">这里求的是 min   需要给其他值置初值：   Arrays.fill(dp,amount+<span class="number">1</span>);  </span><br><span class="line">后</span><br><span class="line">dp[<span class="number">0</span>]赋值   dp[<span class="number">0</span>] = <span class="number">0</span>;	----dp[j] = Math.min  (dp[j],dp[j-nums[i]]+nums[i]);</span><br><span class="line"></span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>; ----dp[j] += dp[j-nums[i]];</span><br></pre></td></tr></table></figure>
<h6 id="4、确定遍历顺序-2"><a href="#4、确定遍历顺序-2" class="headerlink" title="4、确定遍历顺序"></a>4、确定遍历顺序</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">《组合》</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;coins.length;i++)&#123;    <span class="comment">//物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=coins[i] ; j &lt;= amount;j++)&#123;      <span class="comment">//背包    正序，物品可重复</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">或者  《排列》</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>;i&lt;=target;i++ )&#123;						<span class="comment">//背包</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span>  j=<span class="number">0</span>;j &lt; nums.length;j++)&#123;             <span class="comment">//物品</span></span><br><span class="line">             <span class="keyword">if</span>(i&gt;=nums[j])&#123; <span class="comment">//等于 不能丢          //此时要多一个条件  																  原因在于：j-nums[i]&gt;0</span></span><br><span class="line">             </span><br><span class="line">             &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>==注==</p>
<p>先物品后背包:   <code>组合</code></p>
<p>​        是一种组合 是没有固定顺序的 比如  1,2,1   1,1,2 视为一种方法</p>
<p>​        在这种便利条件下  1,2,1   1,1,2  只会出现一种情况</p>
<p>先背包后物品:   <code>排列</code></p>
<p>​        是一种排列 是 有固定顺序的 比如  1,2,1   1,1,2 视为两种方法</p>
<p>​        在这种便利条件下  1,2,1   1,1,2  都会出现</p>
<p>​        注意<code>if(i&gt;=nums[j])</code>不能丢</p>
</blockquote>
<h6 id="5、举例推导dp数组-2"><a href="#5、举例推导dp数组-2" class="headerlink" title="5、举例推导dp数组"></a>5、举例推导dp数组</h6><h6 id="6、总结：-1"><a href="#6、总结：-1" class="headerlink" title="6、总结："></a>6、总结：</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">模版框架</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> dp[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="comment">/** 根据题意来设 */</span>];</span><br><span class="line"> dp[<span class="number">0</span>]=  <span class="number">0</span>  (或者是)  <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;coins.length;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=coins[i] ; j &lt;= amount;j++)&#123;</span><br><span class="line">          dp[j] += dp[j-coins[i]];</span><br><span class="line">          <span class="comment">// 或者</span></span><br><span class="line">       dp[j] = Math.min(dp[j],dp[j-coins[i]]+<span class="number">1</span>);<span class="comment">// 求最小值哪种遍历顺序都可以</span></span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>;i&lt;=target;i++ )&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ;j &lt; nums.length;j++)&#123;  </span><br><span class="line"> <span class="comment">//（也可能  for(int j = 1 ;j &lt;= 2;j++)&#123;//步数要从 1 开始）--当物品时值不是数组的时候</span></span><br><span class="line">                <span class="keyword">if</span>(i&gt;=nums[j])&#123;  <span class="comment">//等于 不能丢</span></span><br><span class="line">                    dp[i] += dp[i-nums[j]];</span><br><span class="line">                    <span class="comment">// 或者</span></span><br><span class="line">         	 dp[j] = Math.min(dp[j],dp[j-coins[i]]+<span class="number">1</span>);<span class="comment">// 求最小值哪种遍历顺序都可以</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dp[amount]   / <span class="keyword">return</span>  dp[amount]== amount+<span class="number">1</span> ? -<span class="number">1</span>  :dp[amount]; ...</span><br><span class="line">剩下的就是根据 题目 进行 数据预处理 返回值变化等 的填充</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">特例：值得推敲</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line"><span class="comment">//dp[i] : 字符串长度为i的话，dp[i]为true，表⽰可以拆分为⼀个或多个在字典中出现的单词。 </span></span><br><span class="line"><span class="comment">//s 是有 顺序的 所以就只能 先背包再物品  --- 排列</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">boolean</span> dp[] = <span class="keyword">new</span> <span class="title class_">boolean</span> [n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;<span class="comment">//其实无意义</span></span><br><span class="line"><span class="comment">// i = 1 原因是字符串时非空的</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">1</span>; i&lt;= n;i++)&#123;   <span class="comment">//背包</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;i ;j++)&#123;  <span class="comment">//其是在字符串里面截取的，所以要小于i</span></span><br><span class="line">       <span class="comment">//只要确定dp[j]是true,dp[j]前面j段距离是true </span></span><br><span class="line">        <span class="comment">//并且[j, i]这个区间的子串出现在字典里，那么dp[i]一定是true</span></span><br><span class="line">      <span class="comment">//每次构造字符串是到不了i的，因此dp[j]看成是到j-1的字符,所以写成s.substring(j,i)&lt;表示截取字符串j-i段&gt;,而不是s.substring(j+1,i) </span></span><br><span class="line">     <span class="comment">// 0              j      i</span></span><br><span class="line">     <span class="comment">// ----------------------------</span></span><br><span class="line">         <span class="keyword">if</span>(wordDict.contains(s.substring(j,i)) &amp;&amp; dp[j])&#123;</span><br><span class="line">             dp[i] =  <span class="literal">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="子序列问题："><a href="#子序列问题：" class="headerlink" title="子序列问题："></a>子序列问题：</h3><blockquote>
<ul>
<li><p>子数组、子序列这类问题，你就可以尝试定义 <code>dp[i]</code> 是以 <code>nums[i]</code> 为结尾的最大子数组和/最长递增子序列，因为这样定义更容易将 <code>dp[i+1]</code> 和 <code>dp[i]</code> 建立起联系，利用数学归纳法写出状态转移方程</p>
</li>
<li><p><strong>对于两个字符串求子序列的问题，都是用两个指针<code>i</code>和<code>j</code>分别在两个字符串上移动，大概率是动态规划思路</strong>。</p>
</li>
<li><p>子序列和最值几乎都是动态规划技巧</p>
</li>
</ul>
</blockquote>
<ul>
<li><p>思路一： 一维dp数组</p>
<p>dp[i] 是一个以  nums[i]/array[i]  为结尾的最长递增子序列的长度（符合归纳法）</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>  n= array.length;</span><br><span class="line"><span class="type">int</span> []dp =<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++)</span><br><span class="line">        dp[i] = max(dp[i],dp[j]+<span class="number">1</span>) /  最值 &#123;dp......&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>思路二：二维数组</p>
<p>两个字符串、数组    的子序列</p>
<ul>
<li>数组arr1 []  数组arr2[] 中需求的子序列(最值 子序列 )  的长度dp[i][j]  —  涉及两个子序列</li>
<li>数组arr1 [] 需求的子序列(最值 子序列 ) 的长度dp[i][j]                       — 设计一个子序列</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span>arr1.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr2.length;</span><br><span class="line"><span class="type">int</span> [][]dp= <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,i&lt;=m;i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">			dp[i] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]    /  最值 &#123;dp......&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>子序列是可以不连续的，也可以连续的，</li>
</ul>
<p>​        连续的子序列之和前一个元素的状态相关，不连续的和前面0-i-1  的状态相关</p>
<ul>
<li>子串子数组是连续的</li>
</ul>
</blockquote>
<h4 id="数组子序列中的一维dp（数组）"><a href="#数组子序列中的一维dp（数组）" class="headerlink" title="数组子序列中的一维dp（数组）"></a>数组子序列中的一维dp（数组）</h4><h6 id="1、确定dp-的含义"><a href="#1、确定dp-的含义" class="headerlink" title="1、确定dp[]的含义"></a>1、确定dp[]的含义</h6><blockquote>
<p>==问什么设什么== 但是 大多数情况之下要判断比较取dp[] 中的最大值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;比如：</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">  ......</span><br><span class="line"><span class="keyword">if</span> (dp[i + <span class="number">1</span>] &gt; result) </span><br><span class="line">      	result = dp[i + <span class="number">1</span>];</span><br><span class="line">&gt;&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
<p>如：</p>
<p>​    <strong>dp[i]</strong>：表⽰以下标<strong>i</strong>为结尾的数组的  最长上升子序列长度为dp[i]  （问的是长度）</p>
<p>​    <strong>dp[i]</strong>：表⽰以下标<strong>i</strong>为结尾的数组的  连续递增的⼦序列长度为<strong>dp[i]</strong> （问的是长度）</p>
<p>​    <strong>dp[i]</strong>：表⽰以下标<strong>i</strong>为结尾的数组的   最⼤连续⼦序列和为<strong>dp[i]</strong>（问的是和）</p>
</blockquote>
<h6 id="2、选择-–状态转移方程"><a href="#2、选择-–状态转移方程" class="headerlink" title="2、选择  –状态转移方程"></a>2、选择  –状态转移方程</h6><blockquote>
<p>判断：是连续的子序列还是不连续的子序列</p>
<p>​        连续的子序列之和前一个元素的状态相关，不连续的和前面<code>0~i-1</code> 的状态相关</p>
<p>如:==不连续==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);   <span class="comment">// 最长递增子序列</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>==连续==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;dp[i] = max(dp[i - <span class="number">1</span>] + nums[i], nums[i]);   <span class="comment">//与前一个元素  i-1 相关  最大子数组和</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//或者</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">if</span>(nums[i-<span class="number">1</span>] &lt; nums[i])&#123;    <span class="comment">//与前一个元素  i-1 相关    最长递增子数组</span></span><br><span class="line"> dp[i]= dp[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">&gt;&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="3、确定初始值"><a href="#3、确定初始值" class="headerlink" title="3、确定初始值"></a>3、确定初始值</h6><blockquote>
<p><code>Arrays.fill(dp,1);</code>     //递增序列</p>
<p><code>dp[0]= nums[0]</code>  //子数组和</p>
</blockquote>
<h6 id="4、确定遍历顺序-3"><a href="#4、确定遍历顺序-3" class="headerlink" title="4、确定遍历顺序"></a>4、确定遍历顺序</h6><blockquote>
<p>一般都是  ：    前     -&gt;       后</p>
<p>==不连续：==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;<span class="comment">//因为和前 i-1 个元素的状态相关,</span></span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>==连续：==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="comment">// 和前一个元素有关，所以要考虑i的起始坐标</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="5、打印dp数组"><a href="#5、打印dp数组" class="headerlink" title="5、打印dp数组"></a>5、打印dp数组</h6><h4 id="二维dp中的-公共子序列-（两个-字符串-数组）"><a href="#二维dp中的-公共子序列-（两个-字符串-数组）" class="headerlink" title="二维dp中的 公共子序列 （两个  字符串/数组）"></a>二维dp中的 公共子序列 （两个  字符串/数组）</h4><h6 id="dp-含义"><a href="#dp-含义" class="headerlink" title="dp[][]含义"></a>dp[][]含义</h6><blockquote>
<p>公共子序列问题中的<code>dp[i][j]</code>定义都是：</p>
<p>​    <code>以长度为[0, i - 1]的 字符串1/ 数组1 ，和长度为[0, j - 1]的 字符串2/数组2，</code></p>
<p>​            <code>的公共子序列长度为dp[i][j]</code></p>
</blockquote>
<h6 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h6><blockquote>
<p>数组会有连续和不连续的区别</p>
<p>==数组和字符串在不连续的时候是一样的==</p>
<p>==连续时==</p>
<p>​        <strong>只讨论当数组值相等的时候</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">if</span>(nums1[i-<span class="number">1</span>] == nums2[j-<span class="number">1</span>])&#123;</span><br><span class="line"> dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>==不连续时==</p>
<p>​        <strong>数组值相等和不等的时候都要讨论</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">if</span>(text1.charAt(i-<span class="number">1</span>) == text2.charAt(j-<span class="number">1</span>))/ <span class="keyword">if</span>(nums1[i-<span class="number">1</span>] == nums2[j-<span class="number">1</span>])</span><br><span class="line">&gt;dp[i][j] =  dp[i-<span class="number">1</span>][j-<span class="number">1</span>] +<span class="number">1</span>;</span><br><span class="line">&gt;<span class="keyword">else</span> </span><br><span class="line">&gt;dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a>初始值</h6><blockquote>
<p>dp表都是空的，维度是<code>i+1，j+1</code>，</p>
<p>第一列 和 第一行 都是全 0的，然后行列都是从 1  开始 判断 填写</p>
</blockquote>
<h6 id="遍历顺序"><a href="#遍历顺序" class="headerlink" title="遍历顺序"></a>遍历顺序</h6><blockquote>
<p>无论是数组还是字符串都是==一样的==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">1</span>; i&lt;=nums1.length;i++) &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span> ;j&lt;= nums2.length;j++)&#123;</span><br><span class="line">         ...</span><br><span class="line">       System.out.print(dp[i][j]);  <span class="comment">//打印dp数组</span></span><br><span class="line">  &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="打印dp数组"><a href="#打印dp数组" class="headerlink" title="打印dp数组"></a>打印dp数组</h6><h4 id="二维dp中-对子序列操作（字符串）"><a href="#二维dp中-对子序列操作（字符串）" class="headerlink" title="二维dp中  对子序列操作（字符串）"></a>二维dp中  对子序列操作（字符串）</h4><h6 id="1、dp-数组定义"><a href="#1、dp-数组定义" class="headerlink" title="1、dp[][]数组定义"></a>1、dp[][]数组定义</h6><blockquote>
<p><code>dp[i][j] 表⽰以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同⼦序列的长度 为dp[i][j]</code></p>
<p><code>dp[i][j]表⽰以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]</code></p>
</blockquote>
<h6 id="2、选择-状态转移方程"><a href="#2、选择-状态转移方程" class="headerlink" title="2、选择:状态转移方程"></a>2、选择:状态转移方程</h6><blockquote>
<p>同样的：分为相等和不相等两种情况；</p>
<p>==相等== <code>if(s.charAt(i-1) == t.charAt(j-1))&#123;...&#125;</code></p>
<p><strong>只允许操作（删除、 增加）一个字符串时 </strong>   ==求个数==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] +<span class="number">1</span>;  ---判断是否是子序列    求子序列个数</span><br><span class="line"></span><br><span class="line">&gt;dp[i][j] = dp[i-<span class="number">1</span>][j]+dp[i-<span class="number">1</span>][j-<span class="number">1</span>]; --- s 的子序列中 t 出现的个数</span><br></pre></td></tr></table></figure>
<p><strong>操作（删除、 增加）两个字符串时  </strong>    ==求操作次数==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];  -- 最小操作个数不要加 <span class="number">1</span> </span><br></pre></td></tr></table></figure>
<p><strong>操作两个字符串（增、删、替换）</strong>==求操作次数==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];  -- 最小操作个数不要加 <span class="number">1</span> </span><br></pre></td></tr></table></figure>
<p>==不相等== <code>else</code></p>
<p><strong>只允许操作（删除、添加）一个字符串时</strong>      ==求个数==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;dp[i][j] = Math.max(dp[i][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j]);      --- 判断是否是子序列   求子序列个数</span><br><span class="line"></span><br><span class="line">&gt;dp[i][j]=dp[i-<span class="number">1</span>][j];       --- s 的子序列中 t 出现的个数</span><br></pre></td></tr></table></figure>
<p><strong>操作（删除、 增加）两个字符串时</strong>       ==求操作次数==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;dp[i][j] = min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>, min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>)</span><br><span class="line">&gt;&lt;=&gt;  dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])+ <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>操作两个字符串（增、删、替换）</strong>         ==求操作次数==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;dp[i][j] = min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>, min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>);</span><br><span class="line"><span class="comment">//区别： 1、这里替换 是 +1 两个都不一样的时候，替换操作 +1;但是 删除 +2； 所以选择替换才是最少的操作次数</span></span><br><span class="line">&gt;&lt;=&gt;  dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>],dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//2、这里不能简化   而且因为 java 原因还要 写 一个 min（） 方法；</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="3、初始化"><a href="#3、初始化" class="headerlink" title="3、初始化"></a>3、初始化</h6><blockquote>
<p>根据题目设定，比如</p>
<p>要是问 操作距离</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;=s1.length/s1.length();i++)&#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = i;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j&lt;= s2.length/s2.length();j++)&#123;</span><br><span class="line">dp[<span class="number">0</span>][j] = j;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;或者</span><br><span class="line">&gt;dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>要是问 有包含多少子序列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=s1.length();i++)&#123;    <span class="comment">//子序列所在的列/行  一行全为 1</span></span><br><span class="line">&gt;dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">&gt;&#125;    <span class="comment">//因为空集是所有字符串子集, 所以我们第一行都是 1</span></span><br></pre></td></tr></table></figure>
<p>否则一般还是设为 全0</p>
</blockquote>
<h6 id="4、遍历顺序"><a href="#4、遍历顺序" class="headerlink" title="4、遍历顺序"></a>4、遍历顺序</h6><blockquote>
<p>一般都是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s1.length /s1.length() ;i++)&#123;</span><br><span class="line">&gt;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=s2.length / s2.length();j++)&#123;</span><br><span class="line"> &#125;          </span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>也可以由递推公式进行  画图 判断</p>
</blockquote>
<h6 id="5、打印数组"><a href="#5、打印数组" class="headerlink" title="5、打印数组"></a>5、打印数组</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;=s1.length /s1.length(); i++) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;=s2.length /s2.length(); j++) &#123;</span><br><span class="line">              System.out.print(dp[i][j]);</span><br><span class="line">          &#125;</span><br><span class="line">           System.out.println();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h4 id="二维dp中-回文串（字符串）"><a href="#二维dp中-回文串（字符串）" class="headerlink" title="二维dp中 回文串（字符串）"></a>二维dp中 回文串（字符串）</h4><h6 id="1、dp-数组的定义"><a href="#1、dp-数组的定义" class="headerlink" title="1、dp[][]数组的定义"></a>1、dp[][]数组的定义</h6><blockquote>
<p><code>dp[i][j]：字符串s在[i, j]范围内最长的回⽂⼦序列的长度为dp[i][j]</code></p>
<p>此时的区间是<code>i，j</code> 不再是两个字符串时候的<code>i-1  j-1</code>了</p>
</blockquote>
<h6 id="2、选择-状态转移方程-1"><a href="#2、选择-状态转移方程-1" class="headerlink" title="2、选择:状态转移方程"></a>2、选择:状态转移方程</h6><blockquote>
<p>==相等==<code>if(s.charAt(i) == s.charAt(j))</code>        ==此处是 i 和 j 了 ，不再是  i-1，j-1  了==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>==不相等==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;dp[i][j] =Math.max(dp[i+<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="3、初始化-1"><a href="#3、初始化-1" class="headerlink" title="3、初始化"></a>3、初始化</h6><blockquote>
<p>看题目，不过一般来说回文串的<code>对角线都是  1</code></p>
<p>即：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">for</span>(<span class="type">int</span>  <span class="variable">j</span> <span class="operator">=</span><span class="number">0</span> ;j&lt;n;j++)&#123;</span><br><span class="line"> 	dp[j][j] =<span class="number">1</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="4、遍历顺序-1"><a href="#4、遍历顺序-1" class="headerlink" title="4、遍历顺序"></a>4、遍历顺序</h6><blockquote>
<p>集体看题目和自己推导</p>
<p>一般为： 自下向上    自左向右</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">for</span>(<span class="type">int</span> i=s.length()-<span class="number">2</span>;i&gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> j= i+<span class="number">1</span> ;j&lt;n;j++)&#123;</span><br><span class="line">    ......        </span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="5、打印dp数组-1"><a href="#5、打印dp数组-1" class="headerlink" title="5、打印dp数组"></a>5、打印dp数组</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">516.</span> 最长回文子序列</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> [][]dp = <span class="keyword">new</span> <span class="title class_">int</span> [n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">             dp[i][i] =<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n-<span class="number">2</span>;i&gt;= <span class="number">0</span>;i--)&#123;                        ----对角线已经初始化  n-<span class="number">2</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == s.charAt(j))&#123;</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] =Math.max(dp[i+<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//想要得到的就是一个 字符串  起止 坐标</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n-<span class="number">1</span>];      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1312.</span> 让字符串成为回文串的最少插入次数--------类似 编辑距离的操作</span><br><span class="line"></span><br><span class="line">        <span class="comment">//间接  总长度 减去 最长回文子串</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> dp[][] = <span class="keyword">new</span>  <span class="title class_">int</span> [n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">//间接</span></span><br><span class="line">            <span class="comment">//dp[i][i] =  1;</span></span><br><span class="line">            <span class="comment">//直接</span></span><br><span class="line">            dp[i][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//间接</span></span><br><span class="line"><span class="comment">//for(int i = n-2;i &gt;= 0;i--)&#123;                      对角线已经初始化   n-2</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;             ----对角线未初始化   n-<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>;j &lt; n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == s.charAt(j))&#123;</span><br><span class="line">                    <span class="comment">//间接</span></span><br><span class="line">                   <span class="comment">//dp[i][j] = dp[i+1][j-1]+2;</span></span><br><span class="line">                   <span class="comment">//直接</span></span><br><span class="line">                   dp[i][j]= dp[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;    <span class="comment">//间接</span></span><br><span class="line">                    <span class="comment">//dp[i][j]  = Math.max(dp[i][j-1],dp[i+1][j]);</span></span><br><span class="line">                    <span class="comment">//直接</span></span><br><span class="line">                    dp[i][j]  = Math.min(dp[i][j-<span class="number">1</span>],dp[i+<span class="number">1</span>][j])+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(dp[0][n-1]);</span></span><br><span class="line">         <span class="comment">//间接</span></span><br><span class="line">        <span class="comment">//return n- dp[0][n-1];</span></span><br><span class="line">        <span class="comment">//直接</span></span><br><span class="line">        <span class="keyword">return</span>  dp[<span class="number">0</span>][n-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">647.</span> 回⽂⼦串</span><br><span class="line"></span><br><span class="line">dp[i][j]：表⽰区间范围[i,j] （注意是左闭右闭）的⼦串是否是回⽂⼦串，如果是dp[i][j]为<span class="literal">true</span>，否则为<span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">  <span class="type">boolean</span> dp[][] = <span class="keyword">new</span> <span class="title class_">boolean</span> [s.length()+<span class="number">1</span>][s.length()+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span>  <span class="variable">n</span> <span class="operator">=</span> s.length()</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;                    --对角线未初始化   n-<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;j &lt; n;j++)&#123;          	--对角线未初始化   所以从对角线开始</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == s.charAt(j))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i==j || (j-i)==<span class="number">1</span>)&#123;   <span class="comment">//左右相邻 或者 指向的是同一个字符的时候</span></span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;     </span><br><span class="line">                        res++;</span><br><span class="line">                   &#125;<span class="keyword">else</span> <span class="keyword">if</span> (dp[i+<span class="number">1</span>][j-<span class="number">1</span>] == <span class="literal">true</span>)&#123;</span><br><span class="line">                        res++;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="打家劫舍问题"><a href="#打家劫舍问题" class="headerlink" title="打家劫舍问题"></a>打家劫舍问题</h3><h5 id="I"><a href="#I" class="headerlink" title="I"></a>I</h5><h6 id="1、dp数组定义：考虑下标i-包括i-以内的房屋，最多可以偷窃的⾦额为dp-i"><a href="#1、dp数组定义：考虑下标i-包括i-以内的房屋，最多可以偷窃的⾦额为dp-i" class="headerlink" title="1、dp数组定义：考虑下标i(包括i)以内的房屋，最多可以偷窃的⾦额为dp[i]"></a>1、dp数组定义：<code>考虑下标i(包括i)以内的房屋，最多可以偷窃的⾦额为dp[i]</code></h6><h6 id="2、选择：状态转移方程"><a href="#2、选择：状态转移方程" class="headerlink" title="2、选择：状态转移方程"></a>2、选择：状态转移方程</h6><blockquote>
<p>偷 不偷</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[i] = max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<h6 id="3、初始值"><a href="#3、初始值" class="headerlink" title="3、初始值"></a>3、初始值</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span>(nums.length &gt;<span class="number">1</span>)    dp[<span class="number">1</span>]=Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<h6 id="4、-遍历顺序"><a href="#4、-遍历顺序" class="headerlink" title="4、 遍历顺序"></a>4、 遍历顺序</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span> ;i &lt; nums.length ;i++)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="5、打印dp数组-2"><a href="#5、打印dp数组-2" class="headerlink" title="5、打印dp数组"></a>5、打印dp数组</h6><h5 id="II"><a href="#II" class="headerlink" title="II"></a>II</h5><blockquote>
<p>==将  环  拆开==</p>
<p>与 I 雷同，区别是</p>
<p>学到了一个java内置函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="type">int</span> [] rob1 = Arrays.copyOfRange(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">&gt;<span class="type">int</span> [] rob2 = Arrays.copyOfRange(nums, <span class="number">1</span>, nums.length);</span><br><span class="line">&gt;<span class="comment">// 将0 ~ nums.length-1 的 你们是数组的值赋值给 rob     -- 将环拆开的方法</span></span><br></pre></td></tr></table></figure>
<p>还有就是在主函数中调用I中函数之前要 排除特例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">if</span>(nums.length == <span class="number">1</span>)  <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="III"><a href="#III" class="headerlink" title="III"></a>III</h5><blockquote>
<p>对于树的话，⾸先就要想到遍历⽅式，前中后序（深度优先搜索）还是层序遍历（⼴度优先搜索）</p>
<p><strong>偏重在递归和树的遍历上</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">&gt;<span class="type">int</span> robtreeres[] = robtree(root);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">return</span> Math.max(robtreeres[<span class="number">0</span>],robtreeres[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="type">int</span>[] robtree(TreeNode root) &#123;</span><br><span class="line">&gt;<span class="comment">//对于以r.left为根的树，计算抢劫根节点(r.left)与不抢劫根节点可获得最大金额. </span></span><br><span class="line">&gt;<span class="comment">//left[0]则为不抢r.left可获得的最大金额,</span></span><br><span class="line">&gt;<span class="comment">//left[1]则为抢劫r.left可获得的最大金额 </span></span><br><span class="line">&gt;<span class="keyword">if</span>(root  == <span class="literal">null</span>)    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">2</span>];</span><br><span class="line">&gt;<span class="comment">//递归遍历</span></span><br><span class="line">&gt;<span class="type">int</span> leftdp [] =robtree(root.left);</span><br><span class="line">&gt;<span class="comment">//right[] 分析同理</span></span><br><span class="line">&gt;<span class="type">int</span> rightdp [] =robtree(root.right) ;</span><br><span class="line"></span><br><span class="line">&gt;<span class="type">int</span> <span class="variable">val1</span> <span class="operator">=</span>  root.val+leftdp[<span class="number">1</span>]+rightdp[<span class="number">1</span>];  <span class="comment">//父节点偷，子节点只能不偷   1 表示不偷   0 表示偷</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//父节点不偷，子节点既能偷也能不偷</span></span><br><span class="line">&gt;<span class="type">int</span> <span class="variable">val2</span> <span class="operator">=</span> Math.max(leftdp[<span class="number">0</span>] ,leftdp[<span class="number">1</span>])+ Math.max(rightdp[<span class="number">0</span>],rightdp[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;val1,val2&#125;;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="树形dp"><a href="#树形dp" class="headerlink" title="树形dp"></a>树形dp</h3><h4 id="ACM形式全方位学习"><a href="#ACM形式全方位学习" class="headerlink" title="ACM形式全方位学习"></a>ACM形式全方位学习</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>树形dp的主要实现形式是<code>𝑑𝑓𝑠</code>，在<code>𝑑𝑓𝑠</code>中<code>𝑑𝑝</code>主要的实现形式是<code>𝑑𝑝[𝑖][𝑗][0/1]</code></p>
<p><code>𝑖</code>是以<code>𝑖</code>为<code>根</code>的子树，<code>𝑗</code>是表示在以<code>𝑖为根的子树</code>中选择<code>𝑗个子节点</code>，0表示这个节点<code>不选</code>，1表示选择这个<code>节点</code>。有的时候<code>𝑗</code>或<code>0/1</code>这<code>一维可以压掉</code></p>
<h5 id="核心dp方程"><a href="#核心dp方程" class="headerlink" title="核心dp方程"></a>核心dp方程</h5><blockquote>
<h5 id="选择节点类"><a href="#选择节点类" class="headerlink" title="选择节点类"></a>选择节点类</h5><p>​      <code>dp[i][0] = dp[j][1]</code></p>
<p>​     <code>dp[i][1]=max/min(dp[j][0],dp[j][1])</code></p>
<h5 id="树形背包类"><a href="#树形背包类" class="headerlink" title="树形背包类"></a>树形背包类</h5><p>​     <code>𝑑𝑝[𝑣][𝑘]=𝑑𝑝[𝑢][𝑘]+𝑣𝑎𝑙</code></p>
<p>​    <code>𝑑𝑝[𝑢][𝑘]=𝑚𝑎𝑥(𝑑𝑝[𝑢][𝑘],𝑑𝑝[𝑣][𝑘−1])</code></p>
</blockquote>
<h5 id="ACM输入格式"><a href="#ACM输入格式" class="headerlink" title="ACM输入格式"></a>ACM输入格式</h5><p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304131133326.png" alt="image-20230413113306286" style="zoom:25%;"></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">// mian 中 进行 dfs  以及输入输出</span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">  <span class="comment">//第一段数字</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">  <span class="comment">//第二段数字</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;= n;i++)&#123;</span><br><span class="line">      value[i]= scanner.nextInt();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表  的预处理</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;= n;i++)&#123;</span><br><span class="line">      tree[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第三段数字</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;= n -<span class="number">1</span>;i++)&#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">      <span class="type">int</span> <span class="variable">father</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将节点 father 的一个子节点 child 加入到 son[k] 中</span></span><br><span class="line">      tree[father].add(child);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 标志位1 就不能是子节点了</span></span><br><span class="line">      not_root[child] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//        for (int i = 0; i &lt;= n; i++) &#123;</span></span><br><span class="line">&gt;<span class="comment">//            System.out.println(tree[i]);</span></span><br><span class="line">&gt;<span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(not_root[i] == <span class="number">0</span>)&#123;</span><br><span class="line">          root = i;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(root);</span><br><span class="line">  System.out.println(Math.max(dp[root][<span class="number">0</span>],dp[root][<span class="number">1</span>]));</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">///////////////////////</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//说明： </span></span><br><span class="line">&gt;ArrayList的存储结构</span><br><span class="line">&gt;<span class="comment">// 执行：</span></span><br><span class="line">&gt;List&lt;Integer&gt;[] tree = <span class="keyword">new</span> <span class="title class_">List</span>[n + <span class="number">1</span>];</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">&gt;tree[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//实际的add操作就是执行了：</span></span><br><span class="line">&gt;tree[<span class="number">3</span>].add(<span class="number">1</span>);</span><br><span class="line">&gt;tree[<span class="number">3</span>].add(<span class="number">2</span>);</span><br><span class="line">&gt;tree[<span class="number">4</span>].add(<span class="number">6</span>);</span><br><span class="line">&gt;tree[<span class="number">4</span>].add(<span class="number">7</span>);</span><br><span class="line">&gt;tree[<span class="number">5</span>].add(<span class="number">4</span>);</span><br><span class="line">&gt;tree[<span class="number">5</span>].add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">&gt;System.out.println(<span class="string">&quot;tree[&quot;</span>+i+<span class="string">&quot;]&quot;</span>+tree[i]);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//即可得到各个节点对应的子节点。</span></span><br><span class="line">&gt;tree[<span class="number">0</span>]<span class="literal">null</span></span><br><span class="line">&gt;tree[<span class="number">1</span>][]</span><br><span class="line">&gt;tree[<span class="number">2</span>][]</span><br><span class="line">&gt;tree[<span class="number">3</span>][<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">&gt;tree[<span class="number">4</span>][<span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">&gt;tree[<span class="number">5</span>][<span class="number">4</span>, <span class="number">3</span>]</span><br><span class="line">&gt;tree[<span class="number">6</span>][]</span><br><span class="line">&gt;tree[<span class="number">7</span>][]</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">// 数据定义</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_Length</span> <span class="operator">=</span> <span class="number">6005</span>;（<span class="number">6005</span>看题目要求而来）</span><br><span class="line">&gt;<span class="keyword">static</span> <span class="type">int</span> value[]= <span class="keyword">new</span> <span class="title class_">int</span>[MAX_Length];</span><br><span class="line">&gt;<span class="keyword">static</span> <span class="type">int</span> dp[][] = <span class="keyword">new</span> <span class="title class_">int</span>[MAX_Length][<span class="number">2</span>];</span><br><span class="line">&gt;<span class="comment">// 判断是否为根</span></span><br><span class="line">&gt;<span class="keyword">static</span> <span class="type">int</span> not_root[] = <span class="keyword">new</span> <span class="title class_">int</span>[MAX_Length];</span><br><span class="line">&gt;<span class="comment">// 使用 邻接表 进行存储 父子节点 这要是 List</span></span><br><span class="line">&gt;<span class="keyword">static</span> List&lt;Integer&gt;[] tree = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[MAX_Length];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">// 进行dp  要注意的是  先找到 子节点在 数组数组链表中的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> root)</span> &#123;</span><br><span class="line">  dp[root][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  dp[root][<span class="number">1</span>] = value[root];</span><br><span class="line">  <span class="comment">//找子树</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tree[root].size(); i++) &#123;</span><br><span class="line">         <span class="comment">//因为dp函数是要进行寻找到子节点的</span></span><br><span class="line">         <span class="type">int</span> <span class="variable">son</span> <span class="operator">=</span> tree[root].get(i);</span><br><span class="line">         dfs(son);</span><br><span class="line">         <span class="comment">// 父亲去 孩子就不能去</span></span><br><span class="line">         dp[root][<span class="number">1</span>] += dp[son][<span class="number">0</span>];</span><br><span class="line">         <span class="comment">// 父亲不去，孩子就能去，但是去不去是取 最大值的</span></span><br><span class="line">         dp[root][<span class="number">0</span>] += Math.max(dp[son][<span class="number">0</span>],dp[son][<span class="number">1</span>]);</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="股票问题"><a href="#股票问题" class="headerlink" title="股票问题"></a>股票问题</h3><blockquote>
<p>==选择：==<br>       买入、卖出、无操作</p>
<p>==状态==</p>
<p>​        第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（用 1 表示持有，0 表示没有持有）</p>
<p>基本的==状态转移方程==：</p>
<p>n 为天数，大 K 为交易数的上限，0 和 1 代表是否持有股票。</p>
<p><code>dp[i][k][0] = max(dp[i-1][k][0]      ,     dp[i-1][k][1] + prices[i])</code></p>
<p>​        一直保持没有持有股票的状态，买的次数还是k       今天刚刚卖掉，但是前一天还是持有股票的状态,但是买的次数还是k</p>
<p><code>dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])</code></p>
<p>​        一直保持持有股票的状态，买的次数还是k          今天刚刚买了，但是之前一直没有持有股票的状态,买的次数是k-1</p>
<p><strong>ps:状态 <code>k</code> 的定义并不是「已进行的交易次数」，而是「最大购买交易的上限」</strong></p>
<p>==初始化==</p>
<p><code>dp[-1][...][0] = dp[...][0][0] = 0</code>       没有股票  所以价值肯定是 0</p>
<p><code>dp[-1][...][1] = dp[...][0][1] = -infinity</code>      购买次数 为 0  或者天数为 &lt;0  此时还有票 显然非法</p>
<p>具体题目：</p>
<ul>
<li>k 为固定值 即：指定的购买次数  &lt;<code>dp[i-1][0][0] = 0</code>&gt;</li>
</ul>
<p>​        此时方程为：</p>
<p>​                <code>dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</code></p>
<p>​                <code>dp[i][1] = max(dp[i-1][1], -prices[i])</code></p>
<p>​                特殊处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">if</span> (i - <span class="number">1</span> &lt; <span class="number">0</span>)&#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 根据状态转移方程可得：</span></span><br><span class="line"><span class="comment">//   dp[i][0] </span></span><br><span class="line"><span class="comment">// = max(dp[-1][0], dp[-1][1] + prices[i])</span></span><br><span class="line"><span class="comment">// = max(0, -infinity + prices[i]) = 0</span></span><br><span class="line"></span><br><span class="line">dp[i][<span class="number">1</span>] = -prices[i];</span><br><span class="line"><span class="comment">// 根据状态转移方程可得：</span></span><br><span class="line"><span class="comment">//   dp[i][1] </span></span><br><span class="line"><span class="comment">// = max(dp[-1][1], dp[-1][0] - prices[i])</span></span><br><span class="line"><span class="comment">// = max(-infinity, 0 - prices[i]) </span></span><br><span class="line"><span class="comment">// = -prices[i]</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 按五部曲来</span></span><br><span class="line">&gt;或者直接进行初始化，在<span class="keyword">for</span> 循环之外</span><br><span class="line">  dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">&gt;<span class="comment">//随后 for循环内就不要进行判断了</span></span><br></pre></td></tr></table></figure>
<ul>
<li>k为 无穷大</li>
</ul>
<p>​        此时方程为：</p>
<p>​                <code>dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</code></p>
<p>​                <code>dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i])</code></p>
<p>​        特殊处理和上面一样</p>
<ul>
<li>k 为  无穷大 且 含有手续费</li>
</ul>
<p>​    此时方程为：</p>
<p> ​                <code>dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</code></p>
<p> ​                <code>dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i]-fee)</code></p>
<p>​    特殊处理和上面类似 <code>dp[i][1] = -prices[i]-fee;</code>  /或者=&gt;(单独初始化)/<code>dp[0][1] = -prices[0]-fee;</code></p>
<ul>
<li>k 为  无穷大 且 存在==冷冻期==（初始化的特例）</li>
</ul>
<p>​        此时方程为：</p>
<p> ​                <code>dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</code></p>
<p> ​                <code>dp[i][1] = max(dp[i-1][1], dp[i-2][0]-prices[i])</code></p>
<p>​        特殊处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// base case 1</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> 循环中</span><br><span class="line">             <span class="keyword">if</span> (i - <span class="number">2</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// base case 2</span></span><br><span class="line">                dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                <span class="comment">// i - 2 小于 0 时根据状态转移方程推出对应 base case</span></span><br><span class="line">                dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">                <span class="comment">//   dp[i][1] </span></span><br><span class="line">                <span class="comment">// = max(dp[i-1][1], dp[-1][0] - prices[i])</span></span><br><span class="line">                <span class="comment">// = max(dp[i-1][1], 0 - prices[i])</span></span><br><span class="line">                <span class="comment">// = max(dp[i-1][1], -prices[i])</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        	&#125;</span><br><span class="line"><span class="comment">// 写在for 循环内是不需要进行n==1 的判断的</span></span><br><span class="line">所以另一种写法，就是将i 从<span class="number">2</span> 开始遍历，那么 basecase 就在循环外定义  循环内无判断的操作</span><br><span class="line">即： </span><br><span class="line">    		<span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//有冷冻期 </span></span><br><span class="line">            <span class="keyword">if</span>(n&lt;<span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> dp[][] = <span class="keyword">new</span> <span class="title class_">int</span> [n][<span class="number">2</span>];</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">0</span>]= Math.max(dp[<span class="number">0</span>][<span class="number">0</span>],dp[<span class="number">0</span>][<span class="number">1</span>]+prices[<span class="number">1</span>]);</span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">1</span>]= Math.max(dp[<span class="number">0</span>][<span class="number">1</span>],-prices[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>k 为最多（固定值）次</p>
<p>此时方程为：</p>
</li>
</ul>
<p>​              <code>dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])</code></p>
<p>​              <code>dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])</code></p>
<pre><code> 特殊处理和上面一样  `for 循环嵌套处理 basecase`
</code></pre><p>​       此处需要嵌套循环，<code>多加一个 对 K 要进行穷举的循环</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">mk</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">      <span class="type">int</span> dp[][][] = <span class="keyword">new</span> <span class="title class_">int</span>[n][mk+<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> mk;k&gt;<span class="number">0</span>;k--)&#123;</span><br><span class="line">          dp[<span class="number">0</span>][k][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">          dp[<span class="number">0</span>][k][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> k= mk;k &gt; <span class="number">0</span>;k--)&#123;</span><br><span class="line">              dp[i][k][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][k][<span class="number">0</span>],dp[i-<span class="number">1</span>][k][<span class="number">1</span>]+prices[i]);</span><br><span class="line">              dp[i][k][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][k][<span class="number">1</span>],dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[n-<span class="number">1</span>][mk][<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;另一种解法：&lt;或者直接使用下面的一题的模板&gt;</span><br><span class="line">  	 <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">n</span>  <span class="operator">=</span>prices.length;</span><br><span class="line">      <span class="type">int</span> dp[][] = <span class="keyword">new</span> <span class="title class_">int</span> [n][<span class="number">5</span>];</span><br><span class="line">      dp[<span class="number">0</span>][<span class="number">0</span>] =  <span class="number">0</span>;</span><br><span class="line">      dp[<span class="number">0</span>][<span class="number">1</span>] =  -prices[<span class="number">0</span>];</span><br><span class="line">      dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">      dp[<span class="number">0</span>][<span class="number">3</span>] =  -prices[<span class="number">0</span>];</span><br><span class="line">      dp[<span class="number">0</span>][<span class="number">4</span>] =  <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">          <span class="comment">// 套娃操作</span></span><br><span class="line">          dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>];  <span class="comment">//不操作   可删</span></span><br><span class="line">          dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i]);    <span class="comment">// 买一次</span></span><br><span class="line">          dp[i][<span class="number">2</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">2</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i]);    <span class="comment">//卖一次</span></span><br><span class="line">          dp[i][<span class="number">3</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">3</span>],dp[i-<span class="number">1</span>][<span class="number">2</span>]-prices[i]);    <span class="comment">// 再买一次</span></span><br><span class="line">          dp[i][<span class="number">4</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">4</span>],dp[i-<span class="number">1</span>][<span class="number">3</span>]+prices[i]);    <span class="comment">// 再卖一次</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dp[n-<span class="number">1</span>][<span class="number">4</span>];  <span class="comment">// 最后一次状态是4</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>k 为最多（非固定值）次</li>
</ul>
<p>​    此时和上面 固定次数类似 只是需要对 k 进行缩小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (max_k &gt; n / <span class="number">2</span>) &#123;</span><br><span class="line">       <span class="comment">// 复用之前交易次数 k 没有限制的情况</span></span><br><span class="line">       <span class="keyword">return</span> maxProfit_k_inf(prices);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">          <span class="type">int</span>  <span class="variable">n</span>  <span class="operator">=</span>prices.length;</span><br><span class="line">          <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span>(k&gt; n/<span class="number">2</span>) <span class="keyword">return</span> maxProfitone(prices);   <span class="comment">//递归  不进行递归调用也能通过</span></span><br><span class="line">          <span class="type">int</span> dp [][][] = <span class="keyword">new</span> <span class="title class_">int</span> [n][k+<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span>k;j&gt;<span class="number">0</span>; j--)&#123;</span><br><span class="line">             <span class="keyword">if</span>(i-<span class="number">1</span>&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                 dp[i][j][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                 dp[i][j][<span class="number">1</span>] = -prices[i];</span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             dp[i][j][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][j][<span class="number">0</span>],dp[i-<span class="number">1</span>][j][<span class="number">1</span>]+prices[i]);</span><br><span class="line">             dp[i][j][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][j][<span class="number">1</span>],dp[i-<span class="number">1</span>][j-<span class="number">1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dp[n-<span class="number">1</span>][k][<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">maxProfitone</span><span class="params">( <span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">      <span class="type">int</span> dp[][]= <span class="keyword">new</span> <span class="title class_">int</span> [n][<span class="number">2</span>];</span><br><span class="line">      dp[<span class="number">0</span>][<span class="number">0</span>]= <span class="number">0</span>;</span><br><span class="line">      dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">          dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">          dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dp[n-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&gt;解法优化：&lt;代码减少&gt;</span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">          <span class="type">int</span>  <span class="variable">n</span>  <span class="operator">=</span>prices.length;</span><br><span class="line">          <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">          <span class="type">int</span> dp [][][] = <span class="keyword">new</span> <span class="title class_">int</span> [n][k+<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">  <span class="comment">// basecase </span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">          dp[<span class="number">0</span>][i][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span>k;j&gt;<span class="number">0</span>; j--)&#123;</span><br><span class="line">             dp[i][j][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][j][<span class="number">0</span>],dp[i-<span class="number">1</span>][j][<span class="number">1</span>]+prices[i]);</span><br><span class="line">             dp[i][j][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][j][<span class="number">1</span>],dp[i-<span class="number">1</span>][j-<span class="number">1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dp[n-<span class="number">1</span>][k][<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;另一种解法&lt;上面一题的模版&gt;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">          <span class="type">int</span>  <span class="variable">n</span>  <span class="operator">=</span>prices.length;</span><br><span class="line">          <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">          <span class="type">int</span> dp [][] = <span class="keyword">new</span> <span class="title class_">int</span> [n][<span class="number">2</span>*k+<span class="number">1</span>];</span><br><span class="line">          dp[<span class="number">0</span>][<span class="number">0</span>] =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>*k;j+=<span class="number">2</span>)&#123;</span><br><span class="line">              dp[<span class="number">0</span>][j+<span class="number">1</span>]= -prices[<span class="number">0</span>];</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">              <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>*k;j+=<span class="number">2</span>)&#123;</span><br><span class="line">                  dp[i][j+<span class="number">1</span>]= Math.max(dp[i-<span class="number">1</span>][j+<span class="number">1</span>],dp[i-<span class="number">1</span>][j]-prices[i]);</span><br><span class="line">                  dp[i][j+<span class="number">2</span>]= Math.max(dp[i-<span class="number">1</span>][j+<span class="number">2</span>],dp[i-<span class="number">1</span>][j+<span class="number">1</span>]+prices[i]);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> dp[n-<span class="number">1</span>][<span class="number">2</span>*k];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>最终答案：求的是 最终答案是 <code>dp[n - 1][K][0]</code></p>
</blockquote>
<h6 id="万里归一：全能答案-lt-不考虑时间空间复杂度-gt"><a href="#万里归一：全能答案-lt-不考虑时间空间复杂度-gt" class="headerlink" title="万里归一：全能答案&lt;不考虑时间空间复杂度&gt;"></a>万里归一：全能答案&lt;不考虑时间空间复杂度&gt;</h6><blockquote>
<p><strong>Q:</strong>股票价格数组 <code>prices</code>，你最多进行 <code>max_k</code> 次交易，每次交易需要额外消耗 <code>fee</code> 的手续费，而且每次交易之后需要经过 <code>cooldown</code> 天的冷冻期才能进行下一次交易，请你计算并返回可以获得的最大利润。</p>
<p><strong>A:</strong><code>int maxProfit_all_in_one(int max_k, int[] prices, int cooldown, int fee);</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit_all_in_one</span><span class="params">(<span class="type">int</span> max_k, <span class="type">int</span>[] prices, <span class="type">int</span> cooldown, <span class="type">int</span> fee)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">  <span class="type">int</span> dp[][][] = <span class="keyword">new</span> <span class="title class_">int</span>[n][max_k][<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">if</span>(n&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;<span class="comment">// 递归  k 为最多（非固定值）次</span></span><br><span class="line">  <span class="keyword">if</span>(max_k&gt;n/<span class="number">2</span>) <span class="keyword">return</span> maxProfit_k_inf(prices, cooldown, fee); </span><br><span class="line">&gt;<span class="comment">// 递归  k 为最多（非固定值）次</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;                  </span><br><span class="line">      dp[i][<span class="number">0</span>][<span class="number">1</span>] = Integer.MIN_VALUE;</span><br><span class="line">      dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">      <span class="comment">// 递归  k 为最多（非固定值）次</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> max_k; k&gt;<span class="number">0</span>; k--) &#123;</span><br><span class="line">          <span class="keyword">if</span> (i - <span class="number">1</span> == -<span class="number">1</span>) &#123;</span><br><span class="line">              dp[i][k][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">              dp[i][k][<span class="number">1</span>] = -prices[i] - fee;</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//存在冷冻期</span></span><br><span class="line">          <span class="keyword">if</span> (i - cooldown - <span class="number">1</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">              dp[i][k][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][k][<span class="number">0</span>], dp[i - <span class="number">1</span>][k][<span class="number">1</span>] + prices[i]);</span><br><span class="line">              dp[i][k][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][k][<span class="number">1</span>], -prices[i] - fee);</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">			<span class="comment">// k 为最多（非固定值）次</span></span><br><span class="line">          dp[i][k][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][k][<span class="number">0</span>], dp[i - <span class="number">1</span>][k][<span class="number">1</span>] + prices[i]);</span><br><span class="line">          <span class="comment">//存在冷冻期    含有手续费</span></span><br><span class="line">          dp[i][k][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][k][<span class="number">1</span>], dp[i - cooldown - <span class="number">1</span>][k - <span class="number">1</span>][<span class="number">0</span>] - prices[i] - fee);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[n-<span class="number">1</span>][max_k][<span class="number">0</span>];</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">private</span> <span class="type">int</span> <span class="title function_">maxProfit_k_inf</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> cooldown, <span class="type">int</span> fee)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">  <span class="type">int</span> dp[][]= <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(i-<span class="number">1</span> == -<span class="number">1</span>)&#123;</span><br><span class="line">          dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">          dp[i][<span class="number">1</span>] = -prices[i]-fee;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="comment">//存在冷冻期    含有手续费</span></span><br><span class="line">      <span class="keyword">if</span>(i-<span class="number">1</span>-cooldown &lt; <span class="number">0</span>)&#123;</span><br><span class="line">          dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);;</span><br><span class="line">          dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], -prices[i] - fee);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">       <span class="comment">//存在冷冻期    含有手续费</span></span><br><span class="line">      dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i-cooldown-<span class="number">1</span>][<span class="number">0</span>]-prices[i]-fee);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>  dp[n-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="玩游戏专题"><a href="#玩游戏专题" class="headerlink" title="玩游戏专题"></a>玩游戏专题</h3><h5 id="路径问题"><a href="#路径问题" class="headerlink" title="路径问题"></a>路径问题</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本的路径： 最小路径和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">            <span class="type">int</span>  <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> dp [][] =<span class="keyword">new</span> <span class="title class_">int</span> [m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">       <span class="comment">// dp[][] =min(dp[i][j-1],dp[i-1][j])+grid[i][j];</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//初始化：</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>]+grid[i][<span class="number">0</span>]; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i]= dp[<span class="number">0</span>][i-<span class="number">1</span>]+grid[<span class="number">0</span>][i]; </span><br><span class="line">        &#125; </span><br><span class="line">       </span><br><span class="line">        </span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j&lt; n;j++)&#123;</span><br><span class="line">               dp[i][j] =Math.min(dp[i][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j])+grid[i][j];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//解救公主  ： 上述问题的 倒序</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculateMinimumHP</span><span class="params">(<span class="type">int</span>[][] dungeon)</span> &#123;</span><br><span class="line">        <span class="comment">// 最小路径 逆向思维</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> dungeon.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> dungeon[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> dp[][] = <span class="keyword">new</span> <span class="title class_">int</span> [m][n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置左下角的值</span></span><br><span class="line">        dp[m-<span class="number">1</span>][n-<span class="number">1</span>]= Math.max(<span class="number">0</span>, -dungeon[m-<span class="number">1</span>][n-<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 设置最后一列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            dp[i][n-<span class="number">1</span>] = dp[i+<span class="number">1</span>][n-<span class="number">1</span>] - dungeon[i][n-<span class="number">1</span>];</span><br><span class="line">            dp[i][n-<span class="number">1</span>] = Math.max(dp[i][n-<span class="number">1</span>],<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置最后一行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            dp[m-<span class="number">1</span>][i] = dp[m-<span class="number">1</span>][i+<span class="number">1</span>]  -  dungeon[m-<span class="number">1</span>][i];</span><br><span class="line">            dp[m-<span class="number">1</span>][i] = Math.max(dp[m-<span class="number">1</span>][i],<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>  i=m-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span>  <span class="variable">j</span> <span class="operator">=</span> n-<span class="number">2</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i+<span class="number">1</span>][j],dp[i][j+<span class="number">1</span>]) - dungeon[i][j];</span><br><span class="line">                dp[i][j] = Math.max(<span class="number">0</span>,dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中转站  min消费</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findCheapestPrice</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] flights, <span class="type">int</span> src, <span class="type">int</span> dst, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//k+1+1 的原因是 将最后一个节点也理解成中转节点  或者理解为 k+1个边</span></span><br><span class="line">        <span class="type">int</span> dp[][] = <span class="keyword">new</span> <span class="title class_">int</span> [k+<span class="number">2</span>][n];</span><br><span class="line">        <span class="comment">// 找最小，所以全都初始化为 不可达</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt; dp.length;i++)&#123;</span><br><span class="line">            Arrays.fill(dp[i],Integer.MAX_VALUE-<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for(int []flight :flights)&#123;</span></span><br><span class="line">        <span class="comment">//     if(flight[0] == src)  dp[0][flight[1]] = flight[2];</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">//无论几次，从出发点到出发点总是花费为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; dp.length ; i++)&#123;</span><br><span class="line">            dp[i][src] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;i&lt;dp.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> []flight :flights)&#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> flight[<span class="number">0</span>];</span><br><span class="line">               <span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> flight[<span class="number">1</span>];</span><br><span class="line">               <span class="type">int</span> <span class="variable">cost</span> <span class="operator">=</span> flight[<span class="number">2</span>];</span><br><span class="line">               dp[i][to]=Math.min(dp[i][to],dp[i-<span class="number">1</span>][from]+cost);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> dp[k+<span class="number">1</span>][dst] == Integer.MAX_VALUE-<span class="number">10000</span>? -<span class="number">1</span>:dp[k+<span class="number">1</span>][dst];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><h4 id="本质："><a href="#本质：" class="headerlink" title="==本质：=="></a>==本质：==</h4><blockquote>
<ul>
<li>for 循环里面嵌套递归    以实现   n 个 for 循环</li>
<li><p>就是 <strong>其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」</strong></p>
</li>
<li><p>解决一个回溯问题，实际上就是一个决策树的遍历过程</p>
</li>
</ul>
</blockquote>
<h4 id="解决的问题："><a href="#解决的问题：" class="headerlink" title="解决的问题："></a>解决的问题：</h4><blockquote>
<ul>
<li>组合问题：N个数里面按一定规则找出k个数的集合</li>
<li>子集问题：一个N个数的集合里有多少符合条件的子集</li>
<li>排列问题：N个数按一定规则全排列，有几种排列方式</li>
<li>切割问题：一个字符串按一定规则有几种切割方式</li>
<li><p>棋盘问题：N皇后，解数独等等</p>
</li>
<li><p><strong>组合是不强调元素顺序的，排列是强调元素顺序</strong>。</p>
</li>
<li><p><strong>组合无序    排列有序</strong></p>
</li>
<li><p><strong>回溯法解决的问题都可以抽象为树形结构</strong>，指的是<strong>所有回溯法</strong>的问题<strong>都可以</strong>抽象为树形结构！</p>
</li>
<li><p>因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度，都构成的树的深度</strong>。</p>
</li>
<li><p>递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。</p>
</li>
</ul>
</blockquote>
<h4 id="录的三步曲："><a href="#录的三步曲：" class="headerlink" title="录的三步曲："></a>录的三步曲：</h4><blockquote>
<ul>
<li><p>回溯函数模板返回值以及参数</p>
</li>
<li><p>回溯算法中函数返回值一般为void</p>
</li>
<li><p>再来看一下参数，因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数</p>
</li>
<li><p>回溯函数终止条件</p>
</li>
<li><p>一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归</p>
</li>
<li><p>回溯搜索的遍历过程</p>
</li>
<li><p>回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">伪代码</span><br><span class="line"></span><br><span class="line">回溯函数伪代码如下：</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(参数)</span></span><br><span class="line"></span><br><span class="line">回溯函数终止条件伪代码</span><br><span class="line">    ```java</span><br><span class="line">    <span class="title function_">if</span> <span class="params">(终止条件)</span> &#123;</span><br><span class="line">               存放结果;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">       	&#125;</span><br></pre></td></tr></table></figure>
<p>回溯函数遍历过程伪代码<br>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">          处理节点;</span><br><span class="line">          backtracking(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">          回溯，撤销处理结果</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>回溯算法模板框架如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(参数)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">              存放结果;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">&gt;<span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">    处理节点;</span><br><span class="line">     backtracking(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">     回溯，撤销处理结果</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="dong-模版"><a href="#dong-模版" class="headerlink" title="dong 模版"></a>dong 模版</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">result = []</span><br><span class="line">def <span class="title function_">backtrack</span><span class="params">(路径, 选择列表)</span>:</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//for 选择 in 选择列表:</span></span><br><span class="line">       <span class="comment">// 做选择</span></span><br><span class="line">       <span class="comment">// backtrack(路径, 选择列表)</span></span><br><span class="line">        <span class="comment">//撤销选择</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> 选择 in 选择列表:</span><br><span class="line">            <span class="comment">// 做选择</span></span><br><span class="line">            将该选择从选择列表移除</span><br><span class="line">            路径.add(选择)</span><br><span class="line">            backtrack(路径, 选择列表)</span><br><span class="line">           <span class="comment">// 撤销选择</span></span><br><span class="line">            路径.remove(选择)</span><br><span class="line">            将该选择再加入选择列表</span><br><span class="line">            </span><br><span class="line"><span class="number">1</span>、路径：也就是已经做出的选择。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、选择列表：也就是你当前可以做的选择。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、结束条件：也就是到达决策树底层，无法再做选择的条件。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>DFS 和  回溯 区别：</p>
<ul>
<li>多叉树 DFS 遍历框架的前序位置和后序位置应该在 for 循环外面，并不应该是在 for 循环里面。而溯算法中跑到 for 循环里面了</li>
</ul>
<p>动态规划 和 回溯算法 区别与联系</p>
<ul>
<li>动态规划和回溯算法底层都把问题抽象成了树的结构，但这两种算法在思路上是完全不同的</li>
</ul>
<p>另外：</p>
<p>​    当遇到选择空间的个数（桶）很多时，我们应该以每次选择的次数（球）为<code>trackbacking</code>函数的for核心，也就是说：</p>
<p>我们应该尽量「少量多次」，就是说宁可多做几次选择（乘法关系），也不要给太大的选择空间（指数关系）；做 <code>n</code> 次「<code>k</code> 选一」仅重复一次（<code>O(k^n)</code>），比 <code>n</code> 次「二选一」重复 <code>k</code> 次（<code>O(k*2^n)</code>）效率低很多。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) &#123;&#125; <span class="comment">// nums[]是指球的个数 选择  √</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;而不是：  (  也就是leetcode  <span class="number">698</span> )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bucket.length; i++) &#123;&#125;    <span class="comment">//bucket[] 桶的个数 不选  ×</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202303221333571.png" alt="image-20230322133359518" style="zoom:25%;"></p>
<p><strong>前序遍历的代码在进入某一个节点之前的那个时间点执行</strong></p>
<p><strong>后序遍历代码在离开某个节点之后的那个时间点执行</strong></p>
<p><strong>写 <code>backtrack</code> 函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集</strong>。</p>
</blockquote>
<h4 id="我的步骤："><a href="#我的步骤：" class="headerlink" title="我的步骤："></a>我的步骤：</h4><blockquote>
<h6 id="1、写出两个集合"><a href="#1、写出两个集合" class="headerlink" title="1、写出两个集合"></a>1、写出两个集合</h6><p>一个用来存放符合条件单一结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();  <span class="comment">// 记录回溯算法的递归路径</span></span><br></pre></td></tr></table></figure>
<p>一个用来存放符合条件结果的集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h6 id="2、书写确定了返回值-和-参数-的函数"><a href="#2、书写确定了返回值-和-参数-的函数" class="headerlink" title="2、书写确定了返回值 和 参数 的函数"></a>2、书写确定了返回值 和 参数 的函数</h6><h6 id="3、确定终止条件"><a href="#3、确定终止条件" class="headerlink" title="3、确定终止条件"></a>3、确定终止条件</h6><h6 id="4、解决嵌套-for-循环的-递归-部分"><a href="#4、解决嵌套-for-循环的-递归-部分" class="headerlink" title="4、解决嵌套 for 循环的 递归  部分"></a>4、解决嵌套 for 循环的 递归  部分</h6></blockquote>
<h4 id="子集、组合、排列整合"><a href="#子集、组合、排列整合" class="headerlink" title="子集、组合、排列整合"></a>子集、组合、排列整合</h4><h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><blockquote>
<p>1、<strong>元素不可以重复</strong>，<strong>最多选一次</strong></p>
<p>2、<strong>元素可以重复</strong>，<strong>最多选一次</strong></p>
<p>3、<strong>元素不可以重复</strong>，<strong>可以选 n 次</strong></p>
</blockquote>
<h5 id="记住两张图"><a href="#记住两张图" class="headerlink" title="记住两张图"></a>记住两张图</h5><p><img src="https://labuladong.gitee.io/algo/images/排列组合/2.jpeg" alt="img" style="zoom:20%;">                      <img src="https://labuladong.gitee.io/algo/images/排列组合/1.jpeg" alt="img" style="zoom:20%;">     </p>
<blockquote>
<p><strong>首先，组合问题和子集问题其实是等价的，这个后面会讲；至于之前说的三种变化形式，无非是在这两棵树上剪掉或者增加一些树枝罢了</strong></p>
<p>==前置==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">// 记录回溯算法的结果集</span></span><br><span class="line">&gt;List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">&gt;<span class="comment">// 记录回溯算法的递归路径</span></span><br><span class="line">&gt;LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="1、元素不可以重复，最多选一次"><a href="#1、元素不可以重复，最多选一次" class="headerlink" title="1、元素不可以重复，最多选一次"></a><strong>1、元素不可以重复</strong>，<strong>最多选一次</strong></h6><blockquote>
<p>==公共部分==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 主函数</span></span><br><span class="line">&gt;<span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; .....(......) &#123;</span><br><span class="line"></span><br><span class="line">  backtrack(........);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 回溯算法核心函数，遍历子集问题的回溯树</span></span><br><span class="line">&gt;<span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(.......)</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//终止条件</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 回溯算法标准框架</span></span><br><span class="line">  <span class="keyword">for</span> (.......) &#123;</span><br><span class="line">      <span class="comment">// 做选择</span></span><br><span class="line">      track.addLast(nums[i]  /  i);</span><br><span class="line">      <span class="comment">// 递归</span></span><br><span class="line">      backtrack(......);  </span><br><span class="line">      <span class="comment">// 撤销选择    </span></span><br><span class="line">      track.removeLast();</span><br><span class="line">  &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>子集|组合中</strong>：</p>
<p>使用 <code>start</code> 变量保证元素 <code>nums[start]</code> 之后只会出现 <code>nums[start+1..]</code> 中的元素，通过固定元素的相对位置保证不出现重复的子集</p>
<p><strong>排列中</strong>：</p>
<p>额外使用 <code>used</code> 数组来标记哪些元素还可以被选择。</p>
<p>==子集==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;主函数:</span><br><span class="line"><span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">backtracking(nums,start);</span><br><span class="line"></span><br><span class="line">&gt;回溯函数:</span><br><span class="line">&gt;<span class="comment">// 加入集合</span></span><br><span class="line">result.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(track));</span><br><span class="line">&gt;<span class="comment">// 核心   i 从start 开始</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; nums.length; i++) &#123;</span><br><span class="line">&gt;<span class="comment">// 做选择</span></span><br><span class="line">      track.addLast(nums[i]);</span><br><span class="line">&gt;<span class="comment">//递归</span></span><br><span class="line">      backtracking(nums,i+<span class="number">1</span>);</span><br><span class="line">&gt;<span class="comment">//撤销选择   </span></span><br><span class="line">      track.removeLast();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<p>==组合==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;主函数:</span><br><span class="line"><span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">1</span>;     <span class="comment">//// 因为这里的数组是从 1 开始 所以也将元素下标从1 开始</span></span><br><span class="line">&gt;backtracking(start,k,n);</span><br><span class="line">&gt;<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&gt;回溯函数:</span><br><span class="line">&gt;<span class="comment">// 加入集合</span></span><br><span class="line">	<span class="keyword">if</span>(track.size() == k )&#123;</span><br><span class="line">      res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(track));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&gt;<span class="comment">// 核心   i 从start 开始</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start;i&lt;= n;i++)&#123;</span><br><span class="line">&gt;<span class="comment">// 做选择</span></span><br><span class="line">      track.addLast(i);</span><br><span class="line">&gt;<span class="comment">//递归</span></span><br><span class="line">      backtracking(i+<span class="number">1</span>,k,n);</span><br><span class="line">&gt;<span class="comment">//撤销选择   </span></span><br><span class="line">      track.removeLast();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>; </span><br></pre></td></tr></table></figure>
<p>==组合总和III==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&gt;主函数:</span><br><span class="line"><span class="type">int</span> nums[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"> <span class="keyword">if</span>(n&gt;<span class="number">55</span>)  <span class="keyword">return</span> res;</span><br><span class="line">&gt;<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">1</span>;     <span class="comment">// 因为这里的数组是从 1 开始 所以也将元素下标从 1 开始</span></span><br><span class="line">&gt;backtracking(nums,start,k,n);</span><br><span class="line">&gt;<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;回溯函数:</span><br><span class="line">&gt;<span class="comment">// 加入集合</span></span><br><span class="line">&gt;<span class="keyword">if</span>(n == sum &amp;&amp; track.size() == k )&#123;</span><br><span class="line">      res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(track));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&gt;<span class="comment">// 核心   i 从start 开始</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start;i&lt;= <span class="number">9</span> ;i++)&#123;     题目要求就是 固定长度 <span class="number">9</span></span><br><span class="line">&gt;<span class="comment">// 做选择</span></span><br><span class="line">      track.add(nums[i]);</span><br><span class="line">      sum += i;</span><br><span class="line">&gt;<span class="comment">//递归</span></span><br><span class="line">       backtracking(nums,i+<span class="number">1</span>,k,n);</span><br><span class="line">&gt;<span class="comment">//撤销选择   </span></span><br><span class="line">      track.removeLast();</span><br><span class="line">      sum -= i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>==全排列==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;主函数:</span><br><span class="line">&gt;<span class="keyword">if</span>(nums.length == <span class="number">0</span> )  <span class="keyword">return</span> res;</span><br><span class="line">  <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">boolean</span>  used[] = <span class="keyword">new</span> <span class="title class_">boolean</span> [nums.length];</span><br><span class="line">  backtracking(nums,used);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&gt;回溯函数:</span><br><span class="line">&gt;<span class="comment">// 加入集合</span></span><br><span class="line">&gt;<span class="keyword">if</span>(track.size() == nums.length)&#123;</span><br><span class="line">      res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(track));</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;<span class="comment">// 核心 i 从start 开始</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(used[i]) <span class="keyword">continue</span>;    <span class="comment">// 保证元素不重复</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 做选择</span></span><br><span class="line">      track.add(nums[i]);</span><br><span class="line">      used[i]= <span class="literal">true</span>;</span><br><span class="line">&gt;<span class="comment">//递归</span></span><br><span class="line">       backtracking(nums,used);</span><br><span class="line">&gt;<span class="comment">//撤销选择   </span></span><br><span class="line">    track.removeLast();</span><br><span class="line">      used[i]= <span class="literal">false</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>==总结==</p>
<p>​    其实最基本的框架都是一样的，无非就是在个基础上要 传的参数 有所区别 而需要的不同的定义有所不同罢了</p>
</blockquote>
<h6 id="2、元素可以重复，最多选一次"><a href="#2、元素可以重复，最多选一次" class="headerlink" title="2、元素可以重复，最多选一次"></a><strong>2、元素可以重复</strong>，<strong>最多选一次</strong></h6><blockquote>
<p><strong>子集 和 排列</strong> 本质和<strong>1、……</strong> 的内容是几乎没有区别的，就是添加 或者改变了几行而已</p>
<p>排序和 for循环添加的行的  目的是：<strong>保证相同元素在排列中的相对位置保持不变</strong>。</p>
<p><strong>排列</strong>：</p>
<p><strong>标准全排列算法之所以出现重复，是因为把相同元素形成的排列序列视为不同的序列，但实际上它们应该是相同的；而如果固定相同元素形成的序列顺序，当然就避免了重复</strong>。</p>
<p>==子集==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;主函数：</span><br><span class="line"> Arrays.sort(nums);</span><br><span class="line">&gt;<span class="keyword">for</span> 循环：</span><br><span class="line"> <span class="keyword">if</span> (i &gt; start &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">     <span class="keyword">continue</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>组合总和 和 <strong>1、</strong>是有些区别</p>
</blockquote>
<p>==组合总和II==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="type">int</span> <span class="variable">targetsum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&gt;主函数:</span><br><span class="line">  Arrays.sort(candidates);     </span><br><span class="line">  <span class="keyword">if</span>(candidates.length == <span class="number">0</span> )  <span class="keyword">return</span> result;</span><br><span class="line">  <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  backtracking(candidates,start,target);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&gt;回溯函数:</span><br><span class="line">&gt;<span class="comment">// 加入集合</span></span><br><span class="line">	<span class="keyword">if</span>(target &lt;  targetsum)   <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span>(target == targetsum)&#123;</span><br><span class="line">      result.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(track));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&gt;<span class="comment">// 核心   i 从start 开始</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>( i&gt;start &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] ) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 做选择</span></span><br><span class="line">       track.addLast(nums[i]);</span><br><span class="line">      targetsum += nums[i];</span><br><span class="line">&gt;<span class="comment">//递归</span></span><br><span class="line">      backtracking(nums,used);</span><br><span class="line">&gt;<span class="comment">//撤销选择   </span></span><br><span class="line">    	track.removeLast();</span><br><span class="line">      targetsum -= nums[i];</span><br><span class="line">&gt;&#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>其实上面的<strong>组合总和II</strong>  和  满足<strong>1、</strong>中的<strong>非组合总和III</strong>  的组合总和的形式也就多了两行</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;主函数：</span><br><span class="line">&gt;Arrays.sort(candidates);  </span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> 循环内</span><br><span class="line">&gt;<span class="keyword">if</span>( i&gt;start &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] ) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>
<p>==全排列==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;主函数：</span><br><span class="line">&gt;Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> 循环内</span><br><span class="line">&gt;<span class="keyword">if</span>( i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; !used[i-<span class="number">1</span>]) <span class="keyword">continue</span>;  <span class="comment">//!used[i-1]</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="3、元素不可以重复，可以选-n-次"><a href="#3、元素不可以重复，可以选-n-次" class="headerlink" title="3、元素不可以重复，可以选 n 次"></a><strong>3、元素不可以重复</strong>，<strong>可以选 n 次</strong></h6><blockquote>
<p>和<strong>1、….</strong> 反着来;也就是说：</p>
<p><strong>标准的子集/组合问题是如何保证不重复使用元素的</strong>？—在于 <code>backtrack</code> 递归时输入的参数 <code>start</code>;</p>
<p>下面只是和<strong>1、……</strong> 进行比较的差别</p>
<p>==组合总和==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">for</span>(.....)&#123;</span><br><span class="line">&gt;...</span><br><span class="line">&gt;backtracking(nums,i,target);</span><br><span class="line">&gt;...</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>下面为补充</p>
</blockquote>
<p>==子集==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;backtracking 函数：</span><br><span class="line">&gt;<span class="comment">//子集个数等于三的，因为子集的个数最大才是三  所以终止条件就是等于三的时候输出</span></span><br><span class="line">&gt;<span class="keyword">if</span>(track.size()  ==  candidates.length) &#123;</span><br><span class="line"> result.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(track));</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;result.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(track));  <span class="comment">//子集个数不为 &lt; 3的</span></span><br><span class="line"><span class="keyword">for</span>(...)&#123;</span><br><span class="line">  ....</span><br><span class="line">&gt;backtracking(candidates,i); <span class="comment">// 实现结果 不会出现  1，2，1  和 1，1，2 的情况</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>==全排列==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;LinkedList&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">&gt;LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">&gt;<span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>)  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    backtracking(nums);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(track.size() == nums.length) &#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i&lt; nums.length;i++) &#123;</span><br><span class="line">        track.add(nums[i]);</span><br><span class="line">        backtracking(nums);</span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>相比之下，<strong>全排列</strong>就是将  used[] 数组这一判定条件有关的代码  <strong>全部去除</strong></p>
<p><strong>子集</strong>要加上 终止条件 （栈元素 大小 <strong>等于</strong> 元素个数），否则会 栈溢出；而且在小于 元素个数的时候也要加到栈中，</p>
</blockquote>
<h4 id="棋盘问题："><a href="#棋盘问题：" class="headerlink" title="棋盘问题："></a>棋盘问题：</h4><h6 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h6><h6 id="解数独："><a href="#解数独：" class="headerlink" title="解数独："></a>解数独：</h6><blockquote>
<p><strong>我们并不想得到所有合法的答案，只想要一个答案</strong></p>
<p>只要用一个外部变量(boolean型)记录是否找到答案，找到答案后就停止继续递归即可：</p>
</blockquote>
<h4 id="分割问题"><a href="#分割问题" class="headerlink" title="分割问题"></a>分割问题</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//93 复位IP</span></span><br><span class="line"></span><br><span class="line">     List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 分成的段数</span></span><br><span class="line">    LinkedList&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        backtracking(s,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>  res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(String s, <span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">        <span class="comment">//当已经 分为四段的时候就需要 将其对每一段进行加 . 进行分割</span></span><br><span class="line">        <span class="keyword">if</span>(startIndex == s.length() &amp;&amp; path.size() == <span class="number">4</span>)&#123;</span><br><span class="line">            res.add(String.join(<span class="string">&quot;.&quot;</span>,path));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//短短几行回溯   </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="comment">// 如果不是合法字符串</span></span><br><span class="line">            <span class="keyword">if</span>(!isValid(s,startIndex,i)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//是合法的</span></span><br><span class="line">            <span class="keyword">if</span>(path.size()&gt;=<span class="number">4</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 这里是将 遍历的满足下标的子串放进path中</span></span><br><span class="line">            path.add(s.substring(startIndex,i+<span class="number">1</span>));</span><br><span class="line">            backtracking(s,i+<span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主要是判断合法性的函数</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s,<span class="type">int</span> startIndex,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> end-startIndex+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(length&lt;=<span class="number">0</span> || length&gt;<span class="number">3</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(length == <span class="number">1</span> ) <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//不能和&lt;=2合并</span></span><br><span class="line">        <span class="comment">// 排除的是startIndex </span></span><br><span class="line">         <span class="keyword">if</span>(s.charAt(startIndex) == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         <span class="keyword">if</span>(length &lt;=<span class="number">2</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">if</span>(Integer.parseInt(s.substring(startIndex,startIndex+length))&gt;<span class="number">255</span>)    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><h4 id="贪心选择性质"><a href="#贪心选择性质" class="headerlink" title="贪心选择性质:"></a>贪心选择性质:</h4><blockquote>
<p>简单说就是：</p>
<p>每一步都做出一个局部最优的选择，最终的结果就是全局最优。</p>
<p>注意!这是一种特殊性质，其实只有一部分问题拥有这个性质</p>
<p>==注==</p>
<p><strong>排序</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">// Arrays.sort(points,(a,b)-&gt;(a[1]-b[1]));// 可能出现溢出情况</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// Arrays.sort(points,Comparator.comparingInt(a-&gt;a[1]));//升序排序 解决溢出方法2  效率较低 调用内置静态方法， 效率较低</span></span><br><span class="line"></span><br><span class="line">&gt;Arrays.sort(points,(a,b)-&gt;&#123;</span><br><span class="line">   <span class="keyword">if</span>(a[<span class="number">1</span>]&gt;b[<span class="number">1</span>]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span>(a[<span class="number">1</span>]&lt;b[<span class="number">1</span>]) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//上述方法可能溢出 解决方法1</span></span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>时间安排的问题，本质上讲就是区间调度问题，十有八九得排序，然后找规律来解决。</strong></p>
</blockquote>
<h4 id="一位数组的游戏"><a href="#一位数组的游戏" class="headerlink" title="一位数组的游戏"></a>一位数组的游戏</h4><blockquote>
<p>跳跃游戏 目标终点是 <code>nums.length-1</code></p>
<p>55 题：可以使用<code>最大跳数</code>作为能否到达终点的判断会更好一点</p>
</blockquote>
<h4 id="二维数组的区间问题："><a href="#二维数组的区间问题：" class="headerlink" title="二维数组的区间问题："></a>二维数组的区间问题：</h4><blockquote>
<p>&lt;就是 线段问题；合并线段、找交集…&gt;</p>
<p><a href="https://labuladong.gitee.io/algo/di-san-zha-24031/jing-dian--a94a0/yi-ge-fang-93124/">区间问题合集</a> : 区间交集、区间并集、区间覆盖这几个问题。</p>
</blockquote>
<h5 id="做法："><a href="#做法：" class="headerlink" title="做法："></a>做法：</h5><blockquote>
<p>==1、排序==</p>
<p>常见的排序方法就是按照区间起点排序，或者先按照起点升序排序，若起点相同，则按照终点降序排序。当然，如果你非要按照终点排序，无非对称操作，本质都是一样的。</p>
<p>==2、画图==</p>
<p>就是说不要偷懒，勤动手，两个区间的相对位置到底有几种可能，不同的相对位置我们的代码应该怎么去处理。</p>
</blockquote>
<p><strong>区间问题肯定按照区间的起点或者终点进行排序</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//排序代码：</span></span><br><span class="line">     Arrays.sort(intervals, (a, b) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 对 起点 进行升序排序</span></span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>]&gt;b[<span class="number">0</span>]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>]&lt;b[<span class="number">0</span>]) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 对 终点 进行降序排序</span></span><br><span class="line">            <span class="keyword">return</span> b[<span class="number">1</span>] - a[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//打印排序之后的代码</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; intervals[i].length; j++) &#123;</span><br><span class="line">                    System.out.print(intervals[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">        &#125; </span><br></pre></td></tr></table></figure>
<h5 id="问题分类："><a href="#问题分类：" class="headerlink" title="问题分类："></a>问题分类：</h5><h6 id="求重叠区间个数一类题："><a href="#求重叠区间个数一类题：" class="headerlink" title="求重叠区间个数一类题："></a>求重叠区间个数一类题：</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义初始时的变量</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>   / <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span> ;i&lt;intervals.length;i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(intervals[i][<span class="number">0</span>]&lt; intervals[i-<span class="number">1</span>][<span class="number">1</span>])&#123;</span><br><span class="line">              <span class="comment">// 取 最小 右侧并集</span></span><br><span class="line">              intervals[i][<span class="number">1</span>] = Math.min(intervals[i][<span class="number">1</span>],intervals[i-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">              res++;</span><br><span class="line">          &#125;  </span><br><span class="line">      &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="求完全覆盖一类题"><a href="#求完全覆盖一类题" class="headerlink" title="求完全覆盖一类题"></a>求完全覆盖一类题</h6><blockquote>
<p>==需要分类讨论==</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分为三种情况</span></span><br><span class="line">        <span class="comment">//覆盖、相交、不相交</span></span><br><span class="line">        <span class="comment">//定义初始时的变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;intervals.length;i++)&#123;</span><br><span class="line"><span class="comment">//完全覆盖时覆盖</span></span><br><span class="line">        <span class="keyword">if</span>(left&lt;= intervals[i][<span class="number">0</span>] &amp;&amp;  right &gt;= intervals[i][<span class="number">1</span>])&#123;</span><br><span class="line">            res ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//相交，取最大 右侧并集</span></span><br><span class="line">            <span class="keyword">if</span>(right&gt;=intervals[i][<span class="number">0</span>])&#123;</span><br><span class="line">                right = Math.max(right,intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不相交</span></span><br><span class="line">            <span class="keyword">if</span>(right &lt; intervals[i][<span class="number">0</span>])&#123;</span><br><span class="line">                left = intervals[i][<span class="number">0</span>];</span><br><span class="line">                right=intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<h6 id="求合并（并集）类题"><a href="#求合并（并集）类题" class="headerlink" title="求合并（并集）类题"></a>求合并（并集）类题</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;<span class="type">int</span>[]&gt; result =  <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 将结果集存放排好序之后的第一个元素</span></span><br><span class="line">result.add(intervals[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;i&lt; intervals.length;i++)&#123;</span><br><span class="line">            <span class="comment">// 取结果集中的元素和当前元素进行比较、</span></span><br><span class="line">            <span class="comment">// 如果当前元素 左坐标比结果集的最后一个元素 右坐标小，</span></span><br><span class="line">    		<span class="comment">//则将结果集的最后一个元素进行合并，并加入结果集，成为末尾元素</span></span><br><span class="line">              </span><br><span class="line"><span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &lt;= result.getLast()[<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="comment">//开始坐标就是 结果集 中的 结尾坐标的左节点</span></span><br><span class="line"><span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> result.getLast()[<span class="number">0</span>];</span><br><span class="line">                <span class="comment">//结束坐标就是 当前比较的坐标的最大节点</span></span><br><span class="line"><span class="type">int</span> <span class="variable">end</span>  <span class="operator">=</span> Math.max(intervals[i][<span class="number">1</span>],result.getLast()[<span class="number">1</span>]);</span><br><span class="line">                <span class="comment">// 移除结果集中的 最后一个坐标 </span></span><br><span class="line">result.removeLast();</span><br><span class="line">                <span class="comment">// 并将当前坐标加入结果集</span></span><br><span class="line">result.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;start,end&#125;);</span><br><span class="line">            <span class="comment">// 如果当前元素 左坐标比结果集的最后一个元素 右坐标大，</span></span><br><span class="line">    		<span class="comment">//则将当前元素直接加入结果集，成为末尾元素</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> result.add(intervals[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[result.size()][]);</span><br></pre></td></tr></table></figure>
<h6 id="求交集类题"><a href="#求交集类题" class="headerlink" title="求交集类题"></a>求交集类题</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求交集</span></span><br><span class="line">            LinkedList&lt;<span class="type">int</span> []&gt;  result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">//双指针</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">while</span>(first &lt; firstList.length  &amp;&amp;  second &lt; secondList.length)&#123;</span><br><span class="line">               <span class="comment">//左边取最大值</span></span><br><span class="line">               <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> Math.max(firstList[first][<span class="number">0</span>],secondList[second][<span class="number">0</span>]);</span><br><span class="line">               <span class="comment">//右边取最小值</span></span><br><span class="line">               <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> Math.min(firstList[first][<span class="number">1</span>],secondList[second][<span class="number">1</span>]);</span><br><span class="line">                <span class="comment">//能够满足基本的区间成立条件</span></span><br><span class="line">               <span class="keyword">if</span>(left &lt;= right)     result.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;left,right&#125;);</span><br><span class="line">               <span class="keyword">if</span>(firstList[first][<span class="number">1</span>]&lt; secondList[second][<span class="number">1</span>])&#123;</span><br><span class="line">                   first++;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   second++;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">            <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>][]);</span><br></pre></td></tr></table></figure>
<h6 id="求拼接类题"><a href="#求拼接类题" class="headerlink" title="求拼接类题"></a>求拼接类题</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(clips[<span class="number">0</span>][<span class="number">0</span>] != <span class="number">0</span> )   <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">nexttime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;clips.length;i++)&#123;</span><br><span class="line">   <span class="comment">//新的 左侧边界 比start 大的时候</span></span><br><span class="line"><span class="keyword">if</span>(clips[i][<span class="number">0</span>] &gt; start)&#123;</span><br><span class="line">     start = nexttime ;  <span class="comment">//将 start 赋值为  上一轮的nexttime, 此时出现了新的start</span></span><br><span class="line">     res++;          <span class="comment">//出现新的 start 再++</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(clips[i][<span class="number">0</span>] &lt;= start)&#123;  <span class="comment">////新的 左侧边界 比start 小的时候 不一定替换</span></span><br><span class="line">      nexttime = Math.max(nexttime, clips[i][<span class="number">1</span>]);   <span class="comment">//出现新的nexttime</span></span><br><span class="line">      <span class="keyword">if</span>(nexttime &gt;= time) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(nexttime &lt; time)   <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="==DFS=="></a>==DFS==</h2><h4 id="一般模版"><a href="#一般模版" class="headerlink" title="一般模版"></a>一般模版</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">boolean</span>[][] visited)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n) &#123;</span><br><span class="line">        <span class="comment">// 超出索引边界</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (visited[i][j]) &#123;</span><br><span class="line">        <span class="comment">// 已遍历过 (i, j)</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进入节点 (i, j)</span></span><br><span class="line">    visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">    dfs(grid, i - <span class="number">1</span>, j, visited); <span class="comment">// 上</span></span><br><span class="line">    dfs(grid, i + <span class="number">1</span>, j, visited); <span class="comment">// 下</span></span><br><span class="line">    dfs(grid, i, j - <span class="number">1</span>, visited); <span class="comment">// 左</span></span><br><span class="line">    dfs(grid, i, j + <span class="number">1</span>, visited); <span class="comment">// 右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方向数组，</span></span><br><span class="line"><span class="comment">//分别代表上、下、左、右</span></span><br><span class="line"><span class="type">int</span>[][] dirs = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,-<span class="number">1</span>&#125;, &#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">boolean</span>[][] visited)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n) &#123;</span><br><span class="line">        <span class="comment">// 超出索引边界</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (visited[i][j]) &#123;</span><br><span class="line">        <span class="comment">// 已遍历过 (i, j)</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入节点 (i, j)</span></span><br><span class="line">    visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 递归遍历上下左右的节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] d : dirs) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">next_i</span> <span class="operator">=</span> i + d[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">next_j</span> <span class="operator">=</span> j + d[<span class="number">1</span>];</span><br><span class="line">        dfs(grid, next_i, next_j, visited);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 离开节点 (i, j)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二维数组（网格）中的DFS"><a href="#二维数组（网格）中的DFS" class="headerlink" title="二维数组（网格）中的DFS"></a>二维数组（网格）中的DFS</h4><p>一般的位置为上下左右 的4 个位置&lt;==比如经典的岛屿问题==&gt;</p>
<p>也可能是上下左右  左上左下  右上右下  的8 个位置</p>
<h5 id="引入："><a href="#引入：" class="headerlink" title="引入："></a><strong>引入：</strong></h5><p>先理解一下二叉树的 递归（DFS 遍历）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断 base case      ---------要素1</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 访问两个相邻结点：左子结点、右子结点--------要素2</span></span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="网格"><a href="#网格" class="headerlink" title="网格"></a>网格</h5><h6 id="两个要素"><a href="#两个要素" class="headerlink" title="两个要素"></a>两个要素</h6><ul>
<li><strong>basecase</strong></li>
</ul>
<p>就是   网格中不需要继续遍历、<code>grid[r][c]</code> 会出现数组下标越界异常的格子 即：</p>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304191221218.png" alt="image-20230419122140180" style="zoom:25%;"></p>
<blockquote>
<p>这一点稍微有些反直觉，坐标竟然可以临时超出网格的范围？</p>
<p>可以称之为  「先污染后治理」—— 甭管当前是在哪个格子，先往四个方向走一步再说，如果发现走出了网格范围再赶紧返回。</p>
<p>这跟二叉树的遍历方法是一样的，先递归调用，发现 root == null 再返回。</p>
</blockquote>
<ul>
<li><strong>相邻节点   ————四叉结构</strong></li>
</ul>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304191219258.png" style="zoom:25%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断 base case</span></span><br><span class="line">    <span class="comment">// 如果坐标 (r, c) 超出了网格范围，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!inArea(grid, r, c)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 访问上、下、左、右四个相邻结点</span></span><br><span class="line">    dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">    dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断坐标 (r, c) 是否在网格中</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">inArea</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt;= r &amp;&amp; r &lt; grid.length </span><br><span class="line">        	&amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="如何避免遇到的重复情况呢"><a href="#如何避免遇到的重复情况呢" class="headerlink" title="如何避免遇到的重复情况呢"></a>如何避免遇到的重复情况呢</h5><ul>
<li><p>就是再使用一个变量（visited）将所有经过的节点 都进行标记</p>
</li>
<li><p>或者    如果是节省空间的话还可以 在其基础上直接更改当前位置的值比如： 直接将<code>grid[i][j]=1</code>改为 <code>grid[i][j] = 2</code>;</p>
</li>
</ul>
<p>岛屿类问题的解法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>题目</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://leetcode.cn/problems/number-of-enclaves/">1020. 飞地的数量</a></td>
</tr>
<tr>
<td><a href="https://leetcode.cn/problems/number-of-closed-islands/">1254. 统计封闭岛屿的数目</a></td>
</tr>
<tr>
<td><a href="https://leetcode.cn/problems/count-sub-islands/">1905. 统计子岛屿</a></td>
</tr>
<tr>
<td><a href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></td>
</tr>
<tr>
<td><a href="https://leetcode.cn/problems/max-area-of-island/">695. 岛屿的最大面积</a></td>
</tr>
<tr>
<td>[463 岛屿的周长][<a href="https://leetcode.cn/problems/island-perimeter/">https://leetcode.cn/problems/island-perimeter/</a>]</td>
</tr>
<tr>
<td>[130 被围绕的区域][<a href="https://leetcode.cn/problems/surrounded-regions/">https://leetcode.cn/problems/surrounded-regions/</a>]</td>
</tr>
</tbody>
</table>
</div>
<p>上面的5 题的<code>dfs</code>函数代码都是一样的</p>
<blockquote>
<p>dfs的主要操作  : 在岛屿问题中的主要操作 就是 将遍历过的点  用海水继续覆盖掉  防止走回头路</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dfs</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> [][]grid, <span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> m=grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span>||i&gt;=m||j&gt;=n  || grid[i][j] != 陆地) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] != 陆地) <span class="keyword">return</span> ;</span><br><span class="line">		<span class="comment">// dfs  的主要操作</span></span><br><span class="line">        grid[i][j] = 非海水、非陆地de值;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//相邻节点</span></span><br><span class="line">        dfs(grid,i-<span class="number">1</span>,j);</span><br><span class="line">        dfs(grid,i+<span class="number">1</span>,j);</span><br><span class="line">        dfs(grid,i,j-<span class="number">1</span>);</span><br><span class="line">        dfs(grid,i,j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//特别的是：岛屿的最大面积</span></span><br><span class="line"><span class="comment">// 相邻节点 应该这么写</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> [][]grid, <span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">   <span class="type">int</span> m=grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span>||i&gt;=m||j&gt;=n  || grid[i][j] != 陆地) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] != 陆地) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// dfs  的主要操作</span></span><br><span class="line">        grid[i][j] = 非海水、非陆地de值;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dfs(grid,i,j-<span class="number">1</span>)+</span><br><span class="line">        dfs(grid,i,j+<span class="number">1</span>)+</span><br><span class="line">        dfs(grid,i-<span class="number">1</span>,j)+</span><br><span class="line">        dfs(grid,i+<span class="number">1</span>,j)+<span class="number">1</span> ;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//周长</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> [][]grid, <span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">   <span class="type">int</span> m=grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span>||i&gt;=m||j&gt;=n  || grid[i][j] != 陆地) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] != 陆地)   <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">		<span class="comment">// dfs  的主要操作</span></span><br><span class="line">        grid[i][j] = <span class="string">&quot;非海水、非陆地de值&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dfs(grid,i,j-<span class="number">1</span>)+</span><br><span class="line">        dfs(grid,i,j+<span class="number">1</span>)+</span><br><span class="line">        dfs(grid,i-<span class="number">1</span>,j)+</span><br><span class="line">        dfs(grid,i+<span class="number">1</span>,j)+<span class="number">1</span> ;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>主函数代码</code></p>
<blockquote>
<p>值得注意的是  <code>每一次 dfs 之后就会将 所有的 陆地  置为  0  所以每一次的开始 dfs 的条件就是   if(grid[i][j] == 陆地)</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  ...;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//200</span></span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span>(grid[i][j] == 陆地)&#123;</span><br><span class="line">     res++;            </span><br><span class="line">     dfs(grid,i,j);  <span class="comment">// dfs找到所有的 链接岛屿群 并淹没  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>  res;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1254</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">     dfs(grid,<span class="number">0</span>,i);</span><br><span class="line">     dfs(grid,m-<span class="number">1</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    dfs(grid,i,<span class="number">0</span>);</span><br><span class="line">    dfs(grid,i,n-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(grid[i][j] == 陆地)&#123;</span><br><span class="line">    res++;  </span><br><span class="line">    dfs(grid,i,j);  <span class="comment">// dfs找到所有的 链接岛屿群 并淹没  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>  res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1020</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">     dfs(grid,<span class="number">0</span>,i);</span><br><span class="line">     dfs(grid,m-<span class="number">1</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    dfs(grid,i,<span class="number">0</span>);</span><br><span class="line">    dfs(grid,i,n-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(grid[i][j] == 陆地)&#123;</span><br><span class="line">    res++;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>  res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1905</span></span><br><span class="line"><span class="comment">//先将在  grid2是陆地  和在   grid1 是海水   地方 在grid2 中全部设置为 海水</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid1.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;grid1[<span class="number">0</span>].length ; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid2[i][j] ==<span class="number">1</span> &amp;&amp; grid1[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    dfs(grid2,i,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 现在 grid2 中剩下的岛屿都是子岛，计算岛屿数量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid2[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    dfs(grid2,i,j);</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  res;</span><br><span class="line"></span><br><span class="line"><span class="comment">//695</span></span><br><span class="line">  		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] ==<span class="number">1</span>)&#123;</span><br><span class="line">                    res = Math.max(res,dfs(grid,i,j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;  </span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"><span class="comment">//463</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] ==<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span>  dfs(grid,i,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//130</span></span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> board.length;  <span class="comment">//行</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board[<span class="number">0</span>].length;  <span class="comment">//列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[<span class="number">0</span>][i] == <span class="string">&#x27;O&#x27;</span>)   dfs(board,<span class="number">0</span>,i);</span><br><span class="line">            <span class="keyword">if</span>(board[m-<span class="number">1</span>][i] == <span class="string">&#x27;O&#x27;</span>) dfs(board,m-<span class="number">1</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span>)   dfs(board,i,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(board[i][n-<span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>) dfs(board,i,n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;#&#x27;</span>)    board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;O&#x27;</span>)    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="一道困难的DFS"><a href="#一道困难的DFS" class="headerlink" title="==一道困难的DFS=="></a>==一道困难的DFS==</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//827(两次bfs   一次遍历海水  一次遍历陆地)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestIsland</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">areaMark</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一次  DFS 进行 各个陆地的面积 计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> dfs(grid, i, j,areaMark);</span><br><span class="line">                    map.put(areaMark,area);</span><br><span class="line">                    areaMark++;</span><br><span class="line">                    res = Math.max(res, area);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(res == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二次  DFS  进行海水 变陆地</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    HashSet&lt;Integer&gt; hashset = dfs2(grid, i, j); <span class="comment">//把上下左右四邻放入set里，set的目的是去重</span></span><br><span class="line">                    <span class="keyword">if</span> (hashset.size() &lt; <span class="number">1</span>)  <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">addIsland</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span> (Integer set : hashset) &#123;</span><br><span class="line">                        addIsland += map.get(set);</span><br><span class="line">                        res = Math.max(res, addIsland);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> areaMark)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i&gt;=m ||j &gt;= n || j &lt; <span class="number">0</span> || i &lt; <span class="number">0</span> || grid[i][j] != <span class="number">1</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 标记为已经遍历过了</span></span><br><span class="line">        grid[i][j] = areaMark;</span><br><span class="line">        <span class="comment">// 就是求飞地的数量</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+dfs(grid, i-<span class="number">1</span>, j,areaMark) + dfs(grid, i+<span class="number">1</span>, j, areaMark)+</span><br><span class="line">                dfs(grid, i, j-<span class="number">1</span>,areaMark) + dfs(grid, i, j+<span class="number">1</span>, areaMark) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HashSet&lt;Integer&gt; <span class="title function_">dfs2</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span>&lt;m &amp;&amp; j &lt; n &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; i+<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i+<span class="number">1</span>][j] != <span class="number">0</span>)</span><br><span class="line">        set.add(grid[i+<span class="number">1</span>][j]);</span><br><span class="line">       <span class="keyword">if</span>(i-<span class="number">1</span>&lt;m &amp;&amp; j &lt; n &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; i-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i-<span class="number">1</span>][j] != <span class="number">0</span>)</span><br><span class="line">        set.add(grid[i-<span class="number">1</span>][j]);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;m &amp;&amp; j+<span class="number">1</span>&lt; n &amp;&amp; j+<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; i &gt;= <span class="number">0</span> &amp;&amp; grid[i][j+<span class="number">1</span>] != <span class="number">0</span>)</span><br><span class="line">        set.add(grid[i][j+<span class="number">1</span>]);</span><br><span class="line">       <span class="keyword">if</span>(i&lt;m &amp;&amp; j-<span class="number">1</span> &lt; n &amp;&amp; j-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; i &gt;= <span class="number">0</span> &amp;&amp; grid[i][j-<span class="number">1</span>] != <span class="number">0</span>)</span><br><span class="line">        set.add(grid[i][j-<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> set;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="8个方向"><a href="#8个方向" class="headerlink" title="8个方向"></a>8个方向</h4><h5 id="扫雷游戏"><a href="#扫雷游戏" class="headerlink" title="扫雷游戏"></a>扫雷游戏</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DFS</span></span><br><span class="line">    <span class="type">int</span> dirs[][] = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">//M  X  1-8  都是和地雷相关</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span>[][] updateBoard(<span class="type">char</span>[][] board, <span class="type">int</span>[] click) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> click[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> click[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">            board[i][j] =<span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dfs(board,i,j);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; dirs.length; k++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newx</span> <span class="operator">=</span> i + dirs[k][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">newy</span> <span class="operator">=</span> j + dirs[k][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(newy &lt; <span class="number">0</span> || newx &lt; <span class="number">0</span> || newx &gt;= board.length || newy &gt;= board[<span class="number">0</span>].length) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(board[newx][newy] == <span class="string">&#x27;M&#x27;</span>) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(count &gt; <span class="number">0</span>) board[i][j] = (<span class="type">char</span>)(count+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            board[i][j] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; dirs.length; k++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">newx</span> <span class="operator">=</span> i + dirs[k][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">newy</span> <span class="operator">=</span> j + dirs[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(newy &lt; <span class="number">0</span> || newx &lt; <span class="number">0</span> || newx &gt;= board.length || newy &gt;= board[<span class="number">0</span>].length || board[newx][newy] !=<span class="string">&#x27;E&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                dfs(board, newx, newy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BFS</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dirs[][] = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">//M  X  1-8  都是和地雷相关</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span>[][] updateBoard(<span class="type">char</span>[][] board, <span class="type">int</span>[] click) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> board.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> click[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> click[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//&#x27;X&#x27; 则表示一个 已挖出的 地雷  如果一个地雷（&#x27;M&#x27;）被挖出，游戏就结束了- 把它改为 &#x27;X&#x27; </span></span><br><span class="line">        <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">            board[i][j] =<span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//bfs处理 E B  数字 三者逻辑</span></span><br><span class="line">            bfs(board,i,j);</span><br><span class="line"><span class="comment">//如果在此次点击中，若无更多方块可被揭露，则返回盘面。</span></span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">boolean</span> visited[][] = <span class="keyword">new</span> <span class="title class_">boolean</span>[board.length][board[<span class="number">0</span>].length];</span><br><span class="line"></span><br><span class="line">        queue.offer(i);</span><br><span class="line">        queue.offer(j);</span><br><span class="line">        visited[i][j] =<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; dirs.length; k++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">newx</span> <span class="operator">=</span> x + dirs[k][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">newy</span> <span class="operator">=</span> y + dirs[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(newy &lt; <span class="number">0</span> || newx &lt; <span class="number">0</span> || newx &gt;= board.length || newy &gt;= board[<span class="number">0</span>].length) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(board[newx][newy] == <span class="string">&#x27;M&#x27;</span>) count++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果一个 至少与一个地雷相邻 的空方块（&#x27;E&#x27;）被挖出，修改它为数字（&#x27;1&#x27; 到 &#x27;8&#x27; ），表示相邻地雷的数量。</span></span><br><span class="line">            <span class="keyword">if</span>(count &gt; <span class="number">0</span>) board[x][y] = (<span class="type">char</span>)(count+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 如果一个 没有相邻地雷 的空方块（&#x27;E&#x27;）被挖出，修改它为（&#x27;B&#x27;），并且所有和其相邻的 未挖出 方块都应该被递归地揭露。</span></span><br><span class="line">                board[x][y] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; dirs.length; k++) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">newx</span> <span class="operator">=</span> x + dirs[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="type">int</span> <span class="variable">newy</span> <span class="operator">=</span> y + dirs[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(newy &lt; <span class="number">0</span> || newx &lt; <span class="number">0</span> || newx &gt;= board.length || newy &gt;= board[<span class="number">0</span>].length || board[newx][newy] !=<span class="string">&#x27;E&#x27;</span> || visited[newx][newy]) <span class="keyword">continue</span>;</span><br><span class="line">                        queue.offer(newx);</span><br><span class="line">                        queue.offer(newy);</span><br><span class="line">                        visited[newx][newy] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="树-图的DFS"><a href="#树-图的DFS" class="headerlink" title="树/图的DFS"></a>树/图的DFS</h4><h5 id="困难一"><a href="#困难一" class="headerlink" title="困难一"></a>困难一</h5><blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">// 332</span></span><br><span class="line">&gt;<span class="comment">// 困难 的 回溯  安排行程    所有的机票 必须都用一次 且 只能用一次</span></span><br><span class="line">&gt;List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();     <span class="comment">// 结果集</span></span><br><span class="line">&gt;LinkedList&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();    <span class="comment">// 路径</span></span><br><span class="line">&gt;<span class="type">boolean</span>  visited[];</span><br><span class="line">&gt;<span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findItinerary</span><span class="params">(List&lt;List&lt;String&gt;&gt; tickets)</span> &#123;</span><br><span class="line"></span><br><span class="line">   visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[tickets.size()+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对  目的地(下标为 1)进行  排序</span></span><br><span class="line">  Collections.sort(tickets,(o1,o2) -&gt; o1.get(<span class="number">1</span>).compareTo(o2.get(<span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始</span></span><br><span class="line">  path.add(<span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">&gt;<span class="comment">//细节一: 强转为 ArrayList</span></span><br><span class="line">  trackback((ArrayList) tickets);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">//细节二: </span></span><br><span class="line">&gt;<span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">trackback</span><span class="params">(ArrayList&lt;List&lt;String&gt;&gt; tickets)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(path.size() == tickets.size()+<span class="number">1</span>)&#123; <span class="comment">//找到 符合的所有路径  </span></span><br><span class="line">      res =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;                     <span class="comment">//结束回溯</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tickets.size(); i++) &#123;</span><br><span class="line">      <span class="comment">// 未访问过    &amp;&amp;    本票的 出发地  是队列中 最后一个元素（上一个票的 目的地）</span></span><br><span class="line">      <span class="keyword">if</span>(!visited[i] &amp;&amp; tickets.get(i).get(<span class="number">0</span>).equals(path.getLast()))&#123;</span><br><span class="line">          <span class="comment">// 做选择</span></span><br><span class="line">         path.add(tickets.get(i).get(<span class="number">1</span>));</span><br><span class="line">         visited[i] = <span class="literal">true</span>;</span><br><span class="line">         <span class="keyword">if</span>(trackback(tickets)) <span class="keyword">return</span> <span class="literal">true</span>;     <span class="comment">//结束回溯</span></span><br><span class="line">          <span class="comment">//撤销选择</span></span><br><span class="line">         visited[i] = <span class="literal">false</span>;</span><br><span class="line">         path.removeLast();</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>进阶写法：</p>
<p>Map   computeIfAbsent      PriorityQueue</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">//332</span></span><br><span class="line">&gt;<span class="comment">// 困难 的 DFS  安排行程    所有的机票 必须都用一次 且 只能用一次</span></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">&gt;<span class="comment">//要点一 : 贪心 : 按照字典顺序访问，我们把每个顶点的临接点按照字典顺序  排序</span></span><br><span class="line">          <span class="comment">// 也 可以不对临接点排序，而是使用小顶堆（Java可以用优先队列）。这样我们删除边的操作和访问最小字典顺序顶点可以用 出队操作代替，时间复杂度应该会比排序再删除要低一些。</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//要点二 : DFS(回溯) : 遍历图时，需要将访问到的节点  逆序  插入到结果集</span></span><br><span class="line">&gt;<span class="comment">//要点三 : 避免存在环路导致节点重复访问，我们  每访问过   一条边  就把它标记为访问过，或者直接将  访问过的边  删除  然后 每次都取临接点的第一个即可满足字典顺序访问</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//computeIfAbsent  该方法适用于需要在 Map 中进行查找或计算某些值的场景，比如对于需要动态生成某些值的场景</span></span><br><span class="line"></span><br><span class="line">&gt;LinkedList&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">&gt;<span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findItinerary</span><span class="params">(List&lt;List&lt;String&gt;&gt; tickets)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(tickets.size() == <span class="number">0</span>  || tickets == <span class="literal">null</span> ) <span class="keyword">return</span> res;</span><br><span class="line">  <span class="comment">// Map&lt;String, List&lt;String&gt;&gt; 存储 图，Key 为顶点，List&lt;String&gt; 为临接点。</span></span><br><span class="line">  HashMap&lt;String, PriorityQueue&lt;String&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (List&lt;String&gt;  ticket : tickets) &#123;</span><br><span class="line">      <span class="comment">//排序</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果 graph 中不存在以 ticket.get(0) 为键的映射，则创建一个新的 PriorityQueue 实例，并将其作为该键值对应的值存入 graph 中；否则，直接返回对应的 PriorityQueue 对象。</span></span><br><span class="line">      PriorityQueue&lt;String&gt; queue = graph.computeIfAbsent(ticket.get(<span class="number">0</span>), k -&gt; <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;());</span><br><span class="line">      queue.add(ticket.get(<span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//dfs</span></span><br><span class="line">  dfs(graph,<span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(HashMap&lt;String, PriorityQueue&lt;String&gt;&gt; graph, String start)</span> &#123;</span><br><span class="line">  PriorityQueue&lt;String&gt; queue = graph.get(start);</span><br><span class="line">  <span class="keyword">while</span> (queue!=<span class="literal">null</span> &amp;&amp; queue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">      dfs(graph, poll);</span><br><span class="line">  &#125;</span><br><span class="line">  res.add(<span class="number">0</span>,start);  <span class="comment">// 逆序插入</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="困难二"><a href="#困难二" class="headerlink" title="困难二"></a>困难二</h5><blockquote>
<p>公共公交</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">// 无(双)向图</span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numBusesToDestination</span><span class="params">(<span class="type">int</span>[][] routes, <span class="type">int</span> source, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(source == target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> bfs(routes, source, target);</span><br><span class="line">  <span class="keyword">return</span>  res;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">private</span> <span class="type">int</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span>[][] routes, <span class="type">int</span> source, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">  <span class="comment">// 邻接表记录   站 与   路线的  关系</span></span><br><span class="line">  HashMap&lt;Integer,List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 记录：经过的路线</span></span><br><span class="line">  Deque&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  Set&lt;Integer&gt; visited= <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="variable">numOfRoutes</span> <span class="operator">=</span> routes.length;</span><br><span class="line">  <span class="comment">//将每个站点出现在的路线号添加到哈希表中。</span></span><br><span class="line">  <span class="comment">// 在循环遍历每个路线时，对于路线中的每个站点 station，</span></span><br><span class="line">  <span class="comment">//          首先判断是否已经存在以 station 为键的值，</span></span><br><span class="line">  <span class="comment">//          如果不存在，则在哈希表中添加一个新的空列表；然后将该路线编号 i 添加到哈希表中以 station 为键的值所对应的列表中。</span></span><br><span class="line">  <span class="comment">//          最后得到的是一个包含每个站点出现在的路线编号的哈希表。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numOfRoutes; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> station : routes[i]) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span>(!graph.containsKey(station))&#123;</span><br><span class="line">              graph.put(station,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">          &#125;</span><br><span class="line">          graph.get(station).add(i);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  queue.addAll(graph.get(source));</span><br><span class="line">  visited.addAll(graph.get(source));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">      count++;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">poll</span> <span class="operator">=</span>  queue.poll();</span><br><span class="line">          <span class="type">int</span>[] route = routes[poll];</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> station: route)&#123;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span>(station == target)  <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">for</span> (<span class="type">int</span> bus : graph.getOrDefault(station, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())) &#123;</span><br><span class="line">                  <span class="keyword">if</span>(!visited.contains(bus)) &#123;</span><br><span class="line">                      queue.offer(bus);</span><br><span class="line">                      visited.add(bus);</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>  -<span class="number">1</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="困难三"><a href="#困难三" class="headerlink" title="困难三"></a>困难三</h5><blockquote>
<p><a href="https://leetcode.cn/problems/word-ladder/">单词接龙</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">//127</span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;</span><br><span class="line">  <span class="comment">// 第 1 步：先将 wordList 放到哈希表里，便于判断某个单词是否在 wordList 里</span></span><br><span class="line">  Set&lt;String&gt; wordSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordList);</span><br><span class="line">  <span class="keyword">if</span> (wordSet.size() == <span class="number">0</span> || !wordSet.contains(endWord)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  wordSet.remove(beginWord);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第 2 步：图的广度优先遍历，必须使用队列和表示是否访问过的 visited 哈希表</span></span><br><span class="line">  Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">  queue.offer(beginWord);</span><br><span class="line">  Set&lt;String&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">  visited.add(beginWord);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第 3 步：开始广度优先遍历，包含起点，因此初始化的时候步数为 1</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">currentSize</span> <span class="operator">=</span> queue.size();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; currentSize; i++) &#123;</span><br><span class="line">          <span class="comment">// 依次遍历当前队列中的单词</span></span><br><span class="line">          <span class="type">String</span> <span class="variable">currentWord</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">          <span class="comment">// 如果 currentWord 能够修改 1 个字符与 endWord 相同，则返回 step + 1</span></span><br><span class="line">          <span class="keyword">if</span> (changeWordEveryOneLetter(currentWord, endWord, queue, visited, wordSet)) &#123;</span><br><span class="line">              <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      step++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 尝试对 currentWord 修改每一个字符，看看是不是能与 endWord 匹配</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> currentWord</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> endWord</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> queue</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> visited</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> wordSet</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">changeWordEveryOneLetter</span><span class="params">(String currentWord, String endWord,</span></span><br><span class="line"><span class="params">                                           Queue&lt;String&gt; queue, Set&lt;String&gt; visited, Set&lt;String&gt; wordSet)</span> &#123;</span><br><span class="line">      <span class="type">char</span>[] charArray = currentWord.toCharArray();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; endWord.length(); i++) &#123;</span><br><span class="line">          <span class="comment">// 先保存，然后恢复</span></span><br><span class="line">          <span class="type">char</span> <span class="variable">originChar</span> <span class="operator">=</span> charArray[i];</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">k</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>; k &lt;= <span class="string">&#x27;z&#x27;</span>; k++) &#123;</span><br><span class="line">              <span class="keyword">if</span> (k == originChar) &#123;</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              charArray[i] = k;</span><br><span class="line">              <span class="type">String</span> <span class="variable">nextWord</span> <span class="operator">=</span> String.valueOf(charArray);</span><br><span class="line">              <span class="keyword">if</span> (wordSet.contains(nextWord)) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (nextWord.equals(endWord)) &#123;</span><br><span class="line">                      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (!visited.contains(nextWord)) &#123;</span><br><span class="line">                      queue.add(nextWord);</span><br><span class="line">                      <span class="comment">// 注意：添加到队列以后，必须马上标记为已经访问</span></span><br><span class="line">                      visited.add(nextWord);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 恢复</span></span><br><span class="line">          charArray[i] = originChar;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="BFS"><a href="#BFS" class="headerlink" title="==BFS=="></a>==BFS==</h2><blockquote>
<ul>
<li><p><strong>BFS 找到的路径一定是最短的</strong></p>
</li>
<li><p>问题的本质就是让你在一幅「图」中找到从起点 <code>start</code> 到终点 <code>target</code> 的最近距离.  找==最短路径==</p>
</li>
<li><p>也就是说  只有在   找最短路径的时候 用 BFS    其他时候 大部分还是DFS</p>
</li>
</ul>
</blockquote>
<h4 id="BFS在层次遍历中模版："><a href="#BFS在层次遍历中模版：" class="headerlink" title="BFS在层次遍历中模版："></a>BFS在层次遍历中模版：</h4><h5 id="返回值是二维数组："><a href="#返回值是二维数组：" class="headerlink" title="返回值是二维数组："></a>返回值是二维数组：</h5><blockquote>
<p>大部分题目就是在这个的基础上进行修改&lt;核心代码 前置&gt;</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();       结果集</span><br><span class="line">Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();							队列</span><br><span class="line">    <span class="comment">// 要是定义在这里就只能打印得到一个整体的一维数组，因为每次for 循环中不会重置该一维数组</span></span><br><span class="line">    <span class="comment">//   ArrayList&lt;Integer&gt; tmpList  = new ArrayList&lt;&gt;();</span></span><br><span class="line">    <span class="comment">//加入根节点</span></span><br><span class="line">queue.offer(root);													入队</span><br><span class="line">        <span class="comment">//判空，返回的要是二维数组不能是null</span></span><br><span class="line"><span class="keyword">if</span>(root == <span class="literal">null</span>)  <span class="keyword">return</span> result;									</span><br><span class="line"><span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">queueSize</span> <span class="operator">=</span> queue.size();										队列的大小</span><br><span class="line"><span class="comment">// 必须要这里定义一维数组,只有在这里定义的才能每层都放在不同的一维数组里面，最终构成二维数组  并且只有 这里定义 tmpList 才能之后在 while中直接加到 result中  即：result.add(tmpList);              </span></span><br><span class="line"><span class="comment">//每层遍历的时候 tmpList 都会重置</span></span><br><span class="line"> </span><br><span class="line">ArrayList&lt;Integer&gt; tmpList  = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();                   临时接受</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; queueSize;i++)&#123;</span><br><span class="line">		<span class="type">TreeNode</span> <span class="variable">outQueue</span> <span class="operator">=</span> queue.poll();              				出队</span><br><span class="line">       <span class="keyword">if</span>(outQueue.left!=<span class="literal">null</span>) queue.offer(outQueue.left);			左右侧进行递归</span><br><span class="line">       <span class="keyword">if</span>(outQueue.right!=<span class="literal">null</span>) queue.offer(outQueue.right);</span><br><span class="line">       tmpList.add(outQueue.val);									临时接受</span><br><span class="line">&#125;	</span><br><span class="line">result.add(tmpList);												进结果集</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
<h5 id="返回值是一维数组："><a href="#返回值是一维数组：" class="headerlink" title="返回值是一维数组："></a>返回值是一维数组：</h5><blockquote>
<p>大部分题目就是在这个的基础上进行修改&lt;核心代码 前置&gt;</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(root == <span class="literal">null</span>)  <span class="keyword">return</span> result;</span><br><span class="line">queue.offer(root);</span><br><span class="line"><span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">             </span><br><span class="line">            </span><br><span class="line"><span class="type">int</span>  <span class="variable">queueSize</span> <span class="operator">=</span> queue.size();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;queueSize;i++)&#123;</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">outqueue</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">      result.add(outqueue.val);</span><br><span class="line">      <span class="keyword">if</span>(outqueue.left!= <span class="literal">null</span>)   queue.add(outqueue.left);</span><br><span class="line">      <span class="keyword">if</span>(outqueue.right!= <span class="literal">null</span>)  queue.add(outqueue.right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不难看出 就是在 <strong>定义结果集的时候</strong>  有区别，也就是结果集 <strong>维度</strong> 和 <strong>位置</strong> 的 区别</p>
</blockquote>
<h4 id="BFS的框架模版"><a href="#BFS的框架模版" class="headerlink" title="BFS的框架模版"></a>BFS的框架模版</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算从起点 start 到终点 target 的最近距离               </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BFS</span><span class="params">(Node start, Node target)</span> &#123;</span><br><span class="line">    Queue&lt;Node&gt; q; <span class="comment">// 核心数据结构                       </span></span><br><span class="line">	q.offer(start); <span class="comment">// 将起点加入队列</span></span><br><span class="line">    </span><br><span class="line">    --------------  区别之处</span><br><span class="line">    Set&lt;Node&gt; visited; <span class="comment">// 避免走回头路     二叉树不用</span></span><br><span class="line">    visited.add(start);</span><br><span class="line">    <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录扩散的步数</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (q not empty) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">        <span class="comment">/* 将当前队列中的所有节点向四周扩散 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            </span><br><span class="line">     ----------------  区别之处</span><br><span class="line">            <span class="comment">/* 划重点：这里判断是否到达终点 */</span></span><br><span class="line">            <span class="keyword">if</span> (cur is target)</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            <span class="comment">/* 将 cur 的相邻节点加入队列 */</span></span><br><span class="line">            <span class="keyword">for</span> (Node x : cur.adj()) &#123;    <span class="comment">//cur.adj() 泛指 cur 相邻的节点</span></span><br><span class="line">                <span class="keyword">if</span> (x not in visited) &#123;</span><br><span class="line">                    q.offer(x);</span><br><span class="line">                    visited.add(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">     ----------------  区别之处</span><br><span class="line">        <span class="comment">/* 划重点：更新步数在这里 */</span></span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//visited 的主要作用是防止走回头路，大部分时候都是必须的，</span></span><br><span class="line"><span class="comment">//但是像一般的二叉树结构，没有子节点到父节点的指针，不会走回头路就不需要 visited。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>==注意==:</p>
<p>这个 <code>while</code> 循环和 <code>for</code> 循环的配合</p>
<p><strong><code>while</code> 循环控制一层一层往下走，<code>for</code> 循环利用 <code>sz</code> 变量控制从左到右遍历每一层二叉树节点</strong>：</p>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202303231104890.png" style="zoom:25%;"></p>
<p>感悟：</p>
<p>==对于含有 <code>for</code> 或者 <code>其他 (while 等)循环</code>的代码中，对于想要得到的结果，往往是在循环之外进行数据处理的，例如 <code>返回结果，取最大值等等</code>==</p>
</blockquote>
<h4 id="岛屿问题的BFS"><a href="#岛屿问题的BFS" class="headerlink" title="岛屿问题的BFS"></a>岛屿问题的BFS</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bfs 函数的基本框架</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>  [][]dirs = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span>/<span class="type">int</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span>/... [][]grid, <span class="type">int</span>  i , <span class="type">int</span>  j )</span>&#123;</span><br><span class="line">    <span class="type">int</span>  <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">    <span class="type">int</span>  <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">            </span><br><span class="line">    <span class="comment">//第一种写法   必须是 n</span></span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(i * n + j );   </span><br><span class="line">    grid[i][j] = 海洋/<span class="string">&#x27;0&#x27;</span>/...;  <span class="comment">// 入队的时候而不是出队的时候加入  可以保证不会重复遍历   第一次加入</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">out</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> out / n;</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> out % n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>  k=<span class="number">0</span> ;k&lt;dirs.length;k++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newx</span> <span class="operator">=</span> x+dirs[k][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">newy</span> <span class="operator">=</span> y+dirs[k][<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(newx &gt;= <span class="number">0</span> &amp;&amp; newy &gt;=<span class="number">0</span> &amp;&amp;  newx &lt; m &amp;&amp; newy &lt; n &amp;&amp; grid[newx][newy]== <span class="string">&quot;陆地&quot;</span>)&#123;</span><br><span class="line">           queue.offer(newx * n  + newy); </span><br><span class="line">            grid[i][j] = 海洋/<span class="string">&#x27;0&#x27;</span>/...;  <span class="comment">// 入队的时候而不是出队的时候加入  可以保证不会重复遍历  第二次加入</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第二种写法</span></span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(i);</span><br><span class="line">    queue.offer(j);</span><br><span class="line">    grid[i][j] = 海洋/<span class="string">&#x27;0&#x27;</span>/...;  <span class="comment">// 入队的时候而不是出队的时候加入  可以保证不会重复遍历   第一次加入</span></span><br><span class="line">    .........(<span class="comment">//695   step++;)</span></span><br><span class="line">    .........(<span class="comment">//1020  step++;)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>  k=<span class="number">0</span> ;k&lt;dirs.length;k++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newx</span> <span class="operator">=</span> x+dirs[k][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">newy</span> <span class="operator">=</span> y+dirs[k][<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(newx &gt;= <span class="number">0</span> &amp;&amp; newy &gt;=<span class="number">0</span> &amp;&amp;  newx &lt; m &amp;&amp; newy &lt; n &amp;&amp; grid[newx][newy]== <span class="string">&quot;陆地&quot;</span>)&#123;</span><br><span class="line">            queue.offer(newx); </span><br><span class="line">            queue.offer(newy); </span><br><span class="line">            grid[i][j] = 海洋/<span class="string">&#x27;0&#x27;</span>/...;  <span class="comment">// 入队的时候而不是出队的时候加入  可以保证不会重复遍历  第二次加入</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">        <span class="comment">//第三种写法</span></span><br><span class="line">    Queue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,j&#125;);</span><br><span class="line">    grid[i][j] = 非海洋非陆地的值/<span class="string">&#x27;2&#x27;</span>/<span class="number">2.</span>..;  <span class="comment">// 入队的时候而不是出队的时候加入  可以保证不会重复遍历 第一次加入</span></span><br><span class="line">    <span class="type">int</span> out[] = queue.poll();</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> out[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> out[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>  k=<span class="number">0</span> ;k&lt;dirs.length;k++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newx</span> <span class="operator">=</span> x+dirs[k][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">newy</span> <span class="operator">=</span> y+dirs[k][<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(newx &gt;= <span class="number">0</span> &amp;&amp; newy &gt;=<span class="number">0</span> &amp;&amp;  newx &lt; m &amp;&amp; newy &lt; n &amp;&amp; grid[newx][newy]== <span class="string">&quot;陆地&quot;</span>)&#123;</span><br><span class="line">            queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>&#123;newx,newy&#125;); </span><br><span class="line">            grid[newx][newy] = 非海洋非陆地的值/<span class="string">&#x27;2&#x27;</span>/<span class="number">2.</span>..;  <span class="comment">// 入队的时候而不是出队的时候加入  可以保证不会重复遍历  第二次加入</span></span><br><span class="line">            .........(<span class="comment">//695   step++;)</span></span><br><span class="line">            .........(<span class="comment">//1020  step++;)</span></span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">/**463 周长 附加判断 </span></span><br><span class="line"><span class="comment">            //bfs 按圈进行扩展  所以每一轮扩展之后 都将会对每一个当前节点的一圈节点进行遍历  </span></span><br><span class="line"><span class="comment">            //所以正好可以利用这个特性对其进行计算周长，看四边是不是 0 是的话就 周长+1 </span></span><br><span class="line"><span class="comment">                if( newx &lt; 0  ||  newy &lt;0 ||  newx &gt;=m ||  newy &gt;=n ||  grid[newx][newy] !=1) &#123;                  </span></span><br><span class="line"><span class="comment">                   if( newx &lt;0  ||  newy &lt;0 ||  newx &gt;=m ||  newy &gt;=n ||  grid[newx][newy]== 0 ) &#123;  </span></span><br><span class="line"><span class="comment">                       count++;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                continue;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">     return count;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//200</span></span><br><span class="line"> 		<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">               <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                  bfs(grid,i,j);</span><br><span class="line">                  count++;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//695</span></span><br><span class="line">------&lt;bfs 有变动&gt;</span><br><span class="line">		<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//每一次的 bfs 都要初始化  才能进行比较 取得 最值</span></span><br><span class="line">                    step = <span class="number">0</span>;</span><br><span class="line">                    bfs(grid,i,j);</span><br><span class="line">                    res = Math.max(res,step);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1905</span></span><br><span class="line">  </span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid1[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//先将在  grid2是陆地  和在   grid1 是海水   地方 在grid2 中全部设置为 海水</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid1.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;grid1[<span class="number">0</span>].length ; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid2[i][j] ==<span class="number">1</span> &amp;&amp; grid1[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    bfs(grid2,i,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 现在 grid2 中剩下的岛屿都是子岛，计算岛屿数量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid2[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    bfs(grid2,i,j);</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  res;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">//1020</span></span><br><span class="line">------&lt;bfs 有变动&gt;</span><br><span class="line">    <span class="type">int</span> step ;</span><br><span class="line"></span><br><span class="line"> 		<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][<span class="number">0</span>] == <span class="number">1</span>) bfs(grid, i, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (grid[i][n-<span class="number">1</span>] == <span class="number">1</span>) bfs(grid, i, n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从上边和下边向中间遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[<span class="number">0</span>][j] == <span class="number">1</span>) bfs(grid, <span class="number">0</span>, j);</span><br><span class="line">            <span class="keyword">if</span> (grid[m - <span class="number">1</span>][j] == <span class="number">1</span>) bfs(grid, m - <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>( grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    bfs(grid,i,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1254&lt;与 1020 几乎一模一样&gt;</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[<span class="number">0</span>][i] == <span class="number">0</span>)   bfs(grid,<span class="number">0</span>,i);</span><br><span class="line">            <span class="keyword">if</span>(grid[m-<span class="number">1</span>][i] == <span class="number">0</span>) bfs(grid,m-<span class="number">1</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span>(grid[i][<span class="number">0</span>] == <span class="number">0</span>) bfs(grid,i,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(grid[i][n-<span class="number">1</span>] == <span class="number">0</span>)  bfs(grid,i,n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    bfs(grid,i,j);</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"><span class="comment">//463 </span></span><br><span class="line"> 		<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] ==<span class="number">1</span>)&#123;</span><br><span class="line">                    res=bfs(grid,i,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//130 </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[<span class="number">0</span>][i] == <span class="string">&#x27;O&#x27;</span>)   bfs(board,<span class="number">0</span>,i);</span><br><span class="line">            <span class="keyword">if</span>(board[m-<span class="number">1</span>][i] == <span class="string">&#x27;O&#x27;</span>) bfs(board,m-<span class="number">1</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span>)   bfs(board,i,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(board[i][n-<span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>) bfs(board,i,n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;#&#x27;</span>)    board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;O&#x27;</span>)    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="一道BFS-DFS-的综合应用"><a href="#一道BFS-DFS-的综合应用" class="headerlink" title="一道BFS\DFS 的综合应用"></a>一道BFS\DFS 的综合应用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//934  最短的桥</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    LinkedList&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> dirs[][] = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">onlyOne</span> <span class="operator">=</span> <span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestBridge</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="comment">//四面相连 == 上下左右</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(onlyOne) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span> &amp;&amp; !onlyOne)&#123;</span><br><span class="line">                    onlyOne = <span class="literal">true</span>;</span><br><span class="line">                    dfs(grid,i,j);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> bfs(grid);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 计算扩展的层数，就是桥的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; size; l++) &#123;</span><br><span class="line">                <span class="type">int</span>[] poll = queue.poll();</span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> poll[<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> poll[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; dirs.length; k++) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">newx</span> <span class="operator">=</span> x + dirs[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="type">int</span> <span class="variable">newy</span> <span class="operator">=</span> y + dirs[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(newx &gt;= <span class="number">0</span> &amp;&amp; newy &gt;= <span class="number">0</span> &amp;&amp; newx &lt; m &amp;&amp; newy &lt; n &amp;&amp; grid[newx][newy] == <span class="number">0</span>) &#123;</span><br><span class="line">                            queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;newx, newy&#125;);</span><br><span class="line">                            grid[newx][newy] = <span class="number">2</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(newx &gt;= <span class="number">0</span> &amp;&amp; newy &gt;= <span class="number">0</span> &amp;&amp; newx &lt; m &amp;&amp; newy &lt; n &amp;&amp; grid[newx][newy] == <span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> res;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//找到岛屿，岛屿的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n || grid[i][j] == <span class="number">2</span> ) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">            grid[i][j] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)&#123;  <span class="comment">//只 向外 扩展一层 即可  所以是 if</span></span><br><span class="line">            grid[i][j] = <span class="number">2</span>;</span><br><span class="line">            queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, j&#125;);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(grid, i, j+<span class="number">1</span>);</span><br><span class="line">        dfs(grid, i+<span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, i-<span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, i, j-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="滑动窗口题："><a href="#滑动窗口题：" class="headerlink" title="滑动窗口题："></a>滑动窗口题：</h2><blockquote>
<p>==注==</p>
<p>​    将 索引<strong>左闭右开</strong>区间 <code>[left, right)</code> 称为一个「窗口」</p>
</blockquote>
<h5 id="核心框架"><a href="#核心框架" class="headerlink" title="核心框架"></a>核心框架</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 核心逻辑</span></span><br><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">    <span class="comment">// 增大窗口</span></span><br><span class="line">    window.add(s[right]);</span><br><span class="line">    right++;   </span><br><span class="line">    ........</span><br><span class="line">    <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">        <span class="comment">// 缩小窗口</span></span><br><span class="line">        window.remove(s[left]);</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">完整框架</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 滑动窗口算法框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">slidingWindow</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; window = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//（ 变量 ）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">		<span class="comment">// 增大窗口</span></span><br><span class="line">        right++;</span><br><span class="line"><span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line">        <span class="comment">// 注意在最终的解法代码中不要 print</span></span><br><span class="line">        <span class="comment">// 因为 IO 操作很耗时，可能导致超时</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;window: [%d, %d)\n&quot;</span>, left, right);</span><br><span class="line">        <span class="comment">/********************/</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">            <span class="comment">// 缩小窗口</span></span><br><span class="line">            left++;</span><br><span class="line"><span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">其中两处 ... 表示的更新窗口数据的地方，到时候直接往里面填就行了。</span><br><span class="line">而且，这两个 ... 处的操作分别是扩大和缩小窗口的更新操作，等会你会发现它们操作是完全对称的。</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<blockquote>
<p>==思考==</p>
<ul>
<li>什么时候应该移动 <code>right</code> 扩大窗口？窗口加入字符时，应该更新哪些数据？</li>
<li>什么时候应该移动 <code>left</code> 缩小窗口？从窗口移出字符时，应该更新哪些数据？</li>
<li>我们要的<strong>结果</strong>应该在扩大窗口时还是缩小窗口时进行更新？</li>
</ul>
</blockquote>
<h5 id="java相关的知识"><a href="#java相关的知识" class="headerlink" title="==java相关的知识=="></a>==java相关的知识==</h5><blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">// 将 string  转为字符串 </span></span><br><span class="line">&gt;<span class="keyword">for</span>(<span class="type">char</span> c:t.toCharArray())&#123;</span><br><span class="line">&gt;<span class="comment">//将 c  加到对应的map结合中，  要是有的话就+1，没有就为 0+1</span></span><br><span class="line">&gt;request.put(c,request.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//map用于 判断是否含有 该键</span></span><br><span class="line">&gt;<span class="keyword">if</span>(request.containsKey(remover))</span><br><span class="line">&gt;<span class="keyword">if</span>(window.get(remover).equals(request.get(remover))) </span><br><span class="line">&gt;<span class="comment">//两个map集合中的键值都一样才为true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="一个字符串-数组"><a href="#一个字符串-数组" class="headerlink" title="一个字符串 / 数组"></a>一个字符串 / 数组</h5><blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">//3  给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。        </span></span><br><span class="line"></span><br><span class="line">&gt;----变量</span><br><span class="line">&gt;HashMap&lt;Character, Integer&gt; window = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&gt;<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&gt;<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&gt;<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&gt;<span class="type">int</span> res= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&gt;----进行窗口内数据的一系列更新</span><br><span class="line">&gt;<span class="comment">// 窗口的大小进行更新； 窗口中的键值更新</span></span><br><span class="line">&gt;window.put(add,window.getOrDefault(add,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">&gt;count++;</span><br><span class="line"></span><br><span class="line">&gt;----判断左侧窗口是否要收缩</span><br><span class="line">&gt;<span class="comment">//窗口缩小的条件： 窗口中的键对应的值 &gt;1 </span></span><br><span class="line">&gt;<span class="keyword">while</span>(window.get(add)&gt;<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">&gt;----进行窗口内数据的一系列更新</span><br><span class="line">&gt;<span class="comment">// 窗口的大小进行更新； 窗口中的键值更新</span></span><br><span class="line"> count --;</span><br><span class="line"> window.put(remove,window.get(remove)-<span class="number">1</span>);</span><br><span class="line">&gt;----返回值</span><br><span class="line">&gt;<span class="comment">//结果集收集：记录每一次的最大值</span></span><br><span class="line">      res = Math.max(res,count);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//209   长度最小的子数组   满足其和 ≥ target 的长度最小的 连续子数组  并返回其长度。如果不存在符合条件的子数组，返回 0 。 </span></span><br><span class="line"></span><br><span class="line">&gt;----变量</span><br><span class="line">	<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> right= <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">  <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;   </span><br><span class="line">&gt;----进行窗口内数据的一系列更新</span><br><span class="line"> <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">          sum =sum+add;</span><br><span class="line">          <span class="comment">//window.put(add,window.getOrDefault(add,0 )+1);</span></span><br><span class="line">          count++;</span><br><span class="line">      &#125;</span><br><span class="line">&gt;----判断左侧窗口是否要收缩</span><br><span class="line">&gt;<span class="keyword">while</span>(sum &gt;= target)</span><br><span class="line">&gt;----进行窗口内数据的一系列更新</span><br><span class="line">&gt;<span class="keyword">if</span>(sum &gt;= target)&#123;</span><br><span class="line"> res = Math.min(res,count);</span><br><span class="line">&gt;&#125;</span><br><span class="line"> sum =sum-remove;</span><br><span class="line"> count--;</span><br><span class="line"></span><br><span class="line">&gt;----返回值</span><br><span class="line">&gt;<span class="keyword">return</span> res== Integer.MAX_VALUE? <span class="number">0</span>:res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 模版框架有变动</span></span><br><span class="line">&gt;<span class="comment">//1004   给定一个二进制数组 nums 和一个整数 k，如果可以翻转最多 k 个 0 ，则返回 数组中连续 1 的最大个数 。</span></span><br><span class="line">&gt;----变量</span><br><span class="line">	<span class="type">int</span> right= <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> left= <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> k;</span><br><span class="line"></span><br><span class="line">&gt;----进行窗口内数据的一系列更新</span><br><span class="line">&gt;<span class="comment">// 扩大窗口的时候 k 是可以等于 0  的 ，</span></span><br><span class="line">&gt;<span class="comment">// 否则要是在扩大窗口的时候  只判断 k&gt;0 会导致 count 的值会变小，</span></span><br><span class="line">&gt;<span class="comment">// 原因是一旦 K == 0;就会使窗口在遇到 k 个0 之后不管最后一个 0 后面的值是否为1 直接缩小窗口，就会导致 计数不完整。</span></span><br><span class="line">&gt;<span class="comment">// 所以 k=0 放在增加窗口的时候，就是为了判断最后一个0 的后面的值是0还是1 ，这个时候即使扩大窗口会多++一次； 但是在缩小窗口的时候还是会--，就会进行抵消；</span></span><br><span class="line">      <span class="keyword">if</span>(nums[right] == <span class="number">0</span> &amp;&amp; k&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">          k--;</span><br><span class="line">      &#125;</span><br><span class="line">      right++;</span><br><span class="line">      count++;</span><br><span class="line"></span><br><span class="line">&gt;----判断左侧窗口是否要收缩</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">while</span>(k&lt;<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">&gt;----进行窗口内数据的一系列更新</span><br><span class="line"><span class="keyword">if</span>(nums[left]==<span class="number">0</span>)&#123;</span><br><span class="line">              k++;</span><br><span class="line">          &#125;</span><br><span class="line">          left++;</span><br><span class="line">          count--;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&gt;----返回值</span><br><span class="line">&gt;<span class="comment">//缩小完窗口进行收集结果</span></span><br><span class="line">&gt;res = Math.max(res,count);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//1004   完整代码</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//思路：遇到 K个 0 之后就缩小窗口，比较每次的收集到的最大 count</span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestOnes</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">  <span class="type">int</span> right= <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> left= <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> k;</span><br><span class="line">  <span class="keyword">while</span>(right&lt;nums.length)&#123;</span><br><span class="line">&gt;<span class="comment">// 扩大窗口的时候 k 是可以等于 0  的 ，</span></span><br><span class="line">&gt;<span class="comment">//否则要是在扩大窗口的时候  只判断 k&gt;0 会导致 count 的值会变小，</span></span><br><span class="line">&gt;<span class="comment">//原因是一旦 K ==0;就会使窗口在遇到 k 个0 之后不管最后一个 0 后面的值是否为1 直接缩小窗口，就会导致 计数不完整。</span></span><br><span class="line">&gt;<span class="comment">//所以 k=0 放在增加窗口的时候，就是为了判断最后一个0 的后面的值是0还是1 ，这个时候即使扩大窗口会多++一次； 但是在缩小窗口的时候还是会--，就会进行抵消；</span></span><br><span class="line">      <span class="keyword">if</span>(nums[right] == <span class="number">0</span> &amp;&amp; k&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">          k--;</span><br><span class="line">      &#125;</span><br><span class="line">      right++;</span><br><span class="line">      count++;</span><br><span class="line">      <span class="keyword">while</span>(k&lt;<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(nums[left]==<span class="number">0</span>)&#123;</span><br><span class="line">              k++;</span><br><span class="line">          &#125;</span><br><span class="line">          left++;</span><br><span class="line">          count--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//缩小完窗口进行收集结果</span></span><br><span class="line">      res = Math.max(res,count);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="两个子符串"><a href="#两个子符串" class="headerlink" title="两个子符串"></a>两个子符串</h5><blockquote>
<p><strong>76 438  567 共性 就是   子串可以无序 但是长度固定 个数一致</strong></p>
<p>==1208则是要逐位比较==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//76   给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &quot;&quot;</span></span><br><span class="line">&gt;----变量</span><br><span class="line"><span class="type">int</span> right= <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">  <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   HashMap&lt;Character,Integer&gt; request = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">   HashMap&lt;Character,Integer&gt;  window = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">char</span> c:t.toCharArray())&#123;</span><br><span class="line">       request.put(c,request.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&gt;----进行窗口内数据的一系列更新</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(request.containsKey(add))&#123;</span><br><span class="line">          window.put(add,window.getOrDefault(add,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">if</span>(window.get(add).equals(request.get(add)))</span><br><span class="line">          count++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&gt;----判断左侧窗口是否要收缩</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">while</span>(count == request.size())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;----进行窗口内数据的一系列更新</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(right- left&lt;len)&#123;</span><br><span class="line">              start = left;</span><br><span class="line">              len  = right - left;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(request.containsKey(remove))&#123;</span><br><span class="line">                <span class="keyword">if</span>(window.get(remove).equals(request.get(remove)))</span><br><span class="line">                  valid--;</span><br><span class="line">                  <span class="comment">// get(remove)-1</span></span><br><span class="line">                  window.put(remove,window.get(remove)-<span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">&gt;----返回值</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> len ==  Integer.MAX_VALUE? <span class="string">&quot;&quot;</span>: s.substring(start,start+len);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//438   给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。 </span></span><br><span class="line">&gt;----变量</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  HashMap&lt;Character, Integer&gt; request = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  HashMap&lt;Character, Integer&gt; window = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">char</span> c : p.toCharArray())&#123;</span><br><span class="line">      request.put(c,request.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;----进行窗口内数据的一系列更新</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(request.containsKey(add))&#123;</span><br><span class="line">          window.put(adder,window.getOrDefault(add,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">if</span>(window.get(add).equals(request.get(add)))</span><br><span class="line">              count++;</span><br><span class="line">          <span class="comment">//System.out.println(window);</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&gt;----判断左侧窗口是否要收缩</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">while</span>(right-left &gt;= p.length())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;----进行窗口内数据的一系列更新</span><br><span class="line"></span><br><span class="line">   		<span class="keyword">if</span>(count == request.size()) &#123;  <span class="comment">//request.size()</span></span><br><span class="line">              result.add(left);</span><br><span class="line">          &#125;</span><br><span class="line">			...</span><br><span class="line">			<span class="keyword">if</span>(request.containsKey(remove))&#123;</span><br><span class="line">              <span class="keyword">if</span>(window.get(remove).equals(request.get(remove)))</span><br><span class="line">                  count--;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// window.put(remover, window.get(remover)-1);</span></span><br><span class="line">              window.put(remove, window.get(remove)-<span class="number">1</span>);</span><br><span class="line">             <span class="comment">// System.out.println(window);</span></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">&gt;----返回值</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//567   给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false   和438几乎没差</span></span><br><span class="line">&gt;----变量</span><br><span class="line"><span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  HashMap&lt;Character, Integer&gt; request = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  HashMap&lt;Character, Integer&gt; window = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">char</span> c : s1.toCharArray())&#123;</span><br><span class="line">      request.put(c,request.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&gt;----进行窗口内数据的一系列更新</span><br><span class="line">	<span class="keyword">if</span>(request.containsKey(add))&#123;</span><br><span class="line">          window.put(add,window.getOrDefault(add,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">if</span>(window.get(add).equals(request.get(add)))</span><br><span class="line">         		count++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&gt;----判断左侧窗口是否要收缩</span><br><span class="line">&gt;<span class="keyword">while</span>(right-left &gt;= s1.length())</span><br><span class="line"></span><br><span class="line">&gt;----进行窗口内数据的一系列更新</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">if</span>(count == request.size())  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(request.containsKey(remove))&#123;</span><br><span class="line">  <span class="keyword">if</span>(window.get(remove).equals(request.get(remove)))</span><br><span class="line">      count--;</span><br><span class="line">  window.put(remove,window.get(remover)-<span class="number">1</span>);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;----返回值</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 模版框架有变动</span></span><br><span class="line">&gt;<span class="comment">// 1208        如果你可以将 s 的子字符串转化为它在 t 中对应的子字符串，则返回可以转化的最大长度。</span></span><br><span class="line">&gt;<span class="comment">// 题意： cost 不是个数  而是|s[i] - t[i]| 就是两个字符的 ASCII 码值的差的绝对值</span></span><br><span class="line">&gt;----变量</span><br><span class="line"><span class="type">int</span> right= <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> left= <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;----进行窗口内数据的一系列更新</span><br><span class="line">	diff += Math.abs(s.charAt(right) - t.charAt(right));</span><br><span class="line">      right++;</span><br><span class="line">      count++;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;----判断左侧窗口是否要收缩</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">while</span>(diff&gt;maxCost)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;----进行窗口内数据的一系列更新</span><br><span class="line"></span><br><span class="line">   diff -= Math.abs(s.charAt(left) - t.charAt(left));</span><br><span class="line">   left++;</span><br><span class="line">   count--;</span><br><span class="line"></span><br><span class="line">&gt;----返回值  </span><br><span class="line">&gt;<span class="comment">// 更新值</span></span><br><span class="line">&gt;res = Math.max(res, count);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//1208 完整代码</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 题意： cost 不是个数  而是|s[i] - t[i]| 就是两个字符的 ASCII 码值的差的绝对值</span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">equalSubstring</span><span class="params">(String s, String t, <span class="type">int</span> maxCost)</span> &#123;</span><br><span class="line">  <span class="type">int</span> right= <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> left= <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 窗口 扩大</span></span><br><span class="line">  <span class="keyword">while</span>(right&lt;s.length())&#123;</span><br><span class="line">      diff += Math.abs(s.charAt(right) - t.charAt(right));</span><br><span class="line">      right++;</span><br><span class="line">      count++;</span><br><span class="line">      <span class="comment">// 缩小窗口</span></span><br><span class="line">      <span class="keyword">while</span>(diff&gt;maxCost)&#123;</span><br><span class="line">          diff -= Math.abs(s.charAt(left) - t.charAt(left));</span><br><span class="line">          left++;</span><br><span class="line">          count--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新值</span></span><br><span class="line">      res = Math.max(res, count);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;----变量</span><br><span class="line"></span><br><span class="line">&gt;----进行窗口内数据的一系列更新</span><br><span class="line"></span><br><span class="line">&gt;----判断左侧窗口是否要收缩</span><br><span class="line"></span><br><span class="line">&gt;----进行窗口内数据的一系列更新</span><br><span class="line"></span><br><span class="line">&gt;----返回值</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h2><blockquote>
<p><strong>不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节</strong>。</p>
<p><strong>另外提前说明一下，计算 <code>mid</code> 时需要防止溢出</strong>，代码中 <code>left + (right - left) / 2</code> 就和 <code>(left + right) / 2</code> 的结果相同，但是有效防止了 <code>left</code> 和 <code>right</code> 太大，直接相加导致溢出的情况。</p>
</blockquote>
<p>&gt;<br>&gt;</p>
<blockquote>
<ul>
<li><p>while(  &lt;= )    &lt;=\=&gt;    right的赋值是<code>nums.length - 1</code>   &lt;==&gt;    两端都闭区间 <code>[left, right]</code></p>
</li>
<li><p><code>left = mid + 1</code>   或者    <code>right = mid - 1</code></p>
</li>
<li><p>while(  &lt; )    &lt;=\=&gt;    right 的赋值是 <code>nums.length</code>     &lt;==&gt;    左闭右开区间 <code>[left, right)</code></p>
</li>
<li><p><code>left = mid + 1</code>  或者     <code>right = mid</code></p>
</li>
</ul>
<p>右侧边界的一个<strong>特殊点</strong>  就是结尾 获取left的时候要 -1</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模板</span></span><br><span class="line">	<span class="keyword">while</span>(left &lt;= right) &#123;			---left &lt; right					---left &lt; right</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>; 		--- right=mid ; 						----right = mid ;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">... <span class="comment">//三选一 		  </span></span><br><span class="line"> <span class="comment">// 返回中点索引值				//左边界                    								//右边界</span></span><br><span class="line"><span class="comment">/**return mid;*/</span>		<span class="comment">/*right = mid - 1;**/</span>   ---right = mid ;          <span class="comment">/**left = mid + 1;*/</span>  ----left = mid + <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">--注意：</span><br><span class="line">	----其实对于左右边界而言</span><br><span class="line">	----返回的条件也是一样的，就是在 <span class="keyword">while</span>()&#123;&#125;中有所变化</span><br><span class="line">....... <span class="comment">//三选一</span></span><br><span class="line"> <span class="comment">// 返回中点索引值		//左边界</span></span><br><span class="line"> <span class="comment">//return -1;  		//if (left == nums.length) return -1;				//if (left - 1 &lt; 0) return -1;</span></span><br><span class="line">                    <span class="comment">// 判断一下 nums[left] 是不是 target                  // 判断一下 nums[left] 是不是 target</span></span><br><span class="line">                    <span class="comment">//return nums[left] == target ? left : -1;         //return nums[left - 1] == target ? (left - 1) : -1;</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="左右边界问题"><a href="#左右边界问题" class="headerlink" title="左右边界问题"></a>左右边界问题</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> [] result = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            result[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">            result[<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftbound</span> <span class="operator">=</span> GetLeftBound(nums,target);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightbound</span> <span class="operator">=</span> GetRightBound(nums,target);</span><br><span class="line">        result[<span class="number">0</span>] = leftbound;</span><br><span class="line">        result[<span class="number">1</span>] = rightbound;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>  result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">GetLeftBound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;   <span class="comment">//[)</span></span><br><span class="line">            mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid  + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                right= mid ;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                right = mid ;  <span class="comment">// 缩小右边界 从而找到最左边界</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// System.out.println(&quot;nums[&quot;+left+&quot;]=&quot; + &quot; &quot;+nums[left]);</span></span><br><span class="line">        <span class="keyword">if</span>(left == nums.length ) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> nums[left]  == target ? left :-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">GetRightBound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;    <span class="comment">//[)</span></span><br><span class="line">            mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid  + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                right = mid ;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(&quot;nums[&quot;+(left-1)+&quot;]=&quot; + &quot; &quot;+nums[left-1]);</span></span><br><span class="line">        <span class="keyword">if</span>(left - <span class="number">1</span> &lt; <span class="number">0</span>)  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> nums[left-<span class="number">1</span>] == target ?  left -<span class="number">1</span> :-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="旋转数组问题"><a href="#旋转数组问题" class="headerlink" title="旋转数组问题"></a>旋转数组问题</h4><blockquote>
<p>旋转数组一般 只比较 <code>mid  最右</code>（因为  尾巴（最右） 必然是小于等于 头  （最左））两个点  的大小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="number">33</span>   <span class="comment">// 找指定的taget</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length -<span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">      mid = left +(right - left)/<span class="number">2</span>;</span><br><span class="line">      <span class="comment">// head   必然是大于  tail 的</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> nums[left];</span><br><span class="line">      <span class="type">int</span> <span class="variable">tail</span> <span class="operator">=</span> nums[right];</span><br><span class="line">      <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">      <span class="comment">//可以明确的是前半部 是升序的</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt;tail)&#123;</span><br><span class="line">          <span class="comment">// 就去前半部分寻找  比如  4 5 6 7 8 9 10 11 12 0 1 2 3  找6</span></span><br><span class="line">          <span class="keyword">if</span>(nums[mid]&gt;target &amp;&amp;  head&lt;=target)&#123;</span><br><span class="line">              right = mid -<span class="number">1</span>;</span><br><span class="line">          <span class="comment">// 否则去后半部分查找  比如  4 5 6 7 8 9 10 11 12 0 1 2 3  找12</span></span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              left = mid + <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;  <span class="comment">//可以明确的是  后半部 是升序的</span></span><br><span class="line">      <span class="comment">// 6 7 0 1 2 3 4 5   找3 </span></span><br><span class="line">          <span class="keyword">if</span>(nums[mid] &lt; target &amp;&amp; tail &gt;= target)&#123;</span><br><span class="line">              left = mid +<span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 6 7 0 1 2 3 4 5   找7 </span></span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              right = mid - <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;牛客   找最小值  只与尾巴比较</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">&gt;<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minNumberInRotateArray</span><span class="params">(<span class="type">int</span> [] array)</span> &#123;</span><br><span class="line">  <span class="type">int</span>  <span class="variable">right</span> <span class="operator">=</span> array.length - <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//尾巴 必然是小于等于 头   所以只进行比较 尾巴就可以了</span></span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (left + <span class="number">1</span>  == right)  <span class="keyword">return</span> Math.min(array[left], array[right]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> <span class="variable">tail</span> <span class="operator">=</span> array[right];</span><br><span class="line">      mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">      <span class="keyword">if</span> (array[mid] &gt; tail) &#123; <span class="comment">//比尾巴还 大</span></span><br><span class="line">          left  =  mid;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] &lt; tail) &#123; <span class="comment">//比尾巴还小  说明后面一段肯定是递增的</span></span><br><span class="line">          right = mid ;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">//和尾巴 或者 头 一样大的时候   一个一个尝试</span></span><br><span class="line">          <span class="comment">// left+=1; 是过不掉 用例  1,0,1,1,1  的  原因是 我们比较的 是结尾节点的 元素(array[right])</span></span><br><span class="line">          right -= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array[mid];</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="nSum问题"><a href="#nSum问题" class="headerlink" title="nSum问题"></a>nSum问题</h2><blockquote>
<p>实际上就是把之前的题目解法合并起来了，<code>n == 2</code> 时是 <code>twoSum</code> 的双指针解法，<code>n &gt; 2</code> 时就是穷举第一个数字，然后递归调用计算 <code>(n-1)Sum</code>，组装答案。</p>
<p><strong>需要注意的是，调用这个 <code>nSum</code> 函数之前一定要先给 <code>nums</code> 数组排序</strong>，因为 <code>nSum</code> 是一个递归函数，如果在 <code>nSum</code> 函数里调用排序函数，那么每次递归都会进行没有必要的排序，效率会非常低。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求和模版：</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; <span class="title function_">nSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">long</span> target, <span class="type">int</span> n, <span class="type">int</span> start)</span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt;  res= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span> || nums.length &lt; n)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> start;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">leftval</span>  <span class="operator">=</span> nums[left];</span><br><span class="line">                <span class="type">int</span> <span class="variable">rightval</span> <span class="operator">=</span> nums[right];</span><br><span class="line">                <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> leftval + rightval;</span><br><span class="line">                <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[left]==leftval) left++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[right]==rightval) right--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                    list.add(nums[left]);</span><br><span class="line">                    list.add(nums[right]);</span><br><span class="line">                    res.add(list);</span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == leftval) left++;</span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == rightval) right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="type">int</span> i= start;</span><br><span class="line">           <span class="keyword">while</span>(i&lt;nums.length)&#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">now</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                List&lt;List&lt;Integer&gt;&gt; lists = nSum(nums,target-now,n-<span class="number">1</span>,i+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">for</span>(List&lt;Integer&gt;list : lists)&#123;</span><br><span class="line">                    list.add(now);</span><br><span class="line">                    res.add(list);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(i&lt;nums.length &amp;&amp; nums[i] == now)</span><br><span class="line">                    i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="前缀和"><a href="#前缀和" class="headerlink" title="==前缀和=="></a>==前缀和==</h2><h4 id="一维数组前缀和"><a href="#一维数组前缀和" class="headerlink" title="一维数组前缀和"></a>一维数组前缀和</h4><blockquote>
<p>就是将 一个数组 前面从  下标<code>i~j</code>的多个数进行求和</p>
</blockquote>
<h4 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">①<span class="comment">//用数组存储的形式</span></span><br><span class="line"><span class="type">int</span> preSum[] = <span class="keyword">new</span> <span class="title class_">int</span>(nums.length+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">    preSum[i] = preSum[i-<span class="number">1</span>]+nums[i-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---- 返回某一个 区间的 值</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> preSum[right + <span class="number">1</span>] - preSum[left];</span><br><span class="line"><span class="comment">//Presum 的 第一位 默认为 0 ;  赋值是从 第二位（i=1）开始的  </span></span><br><span class="line"><span class="comment">//所以是   right + 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">②<span class="comment">//不用数组存储的形式  724</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">       sum += nums[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">③<span class="comment">//使用map 集合的形式：  560   1248</span></span><br><span class="line"> 		HashMap&lt;Integer, Integer&gt; preSumMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="comment">//前缀和map集合 第一位一样为0</span></span><br><span class="line">        preSumMap.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">      	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><blockquote>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202303241717648.png" alt="image-20230324171756609" style="zoom:25%;"></p>
<ul>
<li><p>这样就能得到一个新的数组<code>preSum[]</code>，这个数组存放的 值 就是前 n  个 数求和的结果</p>
</li>
<li><p>Presum 的 第一位 默认为 0 ;  赋值是从 第二位<code>（i=1）</code>开始的</p>
</li>
</ul>
</blockquote>
<h4 id="二维数组前缀和"><a href="#二维数组前缀和" class="headerlink" title="二维数组前缀和"></a>二维数组前缀和</h4><h5 id="核心代码-1"><a href="#核心代码-1" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="type">int</span> [][]preSum = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="comment">// 计算每个矩阵 [0, 0, i, j] 的元素和</span></span><br><span class="line">                preSum[i][j] = preSum[i-<span class="number">1</span>][j] + preSum[i][j-<span class="number">1</span>] + matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] - preSum[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                <span class="comment">//获得每个矩阵的大小</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> preSum[x2+<span class="number">1</span>][y2+<span class="number">1</span>] - preSum[x1][y2+<span class="number">1</span>] - preSum[x2+<span class="number">1</span>][y1] + preSum[x1][y1];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>==注：==<br>   1、<code>preSum[i][j] = preSum[i-1][j] + preSum[i][j-1] + matrix[i - 1][j - 1] - preSum[i-1][j-1];</code></p>
<ul>
<li><p>这是来获得矩阵中每一位的 值，preSum矩阵的 行<code>i</code> 列<code>j</code>表示  原矩阵  的第<code>(i-1)</code>行第<code>(j-1)</code>列的元素之和是多少</p>
</li>
<li><p>这个公式的含义就是：</p>
</li>
</ul>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202303241646207.png" alt="image-20230324164633137"></p>
<p>将已知的 <code>矩阵面积[i-1,j]（红色部分）</code> 和<code>矩阵面积[i,j-1]（红色部分）</code>之和 减去 <code>重叠矩阵面积[i,j-1]（黄色字体部分）</code> 再加上<code>原矩阵的当前值matrix[i-1,j-1]</code>   就是所求得到<code>原矩阵[i-1,j-1]面积之和</code>  存放在 <code>现在矩阵preSum[i][j]</code>中</p>
<p><strong>注意：</strong><code>i，j</code>都是以preSum为基准，上图的矩阵是 <code>matirx</code>中的矩阵</p>
<p>2、<code>preSum[x2+1][y2+1] - preSum[x1][y2+1] - preSum[x2+1][y1] + preSum[x1][y1];</code></p>
<p>​    <strong>原理</strong>：<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202303241707744.png" alt="image-20230324170718702" style="zoom:25%;"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 560   给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的连续子数组的个数 </span></span><br><span class="line">---- 前缀和变量   +  map   一边加  一边寻找  一遍put </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">            HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">// 第一放 0</span></span><br><span class="line">            map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span>  <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">                sum += nums[i];</span><br><span class="line">                <span class="comment">//判断map中有没有 sum-k   要是有的话就说明有这个子集</span></span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(sum-k))&#123;</span><br><span class="line">                    count+=map.get(sum-k);</span><br><span class="line">                &#125;</span><br><span class="line">                map.put(sum, map.getOrDefault(sum,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">----另一种 耗时的写法:</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">            <span class="type">int</span> prefix[] = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length+<span class="number">1</span>];</span><br><span class="line">             <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">                prefix[i+<span class="number">1</span>] = prefix[i]+ nums[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;prefix.length;i++)&#123; </span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;j&lt;prefix.length-<span class="number">1</span>;j++)&#123;</span><br><span class="line">                    <span class="comment">//此处索引偏移</span></span><br><span class="line">                    <span class="keyword">if</span>(prefix[j+<span class="number">1</span>]-prefix[i] == k)&#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//1248  给你一个整数数组 nums 和一个整数 k。如果某个连续子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。</span></span><br><span class="line"></span><br><span class="line">---- 前缀和 + 思想转换 + map</span><br><span class="line">---- 奇偶 某种意义上 是等于 <span class="number">0</span>/<span class="number">1</span> 的</span><br><span class="line">    <span class="comment">// 同 560 奇数变 1，偶数变 0，然后找区间和为 k（K个1） 的子数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfSubarrays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; preSumMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="comment">//前缀和map集合 第一位一样为0</span></span><br><span class="line">        preSumMap.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//变更数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]%<span class="number">2</span> == <span class="number">0</span>) nums[i] =<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> nums[i] =<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 求前缀和为 K 的子集个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(preSumMap.containsKey(sum-k))&#123;</span><br><span class="line">                count+=preSumMap.get(sum-k);</span><br><span class="line">            &#125;</span><br><span class="line">            preSumMap.put(sum,preSumMap.getOrDefault(sum,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//724  数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pivotIndex</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        map.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">          sum -= nums[i];</span><br><span class="line">          <span class="keyword">if</span>(sum == left) <span class="keyword">return</span> i;</span><br><span class="line">          left+=nums[i];</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">------- 另外的解法</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pivotIndex</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">           sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//   方式一:判断左端 和 右端 的和</span></span><br><span class="line">    <span class="comment">//     for(int i =0;i&lt;nums.length;i++) &#123;</span></span><br><span class="line">    <span class="comment">//         right = right - nums[i];</span></span><br><span class="line">    <span class="comment">//         if (right == left) return i;</span></span><br><span class="line">    <span class="comment">//         left += nums[i]; </span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//方式二： 左端 和 + 中间点  = 总和</span></span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">              <span class="comment">//左求和*2+中心索引值 = 总和</span></span><br><span class="line">            <span class="keyword">if</span> (left * <span class="number">2</span> + nums[i] == sum) <span class="keyword">return</span> i;</span><br><span class="line">            left += nums[i]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map + 前缀和的模版</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// k-v k:前缀和（有N个奇数） v：有几种情况</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">--------模版：      <span class="comment">//（sum += num）</span></span><br><span class="line">    </span><br><span class="line">----------<span class="number">1248</span>     sum+=<span class="number">1</span>; <span class="comment">//就是转为0（偶数）/1（奇数）</span></span><br><span class="line">-------<span class="number">560</span>         sum += num; <span class="comment">//724也这么写</span></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">------<span class="number">560</span> <span class="number">1248</span>  能在一个循环的写原因是  每次累加求和 的sum 都要进行比较          </span><br><span class="line">         <span class="keyword">if</span> (map.containsKey(sum - k)) &#123;</span><br><span class="line">              count += map.get(sum - k);</span><br><span class="line">         &#125;</span><br><span class="line">         map.put(sum, map.getOrDefault(sum,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//----724 要两次循环  因为在拿到结果之后再进行比较</span></span><br><span class="line"><span class="comment">//    	for(int i= 0;i&lt;nums.length;i++)&#123;</span></span><br><span class="line"><span class="comment">//          sum -= nums[i];</span></span><br><span class="line"><span class="comment">//          if(sum == count) return i;</span></span><br><span class="line"><span class="comment">//          count+=nums[i];</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>1248  滑动窗口的解法：</p>
<blockquote>
<p>样例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;输入：nums = [2,2,2,1,2,2,1,2,2,2], k = 2</span><br><span class="line">&gt;输出：16</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">&gt;<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfSubarrays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>, oddCnt = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (right &lt; nums.length) &#123;</span><br><span class="line">      <span class="comment">// 右指针先走，每遇到一个奇数则 oddCnt++。</span></span><br><span class="line">      <span class="keyword">if</span> ((nums[right++]  % <span class="number">2</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">          oddCnt++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//  若当前滑动窗口 [left, right) 中有 k 个奇数了，进入此分支统计当前滑动窗口中的优美子数组个数。</span></span><br><span class="line">      <span class="keyword">if</span> (oddCnt == k) &#123;</span><br><span class="line">          <span class="comment">// 先将滑动窗口的右边界向右拓展，直到遇到下一个奇数（或出界）</span></span><br><span class="line">          <span class="comment">// rightEvenCnt 即为第 k 个奇数右边的偶数的个数</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> right;</span><br><span class="line">          <span class="keyword">while</span> (right &lt; nums.length &amp;&amp; (nums[right] % <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">              right++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="type">int</span> <span class="variable">rightEvenCnt</span> <span class="operator">=</span> right - tmp;</span><br><span class="line">          <span class="comment">// leftEvenCnt 即为第 1 个奇数左边的偶数的个数</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">leftEvenCnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> ((nums[left] % <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">              leftEvenCnt++;</span><br><span class="line">              left++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 第 1 个奇数左边的 leftEvenCnt 个偶数都可以作为优美子数组的起点</span></span><br><span class="line">          <span class="comment">// (因为第1个奇数左边可以1个偶数都不取，所以起点的选择有 leftEvenCnt + 1 种）</span></span><br><span class="line">          <span class="comment">// 第 k 个奇数右边的 rightEvenCnt 个偶数都可以作为优美子数组的终点</span></span><br><span class="line">          <span class="comment">// (因为第k个奇数右边可以1个偶数都不取，所以终点的选择有 rightEvenCnt + 1 种）</span></span><br><span class="line">          <span class="comment">// 所以该滑动窗口中，优美子数组左右起点的选择组合数为 (leftEvenCnt + 1) * (rightEvenCnt + 1)</span></span><br><span class="line">          res += (leftEvenCnt + <span class="number">1</span>) * (rightEvenCnt + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 此时 left 指向的是第 1 个奇数，因为该区间已经统计完了，因此 left 右移一位，oddCnt--</span></span><br><span class="line">          left++;</span><br><span class="line">          oddCnt--;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a>差分数组</h2><blockquote>
<p><strong>主要适用场景</strong> 是频繁对原始数组的<strong>某个区间的元素进行增减</strong>。</p>
<p>总共需要<code>三个数组</code></p>
</blockquote>
<h4 id="核心代码-2"><a href="#核心代码-2" class="headerlink" title="核心代码"></a>核心代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">diff[<span class="number">0</span>] = nums[<span class="number">0</span>];  <span class="comment">//区别</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">    diff[i] = nums[i]-nums[i-<span class="number">1</span>];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="原理：-1"><a href="#原理：-1" class="headerlink" title="原理："></a>原理：</h4><blockquote>
<p><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202303241742451.png" style="zoom:25%;"></p>
<p>之后就可以经由 差分数组 <strong>反推</strong> 原数组</p>
</blockquote>
<h4 id="反推代码"><a href="#反推代码" class="headerlink" title="反推代码"></a>反推代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> res[] = <span class="keyword">new</span> <span class="title class_">int</span> [diff.length];</span><br><span class="line">res[<span class="number">0</span>] = diff[<span class="number">0</span>];  <span class="comment">// 同上 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;diff.length;i++)&#123;</span><br><span class="line">    res[i] = res[i-<span class="number">1</span>]+diff[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果要对区间 <code>nums[i..j]</code> 的元素全部加 3，那么只需要让 <code>diff[i] += 3</code>，然后再让 <code>diff[j+1] -= 3</code> 即可</p>
<p>​    <strong>其实 nums[] 和 diff[] 是一样长的，所以下标长度位置也是一样的</strong>，所以直接 j+1</p>
</blockquote>
<h4 id="代码组合"><a href="#代码组合" class="headerlink" title="代码组合"></a>代码组合</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正推 差分数组</span></span><br><span class="line">	<span class="type">int</span>[] diff = <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Difference</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>( nums.length == <span class="number">0</span>)  <span class="keyword">return</span> ;</span><br><span class="line">        </span><br><span class="line">        diff = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 反推原数组</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="type">int</span>[] result() &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[diff.length];</span><br><span class="line">       </span><br><span class="line">        res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; diff.length; i++) &#123;</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行增加（+ 正数）、减少（+ 负数）操作</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">//  diff[i] 加 val   diff是差分数组   意味着从 [i]开始之后的每一个原数组中的数都会+3  就是说，这个加的数是 差值</span></span><br><span class="line">        diff[i] += val;  </span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; diff.length) &#123;</span><br><span class="line">            diff[j + <span class="number">1</span>] -= val;</span><br><span class="line">            <span class="comment">//当 j+1 &gt;= diff.length 时，说明是对 nums[i] 及以后的整个数组都进行修改，那么就不需要再给 diff 数组减 val 了。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="模版整合"><a href="#模版整合" class="headerlink" title="模版整合"></a>模版整合</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//航班预定统计    +    拼车  </span></span><br><span class="line">	<span class="type">int</span> diff[];</span><br><span class="line">    <span class="type">int</span> result [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] corpFlightBookings(<span class="type">int</span>[][] bookings, <span class="type">int</span> n) &#123;</span><br><span class="line">        </span><br><span class="line">        result = <span class="keyword">new</span> <span class="title class_">int</span> [n];</span><br><span class="line">        diff = <span class="keyword">new</span> <span class="title class_">int</span> [n];</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || bookings.length == <span class="number">0</span> ) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正推 diff 数组的值</span></span><br><span class="line">        <span class="comment">//diff[0] = nums[0];</span></span><br><span class="line">        <span class="comment">//for(int i = 1; i &lt; n-1; i++)&#123;</span></span><br><span class="line">        	<span class="comment">// 某个一维数组 nums</span></span><br><span class="line">            <span class="comment">//diff[i] = nums[i]-nums[i-1];</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环 且 操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> []booking :bookings)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> booking[<span class="number">0</span>]-<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> booking[<span class="number">1</span>]-<span class="number">1</span>;  <span class="comment">//-1 是因为下标是从 1 开始的，要是从 0 开始就不用 -1</span></span><br><span class="line">            <span class="type">int</span> val=booking[<span class="number">2</span>];</span><br><span class="line">            							 <span class="comment">//  航班预订统计</span></span><br><span class="line">            							 <span class="comment">//  int j  = trip[2]-1; //坐标范围： 0 &lt;= fromi &lt; toi &lt;= 1000</span></span><br><span class="line">            													 <span class="comment">//但是 在 trip[2]  位置已经下车，在车上的区间就是  [trip[1],trip[2]-1]</span></span><br><span class="line">           <span class="comment">// 进行操作</span></span><br><span class="line">            diff[i] += val;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//diff.length</span></span><br><span class="line">            <span class="keyword">if</span>(j+<span class="number">1</span>&lt;diff.length)&#123;</span><br><span class="line">            	diff[j+<span class="number">1</span>] -= val;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反推 原数组的值</span></span><br><span class="line">        result[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;diff.length;i++)&#123;</span><br><span class="line">            result[i] = result[i-<span class="number">1</span>]+diff[i];</span><br><span class="line">            	<span class="comment">//拼车时：</span></span><br><span class="line">            	 <span class="keyword">if</span>(res[i] &gt; capacity) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;    <span class="comment">//return true;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><h4 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h4><blockquote>
<p>==注意== 所有入栈的元素全是 数组下标  <code>Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();  //存的都是角标</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>()&#123;...见下&#125;</span><br><span class="line"><span class="comment">// 最大面积    单调减栈 -----------------------------------数组扩容，收尾 + 0</span></span><br><span class="line"> <span class="comment">// 当前 比 前面的都要 小的栈顶元素</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> res[stack.peek()];</span><br><span class="line">                <span class="comment">//System.out.print(mid);</span></span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">                     <span class="comment">// 左边第一个比 当前值小 的柱子</span></span><br><span class="line">                    <span class="comment">//int left = res[stack.peek()];</span></span><br><span class="line">                    <span class="comment">//System.out.print(left);</span></span><br><span class="line">                    <span class="comment">// 右边第一个比 当前值小 的柱子</span></span><br><span class="line">                    <span class="comment">//int right = res[i];</span></span><br><span class="line">                    <span class="comment">//System.out.print(right);</span></span><br><span class="line">                    <span class="comment">// 左右最小柱子之间的 间隔 底</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> i-stack.peek()-<span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//System.out.print(len);</span></span><br><span class="line">                    <span class="comment">// 以当前柱子为 高 算得 最 大面积</span></span><br><span class="line">                    result= Math.max(result,mid*len);</span><br><span class="line">                    <span class="comment">//System.out.print(result);</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>==496  下一个更大数 I==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="type">int</span> result[];</span><br><span class="line">&gt;<span class="type">int</span> []res;</span><br><span class="line">&gt;<span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElement(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line"></span><br><span class="line">  res = <span class="keyword">new</span> <span class="title class_">int</span>[nums2.length];</span><br><span class="line">  Arrays.fill(res,-<span class="number">1</span>);</span><br><span class="line">  result  = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length];</span><br><span class="line">  Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">  HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">//先将 第 0 个 元素加入到栈，防止栈空 </span></span><br><span class="line">  stack.push(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums2.length; i++) &#123;</span><br><span class="line">      <span class="comment">//单调递增栈</span></span><br><span class="line">      <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; nums2[i]&gt;nums2[stack.peek()]) &#123;</span><br><span class="line">          res[stack.peek()] = nums2[i];</span><br><span class="line">          stack.pop();</span><br><span class="line">      &#125;</span><br><span class="line">      stack.push(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums2.length; i++) &#123;</span><br><span class="line">      map.put(nums2[i],res[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">      result[i]= map.get(nums1[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>==503 下一个更大数 II==</p>
<p>==环形数组处理方法==  % 取余  加长数组长度，使数组长 * 2   之后对所有的i 相关操作 % nums.length</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="type">int</span> res[];</span><br><span class="line">&gt;<span class="type">int</span> result[];</span><br><span class="line">&gt;<span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElements(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">  res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span> * nums.length];</span><br><span class="line">  result = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">  Arrays.fill(res,-<span class="number">1</span>);</span><br><span class="line">  Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">  stack.push(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;<span class="number">2</span> * nums.length; i++) &#123;</span><br><span class="line">      <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; nums[i%nums.length] &gt; nums[stack.peek()]) &#123;</span><br><span class="line">          res[stack.peek()] = nums[i%nums.length];</span><br><span class="line">          stack.pop();</span><br><span class="line">      &#125;</span><br><span class="line">      stack.push(i%nums.length);</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">      result[i] = res[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>==739  每日温度  下一个大的数的角标==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;</span><br><span class="line">  <span class="type">int</span> []res  = <span class="keyword">new</span> <span class="title class_">int</span> [temperatures.length];</span><br><span class="line">  Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();  <span class="comment">//存的都是角标</span></span><br><span class="line">  <span class="comment">// 首先把数组的 第一个元素入栈，随后才能比较</span></span><br><span class="line">  stack.push(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; temperatures.length;i++)&#123;</span><br><span class="line">      <span class="comment">// 这里 temperatures[i]&gt;temperatures[stack.peek()]  大于  就是单调增 栈</span></span><br><span class="line">      <span class="comment">//       			  &lt;							   小于  就是单调减 栈</span></span><br><span class="line">      <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; temperatures[i]&gt;temperatures[stack.peek()])&#123;</span><br><span class="line">          <span class="comment">// 返回下标之间的差值</span></span><br><span class="line">          res[stack.peek()] = i - stack.peek();   </span><br><span class="line">          <span class="comment">// 返回下标对应的值</span></span><br><span class="line">          <span class="comment">//res[stack.peek()] = nums2[i];     两个数组的话可以用map进行接收 </span></span><br><span class="line">          stack.pop();</span><br><span class="line">      &#125;  </span><br><span class="line">      stack.push(i);      </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>==42接雨水==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">  <span class="type">int</span> res [] = <span class="keyword">new</span> <span class="title class_">int</span>[height.length];</span><br><span class="line">  Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">  stack.push(<span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; height.length;i++) &#123;</span><br><span class="line">      <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peek()]) &#123;</span><br><span class="line">       <span class="comment">// 接雨水    单调增栈</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> height[stack.peek()];</span><br><span class="line">          <span class="comment">// 出栈</span></span><br><span class="line">          stack.pop();</span><br><span class="line">          <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">              <span class="comment">// 左边第一个高的   就是栈里面 凹槽值 的下一个</span></span><br><span class="line">              <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span>height[stack.peek()];</span><br><span class="line">              <span class="comment">// 右边第一个高的   就是当前要进栈的值</span></span><br><span class="line">              <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span>height[i];</span><br><span class="line">              <span class="comment">// 底</span></span><br><span class="line">              <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> i-stack.peek()-<span class="number">1</span>;  <span class="comment">//-1</span></span><br><span class="line">              <span class="comment">// 高</span></span><br><span class="line">              <span class="type">int</span> <span class="variable">hei</span> <span class="operator">=</span> Math.min(left,right)-mid;</span><br><span class="line">              <span class="comment">//面积 = 底*高</span></span><br><span class="line">              sum +=  hei*len;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">         stack.push(i);</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="keyword">return</span> sum;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>==84一维最大面积==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">&gt;<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">  <span class="comment">// 思路是 算出每个柱子为高的最大面积 比较大小</span></span><br><span class="line">  <span class="type">int</span> res[] = <span class="keyword">new</span> <span class="title class_">int</span>[heights.length +<span class="number">2</span>];</span><br><span class="line">  <span class="type">int</span> result= <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//收尾加0 防止特殊情况 &lt;=</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= heights.length; i++) &#123;</span><br><span class="line">     res[i] = heights[i-<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//单调递减栈</span></span><br><span class="line">  Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">  stack.push(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">      <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; res[i] &lt; res[stack.peek()]) &#123;</span><br><span class="line">          <span class="comment">// 当前 比 前面的都要 小的栈顶元素</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> res[stack.peek()];</span><br><span class="line">          <span class="comment">//System.out.print(mid);</span></span><br><span class="line">          stack.pop();</span><br><span class="line">          <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">               <span class="comment">// 左边第一个比 当前值小 的柱子</span></span><br><span class="line">              <span class="comment">//int left = res[stack.peek()];</span></span><br><span class="line"></span><br><span class="line">              <span class="comment">// 右边第一个比 当前值小 的柱子</span></span><br><span class="line">              <span class="comment">//int right = res[i];</span></span><br><span class="line"></span><br><span class="line">              <span class="comment">// 左右最小柱子之间的 间隔 底</span></span><br><span class="line">              <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> i-stack.peek()-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 以当前柱子为 高 算得 最 大面积</span></span><br><span class="line">              result= Math.max(result,mid*len);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      stack.push(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>==85 二维最大面积==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalRectangle</span><span class="params">(<span class="type">char</span>[][] matrix)</span> &#123;</span><br><span class="line">&gt;<span class="type">int</span>  <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">&gt;<span class="type">int</span>  <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">&gt;<span class="type">int</span> height[] = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">&gt;<span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m;i++)&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(matrix[i][j]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">             height[j] +=<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             height[j] = <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">      <span class="comment">// 每一层都进行 求面积  和 对面积的比较</span></span><br><span class="line">      res = Math.max(res,largestRectangleArea(height));</span><br><span class="line"> &#125;</span><br><span class="line">&gt;<span class="keyword">return</span> res;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">      <span class="comment">// 思路是 算出每个柱子为高的最大面积 比较大小</span></span><br><span class="line">      <span class="type">int</span> res[] = <span class="keyword">new</span> <span class="title class_">int</span>[heights.length +<span class="number">2</span>];</span><br><span class="line">      <span class="type">int</span> result= <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//收尾加0 防止特殊情况 &lt;=</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= heights.length; i++) &#123;</span><br><span class="line">         res[i] = heights[i-<span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//单调递减栈</span></span><br><span class="line">      Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">      stack.push(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">          <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; res[i] &lt; res[stack.peek()]) &#123;</span><br><span class="line">              <span class="comment">// 当前 比 前面的都要 小的栈顶元素</span></span><br><span class="line">              <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> res[stack.peek()];</span><br><span class="line">              <span class="comment">//System.out.print(mid);</span></span><br><span class="line">              stack.pop();</span><br><span class="line">              <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">                   <span class="comment">// 左边第一个比 当前值小 的柱子</span></span><br><span class="line">                  <span class="comment">//int left = res[stack.peek()];</span></span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 右边第一个比 当前值小 的柱子</span></span><br><span class="line">                  <span class="comment">//int right = res[i];</span></span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 左右最小柱子之间的 间隔 底</span></span><br><span class="line">                  <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> i-stack.peek()-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 以当前柱子为 高 算得 最 大面积</span></span><br><span class="line">                  result= Math.max(result,mid*len);</span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">          stack.push(i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><h4 id="应用场景：处理字符串前缀相关"><a href="#应用场景：处理字符串前缀相关" class="headerlink" title="应用场景：处理字符串前缀相关"></a>应用场景：处理字符串前缀相关</h4><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TrieMap中的树节点TrieNode的代码实现是这样</span><br><span class="line"></span><br><span class="line">TrieMap&lt;V&gt;的键必须是字符串类型，值的类型V可以随意</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* Trie 树节点实现 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="type">V</span> <span class="variable">val</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    TrieNode&lt;V&gt;[] children = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">256</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val字段存储键对应的值，children数组存储指向子节点的指针。</span><br><span class="line">    </span><br><span class="line">TrieNode中children数组的索引是有意义的，代表键中的一个字符。</span><br><span class="line">比如说children[<span class="number">97</span>]如果非空，说明这里存储了一个字符<span class="string">&#x27;a&#x27;</span>，因为<span class="string">&#x27;a&#x27;</span>的 ASCII 码为 <span class="number">97</span>。</span><br><span class="line">    </span><br><span class="line">TrieNode节点本身只存储val字段，并没有一个字段来存储字符，字符是通过子节点在父节点的children数组中的索引确定的</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>==Trie 树用「树枝」存储字符串（键），用「节点」存储字符串（键）对应的数据（值）。==</p>
</blockquote>
<h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeMap API </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 底层用 Trie 树实现的键值映射</span></span><br><span class="line"><span class="comment">// 键为 String 类型，值为类型 V</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieMap</span>&lt;V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 增/改 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 Map 中添加 key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, V val)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 删 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除键 key 以及对应的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(String key)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 查 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 搜索 key 对应的值，不存在则返回 null</span></span><br><span class="line">    <span class="comment">// get(&quot;the&quot;) -&gt; 4</span></span><br><span class="line">    <span class="comment">// get(&quot;tha&quot;) -&gt; null</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(String key)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 key 是否存在在 Map 中</span></span><br><span class="line">    <span class="comment">// containsKey(&quot;tea&quot;) -&gt; false</span></span><br><span class="line">    <span class="comment">// containsKey(&quot;team&quot;) -&gt; true</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(String key)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 Map 的所有键中搜索 query 的最短前缀</span></span><br><span class="line">    <span class="comment">// shortestPrefixOf(&quot;themxyz&quot;) -&gt; &quot;the&quot;</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">shortestPrefixOf</span><span class="params">(String query)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 Map 的所有键中搜索 query 的最长前缀</span></span><br><span class="line">    <span class="comment">// longestPrefixOf(&quot;themxyz&quot;) -&gt; &quot;them&quot;</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPrefixOf</span><span class="params">(String query)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 搜索所有前缀为 prefix 的键</span></span><br><span class="line">    <span class="comment">// keysWithPrefix(&quot;th&quot;) -&gt; [&quot;that&quot;, &quot;the&quot;, &quot;them&quot;]</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">keysWithPrefix</span><span class="params">(String prefix)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是和否存在前缀为 prefix 的键</span></span><br><span class="line">    <span class="comment">// hasKeyWithPrefix(&quot;tha&quot;) -&gt; true</span></span><br><span class="line">    <span class="comment">// hasKeyWithPrefix(&quot;apple&quot;) -&gt; false</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKeyWithPrefix</span><span class="params">(String prefix)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通配符 . 匹配任意字符，搜索所有匹配的键</span></span><br><span class="line">    <span class="comment">// keysWithPattern(&quot;t.a.&quot;) -&gt; [&quot;team&quot;, &quot;that&quot;]</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">keysWithPattern</span><span class="params">(String pattern)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通配符 . 匹配任意字符，判断是否存在匹配的键</span></span><br><span class="line">    <span class="comment">// hasKeyWithPattern(&quot;.ip&quot;) -&gt; true</span></span><br><span class="line">    <span class="comment">// hasKeyWithPattern(&quot;.i&quot;) -&gt; false</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKeyWithPattern</span><span class="params">(String pattern)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 Map 中键值对的数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="API实现"><a href="#API实现" class="headerlink" title="API实现"></a>API实现</h4><blockquote>
<p><code>TrieMap</code>类中一定需要记录 Trie 的根节点<code>root</code>，以及 Trie 树中的所有节点数量用于实现<code>size()</code>方法</p>
</blockquote>
<h5 id="实现containsKey方法和get方法"><a href="#实现containsKey方法和get方法" class="headerlink" title="实现containsKey方法和get方法"></a>实现<code>containsKey</code>方法和<code>get</code>方法</h5><blockquote>
<p><strong>就算<code>getNode(key)</code>的返回值<code>x</code>非空，也只能说字符串<code>key</code>是一个「前缀」；除非<code>x.val</code>同时非空，才能判断键<code>key</code>存在</strong>。</p>
</blockquote>
<h5 id="实现shortestPrefixOf方法"><a href="#实现shortestPrefixOf方法" class="headerlink" title="实现shortestPrefixOf方法"></a>实现<code>shortestPrefixOf</code>方法</h5><blockquote>
<p><strong>这里需要注意的是 for 循环结束之后我们还需要额外检查一下</strong>。</p>
<p>因为之前说了 Trie 树中「树枝」存储字符串，「节点」存储字符串对应的值，for 循环相当于只遍历了「树枝」，但漏掉了最后一个「节点」，即<code>key</code>本身就是<code>TrieMap</code>中的一个键的情况。</p>
</blockquote>
<h5 id="实现-longestPrefixOf方法"><a href="#实现-longestPrefixOf方法" class="headerlink" title="实现 longestPrefixOf方法"></a>实现 <code>longestPrefixOf</code>方法</h5><blockquote>
<p>每次遇到<code>p.val</code>非空的时候说明找到一个键，但是我们不急着返回，而是更新<code>max_len</code>变量，记录最长前缀的长度。</p>
<p>同样的，在 for 循环结束时还是要特殊判断一下，处理<code>key</code>本身就是键的情况。</p>
</blockquote>
<h5 id="实现keysWithPrefix方法"><a href="#实现keysWithPrefix方法" class="headerlink" title="实现keysWithPrefix方法"></a>实现<code>keysWithPrefix</code>方法</h5><blockquote>
<p>得到所有前缀为<code>prefix</code>的键:先利用<code>getNode</code>函数在 Trie 树中找到<code>prefix</code>对应的节点<code>x</code>，然施展多叉树的遍历算法，遍历以<code>x</code>为根的这棵 Trie 树，找到所有键值对：</p>
</blockquote>
<h5 id="实现keysWithPattern方法"><a href="#实现keysWithPattern方法" class="headerlink" title="实现keysWithPattern方法"></a>实现<code>keysWithPattern</code>方法</h5><blockquote>
<p>使用通配符来匹配多个键，其关键就在于通配符<code>.</code>可以匹配所有字符</p>
<p><code>keysWithPattern</code>和<code>keysWithPrefix</code>的实现是有些类似的，而且这两个函数还有一个潜在的特性：<strong>它们返回的结果列表一定是符合「字典序」的</strong>。</p>
</blockquote>
<h5 id="实现hasKeyWithPattern方法"><a href="#实现hasKeyWithPattern方法" class="headerlink" title="实现hasKeyWithPattern方法"></a>实现<code>hasKeyWithPattern</code>方法</h5><blockquote>
<p>判断是否存在键匹配模式串</p>
</blockquote>
<h5 id="实现put方法"><a href="#实现put方法" class="headerlink" title="实现put方法"></a>实现<code>put</code>方法</h5><blockquote>
<p><strong>Trie 树中的键就是「树枝」，值就是「节点」，所以插入的逻辑就是沿路新建「树枝」，把<code>key</code>的整条「树枝」构建出来之后，在树枝末端的「节点」中存储<code>val</code></strong>：</p>
</blockquote>
<h5 id="实现remove函数"><a href="#实现remove函数" class="headerlink" title="实现remove函数"></a>实现<code>remove</code>函数</h5><blockquote>
<p>如果你想删除键<code>&quot;team&quot;</code>，那么需要删掉<code>&quot;eam&quot;</code>这条树枝才是符合逻辑的;删多了肯定不行，但删少了也不行，否则前文实现的<code>hasKeyWithPrefix</code>就会出错。</p>
<p>首先，递归修改数据结构的时候，如果一个节点想删掉自己，直接返回空指针就行了。</p>
<p><strong>其次，一个节点如何知道自己是否需要被删除呢？主要看自己的<code>val</code>字段是否为空以及自己的<code>children</code>数组是否全都是空指针</strong>。</p>
<p><strong>一个节点如何知道自己是否需要被删除呢？主要看自己的<code>val</code>字段是否为空以及自己的<code>children</code>数组是否全都是空指针</strong>。</p>
<p>==后序位置的特点==</p>
<p>一个节点要先递归处理子树，然后在后序位置检查自己的<code>val</code>字段和<code>children</code>列表，判断自己是否需要被删除。</p>
<p>如果自己的<code>val</code>字段为空，说明自己没有存储值，如果同时自己的<code>children</code>数组全是空指针，说明自己下面也没有接树枝，即不是任何一个键的前缀。这种情况下这个节点就没有存在的意义了，应该删掉自己。</p>
</blockquote>
<h5 id="TrieMap完整API"><a href="#TrieMap完整API" class="headerlink" title="TrieMap完整API"></a><code>TrieMap</code>完整API</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieMap</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">// ASCII 码个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> <span class="number">256</span>;</span><br><span class="line">    <span class="comment">// 当前存在 Map 中的键值对个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Trie 树的根节点</span></span><br><span class="line">    <span class="keyword">private</span> TrieNode&lt;V&gt; root = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TrieNode</span>&lt;V&gt; &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">val</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        TrieNode&lt;V&gt;[] children = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[R];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 增/改 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 map 中添加或修改键值对</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, V val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">// 新增键值对</span></span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 需要一个额外的辅助函数，并接收其返回值</span></span><br><span class="line">        root = put(root, key, val, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：向以 node 为根的 Trie 树中插入 key[i..]，返回插入完成后的根节点</span></span><br><span class="line">    <span class="keyword">private</span> TrieNode&lt;V&gt; <span class="title function_">put</span><span class="params">(TrieNode&lt;V&gt; node, String key, V val, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果树枝不存在，新建</span></span><br><span class="line">            node = <span class="keyword">new</span> <span class="title class_">TrieNode</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == key.length()) &#123;</span><br><span class="line">            <span class="comment">// key 的路径已插入完成，将值 val 存入节点</span></span><br><span class="line">            node.val = val;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> key.charAt(i);</span><br><span class="line">        <span class="comment">// 递归插入子节点，并接收返回值</span></span><br><span class="line">        node.children[c] = put(node.children[c], key, val, i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 删 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 Map 中删除 key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归修改数据结构要接收函数的返回值</span></span><br><span class="line">        root = remove(root, key, <span class="number">0</span>);</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：在以 node 为根的 Trie 树中删除 key[i..]，返回删除后的根节点</span></span><br><span class="line">    <span class="keyword">private</span> TrieNode&lt;V&gt; <span class="title function_">remove</span><span class="params">(TrieNode&lt;V&gt; node, String key, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == key.length()) &#123;</span><br><span class="line">            <span class="comment">// 找到了 key 对应的 TrieNode，删除 val</span></span><br><span class="line">            node.val = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> key.charAt(i);</span><br><span class="line">            <span class="comment">// 递归去子树进行删除</span></span><br><span class="line">            node.children[c] = remove(node.children[c], key, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 后序位置，递归路径上的节点可能需要被清理</span></span><br><span class="line">        <span class="keyword">if</span> (node.val != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果该 TireNode 存储着 val，不需要被清理</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查该 TrieNode 是否还有后缀</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; R; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.children[c] != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 只要存在一个子节点（后缀树枝），就不需要被清理</span></span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 既没有存储 val，也没有后缀树枝，则该节点需要被清理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 查 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 搜索 key 对应的值，不存在则返回 null</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="comment">// 从 root 开始搜索 key</span></span><br><span class="line">        TrieNode&lt;V&gt; x = getNode(root, key);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span> || x.val == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// x 为空或 x 的 val 字段为空都说明 key 没有对应的值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 key 是否存在在 Map 中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> get(key) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是和否存在前缀为 prefix 的键</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKeyWithPrefix</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="comment">// 只要能找到一个节点，就是存在前缀</span></span><br><span class="line">        <span class="keyword">return</span> getNode(root, prefix) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在所有键中寻找 query 的最短前缀</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">shortestPrefixOf</span><span class="params">(String query)</span> &#123;</span><br><span class="line">        TrieNode&lt;V&gt; p = root;</span><br><span class="line">        <span class="comment">// 从节点 node 开始搜索 key</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; query.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 无法向下搜索</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p.val != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 找到一个键是 query 的前缀</span></span><br><span class="line">                <span class="keyword">return</span> query.substring(<span class="number">0</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向下搜索</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> query.charAt(i);</span><br><span class="line">            p = p.children[c];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; p.val != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 query 本身就是一个键</span></span><br><span class="line">            <span class="keyword">return</span> query;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在所有键中寻找 query 的最长前缀</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPrefixOf</span><span class="params">(String query)</span> &#123;</span><br><span class="line">        TrieNode&lt;V&gt; p = root;</span><br><span class="line">        <span class="comment">// 记录前缀的最大长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max_len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从节点 node 开始搜索 key</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; query.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 无法向下搜索</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p.val != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 找到一个键是 query 的前缀，更新前缀的最大长度</span></span><br><span class="line">                max_len = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向下搜索</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> query.charAt(i);</span><br><span class="line">            p = p.children[c];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; p.val != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 query 本身就是一个键</span></span><br><span class="line">            <span class="keyword">return</span> query;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> query.substring(<span class="number">0</span>, max_len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 搜索前缀为 prefix 的所有键</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">keysWithPrefix</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 找到匹配 prefix 在 Trie 树中的那个节点</span></span><br><span class="line">        TrieNode&lt;V&gt; x = getNode(root, prefix);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// DFS 遍历以 x 为根的这棵 Trie 树</span></span><br><span class="line">        traverse(x, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(prefix), res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历以 node 节点为根的 Trie 树，找到所有键</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TrieNode&lt;V&gt; node, StringBuilder path, List&lt;String&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 到达 Trie 树底部叶子结点</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.val != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 找到一个 key，添加到结果列表中</span></span><br><span class="line">            res.add(path.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回溯算法遍历框架</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; R; c++) &#123;</span><br><span class="line">            <span class="comment">// 做选择</span></span><br><span class="line">            path.append(c);</span><br><span class="line">            traverse(node.children[c], path, res);</span><br><span class="line">            <span class="comment">// 撤销选择</span></span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通配符 . 匹配任意字符</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">keysWithPattern</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        traverse(root, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(), pattern, <span class="number">0</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历函数，尝试在「以 node 为根的 Trie 树中」匹配 pattern[i..]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TrieNode&lt;V&gt; node, StringBuilder path, String pattern, <span class="type">int</span> i, List&lt;String&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 树枝不存在，即匹配失败</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == pattern.length()) &#123;</span><br><span class="line">            <span class="comment">// pattern 匹配完成</span></span><br><span class="line">            <span class="keyword">if</span> (node.val != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果这个节点存储着 val，则找到一个匹配的键</span></span><br><span class="line">                res.add(path.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> pattern.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// pattern[i] 是通配符，可以变化成任意字符</span></span><br><span class="line">            <span class="comment">// 多叉树（回溯算法）遍历框架</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; R; j++) &#123;</span><br><span class="line">                path.append(j);</span><br><span class="line">                traverse(node.children[j], path, pattern, i + <span class="number">1</span>, res);</span><br><span class="line">                path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// pattern[i] 是普通字符 c</span></span><br><span class="line">            path.append(c);</span><br><span class="line">            traverse(node.children[c], path, pattern, i + <span class="number">1</span>, res);</span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是和否存在前缀为 prefix 的键</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKeyWithPattern</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">        <span class="comment">// 从 root 节点开始匹配 pattern[0..]</span></span><br><span class="line">        <span class="keyword">return</span> hasKeyWithPattern(root, pattern, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数定义：从 node 节点开始匹配 pattern[i..]，返回是否成功匹配</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasKeyWithPattern</span><span class="params">(TrieNode&lt;V&gt; node, String pattern, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 树枝不存在，即匹配失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == pattern.length()) &#123;</span><br><span class="line">            <span class="comment">// 模式串走到头了，看看匹配到的是否是一个键</span></span><br><span class="line">            <span class="keyword">return</span> node.val != <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> pattern.charAt(i);</span><br><span class="line">        <span class="comment">// 没有遇到通配符</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 从 node.children[c] 节点开始匹配 pattern[i+1..]</span></span><br><span class="line">            <span class="keyword">return</span> hasKeyWithPattern(node.children[c], pattern, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遇到通配符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; R; j++) &#123;</span><br><span class="line">            <span class="comment">// pattern[i] 可以变化成任意字符，尝试所有可能，只要遇到一个匹配成功就返回</span></span><br><span class="line">            <span class="keyword">if</span> (hasKeyWithPattern(node.children[j], pattern, i + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 都没有匹配</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从节点 node 开始搜索 key，如果存在返回对应节点，否则返回 null</span></span><br><span class="line">    <span class="keyword">private</span> TrieNode&lt;V&gt; <span class="title function_">getNode</span><span class="params">(TrieNode&lt;V&gt; node, String key)</span> &#123;</span><br><span class="line">        TrieNode&lt;V&gt; p = node;</span><br><span class="line">        <span class="comment">// 从节点 node 开始搜索 key</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; key.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 无法向下搜索</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向下搜索</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> key.charAt(i);</span><br><span class="line">            p = p.children[c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="TrieSet完整API"><a href="#TrieSet完整API" class="headerlink" title="TrieSet完整API"></a><code>TrieSet</code>完整API</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieSet</span> &#123;</span><br><span class="line">    <span class="comment">// 底层用一个 TrieMap，键就是 TrieSet，值仅仅起到占位的作用</span></span><br><span class="line">    <span class="comment">// 值的类型可以随便设置，我参考 Java 标准库设置成 Object</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TrieMap&lt;Object&gt; map = <span class="keyword">new</span> <span class="title class_">TrieMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 增 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在集合中添加元素 key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        map.put(key, <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 删 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从集合中删除元素 key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        map.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 查 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断元素 key 是否存在集合中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.containsKey(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在集合中寻找 query 的最短前缀</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">shortestPrefixOf</span><span class="params">(String query)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.shortestPrefixOf(query);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在集合中寻找 query 的最长前缀</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPrefixOf</span><span class="params">(String query)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.longestPrefixOf(query);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在集合中搜索前缀为 prefix 的所有元素</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">keysWithPrefix</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.keysWithPrefix(prefix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断集合中是否存在前缀为 prefix 的元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKeyWithPrefix</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.hasKeyWithPrefix(prefix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通配符 . 匹配任意字符，返回集合中匹配 pattern 的所有元素</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">keysWithPattern</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.keysWithPattern(pattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通配符 . 匹配任意字符，判断集合中是否存在匹配 pattern 的元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKeyWithPattern</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.hasKeyWithPattern(pattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回集合中元素的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>==函数的调用关系==</p>
<p>==增/改==    <strong>put</strong> –&gt;<strong>containsKey</strong>、<strong>put</strong>&lt;递归&gt;</p>
<p>==删==    <strong>remove</strong>-&gt;<strong>containsKey</strong>、<strong>remove</strong> &lt;递归&gt;</p>
<p>==查==    <strong>get</strong>-&gt; <strong>getNode</strong></p>
<p>==是否存在==     <strong>containsKey</strong>-&gt; <strong>get</strong></p>
<p>==是否存在前缀为 prefix 的键==   <strong>hasKeyWithPrefix</strong>-&gt;<strong>getNode</strong></p>
<p>==是否存在符合的通配符的键==  <strong>hasKeyWithPattern</strong>  &lt;递归&gt;</p>
<p>==最短前缀==       <strong>shortestPrefixOf</strong></p>
<p>==最长前缀==       <strong>longestPrefixOf</strong></p>
<p>==搜索前缀为 prefix 的所有键==    <strong>keysWithPrefix</strong>-&gt;<strong>getNode</strong> 、 <strong>traverse</strong>&lt;递归&gt;</p>
<p>==通配符 . 匹配任意字符==       <strong>keysWithPattern</strong>-&gt; <strong>traverse</strong>&lt;递归&gt;</p>
<p>==从节点 node 开始搜索 key，如果存在返回对应节点==   <strong>getNode </strong></p>
<p>==大小==       <strong>size</strong></p>
</blockquote>
<h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><blockquote>
<p>本质：  也是递归</p>
<p><strong>1、不要思考整体，而是把目光聚焦局部，只看一个运算符</strong>。</p>
<p>比如 <a href="https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-66994/dong-ge-da-cbce8/">手把手刷二叉树第一期</a> 就告诉你解决二叉树系列问题只要思考每个节点需要做什么，而不要思考整棵树需要做什么。</p>
<p>说白了，解决递归相关的算法问题，就是一个化整为零的过程，你必须瞄准一个小的突破口，然后把问题拆解，大而化小，利用递归函数来解决。</p>
<p><strong>2、明确递归函数的定义是什么，相信并且利用好函数的定义</strong>。</p>
<p>这个函数不就是干这个事儿的吗？<strong>这就是我们之前说的第二个关键点，明确函数的定义，相信并且利用这个函数定义</strong>。</p>
<p>你甭管这个函数怎么做到的，你相信它能做到，然后用就行了，最后它就真的能做到了。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结果集接收</span></span><br><span class="line">     List&lt;Integer&gt; res= <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">     <span class="comment">// 优化</span></span><br><span class="line">     HashMap&lt;String, List&lt;Integer&gt;&gt; meno = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">     <span class="keyword">if</span>(meno.containsKey(expression))&#123;</span><br><span class="line">         <span class="keyword">return</span> meno.get(expression);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="comment">//分治</span></span><br><span class="line">     <span class="comment">// 分（递归）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;expression.length(); i++) &#123;</span><br><span class="line">         <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> expression.charAt(i);</span><br><span class="line">          <span class="comment">//题设只有三种运算符</span></span><br><span class="line">        <span class="comment">// 如果是运算符就 继续进行缩减</span></span><br><span class="line">         <span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span> || c==<span class="string">&#x27;+&#x27;</span> || c==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">             List&lt;Integer&gt; left = diffWaysToCompute(expression.substring(<span class="number">0</span>,i));</span><br><span class="line">             List&lt;Integer&gt; right = diffWaysToCompute(expression.substring(i+<span class="number">1</span>));</span><br><span class="line">    <span class="comment">//治（怎么做）</span></span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> a:left) &#123;</span><br><span class="line">                 <span class="keyword">for</span>(<span class="type">int</span> b:right)&#123;</span><br><span class="line">                     <span class="keyword">if</span>(c ==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                         res.add(a-b);</span><br><span class="line">                     <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">                         res.add(a+b);</span><br><span class="line">                     <span class="keyword">else</span></span><br><span class="line">                         res.add(a*b);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// 递归截止条件</span></span><br><span class="line">     <span class="keyword">if</span>(res.isEmpty())&#123;</span><br><span class="line">         res.add(Integer.parseInt(expression));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>
<h2 id="手撕-LRU"><a href="#手撕-LRU" class="headerlink" title="手撕 LRU"></a>手撕 LRU</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    LinkedHashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//表示访问</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(key))&#123;</span><br><span class="line">            <span class="keyword">return</span>  -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//移至表尾</span></span><br><span class="line">        changeSwap(key);</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示添加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">            <span class="comment">//值的替换</span></span><br><span class="line">            map.put(key, value);</span><br><span class="line">    <span class="comment">//移到表尾</span></span><br><span class="line">            changeSwap(key);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 超出预设值 删除表头</span></span><br><span class="line">        <span class="keyword">if</span>(map.size() &gt; capacity)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> map.keySet().iterator().next();</span><br><span class="line">            map.remove(first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//直接添加到表尾即可</span></span><br><span class="line">        map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">changeSwap</span><span class="params">(<span class="type">int</span> key)</span>&#123;</span><br><span class="line">        <span class="comment">// 找到对应的元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        <span class="comment">//随后进行删除</span></span><br><span class="line">        map.remove(key);</span><br><span class="line">        <span class="comment">//再将其加到表尾</span></span><br><span class="line">        map.put(key,val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="栈实现队列"><a href="#栈实现队列" class="headerlink" title="栈实现队列"></a>栈实现队列</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">//只管入栈就可以了</span></span><br><span class="line">        stack1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//入栈结束之后，栈2 为空才会进行从栈1 进栈，直到栈1 为空</span></span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 防止栈2 为空</span></span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">            peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//要两个栈一起为空的时候才为空，否则可能会因为没有pop操作导致一空一非空</span></span><br><span class="line">        <span class="keyword">return</span> stack2.isEmpty() &amp;&amp; stack1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="队列实现栈"><a href="#队列实现栈" class="headerlink" title="队列实现栈"></a>队列实现栈</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">两个队列</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    Queue&lt;Integer&gt; queue2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//  需要进行交换</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        queue1.offer(x);</span><br><span class="line">        <span class="keyword">while</span>(!queue2.isEmpty())&#123;</span><br><span class="line">            queue1.offer(queue2.poll());</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">//第一遍的时候不会进行while()循环</span></span><br><span class="line">        Queue&lt;Integer&gt; tmp = queue2;</span><br><span class="line">        queue2 = queue1;</span><br><span class="line">        queue1 =tmp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue2.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue2.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">单个队列</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  需要进行交换</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        queue.offer(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;n; i++) &#123;</span><br><span class="line">            queue.offer(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>==通解   （两个栈  、 队列）==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">&gt;Queue&lt;Integer&gt; queue1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">&gt;Queue&lt;Integer&gt; queue2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">&gt;<span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//  需要进行交换   				队列--&gt;栈</span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  queue1.offer(x);</span><br><span class="line">  <span class="keyword">while</span>(!queue2.isEmpty())&#123;</span><br><span class="line">      queue1.offer(queue2.poll());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(!queue1.isEmpty())&#123;</span><br><span class="line">      queue2.offer(queue1.poll());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> queue2.peek();</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> queue2.poll();</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> queue2.isEmpty();</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">&gt;Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">&gt;Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 栈转队列</span></span><br><span class="line">  <span class="keyword">while</span>(!stack2.isEmpty())&#123;</span><br><span class="line">      stack1.push(stack2.pop());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stack1.push(x);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">      stack2.push(stack1.pop());</span><br><span class="line">  &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> stack2.pop();</span><br><span class="line"></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> stack2.peek();</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span>  stack2.isEmpty();</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;* Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">&gt;* MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment">&gt;* obj.push(x);</span></span><br><span class="line"><span class="comment">&gt;* int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment">&gt;* int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment">&gt;* boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment">&gt;*/</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="二叉树公共祖先"><a href="#二叉树公共祖先" class="headerlink" title="二叉树公共祖先"></a>二叉树公共祖先</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">         <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == p  || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span>  <span class="operator">=</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span>  &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> right == <span class="literal">null</span>? left : right; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//要是二叉搜索树的话还有这样的一种写法，因为  二叉搜索树是有序的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(p.val &lt; cur.val &amp;&amp; q.val &lt; cur.val || p.val &gt;cur.val &amp;&amp; q.val &gt; cur.val)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.val &lt; cur.val)&#123;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="手撕快排"><a href="#手撕快排" class="headerlink" title="手撕快排"></a>手撕快排</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//手撕快排</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Quick</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> nums[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line">        shuffle(nums);</span><br><span class="line">        sortQuick(nums,low,high);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sortQuick</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(low  &gt;= high) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="comment">//获取坐标</span></span><br><span class="line">        <span class="type">int</span>  <span class="variable">mid</span> <span class="operator">=</span> partitions(nums,low,high);</span><br><span class="line">        sortQuick(nums,low,mid-<span class="number">1</span>);</span><br><span class="line">        sortQuick(nums,mid+<span class="number">1</span>,high);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partitions</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[low];</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> low+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> high;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; high &amp;&amp; nums[left] &lt;= pivot)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(right&gt; low &amp;&amp; nums[right] &gt; pivot)&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(left &gt;= right) <span class="keyword">break</span>;</span><br><span class="line">            swap(nums,left,right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 pivot 放到合适的位置，即 pivot 左边元素较小，右边元素较大</span></span><br><span class="line">        swap(nums,low,right);</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span>  <span class="operator">=</span> nums[left];</span><br><span class="line">        nums[left] = nums[right];</span><br><span class="line">        nums[right] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> i + random.nextInt(n-i);</span><br><span class="line">            swap(nums,i,t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="手撕二叉堆实现优先级队列"><a href="#手撕二叉堆实现优先级队列" class="headerlink" title="手撕二叉堆实现优先级队列"></a>手撕二叉堆实现优先级队列</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Priority_Queue</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt;&#123;</span><br><span class="line">    T[] pq;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    Priority_Queue(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        pq = (T[]) <span class="keyword">new</span> <span class="title class_">Comparable</span>[capacity +<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">max</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pq[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(T e)</span>&#123;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="comment">// 先把新元素加到最后</span></span><br><span class="line">        pq[size] = e;</span><br><span class="line">        <span class="comment">// 然后让它上浮到正确的位置</span></span><br><span class="line">        swim(size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">delMax</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">max</span> <span class="operator">=</span> pq[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 把这个最大元素换到最后，删除之</span></span><br><span class="line">        swap(<span class="number">1</span>, size);</span><br><span class="line">        pq[size] = <span class="literal">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="comment">// 让 pq[1] 下沉到正确位置</span></span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x &gt; <span class="number">1</span> &amp;&amp; less(parent(x),x ))&#123;</span><br><span class="line">            swap(parent(x),x );</span><br><span class="line">            x = parent(x);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left(x) &lt;= size)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> left(x);</span><br><span class="line">            <span class="keyword">if</span>(right(x) &lt;= size &amp;&amp; less(max,right(x))) <span class="keyword">break</span>;</span><br><span class="line">            swap(x,max);</span><br><span class="line">            x= max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">temp</span> <span class="operator">=</span> pq[i];</span><br><span class="line">        pq[i] = pq[j];</span><br><span class="line">        pq[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pq[i].compareTo(pq[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父节点的索引</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">parent</span><span class="params">(<span class="type">int</span> root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左孩子的索引</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">left</span><span class="params">(<span class="type">int</span> root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右孩子的索引</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">right</span><span class="params">(<span class="type">int</span> root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h4 id="前置：-图论基础"><a href="#前置：-图论基础" class="headerlink" title="前置： 图论基础"></a>前置： 图论基础</h4><blockquote>
<p><code>图节点的逻辑结构</code>      ——和多叉树节点几乎完全一样</p>
<p>而是用常说的<strong>邻接表和邻接矩阵</strong>来实现</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 邻接表     </span></span><br><span class="line">    我把每个节点 x 的邻居都存到一个列表里，然后把 x 和这个列表关联起来，这样就可以通过一个节点 x 找到它的所有相邻节点。</span><br><span class="line"><span class="comment">// graph[x] 存储 x 的所有邻居节点</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">List&lt;Integer&gt;[] graph;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接矩阵</span></span><br><span class="line">邻接矩阵则是一个二维布尔数组，我们权且称为 matrix，如果节点 x 和 y 是相连的，那么就把 matrix[x][y] 设为 <span class="literal">true</span>（上图中绿色的方格代表 <span class="literal">true</span>）。如果想找节点 x 的邻居，去扫一圈 matrix[x][..] 就行了</span><br><span class="line"><span class="comment">// matrix[x][y] 记录 x 是否有一条指向 y 的边</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="type">boolean</span>[][] matrix;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>==有向加权图==<br>如果是邻接表，我们不仅仅存储某个节点 x 的所有邻居节点，还存储 x 到每个邻居的权重，<br>如果是邻接矩阵，<code>matrix[x][y]</code> 不再是布尔值，而是一个 int 值，0 表示没有连接，其他值表示权重，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">// 邻接表</span></span><br><span class="line">&gt;<span class="comment">// graph[x] 存储 x 的所有邻居节点以及对应的权重</span></span><br><span class="line">&gt;List&lt;<span class="type">int</span>[]&gt;[] graph;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 邻接矩阵</span></span><br><span class="line">&gt;<span class="comment">// matrix[x][y] 记录 x 指向 y 的边的权重，0 表示不相邻</span></span><br><span class="line">&gt;<span class="type">int</span>[][] matrix;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>==无向图==<br>所谓的「无向」，等同于「双向」<br>如果连接无向图中的节点 x 和 y，把 <code>matrix[x][y]</code> 和 <code>matrix[y][x]</code> 都变成 true 就行了；</p>
<p>邻接表也是类似的操作，在 x 的邻居列表里添加 y，同时在 y 的邻居列表里添加 x。</p>
</blockquote>
<h4 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h4><h6 id="多叉树的-DFS-遍历框架如下"><a href="#多叉树的-DFS-遍历框架如下" class="headerlink" title="多叉树的 DFS 遍历框架如下"></a>多叉树的 DFS 遍历框架如下</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/* 多叉树遍历框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode child : root.children) &#123;</span><br><span class="line">        traverse(child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="图的遍历-1"><a href="#图的遍历-1" class="headerlink" title="图的遍历"></a>图的遍历</h6><p>图  与 树 的最大区别就是  图可能==有环==</p>
<p><strong>有环</strong>  时候就需要一个 <code>visited</code> 数组进行辅助</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录被遍历过的节点</span></span><br><span class="line"><span class="type">boolean</span>[] visited;</span><br><span class="line"><span class="comment">// 记录从起点到当前节点的路径</span></span><br><span class="line"><span class="type">boolean</span>[] onPath;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 图遍历框架 */</span></span><br><span class="line"><span class="comment">//  过程就是：判断是否已经遍历过，有的话就返回，没有的话就将其置为 遍历过并加到 路径数组中，再循环遍历邻居节点，最后再从 路径节点中删去</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(Graph graph, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 经过节点 s，标记为已遍历</span></span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 做选择：标记节点 s 在路径上</span></span><br><span class="line">    onPath[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> neighbor : graph.neighbors(s)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[s])</span><br><span class="line">        traverse(graph, neighbor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 撤销选择：节点 s 离开路径</span></span><br><span class="line">    onPath[s] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果让你处理<strong>路径相关</strong>的问题，这个 <code>onPath</code> 变量是肯定会被用到的，比如 <a href="https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/huan-jian--e36de/">拓扑排序</a> 中就有运用。</p>
<p>另外，这个 <code>onPath</code> 数组的操作很像前文 <a href="https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/hui-su-sua-c26da/">回溯算法核心套路</a> 中做「做选择」和「撤销选择」，区别在于位置：回溯算法的「做选择」和「撤销选择」在 for 循环里面，而对 <code>onPath</code> 数组的操作在 for 循环外面。</p>
</blockquote>
<h4 id="DFS-VS-回溯"><a href="#DFS-VS-回溯" class="headerlink" title="DFS VS 回溯"></a>DFS VS 回溯</h4><blockquote>
<p>对于这里「图」的遍历，我们应该用 DFS 算法，即把 <code>onPath</code> 的操作放到 for 循环外面，否则会漏掉记录起始点的遍历。</p>
</blockquote>
<h6 id="代码区别"><a href="#代码区别" class="headerlink" title="代码区别"></a>代码区别</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DFS 算法，关注点在节点</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    printf(<span class="string">&quot;进入节点 %s&quot;</span>, root);</span><br><span class="line">    <span class="keyword">for</span> (TreeNode child : root.children) &#123;</span><br><span class="line">        traverse(child);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">&quot;离开节点 %s&quot;</span>, root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回溯算法，关注点在树枝</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode child : root.children) &#123;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        printf(<span class="string">&quot;从 %s 到 %s&quot;</span>, root, child);</span><br><span class="line">        backtrack(child);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        printf(<span class="string">&quot;从 %s 到 %s&quot;</span>, child, root);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>所以对于「图」的遍历，我们应该用 DFS 算法，即把 <code>onPath</code> 的操作放到 for 循环外面，否则会漏掉记录起始点的遍历。</p>
<p>再说下 <code>visited</code> 数组，其目的很明显了，由于图可能含<code>有环</code>，<code>visited</code> 数组就是防止递归重复遍历同一个节点进入死循环的。</p>
<p>路径相关的问题，这个 <code>onPath</code> 变量是肯定会被用到的，比如 <a href="https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/huan-jian--e36de/">拓扑排序</a> 中就有运用。</p>
<p>如果题目告诉你图中不含环，可以把 <code>visited</code> 数组都省掉，基本就是多叉树的遍历。</p>
</blockquote>
<h4 id="有向无环图的遍历"><a href="#有向无环图的遍历" class="headerlink" title="有向无环图的遍历"></a>有向无环图的遍历</h4><blockquote>
<p>==思路1、区别于回溯的写法==</p>
<p>1、定义结果集</p>
<p>2、定义路径集  -&gt; dfs -&gt; return</p>
<p>3、dfs: 做选择   –&gt; 循环结束条件  -&gt;  遍历相邻节点 -&gt; 撤销选择</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接收结果集</span></span><br><span class="line">   List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">allPathsSourceTarget</span><span class="params">(<span class="type">int</span>[][] graph)</span> &#123;</span><br><span class="line">       LinkedList&lt;Integer&gt; path =  <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">       traverse(graph,<span class="number">0</span>,path);</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">void</span>  <span class="title function_">traverse</span> <span class="params">(<span class="type">int</span>[][] graph,<span class="type">int</span> s,LinkedList&lt;Integer&gt; path)</span> &#123;</span><br><span class="line">       <span class="comment">//加到路径中    做选择</span></span><br><span class="line">       path.add(s);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//循环结束条件</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> graph.length;</span><br><span class="line">       <span class="keyword">if</span>(s== n-<span class="number">1</span>)  result.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">      </span><br><span class="line">       <span class="comment">//dfs</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i: graph[s])&#123;</span><br><span class="line">           traverse(graph,i,path);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 撤销选择</span></span><br><span class="line">       path.removeLast();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>拓展内容</p>
<p>BFS</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">&gt;<span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">allPathsSourceTarget</span><span class="params">(<span class="type">int</span>[][] graph)</span> &#123;</span><br><span class="line">  bfs(graph,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span>[][] graph, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">  Queue&lt;List&lt;Integer&gt;&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">  queue.offer(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;()&#123;</span><br><span class="line">      &#123;</span><br><span class="line">          add(i);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">      List&lt;Integer&gt; out = queue.poll();</span><br><span class="line">      <span class="type">int</span> <span class="variable">curNode</span> <span class="operator">=</span> out.get(out.size() - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j : graph[curNode]) &#123;</span><br><span class="line">          out.add(j);</span><br><span class="line">          <span class="keyword">if</span>(i == graph.length - <span class="number">1</span>) &#123;</span><br><span class="line">              res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(out));</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              queue.offer(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(out));</span><br><span class="line">          &#125;</span><br><span class="line">          out.remove(out.size()-<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<h6 id="略-gt"><a href="#略-gt" class="headerlink" title="略&gt;"></a>略&gt;</h6><p>==思路二：类似于回溯的写法==</p>
<p>1、 定义结果集 和 路径变量</p>
<p>2、为避免  漏掉记录起始点的遍历   所以要先将 0 加到path 中</p>
<p>3、<strong>dfs&lt;此处是和回溯一样的&gt;</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">&gt;LinkedList&lt;Integer&gt; path =  <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">allPathsSourceTarget</span><span class="params">(<span class="type">int</span>[][] graph)</span> &#123;</span><br><span class="line">  path.add(<span class="number">0</span>);</span><br><span class="line">  dfs(graph,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">void</span>  <span class="title function_">dfs</span> <span class="params">(<span class="type">int</span>[][] graph,<span class="type">int</span> s)</span> &#123;</span><br><span class="line">  <span class="comment">//返回条件</span></span><br><span class="line">  <span class="keyword">if</span>(s== graph.length-<span class="number">1</span>)  result.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">  <span class="comment">//dfs</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;graph[s].length;i++)&#123;</span><br><span class="line">      <span class="comment">// 做选择</span></span><br><span class="line">      path.add(graph[s][i]);</span><br><span class="line">      dfs(graph,graph[s][i]);</span><br><span class="line">       <span class="comment">// 撤销选择</span></span><br><span class="line">      path.removeLast();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>==注==</p>
<p>==什么时候建图：  如果不能通过下标找到下一个节点就得建图==</p>
<p><strong>就是说  一旦存的是边 就要建图用邻接表存储   否则就不要建图</strong></p>
</blockquote>
<h4 id="图的DFS"><a href="#图的DFS" class="headerlink" title="图的DFS"></a>图的DFS</h4><h5 id="有向图是否无环"><a href="#有向图是否无环" class="headerlink" title="有向图是否无环"></a>有向图是否无环</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无环判断=收集最终结果集 + traverse + 构建依赖关系	</span></span><br><span class="line">	<span class="type">boolean</span> visited[];</span><br><span class="line">    <span class="type">boolean</span> path[];</span><br><span class="line"><span class="comment">//visited 记录哪些节点被遍历过，而 onPath 记录当前递归堆栈中有哪些节点，它们的作用不同，所以并不重复。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果有向图中存在环，那就说明课程之间存在循环依赖，肯定没办法全部上完；反之，如果没有环，那么肯定能上完全部课程。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hasCycle</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据现有左边建立树</span></span><br><span class="line">        List&lt;Integer&gt;[] graph = buildGraph(numCourses, prerequisites);</span><br><span class="line">		<span class="comment">// 初始化数组</span></span><br><span class="line">        visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[numCourses];</span><br><span class="line">        path = <span class="keyword">new</span> <span class="title class_">boolean</span>[numCourses];</span><br><span class="line">		<span class="comment">// 避免由于 不连通分量导致的错误，所以对每一个节点 都要进行一次 dfs</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span>  <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            dfs(graph, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 收集结果</span></span><br><span class="line">        <span class="keyword">return</span> !hasCycle;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="拓扑排序-lt-是逆后序-gt"><a href="#拓扑排序-lt-是逆后序-gt" class="headerlink" title="拓扑排序&lt;是逆后序 &gt;"></a>拓扑排序&lt;是逆后序 &gt;</h5><blockquote>
<p>==&lt;是逆后序 != 先序&gt;==</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 拓扑 = 成环判断 +收集最终结果集 + traverse + 构建依赖关系</span></span><br><span class="line">    <span class="type">boolean</span> visited[];</span><br><span class="line">    <span class="type">boolean</span> path[];</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hasCycle</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"> <span class="comment">//拓扑排序的区别一</span></span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">public</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">            List&lt;Integer&gt;[] graph = buildGraph(numCourses, prerequisites);</span><br><span class="line">            visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[numCourses];</span><br><span class="line">            path = <span class="keyword">new</span> <span class="title class_">boolean</span>[numCourses];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt; numCourses;i++) &#123;</span><br><span class="line">                dfs(graph, i);</span><br><span class="line">        	&#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="comment">//拓扑排序的区别二</span></span><br><span class="line"><span class="keyword">if</span>(hasCycle)&#123;</span><br><span class="line"><span class="comment">//一个空的整型数组</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line"><span class="comment">//拓扑排序的区别三    </span></span><br><span class="line">        <span class="comment">// 反转 ；达成逆后序结果</span></span><br><span class="line">Collections.reverse(res);</span><br><span class="line"><span class="type">int</span> result[] = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;numCourses; i++) &#123;</span><br><span class="line">   result[i] = res.get(i);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">return</span>  result;</span><br><span class="line">		</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="复用的代码"><a href="#复用的代码" class="headerlink" title="复用的代码"></a>复用的代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span> <span class="params">(List&lt;Integer&gt;[] graph, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">       <span class="comment">//  path[s] == true  表示已经走过了，所以是环</span></span><br><span class="line">       <span class="keyword">if</span>(path[s])  hasCycle= <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">if</span>(visited[s] || hasCycle)   <span class="keyword">return</span>;</span><br><span class="line">    	visited[s] = <span class="literal">true</span>;</span><br><span class="line">       path[s] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i : graph[s])&#123;</span><br><span class="line">           dfs(graph, i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 后序位置        //环检测不需要这一段代码</span></span><br><span class="line">       <span class="comment">//  res.add(s);---- 拓扑排序需要进行一个结果收集所以需要加上这一段代码						</span></span><br><span class="line">       path[s] = <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// numCourses: 课程数 即  prerequisites[][] 的 不同的元素个数</span></span><br><span class="line">   <span class="comment">//根据邻接表去创建一个图  将 输入的  prerequisites[][]   转化为邻接表形式</span></span><br><span class="line">   List&lt;Integer&gt;[] buildGraph(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">       <span class="comment">//  将 prerequisites[][] 存储的边 转为用邻接表的形式进行存储</span></span><br><span class="line">       LinkedList&lt;Integer&gt;[] graph = <span class="keyword">new</span> <span class="title class_">LinkedList</span>[numCourses];</span><br><span class="line">       <span class="comment">// 转换数据类型   graph[i] 从 LinkedList（null）  转化为  [] 数组类型</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">           graph[i] = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 将每一个边 存到邻接表中graph</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span>[] edge:prerequisites) &#123;</span><br><span class="line">           <span class="comment">//定义正常的依赖关系</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> edge[<span class="number">1</span>];</span><br><span class="line">           <span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> edge[<span class="number">0</span>];</span><br><span class="line">           <span class="comment">// 添加一条从 from 指向 to 的有向边</span></span><br><span class="line">           <span class="comment">// 边的方向是「被依赖」关系，即修完课程 from 才能修课程 to</span></span><br><span class="line">           graph[from].add(to);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> graph;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="BFS-1"><a href="#BFS-1" class="headerlink" title="BFS"></a>BFS</h4><blockquote>
<p>有向图 的 BFS 中  通过 <code>indegree</code> 数组实现的 <code>visited</code> 数组的作用，只有入度为 0 的节点才能入队，从而保证不会出现死循环。</p>
</blockquote>
<h5 id="有向图是否无环、拓扑排序"><a href="#有向图是否无环、拓扑排序" class="headerlink" title="有向图是否无环、拓扑排序"></a>有向图是否无环、拓扑排序</h5><blockquote>
<p>解耦写法</p>
<ul>
<li>有无环</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> []indegree;     <span class="comment">// 取代 visited</span></span><br><span class="line">   Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">      indegree = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">      List&lt;Integer&gt; [] graph = build(numCourses, prerequisites);</span><br><span class="line">&gt;<span class="comment">//入度</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> edge[]: prerequisites) &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> edge[<span class="number">0</span>];</span><br><span class="line">          indegree[to]++;</span><br><span class="line">      &#125;</span><br><span class="line">&gt;<span class="comment">//入队</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(indegree[i] == <span class="number">0</span> )&#123;</span><br><span class="line">             queue.offer(i);</span><br><span class="line">            <span class="comment">// count++;  //入队的时候 ++ </span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&gt;<span class="comment">//bfs</span></span><br><span class="line">      bfs(graph);</span><br><span class="line">      <span class="keyword">return</span> count == numCourses;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(List&lt;Integer&gt;[] graph)</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">          <span class="type">Integer</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">           count++;  <span class="comment">//出队的时候 ++ </span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> j : graph[poll]) &#123;</span><br><span class="line">              indegree[j]--;</span><br><span class="line">              <span class="keyword">if</span>(indegree[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                  queue.offer(j);</span><br><span class="line">                 <span class="comment">// count++;  //入队的时候 ++ </span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//建图</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;Integer&gt;[] build(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">      List&lt;Integer&gt; []graph = <span class="keyword">new</span> <span class="title class_">LinkedList</span>[numCourses];</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">          graph[i] = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> []edge : prerequisites) &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">from</span>  <span class="operator">=</span> edge[<span class="number">1</span>];</span><br><span class="line">          <span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> edge[<span class="number">0</span>];</span><br><span class="line">          graph[from].add(to);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> graph;</span><br><span class="line">  &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>拓扑排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  Queue&lt;Integer&gt; queue= <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">  <span class="type">int</span>[] res ;</span><br><span class="line">  <span class="type">int</span> indegree[] ;</span><br><span class="line">  <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">      List&lt;Integer&gt; []graph = build(numCourses, prerequisites);</span><br><span class="line">      indegree = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> []edge : prerequisites)&#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> edge[<span class="number">0</span>];</span><br><span class="line">          indegree[to]++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">              queue.offer(i); </span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      res = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">      bfs(graph);</span><br><span class="line">      <span class="keyword">if</span>(count != numCourses)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(List&lt;Integer&gt;[] graph)</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">         <span class="type">Integer</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">         res[count]=poll;</span><br><span class="line">           count++;   <span class="comment">//出队的时候加到结果集   并且进行++ </span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> i : graph[poll]) &#123;</span><br><span class="line">              indegree[i]--;</span><br><span class="line">              <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                  queue.offer(i);</span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&gt;<span class="comment">//建图</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;Integer&gt;[] build(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">      List&lt;Integer&gt; []graph = <span class="keyword">new</span> <span class="title class_">LinkedList</span>[numCourses];</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">          graph[i] = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> []edge : prerequisites) &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">from</span>  <span class="operator">=</span> edge[<span class="number">1</span>];</span><br><span class="line">          <span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> edge[<span class="number">0</span>];</span><br><span class="line">          graph[from].add(to);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> graph;</span><br><span class="line">  &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 1、建图，有向边代表「被依赖」关系</span></span><br><span class="line">        List&lt;Integer&gt;[] graph = buildGraph(numCourses, prerequisites);</span><br><span class="line">        <span class="comment">// 2、建立入度数组</span></span><br><span class="line">        <span class="type">int</span>[] degree = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">		<span class="comment">// 根据 题目中的边的关系 对  入度数组  进行  赋值操作	</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> []edge :prerequisites)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> edge[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> edge[<span class="number">0</span>];  <span class="comment">//从其他处 来的</span></span><br><span class="line">            degree[to]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3、建立队列</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//4、判断入度数目，将可能 的起点 加到队列中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(degree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//只要节点 i 没有入度，即没有依赖的节点,就把他作为拓扑排序的起点，加入队列</span></span><br><span class="line">                queue.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="comment">//5、 取出对头元素，每次 取到一个 就让 count ++</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//int res[] = new int[numCourses]; //BFS 区别一</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            </span><br><span class="line"><span class="comment">//res[count] = current;  // 弹出的队列元素的顺序就是拓扑排序的结果 //BFS 区别二</span></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            count++;</span><br><span class="line">        <span class="comment">//6、 将邻居节点的入度 -1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> next:graph[current])&#123;</span><br><span class="line">                degree[next]--;</span><br><span class="line">        <span class="comment">//7、邻居节点的个数为 0 也加到队列中</span></span><br><span class="line">                <span class="keyword">if</span>(degree[next] == <span class="number">0</span>)&#123;</span><br><span class="line">                    queue.offer(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//8、 如果所有节点都被遍历过，说明不成环</span></span><br><span class="line"><span class="comment">//也就是说  只要有环  就必然会至少有1个节点的入度个数&gt;0 就会使得count！=numCourses,就会有环----false</span></span><br><span class="line">            <span class="keyword">return</span> count == numCourses;      -------<span class="literal">true</span>  无环</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line"><span class="comment">// 拓扑排序</span></span><br><span class="line"><span class="comment">//if(count != numCourses)&#123;   //BFS 区别三</span></span><br><span class="line"><span class="comment">//   return new int[]&#123;&#125;;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//return res;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>==其实比判定环的代码就多了几行，添加到指定集合中，从而获取拓扑排序==</p>
<p><strong>流程</strong></p>
<p>​         1、建图，有向边代表「被依赖」关系<br>​        2、建立入度数组<br>​        3、建立队列<br>​        4、判断入度数目，将所有可能 的起点(入度为  0  ) 加到队列中<br>​                只要节点 i 没有入度，即没有依赖的节点,就把他作为拓扑排序的起点，加入队列<br>​        5、 取出队头元素，每次 取到一个 就让 count ++<br>​        6、 将邻居节点的入度 -1<br>​        7、邻居节点的个数为 0 也加到队列中<br>​        8、 如果所有节点都被遍历过，说明不成环</p>
</blockquote>
<h5 id="复用的代码-1"><a href="#复用的代码-1" class="headerlink" title="复用的代码"></a>复用的代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据邻接表去创建一个图  将 输入的  prerequisites[][]   转化为邻接表形式</span></span><br><span class="line">    List&lt;Integer&gt;[] buildGraph(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt;[] graph = <span class="keyword">new</span> <span class="title class_">LinkedList</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] edge:prerequisites) &#123;</span><br><span class="line">            <span class="comment">//定义正常的依赖关系</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> edge[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> edge[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// 添加一条从 from 指向 to 的有向边</span></span><br><span class="line">            <span class="comment">// 边的方向是「被依赖」关系，即修完课程 from 才能修课程 to</span></span><br><span class="line">            graph[from].add(to);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> graph;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h4><blockquote>
<p>&lt; 图中  各个节点  的状态 只有两个 可进行选取 &gt;</p>
</blockquote>
<h5 id="二分图判定思路"><a href="#二分图判定思路" class="headerlink" title="二分图判定思路"></a>二分图判定思路</h5><blockquote>
<p><strong>二分图怎么判断，其实就是让 <code>dfs</code> 函数一边遍历节点，一边给节点染色，尝试让每对相邻节点的颜色都不一样</strong>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 二分图遍历框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Graph graph, <span class="type">boolean</span>[] visited, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 遍历节点 v 的所有相邻节点 neighbor</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> neighbor : graph.neighbors(v)) &#123;</span><br><span class="line">         <span class="comment">// 相邻节点 neighbor 没有被访问过</span></span><br><span class="line">        <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">           </span><br><span class="line">            <span class="comment">// 那么应该给节点 neighbor 涂上和节点 v 不同的颜色</span></span><br><span class="line">            </span><br><span class="line">           dfs(graph, visited, neighbor);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 相邻节点 neighbor 已经被访问过</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 那么应该比较节点 neighbor 和节点 v 的颜色</span></span><br><span class="line">            <span class="comment">// 若相同，则此图不是二分图</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="判定"><a href="#判定" class="headerlink" title="判定"></a>判定</h5><blockquote>
<p>已知邻接表  或者邻接矩阵  不要建图   所谓的 <code>graph[][]</code> 的形参就是  邻接表/ 邻接矩阵的表示方法</p>
</blockquote>
<h6 id="BFS-2"><a href="#BFS-2" class="headerlink" title="BFS"></a>BFS</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">            <span class="type">boolean</span> color[];</span><br><span class="line">            <span class="type">boolean</span> visited[];</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isbipartiteGraph</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBipartite</span><span class="params">(<span class="type">int</span>[][] graph)</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>graph.length;</span><br><span class="line">                color = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">                visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">                <span class="comment">//应对 多个 不连通 的 子图的时候</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!visited[i]) &#123;</span><br><span class="line">bfs(graph, i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> isbipartiteGraph;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span>[][] graph, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">                 <span class="keyword">if</span>(!isbipartiteGraph)  <span class="keyword">return</span> ;</span><br><span class="line">Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">visited[start] = <span class="literal">true</span>;</span><br><span class="line">queue.offer(start);</span><br><span class="line">                 <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">                     <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                     <span class="comment">// 邻居节点</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j:graph[i]) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(!visited[j])&#123;</span><br><span class="line">                            color[j] = !color[i];</span><br><span class="line">visited[j] =<span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 邻居节点进队</span></span><br><span class="line">queue.offer(j);</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="keyword">if</span>(color[j] == color[i])&#123;</span><br><span class="line">                                isbipartiteGraph = <span class="literal">false</span>;</span><br><span class="line">                                <span class="keyword">return</span> ;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br></pre></td></tr></table></figure>
<h6 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> color[];</span><br><span class="line">            <span class="type">boolean</span> visited[];</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isbipartiteGraph</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBipartite</span><span class="params">(<span class="type">int</span>[][] graph)</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> graph.length;</span><br><span class="line">                color =<span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">                visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">                <span class="comment">// 应对出现  不联通子图的 情况</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!visited[i])  </span><br><span class="line"><span class="comment">//和 BFS 的区别 一</span></span><br><span class="line">dfs(graph,i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>  isbipartiteGraph;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和 BFS 的区别二</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] graph, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">               <span class="keyword">if</span>(!isbipartiteGraph) <span class="keyword">return</span>;</span><br><span class="line">visited[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j: graph[i]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!visited[j]) &#123;</span><br><span class="line">                        <span class="comment">//上 不同的色</span></span><br><span class="line">                        color[j] = !color[i];</span><br><span class="line"><span class="comment">//继续递归</span></span><br><span class="line">dfs(graph, j);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//判断颜色一不一样</span></span><br><span class="line">                        <span class="keyword">if</span> (color[j] == color[i]) &#123;</span><br><span class="line">                            isbipartiteGraph = <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="可能的二分图"><a href="#可能的二分图" class="headerlink" title="可能的二分图"></a>可能的二分图<DFS、BFS></DFS、BFS></h4><blockquote>
<p>只给出了各个节点 和什么节点相连  就要建图</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> 	<span class="type">boolean</span> color[];</span><br><span class="line">    <span class="type">boolean</span> visited[];</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">bipartiteGraph</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">possibleBipartition</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] dislikes)</span> &#123;</span><br><span class="line">        <span class="comment">//索引 偏移</span></span><br><span class="line">       color = <span class="keyword">new</span> <span class="title class_">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">         <span class="comment">//索引 偏移</span></span><br><span class="line">       visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">       List&lt;Integer&gt;[] graph =  buildGraph(n,dislikes);</span><br><span class="line">         <span class="comment">//索引 偏移</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">         <span class="comment">//   if(!visited[i])</span></span><br><span class="line">            dfs(graph,i);   <span class="comment">//bfs(graph, i); </span></span><br><span class="line">       <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> bipartiteGraph;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//dfs</span></span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(List&lt;Integer&gt;[] graph, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!bipartiteGraph)  <span class="keyword">return</span>;</span><br><span class="line">        visited[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j:graph[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[j])&#123;</span><br><span class="line">                color[j] = !color[i];</span><br><span class="line">                dfs(graph,j);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(color[j] == color[i])&#123;</span><br><span class="line">                    bipartiteGraph = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//bfs</span></span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(List&lt;Integer&gt;[] graph, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">         <span class="keyword">if</span>(!bipartiteGraph) <span class="keyword">return</span> ;</span><br><span class="line">         Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">         visited[start]=<span class="literal">true</span>;</span><br><span class="line">         queue.offer(start);</span><br><span class="line">         <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//遍历 每一个弹出队列的邻接节点（邻居）</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j:graph[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(!visited[j])&#123;</span><br><span class="line">                    color[j] = !color[i];</span><br><span class="line">                    visited[j]=<span class="literal">true</span>;</span><br><span class="line">                    queue.offer(j);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(color[j]==color[i])&#123;</span><br><span class="line">                        bipartiteGraph = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">return</span> ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<h5 id="建无向图"><a href="#建无向图" class="headerlink" title="建无向图"></a>建无向图</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 建图的 邻接矩阵表示法</span></span><br><span class="line">List&lt;Integer&gt;[] buildGraph(<span class="type">int</span> n,<span class="type">int</span>[][] dislikes)&#123;</span><br><span class="line">    <span class="comment">// 下标 从一 开始  所以会有索引 偏移</span></span><br><span class="line">    List&lt;Integer&gt;[]graph = <span class="keyword">new</span> <span class="title class_">LinkedList</span>[n+<span class="number">1</span>];</span><br><span class="line">      <span class="comment">//索引 偏移  初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=n; i++) &#123;</span><br><span class="line">        graph[i] = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>[]edge:dislikes) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> edge[<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> edge[<span class="number">0</span>];</span><br><span class="line">        graph[from].add(to);</span><br><span class="line">        graph[to].add(from);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面两题的bfs dfs 是一模一样，  只有主函数有些区别，一方面是：多了个 <strong>建图</strong>   另一方面是由于题目问题导致的<strong>索引偏移</strong></p>
</blockquote>
<h4 id="Union-Find-并查集"><a href="#Union-Find-并查集" class="headerlink" title="Union Find  并查集"></a>Union Find  并查集</h4><h6 id="主要需要实现这两个-API："><a href="#主要需要实现这两个-API：" class="headerlink" title="主要需要实现这两个 API："></a>主要需要实现这两个 API：</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line">    <span class="comment">/* 将 p 和 q 连接 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>;</span><br><span class="line">    <span class="comment">/* 判断 p 和 q 是否连通 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>;</span><br><span class="line">    <span class="comment">/* 返回图中有多少个连通分量 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里所说的「连通」是一种等价关系，也就是说具有如下三个性质：</p>
<p>1、自反性：节点 <code>p</code> 和 <code>p</code> 是连通的。</p>
<p>2、对称性：如果节点 <code>p</code> 和 <code>q</code> 连通，那么 <code>q</code> 和 <code>p</code> 也连通。</p>
<p>3、传递性：如果节点 <code>p</code> 和 <code>q</code> 连通，<code>q</code> 和 <code>r</code> 连通，那么 <code>p</code> 和 <code>r</code> 也连通。</p>
<p>因为我们使用森林（若干棵树）来表示图的动态连通性，用数组来具体实现这个森林。</p>
<p>怎么用森林来表示连通性呢？我们设定树的每个节点有一个指针指向其父节点，如果是根节点的话，这个指针指向自己。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line">    <span class="comment">// 记录连通分量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="comment">// 节点 x 的父节点是 parent[x]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造函数，n 为图的节点总数 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UF</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 一开始互不连通</span></span><br><span class="line">        <span class="built_in">this</span>.count = n;</span><br><span class="line">        <span class="comment">// 父节点指针初始指向自己</span></span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 其他函数 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>如果某两个节点被连通，则让其中的（任意）一个节点的根节点接到另一个节点的根节点上</strong>;</p>
<p><strong>这样，如果节点 <code>p</code> 和 <code>q</code> 连通的话，它们一定拥有相同的根节点</strong>;</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line">    <span class="comment">// 连通分量个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="comment">// 存储每个节点的父节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// n 为图中节点的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UF</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = n;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将节点 p 和节点 q 连通</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (rootP == rootQ)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        parent[rootQ] = rootP;</span><br><span class="line">        <span class="comment">// 两个连通分量合并成一个连通分量</span></span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断节点 p 和节点 q 是否连通</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">        <span class="keyword">return</span> rootP == rootQ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">            parent[x] = find(parent[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回图中的连通分量个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结一下我们优化算法的过程：</p>
<p>1、用 <code>parent</code> 数组记录每个节点的父节点，相当于指向父节点的指针，所以 <code>parent</code> 数组内实际存储着一个森林（若干棵多叉树）。</p>
<p>2、用 <code>size</code> 数组记录着每棵树的重量，目的是让 <code>union</code> 后树依然拥有平衡性，保证各个 API 时间复杂度为 O(logN)，而不会退化成链表影响操作效率。</p>
<p>3、在 <code>find</code> 函数中进行路径压缩，保证任意树的高度保持在常数，使得各个 API 时间复杂度为 O(1)。使用了路径压缩之后，可以不使用 <code>size</code> 数组的平衡优化。</p>
<p>==注== 二维坐标 <code>(x,y)</code> 可以转换成 <code>x * n + y</code> 这个数（<code>m</code> 是棋盘的行数，<code>n</code> 是棋盘的列数），<strong>敲黑板，这是将二维坐标映射到一维的常用技巧</strong>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equationsPossible</span><span class="params">(String[] equations)</span> &#123;</span><br><span class="line">        <span class="type">Union_Find</span> <span class="variable">union_find</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Union_Find</span>(<span class="number">26</span>);</span><br><span class="line">        <span class="keyword">for</span>(String eq:equations) &#123;</span><br><span class="line">            <span class="comment">// 先让相等的字母形成 连通分量</span></span><br><span class="line">            <span class="keyword">if</span> (eq.charAt(<span class="number">1</span>) == <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">x</span> <span class="operator">=</span> eq.charAt(<span class="number">0</span>);</span><br><span class="line">                <span class="type">char</span> <span class="variable">y</span> <span class="operator">=</span> eq.charAt(<span class="number">3</span>);</span><br><span class="line">                <span class="comment">//转为数字</span></span><br><span class="line">                union_find.union(x - <span class="string">&#x27;a&#x27;</span>, y - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 要是有不等的就判断不等的是不是 相连通的 </span></span><br><span class="line">        <span class="keyword">for</span>(String eq:equations)&#123;</span><br><span class="line">            <span class="keyword">if</span>(eq.charAt(<span class="number">1</span>) == <span class="string">&#x27;!&#x27;</span>)&#123;</span><br><span class="line">                <span class="type">char</span> x= eq.charAt(<span class="number">0</span>);</span><br><span class="line">                <span class="type">char</span> <span class="variable">y</span> <span class="operator">=</span> eq.charAt(<span class="number">3</span>);</span><br><span class="line">                <span class="comment">//转为数字   != 还连通了那肯定就是错了</span></span><br><span class="line">               <span class="keyword">if</span>(union_find.connection(x-<span class="string">&#x27;a&#x27;</span>,y-<span class="string">&#x27;a&#x27;</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 并将上述的unionFind 代码框架进行复写</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
