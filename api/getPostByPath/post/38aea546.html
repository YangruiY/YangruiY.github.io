{"type":"getPostByPath","data":{"title":"Caffeine 本地缓存","date":"2023-10-16T03:40:24.000Z","description":"缓存","categories":[{"name":"缓存","_id":"clo9tj5v30004l10p8hy8hhtg"}],"tags":[{"name":"缓存","_id":"clo9tj5v40005l10p10hh036s"}],"content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<h1 id=\"Caffeine\"><a href=\"#Caffeine\" class=\"headerlink\" title=\"Caffeine\"></a>Caffeine</h1><p>[原文出处][<a href=\"https://blog.csdn.net/lemon_TT/article/details/122905113\">https://blog.csdn.net/lemon_TT/article/details/122905113</a>]</p>\n<p>[官网][<a href=\"https://github.com/ben-manes/caffeine\">https://github.com/ben-manes/caffeine</a>]</p>\n<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><blockquote>\n<p><Wiki：>Caffeine 是一个基于 Java8 开发的提供<a href=\"https://github.com/ben-manes/caffeine/wiki/Efficiency-zh-CN\">近乎最佳</a>命中率的<a href=\"https://github.com/ben-manes/caffeine/wiki/Benchmarks-zh-CN\">HP</a>磁盘库</Wiki：></p>\n<p>基于Guava改进而来，是一个独立的高性能的本地缓存库，是在ConcurrentHashMap的基础上实现的，在Spring5开始取代原来的的Google Guava缓存</p>\n<p>Caffeine 和 Google guava 区别</p>\n</blockquote>\n<ul>\n<li>维护者：Caffeine是由Ben Manes开发和维护的，而Google Guava是由Google开发和维护的。</li>\n<li>功能：<ul>\n<li>Caffeine 专注于提供<code>高性能和灵活性</code>，同时支持<code>异步加载和刷新缓存项</code>。</li>\n<li>Google Guava的缓存模块也提供了<code>缓存功能</code>，但功能相对较少，主要关注缓存的基本操作。</li>\n</ul>\n</li>\n<li>并发性：<ul>\n<li>Caffeine在并发性能方面进行了优化，采用了<code>更高效的数据结构和算法</code>，以提供更好的并发访问性能。</li>\n<li>Google Guava的缓存模块也是线程安全的，但在高并发场景下可能不如Caffeine表现出色。</li>\n</ul>\n</li>\n<li>API设计：<ul>\n<li>Caffeine的API设计更加简洁和易用，提供了更多的配置选项和扩展点，允许开发人员根据具体需求进行自定义。</li>\n<li>Google Guava的API设计也非常好，但相对来说更加保守，提供了较少的配置选项。</li>\n</ul>\n</li>\n<li>依赖关系：<ul>\n<li>Caffeine是一个独立的库，没有依赖于其他库。</li>\n<li>Google Guava是一个功能强大的Java库，除了缓存模块外，还包含了许多其他实用功能，因此使用Google Guava的缓存模块需要引入整个Guava库。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>实际上 Caffeine 和ConcurrentHashMap类似，支持高并发，存取的时间复杂度可以达到O(1)，但是又是有一定的区别的：</p>\n</blockquote>\n<ul>\n<li>功能：<ul>\n<li><code>ConcurrentHashMap</code>是<code>JUC</code>的一部分，是一个线程安全的哈希表，用于在<code>并发环境</code>中<code>存储和访问键值对</code>。</li>\n<li>而<code>Caffeine</code>是一个开源的高性能缓存库，它是在ConcurrentHashMap的基础上实现的，提供了更丰富的<code>缓存功能</code>，如过期策略、缓存加载、异步刷新等。</li>\n</ul>\n</li>\n<li>缓存策略：<ul>\n<li>ConcurrentHashMap没有内置的缓存策略，它只提供了基本的键值对存储和访问功能。</li>\n<li>Caffeine提供了多种缓存策略，如基于大小、基于时间的过期策略、基于访问频率的过期策略等，可以根据需求选择适合的缓存策略。</li>\n</ul>\n</li>\n<li>异步加载和刷新：<ul>\n<li>Caffeine支持异步加载缓存项，即当缓存中不存在某个键时，可以通过自定义的加载器异步加载该键对应的值。同时，Caffeine还支持异步刷新缓存项，即当缓存中的某个键过期时，可以异步刷新该键对应的值。</li>\n<li>ConcurrentHashMap本身并不直接支持异步加载缓存项的功能，但是可以借助其他手段进行实现支持异步加载缓存项的功能；常见的做法是使用CompletableFuture或ExecutorService来进行异步加载操作，并将加载的结果存储到ConcurrentHashMap中。您可以在获取缓存项时，首先检查是否存在该缓存项，如果不存在，则使用异步加载的方式来获取并存储到ConcurrentHashMap中。</li>\n</ul>\n</li>\n<li>内存管理：<ul>\n<li>Caffeine提供了更灵活的内存管理功能，可以通过配置项来控制缓存的最大大小、最大权重等，以避免内存溢出。</li>\n<li>ConcurrentHashMap没有内置的内存管理功能。</li>\n</ul>\n</li>\n<li>扩展性：<ul>\n<li>Caffeine提供了更多的扩展性，可以通过自定义缓存加载器、缓存监听器等来实现更复杂的缓存逻辑。</li>\n<li>ConcurrentHashMap的功能相对较为简单，扩展性有限。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h3><ul>\n<li><a href=\"https://github.com/ben-manes/caffeine/wiki/Population-zh-CN\">自动加载</a>元素到缓存当中，异步加载的方式也可供选择</li>\n<li>当达到最大容量的时候可以使用基于<a href=\"https://github.com/ben-manes/caffeine/wiki/Efficiency-zh-CN\">就近度和频率</a>的算法进行<a href=\"https://github.com/ben-manes/caffeine/wiki/Eviction-zh-CN#基于容量\">基于容量的驱逐</a></li>\n<li>将根据缓存中的元素上一次访问或者被修改的时间进行<a href=\"https://github.com/ben-manes/caffeine/wiki/Eviction-zh-CN#基于时间\">基于过期时间的驱逐</a></li>\n<li>当向缓存中一个已经过时的元素进行访问的时候将会进行<a href=\"https://github.com/ben-manes/caffeine/wiki/Refresh-zh-CN\">异步刷新</a></li>\n<li>key将自动被<a href=\"https://github.com/ben-manes/caffeine/wiki/Eviction-zh-CN#基于引用\">弱引用</a>所封装</li>\n<li>value将自动被<a href=\"https://github.com/ben-manes/caffeine/wiki/Eviction-zh-CN#基于引用\">弱引用或者软引用</a>所封装</li>\n<li>驱逐(或移除)缓存中的元素时将会进行<a href=\"https://github.com/ben-manes/caffeine/wiki/Removal-zh-CN\">通知</a></li>\n<li><a href=\"https://github.com/ben-manes/caffeine/wiki/Writer-zh-CN\">写入传播</a>到一个外部数据源当中</li>\n<li>持续计算缓存的访问<a href=\"https://github.com/ben-manes/caffeine/wiki/Statistics-zh-CN\">统计指标</a></li>\n</ul>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><blockquote>\n<p>官网介绍：对于 Java 11 或更高版本，请使用<code>3.x</code>，否则使用<code>2.x</code></p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- https:<span class=\"comment\">//mvnrepository.com/artifact/com.github.ben-manes.caffeine/caffeine --&gt;</span></span><br><span class=\"line\">   &lt;dependency&gt;</span><br><span class=\"line\">       &lt;groupId&gt;com.github.ben-manes.caffeine&lt;/groupId&gt;</span><br><span class=\"line\">       &lt;artifactId&gt;caffeine&lt;/artifactId&gt;</span><br><span class=\"line\">       &lt;version&gt;<span class=\"number\">2.6</span><span class=\"number\">.1</span>&lt;/version&gt;</span><br><span class=\"line\">   &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"缓存加载策略\"><a href=\"#缓存加载策略\" class=\"headerlink\" title=\"缓存加载策略\"></a>缓存加载策略</h4><blockquote>\n<p>相关参数解析</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache&lt;Object, Object&gt; cache = Caffeine.newBuilder()</span><br><span class=\"line\">          <span class=\"comment\">//初始数量</span></span><br><span class=\"line\">          .initialCapacity(<span class=\"number\">10</span>)</span><br><span class=\"line\">          <span class=\"comment\">//最大条数</span></span><br><span class=\"line\">          .maximumSize(<span class=\"number\">10</span>)</span><br><span class=\"line\">          <span class=\"comment\">//expireAfterWrite和expireAfterAccess同时存在时，以expireAfterWrite为准</span></span><br><span class=\"line\">          <span class=\"comment\">//最后一次写操作后经过指定时间过期</span></span><br><span class=\"line\">          .expireAfterWrite(<span class=\"number\">1</span>, TimeUnit.SECONDS)</span><br><span class=\"line\">          <span class=\"comment\">//最后一次读或写操作后经过指定时间过期</span></span><br><span class=\"line\">          .expireAfterAccess(<span class=\"number\">1</span>, TimeUnit.SECONDS)</span><br><span class=\"line\">          <span class=\"comment\">//监听缓存被移除</span></span><br><span class=\"line\">          .removalListener((key, val, removalCause) -&gt; &#123; &#125;)</span><br><span class=\"line\">          <span class=\"comment\">//记录命中</span></span><br><span class=\"line\">          .recordStats()</span><br><span class=\"line\">          .build();</span><br></pre></td></tr></table></figure>\n<h5 id=\"方式1：Cache的手动创建\"><a href=\"#方式1：Cache的手动创建\" class=\"headerlink\" title=\"方式1：Cache的手动创建\"></a>方式1：Cache的手动创建</h5><blockquote>\n<p>最普通的缓存，不用指定加载方式</p>\n<ol>\n<li>但是需要手动调用<code>put()</code>方法进行加载，和  Map类似，使用<code>put()</code>的时候会对易于的key 进行覆盖</li>\n<li>获取的时候可以调用 <code>get(key, k -&gt; value)</code>方法，这个方法会避免写竞争「多线程情况下，在使用<code>get(key, k -&gt; value)</code>时，如果有另一个线程同时调用本方法进行竞争，则后来的那个线程会被阻塞，直到前一线程更新缓存完成；而若另一线程调用<code>getIfPresent()</code>方法，则会立即返回null，不会被阻塞」</li>\n<li>调用 <code>invaliadate()</code> 方法，可以手动移除缓存。</li>\n</ol>\n<p><code>Cache</code> 接口提供了显式<code>搜索查找、更新和移除缓存元素</code>的能力。</p>\n<p>推荐：使用 <code>cache.get(key, k -&gt; value)</code>  ，</p>\n<p>​    当在缓存中不存在该key对应的缓存元素的时候，进行计算生成并直接写入至缓存内，</p>\n<p>​    当该key对应的缓存元素存在的时候将会直接返回存在的缓存值。</p>\n<p>一次 <code>cache.put(key, value)</code> 操作将会直接写入或者更新缓存里的缓存元素，在缓存中已经存在的该key对应缓存值都会直接被覆盖。值得注意的是，当缓存的元素无法生成或者在生成的过程中抛出异常而导致生成元素失败，<code>cache.get</code> 也许会返回 <code>null</code> 。</p>\n<p>​    也可以使用<code>Cache.asMap()</code>所暴露出来的<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html\">ConcurrentMap</a>的方法对缓存进行操作。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache&lt;Key, Graph&gt; cache = Caffeine.newBuilder()</span><br><span class=\"line\">    .expireAfterWrite(<span class=\"number\">10</span>, TimeUnit.MINUTES)</span><br><span class=\"line\">    .maximumSize(<span class=\"number\">10_000</span>)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查找一个缓存元素， 没有查找到的时候返回null</span></span><br><span class=\"line\"><span class=\"type\">Graph</span> <span class=\"variable\">graph</span> <span class=\"operator\">=</span> cache.getIfPresent(key);</span><br><span class=\"line\"><span class=\"comment\">// 查找缓存，如果缓存不存在则生成缓存元素,  如果无法生成则返回null</span></span><br><span class=\"line\">graph = cache.get(key, k -&gt; createExpensiveGraph(key));</span><br><span class=\"line\"><span class=\"comment\">// 添加或者更新一个缓存元素</span></span><br><span class=\"line\">cache.put(key, graph);</span><br><span class=\"line\"><span class=\"comment\">// 移除一个缓存元素</span></span><br><span class=\"line\">cache.invalidate(key);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache&lt;String, String&gt; cache = Caffeine.newBuilder()</span><br><span class=\"line\">              .expireAfterAccess(<span class=\"number\">10</span>, TimeUnit.SECONDS)</span><br><span class=\"line\">              .maximumSize(<span class=\"number\">10000</span>)</span><br><span class=\"line\">              .build();</span><br><span class=\"line\">      <span class=\"type\">String</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;ry&quot;</span>;</span><br><span class=\"line\">      cache.put(key,<span class=\"string\">&quot;rycan&quot;</span>);</span><br><span class=\"line\">      System.out.println(cache.getIfPresent(key));</span><br><span class=\"line\">      cache.invalidate(key);</span><br><span class=\"line\">      System.out.println(cache.get(key,k-&gt;<span class=\"string\">&quot;default&quot;</span>));</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rycan</span><br><span class=\"line\">default</span><br></pre></td></tr></table></figure>\n<h5 id=\"方式2：自动创建\"><a href=\"#方式2：自动创建\" class=\"headerlink\" title=\"方式2：自动创建\"></a>方式2：自动创建</h5><blockquote>\n<p>LoadingCache是一种自动加载的缓存，和普通缓存的不同之处在于：</p>\n<ul>\n<li>当缓存不存在/缓存已过期时，若调用<code>get()</code>方法，则会自动调用<code>CacheLoader.load()</code>方法加载最新值。</li>\n<li>调用<code>getAll()</code>方法将遍历所有的key调用get()，除非实现了<code>CacheLoader.loadAll()</code>方法。</li>\n<li>使用LoadingCache时，需要指定CacheLoader，并实现其中的<code>load()</code>方法供缓存缺失时自动加载。</li>\n</ul>\n<p>相同之处在于：在多线程情况下，当两个线程同时调用<code>get()</code>，则后一线程将被阻塞，直至前一线程更新缓存完成。</p>\n<p>一个<code>LoadingCache</code>是服务器实现后的<code>Cache</code>附加上<code>CacheLoader</code>能力。</p>\n<p>通过<code>getAll</code>可以达到批量查找存储的目的。默认情况下，在<code>getAll</code>方法中，将会对每个不存在对应存储的key调用一次<code>CacheLoader.load</code>来生成存储元素。在批量查找比单个查找更高效率的场景下，你可以覆盖并开发<code>CacheLoader.loadAll</code>方法可以使您的存储效率更高。你可以通过实现一个<code>CacheLoader.loadAll</code>并在其中为没有在参数中请求的key也生成对应的服务器元素。比如：如果对应某个key生成的服务器元素与包含该key的一组集合剩余key所对应的元素是一致的，那么在<code>loadAll</code>中也可以同时加载剩余的key对应的元素到缓存中。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LoadingCache&lt;Key, Graph&gt; cache = Caffeine.newBuilder()</span><br><span class=\"line\">    .maximumSize(<span class=\"number\">10_000</span>)</span><br><span class=\"line\">    .expireAfterWrite(<span class=\"number\">10</span>, TimeUnit.MINUTES)</span><br><span class=\"line\">    .build(key -&gt; createExpensiveGraph(key));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查找缓存，如果缓存不存在则生成缓存元素,  如果无法生成则返回null</span></span><br><span class=\"line\"><span class=\"type\">Graph</span> <span class=\"variable\">graph</span> <span class=\"operator\">=</span> cache.get(key);</span><br><span class=\"line\"><span class=\"comment\">// 批量查找缓存，如果缓存不存在则生成缓存元素</span></span><br><span class=\"line\">Map&lt;Key, Graph&gt; graphs = cache.getAll(keys);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">testLoading</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        LoadingCache&lt;String, String&gt; localcache = Caffeine.newBuilder()</span><br><span class=\"line\">                .refreshAfterWrite(<span class=\"number\">10</span>,TimeUnit.SECONDS)</span><br><span class=\"line\">                .expireAfterWrite(<span class=\"number\">10</span>, TimeUnit.SECONDS)</span><br><span class=\"line\">                .expireAfterAccess(<span class=\"number\">10</span>,TimeUnit.SECONDS)</span><br><span class=\"line\">                .maximumSize(<span class=\"number\">10</span>)</span><br><span class=\"line\">                .build(key-&gt;creatkKey(key));</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> localcache.get(<span class=\"string\">&quot;ry&quot;</span>);</span><br><span class=\"line\">        System.out.println(value);</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">        List&lt;String&gt; keys = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        keys.add(<span class=\"string\">&quot;ry&quot;</span>);</span><br><span class=\"line\">        keys.add(<span class=\"string\">&quot;ty&quot;</span>);</span><br><span class=\"line\">        keys.add(<span class=\"string\">&quot;cy&quot;</span>);</span><br><span class=\"line\">        localcache.put(<span class=\"string\">&quot;ty&quot;</span>,<span class=\"string\">&quot;tycan&quot;</span>);</span><br><span class=\"line\">        Map&lt;String, String&gt; Maps = localcache.getAll(keys);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String map:Maps.keySet()) &#123;</span><br><span class=\"line\">            System.out.println(map);</span><br><span class=\"line\">            System.out.println(Maps.get(map));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String <span class=\"title function_\">creatkKey</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;rycan&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rycan</span><br><span class=\"line\"></span><br><span class=\"line\">ty</span><br><span class=\"line\">tycan</span><br><span class=\"line\">cy</span><br><span class=\"line\">rycan</span><br><span class=\"line\">ry</span><br><span class=\"line\">rycan</span><br></pre></td></tr></table></figure>\n<h5 id=\"方式3：异步创建（手动）\"><a href=\"#方式3：异步创建（手动）\" class=\"headerlink\" title=\"方式3：异步创建（手动）\"></a>方式3：异步创建（手动）</h5><blockquote>\n<p>一个<code>AsyncCache</code>是<code>Cache</code>一个变体，<code>AsyncCache</code>提供了在<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executor.html\">Executor</a>上生成磁盘元素并返回<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html\">CompletableFuture</a>的能力。这给出了当前流行的响应式编程模型中利用磁盘的能力。</p>\n<p><code>synchronous()</code>该方法<code>Cache</code>提供了阻塞直到异步缓存生成完毕的能力。</p>\n<p>当然，也可以使用<code>AsyncCache.asMap()</code>所公开的<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html\">ConcurrentMap</a>的方法对服务器进行操作。</p>\n<p>默认的线程池实现是<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html\">ForkJoinPool.commonPool()</a>，当然你也可以通过覆盖并实现<code>Caffeine.executor(Executor)</code>方法来自定义你的线程池选择。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AsyncCache&lt;Key, Graph&gt; cache = Caffeine.newBuilder()</span><br><span class=\"line\">    .expireAfterWrite(<span class=\"number\">10</span>, TimeUnit.MINUTES)</span><br><span class=\"line\">    .maximumSize(<span class=\"number\">10_000</span>)</span><br><span class=\"line\">    .buildAsync();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查找一个缓存元素， 没有查找到的时候返回null</span></span><br><span class=\"line\">CompletableFuture&lt;Graph&gt; graph = cache.getIfPresent(key);</span><br><span class=\"line\"><span class=\"comment\">// 查找缓存元素，如果不存在，则异步生成</span></span><br><span class=\"line\">graph = cache.get(key, k -&gt; createExpensiveGraph(key));</span><br><span class=\"line\"><span class=\"comment\">// 添加或者更新一个缓存元素</span></span><br><span class=\"line\">cache.put(key, graph);</span><br><span class=\"line\"><span class=\"comment\">// 移除一个缓存元素</span></span><br><span class=\"line\">cache.synchronous().invalidate(key);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意这个方式应该尽可能的使用最新的版本，2.6.1版本不提供这种手动异步创建的方式</p>\n<p>&lt;下面的为GPT4提供的案例&gt;</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AsyncCache&lt;String, String&gt; asyncCache = Caffeine.newBuilder()</span><br><span class=\"line\">                .expireAfterWrite(<span class=\"number\">10</span>, TimeUnit.MINUTES)</span><br><span class=\"line\">                .maximumSize(<span class=\"number\">10_000</span>)</span><br><span class=\"line\">                .buildAsync();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;key&quot;</span>;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;value&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        CompletableFuture&lt;Void&gt; putFuture = asyncCache.put(key, CompletableFuture.completedFuture(value));</span><br></pre></td></tr></table></figure>\n<h5 id=\"方式4：异步排序加载（自动）\"><a href=\"#方式4：异步排序加载（自动）\" class=\"headerlink\" title=\"方式4：异步排序加载（自动）\"></a>方式4：异步排序加载（自动）</h5><blockquote>\n<p>AsyncCache是Cache的一个变体，其响应结果为<code>CompletableFuture</code>，通过这种方式，AsyncCache对异步编程模式进行了适配。默认情况下，缓存计算使用<code>ForkJoinPool.commonPool()</code>作为线程池，如果想要指定线程池，则可以覆盖并实现<code>Caffeine.executor(Executor)</code>方法。<code>synchronous()</code>提供了阻塞直到异步缓存生成完还能将Cache进行返回。</p>\n<p>在多线程情况下，当两个线程同时调用<code>get(key, k -&gt; value)</code>，则会返回同一个<code>CompletableFuture</code>对象。由于返回结果本身不进行阻塞，可以根据业务设计自行选择阻塞等待或者非阻塞。</p>\n<p>一个<code>AsyncLoadingCache</code>是一个<code>AsyncCache</code>附加<code>AsyncCacheLoader</code>能力的实现。</p>\n<p>在需要同步的方式去生成缓存元素的时候，<code>CacheLoader</code>是合适的选择。而在异步生成缓存的场景下，<code>AsyncCacheLoader</code>则更合适的选择并且它会返回一个<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html\">CompletableFuture</a>。</p>\n<p>通过<code>getAll</code>可以达到批量查找存储的目的。默认情况下，在<code>getAll</code>方法中，将会对每个不存在对应存储的key调用一次<code>AsyncCacheLoader.asyncLoad</code>来生成存储元素。在批量查找比单个查找更高效率的场景下，你也可以覆盖并开发<code>AsyncCacheLoader.asyncLoadAll</code>方法可以使存储效率更高。</p>\n<p>就是说：可以通过实现一个<code>AsyncCacheLoader.asyncLoadAll</code>并在其中为没有在参数中请求的key也生成对应的服务器元素。打个比方，如果对应某个key生成的服务器元素与包含该key的一组集合剩余key所对应的元素是一致的，那么在<code>asyncLoadAll</code>中也可以同时加载剩余的key对应的元素到缓存中。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AsyncLoadingCache&lt;Key, Graph&gt; cache = Caffeine.newBuilder()</span><br><span class=\"line\">    .maximumSize(<span class=\"number\">10_000</span>)</span><br><span class=\"line\">    .expireAfterWrite(<span class=\"number\">10</span>, TimeUnit.MINUTES)</span><br><span class=\"line\">    <span class=\"comment\">// 你可以选择: 去异步的封装一段同步操作来生成缓存元素</span></span><br><span class=\"line\">    .buildAsync(key -&gt; createExpensiveGraph(key));</span><br><span class=\"line\">    <span class=\"comment\">// 你也可以选择: 构建一个异步缓存元素操作并返回一个future</span></span><br><span class=\"line\">    .buildAsync((key, executor) -&gt; createExpensiveGraphAsync(key, executor));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查找缓存元素，如果其不存在，将会异步进行生成</span></span><br><span class=\"line\">CompletableFuture&lt;Graph&gt; graph = cache.get(key);</span><br><span class=\"line\"><span class=\"comment\">// 批量查找缓存元素，如果其不存在，将会异步进行生成</span></span><br><span class=\"line\">CompletableFuture&lt;Map&lt;Key, Graph&gt;&gt; graphs = cache.getAll(keys);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"> <span class=\"keyword\">void</span> <span class=\"title function_\">testAsync</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class=\"line\">     AsyncLoadingCache&lt;String, String&gt; AsyncLoadingCache = Caffeine.newBuilder()</span><br><span class=\"line\">             .maximumSize(<span class=\"number\">1000</span>)</span><br><span class=\"line\">             .expireAfterAccess(<span class=\"number\">2</span>, TimeUnit.SECONDS)</span><br><span class=\"line\">             .buildAsync(key -&gt; createAsyncKey(key));</span><br><span class=\"line\">     CompletableFuture&lt;String&gt; future = AsyncLoadingCache.get(<span class=\"string\">&quot;ry&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"type\">String</span> <span class=\"variable\">f</span> <span class=\"operator\">=</span> future!=<span class=\"literal\">null</span>? String.valueOf(future) :<span class=\"literal\">null</span>;</span><br><span class=\"line\">     System.out.println(<span class=\"string\">&quot;future?&quot;</span>+f);</span><br><span class=\"line\">     <span class=\"type\">String</span> <span class=\"variable\">futureget</span>  <span class=\"operator\">=</span>future.get()!=<span class=\"literal\">null</span>? future.get(): <span class=\"literal\">null</span>;</span><br><span class=\"line\">     System.out.println(<span class=\"string\">&quot;future.get() ?&quot;</span>+ futureget);</span><br><span class=\"line\"></span><br><span class=\"line\">     System.out.println();</span><br><span class=\"line\"></span><br><span class=\"line\">     List&lt;String&gt; keys = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">     keys.add(<span class=\"string\">&quot;ty&quot;</span>);</span><br><span class=\"line\">     keys.add(<span class=\"string\">&quot;cy&quot;</span>);</span><br><span class=\"line\">     keys.add(<span class=\"string\">&quot;myd&quot;</span>);</span><br><span class=\"line\">     AsyncLoadingCache.put(<span class=\"string\">&quot;ty&quot;</span>,CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span>  <span class=\"string\">&quot;Now Time is &quot;</span>+<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>();</span><br><span class=\"line\">     &#125;));</span><br><span class=\"line\">     Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">     CompletableFuture&lt;Map&lt;String, String&gt;&gt; futureMaps = AsyncLoadingCache.getAll(keys);</span><br><span class=\"line\">     Map&lt;String, String&gt; Maps = futureMaps.get();</span><br><span class=\"line\">     <span class=\"keyword\">for</span> (String map:Maps.keySet()) &#123;</span><br><span class=\"line\">         System.out.println(map);</span><br><span class=\"line\">         System.out.println(Maps.get(map));</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">future?java.util.concurrent.CompletableFuture@2e060819[Not completed, 1 dependents]</span><br><span class=\"line\">future.get() ?Mon Oct 09 15:45:50 CST 2023</span><br><span class=\"line\"></span><br><span class=\"line\">ty</span><br><span class=\"line\">Now Time is Mon Oct 09 15:45:50 CST 2023</span><br><span class=\"line\">myd</span><br><span class=\"line\">Mon Oct 09 15:45:51 CST 2023</span><br><span class=\"line\">cy</span><br><span class=\"line\">Mon Oct 09 15:45:51 CST 2023</span><br><span class=\"line\"></span><br><span class=\"line\">进程已结束，退出代码为 0</span><br></pre></td></tr></table></figure>\n<h4 id=\"驱逐策略\"><a href=\"#驱逐策略\" class=\"headerlink\" title=\"驱逐策略\"></a>驱逐策略</h4><p>驱逐策略在创建缓存的时候进行指定。常用的有<code>基于容量</code>的驱逐和<code>基于时间</code>的驱逐。</p>\n<ul>\n<li>基于容量的驱逐需要指定缓存容量的最大值，当缓存容量达到最大时，Caffeine将使用LRU策略对缓存进行淘汰；</li>\n<li>基于时间的驱逐策略如字面意思，可以设置在最后访问/写入一个缓存经过指定时间后，自动进行淘汰。</li>\n</ul>\n<p>驱逐策略可以组合使用，任意驱逐策略生效后，该缓存条目即被驱逐。</p>\n<ul>\n<li>LRU 最近最少使用，淘汰最长时间没有被使用的页面。</li>\n<li>LFU 最不经常使用，淘汰一段时间内使用次数最少的页面</li>\n<li>FIFO 先进先出</li>\n</ul>\n<p>Caffeine有4种缓存淘汰策略</p>\n<ul>\n<li>大小 （LFU算法进行淘汰）</li>\n</ul>\n<blockquote>\n<p>如果您的缓存不应增长超过特定大小，请使用<code>Caffeine.maximumSize(long)</code>. 缓存将尝试逐出<a href=\"https://github.com/ben-manes/caffeine/wiki/Efficiency\">最近或不经常</a>使用的条目。</p>\n<p>或者，如果不同的缓存条目具有不同的“权重”（例如，如果您的缓存值具有完全不同的内存占用量），您可以使用 指定权重函数，并使用 指定<code>Caffeine.weigher(Weigher)</code>最大缓存权重<code>Caffeine.maximumWeight(long)</code>。除了与<code>maximumSize</code>要求相同的警告之外，请注意权重是在条目创建和更新时计算的，此后是静态的，并且在进行驱逐选择时不使用相对权重</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 基于缓存内的元素个数进行驱逐</span></span><br><span class=\"line\">LoadingCache&lt;Key, Graph&gt; graphs = Caffeine.newBuilder()</span><br><span class=\"line\">    .maximumSize(<span class=\"number\">10_000</span>)</span><br><span class=\"line\">    .build(key -&gt; createExpensiveGraph(key));</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">testeviction</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 基于缓存内的元素个数进行驱逐</span></span><br><span class=\"line\">    LoadingCache&lt;Integer, Integer&gt; loadingCache = Caffeine.newBuilder()</span><br><span class=\"line\">      <span class=\"comment\">//超过10个后会使用W-TinyLFU算法进行淘汰</span></span><br><span class=\"line\">            .maximumSize(<span class=\"number\">10</span>)</span><br><span class=\"line\">            .build(key-&gt;createEvictionKey(key));</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">30</span>; i++) &#123;</span><br><span class=\"line\">        loadingCache.put(i,i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">1000</span>); <span class=\"comment\">//等待一段时间，驱逐是异步的</span></span><br><span class=\"line\">    <span class=\"comment\">//asMap() 是 Guava 中的一个方法，用于将一个集合或者 Multimap 转换为 Map。</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">//在 Guava 的 ImmutableCollection、ImmutableList、ImmutableSet 和 ImmutableMultimap 类中，都有一个 asMap() 方法。</span></span><br><span class=\"line\">    <span class=\"comment\">// 这个方法返回一个不可变的 Map，其中的键是集合或 Multimap 中的元素，值是默认的或自定义的值。</span></span><br><span class=\"line\">    System.out.println(loadingCache.asMap() + <span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;20=20, 21=21, 22=22, 23=23, 24=24, 25=25, 26=26, 27=27, 28=28, 29=29&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 基于缓存内元素权重进行驱逐</span></span><br><span class=\"line\">LoadingCache&lt;Key, Graph&gt; graphs = Caffeine.newBuilder()</span><br><span class=\"line\">    .maximumWeight(<span class=\"number\">10_000</span>)</span><br><span class=\"line\">    .weigher((Key key, Graph graph) -&gt; graph.vertices().size())</span><br><span class=\"line\">    .build(key -&gt; createExpensiveGraph(key));</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\">   <span class=\"keyword\">void</span> <span class=\"title function_\">testeviction</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 基于缓存内的元素权重进行驱逐</span></span><br><span class=\"line\">       Cache&lt;Integer, Integer&gt; cache = Caffeine.newBuilder()</span><br><span class=\"line\">               .weigher((Weigher&lt;Integer,Integer&gt;)(key,value)-&gt;key)</span><br><span class=\"line\">               <span class=\"comment\">//限制总权重，若所有缓存的权重加起来&gt;总权重就会淘汰权重小的缓存</span></span><br><span class=\"line\">               .maximumWeight(<span class=\"number\">30</span>)</span><br><span class=\"line\">               .removalListener(<span class=\"keyword\">new</span> <span class=\"title class_\">RemovalListener</span>&lt;Integer, Integer&gt;() &#123;</span><br><span class=\"line\">                   <span class=\"meta\">@Override</span></span><br><span class=\"line\">                   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onRemoval</span><span class=\"params\">(Integer key, Integer value, RemovalCause removalCause)</span> &#123;</span><br><span class=\"line\">                       System.out.println(<span class=\"string\">&quot;remove data is :&quot;</span>+<span class=\"string\">&quot;key: &quot;</span>+ key +<span class=\"string\">&quot;,value:&quot;</span>+ value);</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125;)</span><br><span class=\"line\">               .build();</span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">maxweight</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">30</span>; i++) &#123;</span><br><span class=\"line\">           cache.put(i,i);</span><br><span class=\"line\">           maxweight+=i;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       System.out.println(<span class=\"string\">&quot;total weight: &quot;</span>+ maxweight);</span><br><span class=\"line\">       Thread.sleep(<span class=\"number\">1000</span>); <span class=\"comment\">//等待一段时间，驱逐是异步的</span></span><br><span class=\"line\">       <span class=\"comment\">//asMap() 是 Guava 中的一个方法，用于将一个集合或者 Multimap 转换为 Map。</span></span><br><span class=\"line\">       <span class=\"comment\">//在 Guava 的 ImmutableCollection、ImmutableList、ImmutableSet 和 ImmutableMultimap 类中，都有一个 asMap() 方法。</span></span><br><span class=\"line\">       <span class=\"comment\">// 这个方法返回一个不可变的 Map，其中的键是集合或 Multimap 中的元素，值是默认的或自定义的值。</span></span><br><span class=\"line\">       System.out.println(cache.asMap());</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">total weight: 435</span><br><span class=\"line\">remove data is :key: 29,value:29</span><br><span class=\"line\">remove data is :key: 1,value:1</span><br><span class=\"line\">remove data is :key: 28,value:28</span><br><span class=\"line\">remove data is :key: 26,value:26</span><br><span class=\"line\">remove data is :key: 25,value:25</span><br><span class=\"line\">remove data is :key: 27,value:27</span><br><span class=\"line\">remove data is :key: 24,value:24</span><br><span class=\"line\">remove data is :key: 23,value:23</span><br><span class=\"line\">remove data is :key: 21,value:21</span><br><span class=\"line\">remove data is :key: 22,value:22</span><br><span class=\"line\">remove data is :key: 20,value:20</span><br><span class=\"line\">remove data is :key: 18,value:18</span><br><span class=\"line\">remove data is :key: 19,value:19</span><br><span class=\"line\">remove data is :key: 16,value:16</span><br><span class=\"line\">remove data is :key: 17,value:17</span><br><span class=\"line\">remove data is :key: 15,value:15</span><br><span class=\"line\">remove data is :key: 14,value:14</span><br><span class=\"line\">remove data is :key: 13,value:13</span><br><span class=\"line\">remove data is :key: 12,value:12</span><br><span class=\"line\">remove data is :key: 10,value:10</span><br><span class=\"line\">remove data is :key: 8,value:8</span><br><span class=\"line\">remove data is :key: 11,value:11</span><br><span class=\"line\">remove data is :key: 9,value:9</span><br><span class=\"line\">&#123;0=0, 2=2, 3=3, 4=4, 5=5, 6=6, 7=7&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>时间</li>\n</ul>\n<blockquote>\n<p>Caffeine 提供了三种定时驱逐的方法：</p>\n<ul>\n<li><code>expireAfterAccess(long, TimeUnit):</code>自上次读取或写入访问条目以来经过指定的持续时间后使条目过期。如果缓存的数据绑定到会话并由于不活动而过期，则这可能是理想的。</li>\n<li><code>expireAfterWrite(long, TimeUnit):</code>自创建条目以来指定的持续时间或最近的值替换后，使条目过期。如果缓存的数据在一段时间后变得陈旧，这可能是理想的。</li>\n<li><code>expireAfter(Expiry):</code>可变持续时间过后条目将过期。如果条目的到期时间由外部资源确定，则这可能是理想的。</li>\n</ul>\n<p>到期是通过在写入期间定期维护以及偶尔在读取期间执行的。到期事件的调度和触发是在分摊的 O(1) 时间内执行的。</p>\n<p>为了快速过期，不要依赖其他缓存活动来触发例行维护，而是使用接口<code>Scheduler</code>和<code>Caffeine.scheduler(Scheduler)</code>方法在缓存构建器中指定调度线程。Java 9+ 用户可能更喜欢利用<code>Scheduler.systemScheduler()</code>专用的系统范围调度线程。</p>\n<p>测试定时驱逐并不要求测试等到挂钟时间过去。使用该<code>Ticker</code>接口和<code>Caffeine.ticker(Ticker)</code>方法在缓存生成器中指定时间源，而不必等待系统时钟。<code>FakeTicker</code>Guava 的 testlib为此提供了方便。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 基于固定的过期时间驱逐策略</span></span><br><span class=\"line\">LoadingCache&lt;Key, Graph&gt; graphs = Caffeine.newBuilder()</span><br><span class=\"line\">    .expireAfterAccess(<span class=\"number\">5</span>, TimeUnit.MINUTES)</span><br><span class=\"line\">    .build(key -&gt; createExpensiveGraph(key));</span><br><span class=\"line\">LoadingCache&lt;Key, Graph&gt; graphs = Caffeine.newBuilder()</span><br><span class=\"line\">    .expireAfterWrite(<span class=\"number\">10</span>, TimeUnit.MINUTES)</span><br><span class=\"line\">    .build(key -&gt; createExpensiveGraph(key));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 基于不同的过期驱逐策略</span></span><br><span class=\"line\">LoadingCache&lt;Key, Graph&gt; graphs = Caffeine.newBuilder()</span><br><span class=\"line\">    .expireAfter(<span class=\"keyword\">new</span> <span class=\"title class_\">Expiry</span>&lt;Key, Graph&gt;() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">expireAfterCreate</span><span class=\"params\">(Key key, Graph graph, <span class=\"type\">long</span> currentTime)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Use wall clock time, rather than nanotime, if from an external resource</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">seconds</span> <span class=\"operator\">=</span> graph.creationDate().plusHours(<span class=\"number\">5</span>)</span><br><span class=\"line\">            .minus(System.currentTimeMillis(), MILLIS)</span><br><span class=\"line\">            .toEpochSecond();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> TimeUnit.SECONDS.toNanos(seconds);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">expireAfterUpdate</span><span class=\"params\">(Key key, Graph graph, </span></span><br><span class=\"line\"><span class=\"params\">          <span class=\"type\">long</span> currentTime, <span class=\"type\">long</span> currentDuration)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> currentDuration;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">expireAfterRead</span><span class=\"params\">(Key key, Graph graph,</span></span><br><span class=\"line\"><span class=\"params\">          <span class=\"type\">long</span> currentTime, <span class=\"type\">long</span> currentDuration)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> currentDuration;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .build(key -&gt; createExpensiveGraph(key));</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 访问后到期（每次访问都会重置时间，也就是说如果一直被访问就不会被淘汰）</span></span><br><span class=\"line\"><span class=\"comment\">   */</span>  </span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">testSechedule</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">      Cache&lt;String, String&gt; cache = Caffeine.newBuilder()</span><br><span class=\"line\">              .expireAfterAccess(<span class=\"number\">1</span>, TimeUnit.SECONDS)</span><br><span class=\"line\">              <span class=\"comment\">//可以指定调度程序来及时删除过期缓存项，而不是等待Caffeine触发定期维护</span></span><br><span class=\"line\">              <span class=\"comment\">//若不设置scheduler，则缓存会在下一次调用get的时候才会被动删除</span></span><br><span class=\"line\">              .scheduler(Scheduler.systemScheduler())</span><br><span class=\"line\">              .evictionListener((key, val, removalCause) -&gt; &#123;</span><br><span class=\"line\">                  log.info(<span class=\"string\">&quot;eviction data is : key:&#123;&#125; val:&#123;&#125;&quot;</span>, key, val);</span><br><span class=\"line\">              &#125;)</span><br><span class=\"line\">              .build();</span><br><span class=\"line\">      cache.put(<span class=\"string\">&quot;ry&quot;</span>, <span class=\"string\">&quot;rycan&quot;</span>);</span><br><span class=\"line\">      System.out.println(cache.getIfPresent(<span class=\"string\">&quot;ry&quot;</span>));</span><br><span class=\"line\">      Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">      System.out.println(cache.getIfPresent(<span class=\"string\">&quot;ry&quot;</span>));<span class=\"comment\">//null</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rycan</span><br><span class=\"line\">2023-10-09 17:26:05.081  INFO 82151 --- [onPool-worker-1] c.r.j.Learning.LearningApplicationTests  : eviction data is : key:ry val:rycan</span><br><span class=\"line\">null</span><br></pre></td></tr></table></figure>\n<ul>\n<li>引用</li>\n</ul>\n<blockquote>\n<p>Caffeine 允许您通过对键或值使用弱引用以及对值使用软引用来设置缓存以允许条目的垃圾收集。请注意， 不支持弱值引用和软值引用<code>AsyncCache</code>。</p>\n<p><code>Caffeine.weakKeys()</code>使用弱引用存储键。如果没有其他对键的强引用，这允许对条目进行垃圾收集。由于垃圾收集仅依赖于身份相等性，这会导致整个缓存使用身份（==）相等性来比较键，而不是<code>equals()</code>。</p>\n<p><code>Caffeine.weakValues()</code>使用弱引用存储值。如果没有其他对值的强引用，这允许对条目进行垃圾收集。由于垃圾收集仅依赖于标识相等性，这会导致整个缓存使用标识（==）相等性来比较值，而不是使用<code>equals()</code>.</p>\n<p><code>Caffeine.softValues()</code>使用软引用存储值。软引用的对象以全局最近最少使用的方式进行垃圾收集，以响应内存需求。由于使用软引用的性能影响，我们通常建议使用更可预测的最大缓存大小。使用 of<code>softValues()</code>将导致使用恒等 (==) 相等而不是 来比较值<code>equals()</code>。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 当key和缓存元素都不再存在其他强引用的时候驱逐</span></span><br><span class=\"line\">LoadingCache&lt;Key, Graph&gt; graphs = Caffeine.newBuilder()</span><br><span class=\"line\">    .weakKeys()</span><br><span class=\"line\">    .weakValues()</span><br><span class=\"line\">    .build(key -&gt; createExpensiveGraph(key));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当进行GC的时候进行驱逐</span></span><br><span class=\"line\">LoadingCache&lt;Key, Graph&gt; graphs = Caffeine.newBuilder()</span><br><span class=\"line\">    .softValues()</span><br><span class=\"line\">    .build(key -&gt; createExpensiveGraph(key));</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>不好演示</p>\n</blockquote>\n<h4 id=\"移除\"><a href=\"#移除\" class=\"headerlink\" title=\"移除\"></a>移除</h4><ul>\n<li>显式移除</li>\n</ul>\n<blockquote>\n<p>在任何时候，你都可以手动去让某个缓存元素失效而不是只能等待其因为策略而被驱逐。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 失效key</span></span><br><span class=\"line\">cache.invalidate(key)</span><br><span class=\"line\"><span class=\"comment\">// 批量失效key</span></span><br><span class=\"line\">cache.invalidateAll(keys)</span><br><span class=\"line\"><span class=\"comment\">// 失效所有的key</span></span><br><span class=\"line\">cache.invalidateAll()</span><br></pre></td></tr></table></figure>\n<ul>\n<li>移除监听器</li>\n</ul>\n<blockquote>\n<p>你可以为你的缓存通过<code>Caffeine.removalListener(RemovalListener)</code>方法定义一个移除监听器在一个元素被移除的时候进行相应的操作。这些操作是使用 <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executor.html\">Executor</a> 异步执行的，其中默认的 Executor 实现是 <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html\">ForkJoinPool.commonPool()</a> 并且可以通过覆盖<code>Caffeine.executor(Executor)</code>方法自定义线程池的实现。</p>\n<p>当移除之后的自定义操作必须要同步执行的时候，你需要使用 <code>Caffeine.evictionListener(RemovalListener)</code> 。这个监听器将在 <code>RemovalCause.wasEvicted()</code> 为 true 的时候被触发。为了移除操作能够明确生效， <code>Cache.asMap()</code> 提供了方法来执行原子操作。</p>\n<p>记住任何在 <code>RemovalListener</code>中被抛出的异常将会被打印日志 (通过<a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/logging/package-summary.html\">Logger</a>)并被吞食。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache&lt;Key, Graph&gt; graphs = Caffeine.newBuilder()</span><br><span class=\"line\">    .evictionListener((Key key, Graph graph, RemovalCause cause) -&gt;</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;Key %s was evicted (%s)%n&quot;</span>, key, cause))</span><br><span class=\"line\">    .removalListener((Key key, Graph graph, RemovalCause cause) -&gt;</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;Key %s was removed (%s)%n&quot;</span>, key, cause))</span><br><span class=\"line\">    .build();</span><br></pre></td></tr></table></figure>\n<h4 id=\"刷新\"><a href=\"#刷新\" class=\"headerlink\" title=\"刷新\"></a>刷新</h4><blockquote>\n<p>刷新和驱逐并不相同。可以通过<code>LoadingCache.refresh(K)</code>方法，异步为key对应的缓存元素刷新一个新的值。与驱逐不同的是，在刷新的时候如果查询缓存元素，其旧值将仍被返回，直到该元素的刷新完毕后结束后才会返回刷新后的新值。</p>\n<p>与 <code>expireAfterWrite</code>相反，<code>refreshAfterWrite</code> 将会使在写操作之后的一段时间后允许key对应的缓存元素进行刷新，但是只有在这个key被真正查询到的时候才会正式进行刷新操作。所以打个比方，你可以在同一个缓存中同时用到 <code>refreshAfterWrite</code>和<code>expireAfterWrite</code> ，这样缓存元素的在被允许刷新的时候不会直接刷新使得过期时间被盲目重置。当一个元素在其被允许刷新但是没有被主动查询的时候，这个元素也会被视为过期。</p>\n<p>一个<code>CacheLoader</code>可以通过覆盖重写 <code>CacheLoader.reload(K, V)</code> 方法使得在刷新中可以将旧值也参与到更新的过程中去，这也使得刷新操作显得更加智能。</p>\n<p>更新操作将会异步执行在一个<a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executor.html\">Executor</a>上。默认的线程池实现是<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html\">ForkJoinPool.commonPool()</a>当然也可以通过覆盖<code>Caffeine.executor(Executor)</code>方法自定义线程池的实现。</p>\n<p>在刷新的过程中，如果抛出任何异常，都会使旧值被保留，并且异常将会被打印日志 (通过 <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/logging/package-summary.html\">System.Logger</a> )并被吞食。</p>\n<p><code>refreshAfterWrite()</code>表示x秒后自动刷新缓存的策略可以配合淘汰策略使用，注意的是刷新机制只支持LoadingCache和AsyncLoadingCache</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LoadingCache&lt;Key, Graph&gt; graphs = Caffeine.newBuilder()</span><br><span class=\"line\">    .maximumSize(<span class=\"number\">10_000</span>)</span><br><span class=\"line\">    .refreshAfterWrite(<span class=\"number\">1</span>, TimeUnit.MINUTES)</span><br><span class=\"line\">    .build(key -&gt; createExpensiveGraph(key));</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">NUM</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">testrefresh</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        LoadingCache&lt;Integer, Integer&gt; cache = Caffeine.newBuilder()</span><br><span class=\"line\">                .refreshAfterWrite(<span class=\"number\">1</span>, TimeUnit.SECONDS)</span><br><span class=\"line\">                <span class=\"comment\">//模拟获取数据，每次获取就自增1</span></span><br><span class=\"line\">                .build(key -&gt; ++NUM);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//获取ID=1的值，由于缓存里还没有，所以会自动放入缓存</span></span><br><span class=\"line\">        System.out.println(cache.get(<span class=\"number\">1</span>));<span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;sleep() first  &quot;</span> + cache.getIfPresent(<span class=\"number\">1</span>));<span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//此时才会刷新缓存，而第一次拿到的还是旧值</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;sleep() second  &quot;</span> + cache.getIfPresent(<span class=\"number\">1</span>));<span class=\"comment\">// 2</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">sleep() first  2</span><br><span class=\"line\">sleep() second  2</span><br></pre></td></tr></table></figure>\n<h4 id=\"统计\"><a href=\"#统计\" class=\"headerlink\" title=\"统计\"></a>统计</h4><blockquote>\n<p>使用<code>Caffeine.recordStats()</code>方法可以打开数据收集功能。<code>Cache.stats()</code>方法将会返回一个<code>CacheStats</code>对象，其将会含有一些统计指标，比如：</p>\n<ul>\n<li><code>hitRate():</code> 查询缓存的命中率</li>\n<li><code>evictionCount():</code> 被驱逐的缓存数量</li>\n<li><code>averageLoadPenalty():</code> 新值被载入的平均耗时</li>\n</ul>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache&lt;Key, Graph&gt; graphs = Caffeine.newBuilder()</span><br><span class=\"line\">    .maximumSize(<span class=\"number\">10_000</span>)</span><br><span class=\"line\">    .recordStats()</span><br><span class=\"line\">    .build();</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\">   <span class=\"keyword\">void</span> <span class=\"title function_\">testsum</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">       LoadingCache&lt;Integer, String&gt; cache = Caffeine.newBuilder()</span><br><span class=\"line\">               <span class=\"comment\">//创建缓存或者最近一次更新缓存后经过指定时间间隔，刷新缓存；refreshAfterWrite仅支持LoadingCache</span></span><br><span class=\"line\">               .refreshAfterWrite(<span class=\"number\">1</span>, TimeUnit.SECONDS)</span><br><span class=\"line\">               .expireAfterWrite(<span class=\"number\">1</span>, TimeUnit.SECONDS)</span><br><span class=\"line\">               .expireAfterAccess(<span class=\"number\">1</span>, TimeUnit.SECONDS)</span><br><span class=\"line\">               .maximumSize(<span class=\"number\">10</span>)</span><br><span class=\"line\">               <span class=\"comment\">//开启记录缓存命中率等信息</span></span><br><span class=\"line\">               .recordStats()</span><br><span class=\"line\">               <span class=\"comment\">//根据key查询数据库里面的值</span></span><br><span class=\"line\">               .build(key -&gt; &#123;</span><br><span class=\"line\">                   Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">                   <span class=\"keyword\">return</span> <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">               &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">           cache.put(i,<span class=\"string\">&quot;rycan&quot;</span>);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">           cache.get(i);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       System.out.println(cache.stats());</span><br><span class=\"line\">         <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        * hitCount :命中的次数</span></span><br><span class=\"line\"><span class=\"comment\">        * missCount:未命中次数</span></span><br><span class=\"line\"><span class=\"comment\">        * requestCount:请求次数</span></span><br><span class=\"line\"><span class=\"comment\">        * hitRate:命中率</span></span><br><span class=\"line\"><span class=\"comment\">        * missRate:丢失率</span></span><br><span class=\"line\"><span class=\"comment\">        * loadSuccessCount:成功加载新值的次数</span></span><br><span class=\"line\"><span class=\"comment\">        * loadExceptionCount:失败加载新值的次数</span></span><br><span class=\"line\"><span class=\"comment\">        * totalLoadCount:总条数</span></span><br><span class=\"line\"><span class=\"comment\">        * loadExceptionRate:失败加载新值的比率</span></span><br><span class=\"line\"><span class=\"comment\">        * totalLoadTime:全部加载时间</span></span><br><span class=\"line\"><span class=\"comment\">        * evictionCount:丢失的条数</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CacheStats&#123;hitCount=10, missCount=90, loadSuccessCount=90, loadFailureCount=0, totalLoadTime=1099684542, evictionCount=90, evictionWeight=90&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>其余见官网</p>\n</blockquote>\n<p><a href=\"https://github.com/ben-manes/caffeine/wiki/Compute-zh-CN\">计算</a></p>\n<p><a href=\"https://github.com/ben-manes/caffeine/wiki/Interner-zh-CN\">Interner</a></p>\n<p><a href=\"https://github.com/ben-manes/caffeine/wiki/Specification-zh-CN\">规范</a></p>\n<p><a href=\"https://github.com/ben-manes/caffeine/wiki/Cleanup-zh-CN\">清理</a></p>\n<p><a href=\"https://github.com/ben-manes/caffeine/wiki/Policy-zh-CN\">策略</a></p>\n<p><a href=\"https://github.com/ben-manes/caffeine/wiki/Testing-zh-CN\">测试</a></p>\n<p><a href=\"https://github.com/ben-manes/caffeine/wiki/Faq-zh-CN\">Faq</a></p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>上述一些策略在创建时都可以进行自由组合，一般情况下有<code>两种</code>方法</p>\n<blockquote>\n<p>1、设置 <code>maxSize</code>、<code>refreshAfterWrite</code>，不设置 <code>expireAfterWrite/expireAfterAccess</code>，设置<code>expireAfterWrite</code>当缓存过期时会同步加锁获取缓存，所以设置<code>expireAfterWrite</code>时性能较好，但是某些时候会取旧数据,适合允许取到旧数据的场景</p>\n<p>2、设置 <code>maxSize</code>、<code>expireAfterWrite/expireAfterAccess</code>，不设置 <code>refreshAfterWrite</code> 数据一致性好，不会获取到旧数据，但是性能没那么好（对比起来），适合获取数据时不耗时的场景</p>\n</blockquote>\n<h3 id=\"使用注解\"><a href=\"#使用注解\" class=\"headerlink\" title=\"使用注解\"></a>使用注解</h3><h4 id=\"Cacheable相关注解\"><a href=\"#Cacheable相关注解\" class=\"headerlink\" title=\"@Cacheable相关注解\"></a>@Cacheable相关注解</h4><blockquote>\n<p>如果要使用<code>@Cacheable</code>注解，需要引入相关依赖，并在任一配置类文件上添加<code>@EnableCaching</code>注解</p>\n</blockquote>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-cache<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>常见注解</p>\n</blockquote>\n<ul>\n<li><strong>@Cacheable</strong>：表示该方法支持缓存。当调用被注解的方法时，如果对应的键已经存在缓存，则不再执行方法体，而从缓存中直接返回。当方法返回null时，将不进行缓存操作。</li>\n<li><strong>@CachePut</strong>：表示执行该方法后，其值将作为最新结果更新到缓存中，每次都会执行该方法。</li>\n<li><strong>@CacheEvict</strong>：表示执行该方法后，将触发缓存清除操作。</li>\n<li><strong>@Caching</strong>：用于组合前三个注解</li>\n</ul>\n<blockquote>\n<p>注解常见属性</p>\n</blockquote>\n<ul>\n<li><strong>cacheNames/value</strong>：缓存组件的名字，即cacheManager中缓存的名称。</li>\n<li><strong>key</strong>：缓存数据时使用的key。默认使用方法参数值，也可以使用SpEL表达式进行编写。</li>\n<li><strong>keyGenerator</strong>：和key二选一使用。</li>\n<li><strong>cacheManager</strong>：指定使用的缓存管理器。</li>\n<li><strong>condition</strong>：在方法执行开始前检查，在符合condition的情况下，进行缓存</li>\n<li><strong>unless</strong>：在方法执行完成后检查，在符合unless的情况下，不进行缓存</li>\n<li><strong>sync</strong>：是否使用同步模式。若使用同步模式，在多个线程同时对一个key进行load时，其他线程将被阻塞。</li>\n</ul>\n<blockquote>\n<p> 缓存同步模式</p>\n</blockquote>\n<p>sync开启或关闭，在Cache和LoadingCache中的表现是不一致的：</p>\n<ul>\n<li>Cache中，sync表示是否需要所有线程同步等待</li>\n<li>LoadingCache中，sync表示在读取不存在/已驱逐的key时，是否执行被注解方法</li>\n</ul>\n<blockquote>\n<p>Caffeine配置说明：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  ** initialCapacity=[integer]: 初始的缓存空间大小*</span></span><br><span class=\"line\"><span class=\"comment\">  ** maximumSize=[long]: 缓存的最大条数*</span></span><br><span class=\"line\"><span class=\"comment\">  ** maximumWeight=[long]: 缓存的最大权重*</span></span><br><span class=\"line\"><span class=\"comment\">  ** expireAfterAccess=[duration]: 最后一次写入或访问后经过固定时间过期*</span></span><br><span class=\"line\"><span class=\"comment\">  ** expireAfterWrite=[duration]: 最后一次写入后经过固定时间过期*</span></span><br><span class=\"line\"><span class=\"comment\">  ** refreshAfterWrite=[duration]: 创建缓存或者最近一次更新缓存后经过固定的时间间隔，刷新缓存*</span></span><br><span class=\"line\"><span class=\"comment\">  ** weakKeys: 打开key的弱引用*</span></span><br><span class=\"line\"><span class=\"comment\">  ** weakValues：打开value的弱引用*</span></span><br><span class=\"line\"><span class=\"comment\">  ** softValues：打开value的软引用*</span></span><br><span class=\"line\"><span class=\"comment\">  ** recordStats：开发统计功能*</span></span><br><span class=\"line\"><span class=\"comment\">  ** 注意：*</span></span><br><span class=\"line\"><span class=\"comment\">  ** expireAfterWrite和expireAfterAccess同事存在时，以expireAfterWrite为准。</span></span><br><span class=\"line\"><span class=\"comment\">  ** maximumSize和maximumWeight不可以同时使用*</span></span><br><span class=\"line\"><span class=\"comment\">  ** weakValues和softValues不可以同时使用*</span></span><br><span class=\"line\"><span class=\"comment\">  **/</span></span><br></pre></td></tr></table></figure>","_path":"post/38aea546.html","_link":"http://rycan.top/post/38aea546.html","_id":"clo9tj5ux0001l10p5pfm6o8d"}}