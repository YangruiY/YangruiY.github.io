{"type":"getPostById","data":{"title":"lambda浅学","date":"2023-11-03T13:38:28.000Z","description":"lambda浅学","categories":[{"name":"Java","_id":"cloioo9e3003jni0pa4q13wrr"}],"tags":[{"name":"lambda","_id":"cloioo9eq008lni0p8ayw8tvf"}],"content":"<meta name=\"referrer\" content=\"no-referrer\">\n<h1>Java8 新特性</h1>\n<ul>\n<li>处理集合的时候效率会更高</li>\n<li>代码可读性更高</li>\n<li>减少代码中的嵌套</li>\n<li>增加可读性</li>\n</ul>\n<h2 id=\"lambda-表达式\">lambda 表达式</h2>\n<ul>\n<li>\n<p>分界： <strong>-&gt;</strong></p>\n</li>\n<li>\n<p>左侧：参数列表</p>\n</li>\n<li>\n<p>右侧：表达式或者运算公式</p>\n</li>\n</ul>\n<blockquote>\n<p><code>(参数列表)-&gt;&#123;代码&#125;</code></p>\n<p>前提：实现的接口中只有一个抽象方法（默认为 abstract() ，可以省略 ）</p>\n</blockquote>\n<blockquote>\n<p>本质上只关注  方法的参数和方法体，其他的都不关注。</p>\n<p>省略规则：</p>\n<ul>\n<li>参数类型可以省略</li>\n<li>方法体只有一句代码时大括号   return和唯一  一句代码的分号可以省略</li>\n<li>方法只有一个参数时小括号可以省略</li>\n<li><code>以上这些规则都记不住也可以省略不记</code></li>\n</ul>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> printNum(<span class=\"keyword\">new</span> <span class=\"title class_\">IntPredicate</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">test</span><span class=\"params\">(<span class=\"type\">int</span> value)</span> &#123;</span><br><span class=\"line\">               <span class=\"keyword\">return</span> value % <span class=\"number\">2</span> ==<span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//等价于</span></span><br><span class=\"line\">printNum((value)-&gt;value %<span class=\"number\">2</span> ==<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">printNum</span><span class=\"params\">(IntPredicate predicate)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] arr = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i : arr) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(predicate.test(i))&#123;</span><br><span class=\"line\">                System.out.println(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;R&gt; R <span class=\"title function_\">typeConver</span><span class=\"params\">(Function&lt;String,R&gt; function)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;12345&quot;</span>;</span><br><span class=\"line\">    <span class=\"type\">R</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> function.apply(str);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> typeConver(<span class=\"keyword\">new</span> <span class=\"title class_\">Function</span>&lt;String, Integer&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> Integer <span class=\"title function_\">apply</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> Integer.parseInt(s);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">System.out.println(res);</span><br><span class=\"line\"><span class=\"comment\">// 等价于</span></span><br><span class=\"line\">res = typeConver((s)-&gt;Integer.parseInt(s));</span><br><span class=\"line\">System.out.println(res);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<blockquote>\n<h4 id=\"Comparable与Comparator的区别\">Comparable与Comparator的区别</h4>\n<p>相同点： 都是可以进行比较和排序的接口</p>\n<p>Comparable：在集合内部进行实现排序，java.lang包下</p>\n<p>Comparator：在集合外部进行实现排序，java.util 包下</p>\n<h4 id=\"实现方式\">实现方式</h4>\n<p>一、实现java.lang.Comparable接口，使 创建的类天生具有比较的能力，只要重写  compareTo()的方法就可以了，</p>\n<ul>\n<li>o1.compare(o2)   《从小到大排序》     「o2.compare(o1)   《从大到小排序》」\n<ul>\n<li>o1 &lt; o2      -1,</li>\n<li>o1 = o2      0,</li>\n<li>o1 &gt; o2      1,</li>\n</ul>\n</li>\n</ul>\n<p>二、实现java.util.Comparator接口</p>\n<h4 id=\"举例\">举例</h4>\n<ul>\n<li><code>类</code>实现 <code>implements  java.lang.Comparable</code>接口</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Comparable</span>&lt;Person&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compareTo</span><span class=\"params\">(Person person)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name.compareTo(person.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Person</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        List&lt;Person&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;ry&quot;</span>));</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;qy&quot;</span>));</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;wy&quot;</span>));</span><br><span class=\"line\">        Collections.sort(list);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Person person:list) &#123;</span><br><span class=\"line\">            System.out.print(person.name + <span class=\"string\">&quot;\\t&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>排序的时候使用内部类自定义比较规则 ：<code>new  Comparator</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">student</span>&#123;</span><br><span class=\"line\">     String name;</span><br><span class=\"line\">     <span class=\"type\">int</span> age;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">student</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        List&lt;student&gt; list = Arrays.asList(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">student</span>(<span class=\"string\">&quot;qw&quot;</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">student</span>(<span class=\"string\">&quot;we&quot;</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">student</span>(<span class=\"string\">&quot;er&quot;</span>)</span><br><span class=\"line\">        );</span><br><span class=\"line\">        Collections.sort(list,<span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>&lt;student&gt;()&#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(student a, student b)</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> b.name.compareTo(a.name);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (student student:list) &#123;</span><br><span class=\"line\">            System.out.print(student.name + <span class=\"string\">&quot;\\t&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"Stream-流\">Stream 流</h2>\n<h3 id=\"常见操作\">常见操作</h3>\n<h4 id=\"创建流\">创建流</h4>\n<ul>\n<li>\n<p>==单列集合== （List / Set）  创建方式： <code>集合对象.stream()      </code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Author&gt; authors = getAuthors();</span><br><span class=\"line\">Stream&lt;Author&gt; stream = authors.stream();    </span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>数组（Arrays）  创建方式： <code>Arrays.stream(arr)</code> 或者  <code>Stream.of(arr)</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer[] arr = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">//Stream&lt;Integer&gt; stream = Arrays.stream(arr);</span></span><br><span class=\"line\">Stream&lt;Integer&gt; stream = Stream.of(arr);</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>双列集合 （Map）  创建方式： <code>转换为单列集合再进行创建</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HashMap&lt;String, Integer&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;蜡笔小新&quot;</span>,<span class=\"number\">19</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;黑子&quot;</span>,<span class=\"number\">17</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;日向翔阳&quot;</span>,<span class=\"number\">16</span>);</span><br><span class=\"line\">Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet();</span><br><span class=\"line\">Stream&lt;Map.Entry&lt;String, Integer&gt;&gt; stream = entries.stream();</span><br><span class=\"line\">&lt;==&gt; Stream&lt;Map.Entry&lt;String, Integer&gt;&gt; stream = map.entrySet().stream();</span><br><span class=\"line\"></span><br><span class=\"line\">Stream&lt;String&gt; stream2 = map.keySet().stream();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"中间操作\">中间操作</h4>\n<ul>\n<li>\n<p>filter         可以对流中的元素进行条件过滤，符合过滤条件的才能继续留在流中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//可以对流中的元素进行条件过滤，符合过滤条件的才能继续留在流中。</span></span><br><span class=\"line\">authors.stream()</span><br><span class=\"line\">        .filter(author -&gt; author.getName().length()&gt; <span class=\"number\">2</span>)</span><br><span class=\"line\">        .forEach(author -&gt; System.out.println(author.getName()));</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>map         可以把对流中的元素进行计算或转换</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//打印所有作家的姓名</span></span><br><span class=\"line\">authors.stream()</span><br><span class=\"line\">        .map(author -&gt; author.getName()) <span class=\"comment\">//类型转换</span></span><br><span class=\"line\">        .forEach(name -&gt; System.out.println(name));</span><br><span class=\"line\"><span class=\"comment\">//打印所有作家的年龄 并对年龄 + 10</span></span><br><span class=\"line\">authors.stream()</span><br><span class=\"line\">        .map(author-&gt;author.getAge())</span><br><span class=\"line\">        .map(age-&gt;age +<span class=\"number\">10</span>)</span><br><span class=\"line\">        .forEach(age-&gt; System.out.println(age));</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>distinct    可以去除流中的重复元素</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//打印所有作家的姓名，并且要求其中不能有重复元素。</span></span><br><span class=\"line\">authors.stream()</span><br><span class=\"line\">                .distinct()</span><br><span class=\"line\">                .forEach(author -&gt; System.out.println(author));</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>注意：distinct方法是依赖Object的equals()(或者重写的equals())来判断是否是相同对象的。所以需要注意重写equals方法。</strong></p>\n</blockquote>\n</li>\n<li>\n<p>sort            可以对流中的元素进行排序</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素。</span></span><br><span class=\"line\">authors.stream()</span><br><span class=\"line\">        .distinct()</span><br><span class=\"line\">        .sorted()</span><br><span class=\"line\">        .forEach(author -&gt; System.out.println(author.getAge()));</span><br><span class=\"line\"></span><br><span class=\"line\">authors.stream()</span><br><span class=\"line\">                .distinct()</span><br><span class=\"line\">                .sorted((o1,o2)-&gt;&#123;<span class=\"keyword\">return</span> o2.getAge() - o1.getAge();&#125;)</span><br><span class=\"line\">                .forEach(author -&gt; System.out.println(author.getAge()));</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>注意：如果调用空参的sorted()方法，需要流中的元素是实现了Comparable。</strong></p>\n</blockquote>\n</li>\n<li>\n<p>limit           可以设置流的最大长度，超出的部分将被抛弃</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素,然后打印其中年龄最大的两个作家的姓名。</span></span><br><span class=\"line\">authors.stream()</span><br><span class=\"line\">        .distinct()</span><br><span class=\"line\">        .sorted((o1,o2)-&gt;o2.getAge()-o1.getAge())</span><br><span class=\"line\">        .limit(<span class=\"number\">2</span>)</span><br><span class=\"line\">        .forEach(author -&gt; System.out.println(author));</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>skip            跳过流中的前n个元素，返回剩下的元素</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//\t打印除了年龄最大的作家外的其他作家，要求不能有重复元素，并且按照年龄降序排序。</span></span><br><span class=\"line\">authors.stream()</span><br><span class=\"line\">        .distinct()</span><br><span class=\"line\">        .sorted((o1,o2)-&gt;o2.getAge()-o1.getAge())</span><br><span class=\"line\">        .skip(<span class=\"number\">1</span>)</span><br><span class=\"line\">        .forEach(author -&gt; System.out.println(author));</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>flatMap       map只能把一个对象转换成另一个对象来作为流中的元素。而flatMap可以把一个对象转换成多个对象作为流中的元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  打印所有书籍的名字。要求对重复的元素进行去重。</span></span><br><span class=\"line\"> authors.stream()</span><br><span class=\"line\">                .distinct()</span><br><span class=\"line\">                .flatMap(author -&gt; author.getBooks().stream()) <span class=\"comment\">//流中的对象   由  Author  转为 Book</span></span><br><span class=\"line\">                .forEach(author-&gt; System.out.println(author.getName()));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//打印现有数据的所有分类。要求对分类进行去重。不能出现这种格式：哲学,爱情     爱情</span></span><br><span class=\"line\">authors.stream()</span><br><span class=\"line\">                .flatMap(author -&gt; author.getBooks().stream())<span class=\"comment\">//流中的对象   由  Author  转为 Book</span></span><br><span class=\"line\">                .distinct()</span><br><span class=\"line\">                .flatMap(book -&gt; Arrays.stream(book.getCategory().split(<span class=\"string\">&quot;,&quot;</span>)))<span class=\"comment\">//流中的对象 由Book  转为 String</span></span><br><span class=\"line\">                .distinct()</span><br><span class=\"line\">                .forEach(category-&gt; System.out.println(category));</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"终结操作\">终结操作</h4>\n<ul>\n<li>\n<p>foreach\t\t\t\t 对流中的元素进行遍历操作，我们通过传入的参数去指定对遍历到的元素进行什么具体操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//        输出所有作家的名字</span></span><br><span class=\"line\">authors.stream()</span><br><span class=\"line\">       .map(author -&gt; author.getName())</span><br><span class=\"line\">       .distinct()</span><br><span class=\"line\">       .forEach(name-&gt; System.out.println(name));</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>count  \t\t\t\t   可以用来获取当前流中元素的个数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//        打印这些作家的所出书籍的数目，注意删除重复元素。</span></span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> authors.stream()</span><br><span class=\"line\">        .flatMap(author -&gt; author.getBooks().stream())</span><br><span class=\"line\">        .distinct()</span><br><span class=\"line\">        .count();</span><br><span class=\"line\">System.out.println(count);</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>max&amp;min              可以用来或者流中的最值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//       分别获取这些作家的所出书籍的最高分和最低分并打印</span></span><br><span class=\"line\">Optional&lt;Integer&gt; max = authors.stream()</span><br><span class=\"line\">        .flatMap(author -&gt; author.getBooks().stream())</span><br><span class=\"line\">        .map(book -&gt; book.getScore())</span><br><span class=\"line\">        .max((score1, score2) -&gt;score1 -score2);</span><br><span class=\"line\">System.out.println(max.get());</span><br><span class=\"line\">Optional&lt;Integer&gt; min = authors.stream()</span><br><span class=\"line\">        .flatMap(author -&gt; author.getBooks().stream())</span><br><span class=\"line\">        .map(book -&gt; book.getScore())</span><br><span class=\"line\">        .min((score1, score2) -&gt; score1 - score2);</span><br><span class=\"line\">System.out.println(min.get());</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>collect                    把当前流转换成一个集合。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//        获取一个存放所有作者名字的List集合。</span></span><br><span class=\"line\">        List&lt;String&gt; list = authors.stream()</span><br><span class=\"line\">                .map(author -&gt; author.getName())</span><br><span class=\"line\">                .collect(Collectors.toList());</span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\"><span class=\"comment\">//        获取一个所有书名的Set集合。</span></span><br><span class=\"line\">        Set&lt;Book&gt; set = authors.stream()</span><br><span class=\"line\">                .flatMap(author -&gt; author.getBooks().stream())</span><br><span class=\"line\">                .collect(Collectors.toSet());</span><br><span class=\"line\">        System.out.println(set);</span><br><span class=\"line\"><span class=\"comment\">//        获取一个Map集合，map的key为作者名，value为List&lt;Book&gt;</span></span><br><span class=\"line\">        Map&lt;String, List&lt;Book&gt;&gt; map = authors.stream()</span><br><span class=\"line\">                .distinct()</span><br><span class=\"line\">                .collect(Collectors.toMap(author -&gt; author.getName(), author -&gt; author.getBooks()));</span><br><span class=\"line\">        System.out.println(map);</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>查找与匹配</p>\n<ul>\n<li>\n<p>anyMatch    可以用来判断是否有任意符合匹配条件的元素，结果为boolean类型。</p>\n</li>\n<li>\n<p>allMatch        可以用来判断是否都符合匹配条件，结果为boolean类型。如果都符合结果为true，否则结果为false。</p>\n</li>\n<li>\n<p>noneMatch   可以判断流中的元素是否都不符合匹配条件。如果都不符合结果为true，否则结果为false</p>\n</li>\n<li>\n<p>findAny          获取流中的任意一个元素。该方法没有办法保证获取的一定是流中的第一个元素。</p>\n</li>\n<li>\n<p>findFirst         获取流中的第一个元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  判断是否有年龄在29以上的作家</span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"variable\">flagAny</span> <span class=\"operator\">=</span> authors.stream()</span><br><span class=\"line\">        .anyMatch(author -&gt; author.getAge() &gt; <span class=\"number\">29</span>);</span><br><span class=\"line\">System.out.println(flagAny);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//判断是否所有的作家都是成年人</span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"variable\">flagAll</span> <span class=\"operator\">=</span> authors.stream()</span><br><span class=\"line\">        .allMatch(author -&gt; author.getAge() &gt; <span class=\"number\">18</span>);</span><br><span class=\"line\">System.out.println(flagAll);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//判断作家是否都没有超过100岁的。</span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"variable\">flagnone</span> <span class=\"operator\">=</span> authors.stream()</span><br><span class=\"line\">        .noneMatch(author -&gt; author.getAge() &gt; <span class=\"number\">100</span>);</span><br><span class=\"line\">System.out.println(flagnone);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取任意一个年龄大于18的作家，如果存在就输出他的名字</span></span><br><span class=\"line\">Optional&lt;Author&gt; optionalAuthor = authors.stream()</span><br><span class=\"line\">        .filter(author -&gt; author.getAge() &gt; <span class=\"number\">18</span>)</span><br><span class=\"line\">        .findAny();</span><br><span class=\"line\">optionalAuthor.ifPresent(author -&gt; System.out.println(author.getName()));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取一个年龄最小的作家，并输出他的姓名。</span></span><br><span class=\"line\">Optional&lt;Author&gt; optionalName = authors.stream()</span><br><span class=\"line\">        .sorted((o1, o2) -&gt; o1.getAge() - o2.getAge())</span><br><span class=\"line\">        .findFirst();</span><br><span class=\"line\">optionalName.ifPresent(author-&gt; System.out.println(author.getName()));</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>reduce归并    对流中的数据按照你指定的计算方式计算出一个结果。（缩减操作）</p>\n<blockquote>\n<p><strong>reduce的作用</strong></p>\n<ul>\n<li>把stream中的元素给组合起来，我们可以传入一个初始值，它会按照我们的计算方式依次拿流中的元素和初始化值进行计算，计算结果再和后面的元素计算。</li>\n</ul>\n<p>reduce两个参数的<strong>重载</strong>形式内部的计算方式如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">T</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> identity;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (T element : <span class=\"built_in\">this</span> stream)</span><br><span class=\"line\">\tresult = accumulator.apply(result, element)</span><br><span class=\"line\"><span class=\"keyword\">return</span> result;</span><br></pre></td></tr></table></figure>\n<p>其中identity就是我们可以通过方法参数传入的初始值，accumulator的apply具体进行什么计算也是我们通过方法参数来确定的。</p>\n<p>reduce一个参数的重载形式内部的计算(<code>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);</code>)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"variable\">foundAny</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\"><span class=\"type\">T</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (T element : <span class=\"built_in\">this</span> stream) &#123;      </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!foundAny) &#123;          </span><br><span class=\"line\">    foundAny = <span class=\"literal\">true</span>;          </span><br><span class=\"line\">    result = element;      </span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span></span><br><span class=\"line\">    result = accumulator.apply(result, element);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"keyword\">return</span> foundAny ? Optional.of(result) : Optional.empty();</span><br></pre></td></tr></table></figure>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//        使用reduce求所有作者年龄的和</span></span><br><span class=\"line\">        <span class=\"type\">Integer</span> <span class=\"variable\">reduceSum</span> <span class=\"operator\">=</span> authors.stream()</span><br><span class=\"line\">                .map(author -&gt; author.getAge())</span><br><span class=\"line\">                .reduce(<span class=\"number\">0</span>, (res, ele) -&gt; res + ele);</span><br><span class=\"line\">        System.out.println(reduceSum);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//          使用reduce求所有作者中年龄的最大值</span></span><br><span class=\"line\">        <span class=\"type\">Integer</span> <span class=\"variable\">reduceMax</span> <span class=\"operator\">=</span> authors.stream()</span><br><span class=\"line\">                .distinct()</span><br><span class=\"line\">                .map(author -&gt; author.getAge())</span><br><span class=\"line\">                .reduce(Integer.MIN_VALUE, (res, ele) -&gt; res &gt; ele ? res : ele);</span><br><span class=\"line\">        System.out.println(reduceMax);</span><br><span class=\"line\"><span class=\"comment\">//          使用reduce求所有作者中年龄的最小值</span></span><br><span class=\"line\">        <span class=\"type\">Integer</span> <span class=\"variable\">reduceMin</span> <span class=\"operator\">=</span> authors.stream()</span><br><span class=\"line\">                .distinct()</span><br><span class=\"line\">                .map(author -&gt; author.getAge())</span><br><span class=\"line\">                .reduce(Integer.MAX_VALUE, (res, ele) -&gt; res &lt; ele ? res : ele);</span><br><span class=\"line\">        System.out.println(reduceMin);</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">// 如果用一个参数的重载方法去求最小值代码如下：</span></span><br><span class=\"line\">        Optional&lt;Integer&gt; reducemin = authors.stream()</span><br><span class=\"line\">                .map(author -&gt; author.getAge())</span><br><span class=\"line\">                .reduce(<span class=\"keyword\">new</span> <span class=\"title class_\">BinaryOperator</span>&lt;Integer&gt;() &#123;</span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"keyword\">public</span> Integer <span class=\"title function_\">apply</span><span class=\"params\">(Integer res, Integer ele)</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> res &lt; ele ? res : ele;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">        reducemin.ifPresent(age -&gt; System.out.println(age));</span><br><span class=\"line\">        </span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"Stream的特点\">Stream的特点</h5>\n<ul>\n<li>惰性求值（如果没有终结操作，没有中间操作是不会得到执行的）</li>\n<li>流是一次性的（一旦一个流对象经过一个终结操作后。这个流就不能再被使用；所以每次都需要重新创建流对象  <code>集合/数组.stream()</code>）</li>\n<li>不会影响原数据（我们在流中可以多数据做很多处理。但是正常情况下是不会影响原来集合中的元素的。这往往也是我们期望的）</li>\n</ul>\n<h2 id=\"Optional\">Optional</h2>\n<blockquote>\n<p>可以减少过多的空指针异常的臃肿判断</p>\n</blockquote>\n<h3 id=\"创建对象\">创建对象</h3>\n<blockquote>\n<p>Optional就好像是<code>包装类</code>，可以把我们的具体数据封装<code>Optional</code>对象内部。然后我们去使用<code>Optional</code>中封装好的方法操作封装进去的数据就可以非常优雅的避免空指针异常。</p>\n</blockquote>\n<p>一般使用<strong>Optional</strong>的<strong>静态方法ofNullable</strong>来把数据封装成一个Optional对象。无论传入的参数是否为null都不会出现问题。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//List&lt;Author&gt; authors = getAuthors();</span></span><br><span class=\"line\"><span class=\"comment\">//Optional&lt;List&lt;Author&gt;&gt; optional = Optional.ofNullable(authors);</span></span><br><span class=\"line\"><span class=\"comment\">//  private static List&lt;Author&gt; getAuthors() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//      ... </span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">Optional&lt;Author&gt; authors = getAuthors1();</span><br><span class=\"line\">authors.ifPresent(author -&gt; System.out.println(author.getName()));</span><br><span class=\"line\"><span class=\"comment\">//  private static Optional&lt;Author&gt; getAuthors1() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//      ... </span></span><br><span class=\"line\"><span class=\"comment\">//  &#125;</span></span><br></pre></td></tr></table></figure>\n<p>如果你<strong>确定一个对象不是空</strong>的则可以使用<strong>Optional</strong>的<strong>静态方法of</strong>来把数据封装成Optional对象。</p>\n<blockquote>\n<p>注意，如果使用of的时候传入的参数必须不为null。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Optional&lt;Optional&lt;Author&gt;&gt; authors1 = Optional.of(authors);</span><br></pre></td></tr></table></figure>\n<p>如果一个方法的返回值类型是Optional类型。而如果我们经判断发现某次计算得到的返回值为null，这个时候就需要把null封装成Optional对象返回。这时则可以使用<strong>Optional</strong>的<strong>静态方法empty</strong>来进行封装。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Optional&lt;Author&gt; <span class=\"title function_\">getAuthors1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> author == <span class=\"literal\">null</span>? Optional.empty() : Optional.of(author);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"获取值\">获取值</h3>\n<ul>\n<li>不安全的获取值的方式： 直接使用get方法获取，但是不推荐。因为当Optional内部的数据为空的时候会出现异常。</li>\n<li>安全获取值 ： 如果我们期望安全的获取值。我们不推荐使用get方法，而是使用Optional提供的以下方法。\n<ul>\n<li>orElseGet   获取数据并且设置数据为空时的默认值。如果数据不为空就能获取到该数据。如果为空则根据你传入的参数来创建对象作为默认值返回。</li>\n<li>orElseThrow    获取数据，如果数据不为空就能获取到该数据。如果为空则根据你传入的参数来创建异常抛出。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Optional&lt;Author&gt; authors = getAuthorsOptional();</span><br><span class=\"line\"><span class=\"type\">Author</span> <span class=\"variable\">author</span> <span class=\"operator\">=</span> authors.orElseGet(() -&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">Author</span>());</span><br><span class=\"line\">System.out.println(author);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Author</span> <span class=\"variable\">author1</span> <span class=\"operator\">=</span> authors.orElseThrow(() -&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;数据为 null&quot;</span>));</span><br><span class=\"line\">System.out.println(author1);</span><br></pre></td></tr></table></figure>\n<h3 id=\"过滤\">过滤</h3>\n<p>我们可以使用filter方法对数据进行过滤。如果原本是有数据的，但是不符合判断，也会变成一个无数据的Optional对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Optional&lt;Author&gt; authorsOptionals = getAuthors1();</span><br><span class=\"line\">authorsOptionals.filter(author2 -&gt; author2.getAge() &lt; <span class=\"number\">1</span>)</span><br><span class=\"line\">                .ifPresent(authorname -&gt; System.out.println(authorname));</span><br></pre></td></tr></table></figure>\n<h3 id=\"判断\">判断</h3>\n<p>我们可以使用isPresent方法进行是否存在数据的判断。如果为空返回值为false,如果不为空，返回值为true。但是这种方式并不能体现Optional的好处，<strong>更推荐使用ifPresent方法</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Optional&lt;Author&gt; authorsOptionals = getAuthors1();</span><br><span class=\"line\"><span class=\"keyword\">if</span>(authorsOptionals.isPresent())&#123;</span><br><span class=\"line\">    System.out.println(authorsOptionals.get().getName());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"数据转换\">数据转换</h3>\n<p>Optional还提供了map可以让我们的对数据进行转换，并且转换得到的数据也还是被Optional包装好的，保证了我们的使用安全。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Optional&lt;Author&gt; authorsOptionals = getAuthors1();</span><br><span class=\"line\">authorsOptionals.map(author2 -&gt; author2.getBooks())</span><br><span class=\"line\">        .ifPresent(book -&gt; System.out.println(book));</span><br></pre></td></tr></table></figure>\n<h2 id=\"函数式接口\">函数式接口</h2>\n<blockquote>\n<p>一个接口中的抽象方法只有一个，那么就是函数值接口；</p>\n<p>JDK的函数式接口都加上了**@FunctionalInterface** 注解进行标识。但是无论是否加上该注解只要接口中只有一个抽象方法，都是函数式接口。</p>\n</blockquote>\n<h4 id=\"常见的函数式接口\">常见的函数式接口</h4>\n<blockquote>\n<ol>\n<li>Consumer 消费接口        根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中对传入的参数    进行消费。</li>\n<li>Function 计算转换接口   根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中对传入的参数    计算或转换，把结果返回</li>\n<li>Predicate 判断接口          根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中对传入的参数    条件判断，返回判断结果</li>\n<li>Supplier 生产型接口        根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中                           创建对象，把创建好的对象返回</li>\n</ol>\n</blockquote>\n<h4 id=\"常见的默认方法\">常见的默认方法</h4>\n<ul>\n<li>and    我们在使用Predicate接口时候可能需要进行判断条件的拼接。而and方法相当于是使用<code>&amp;&amp;</code>来拼接两个判断条件</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> List&lt;Author&gt; authors = getAuthors();</span><br><span class=\"line\">    authors.stream()</span><br><span class=\"line\">            .filter(<span class=\"keyword\">new</span> <span class=\"title class_\">Predicate</span>&lt;Author&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">test</span><span class=\"params\">(Author author)</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> author.getAge() &gt; <span class=\"number\">16</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;.and(<span class=\"keyword\">new</span> <span class=\"title class_\">Predicate</span>&lt;Author&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">test</span><span class=\"params\">(Author author)</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> author.getBooks().size() &gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;)).forEach(author -&gt; System.out.println(author.getAge() + <span class=\"string\">&quot;::::&quot;</span> + author.getBooks()));</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>or         我们在使用Predicate接口时候可能需要进行判断条件的拼接。而or方法相当于是使用 <code> ||</code>  来拼接两个判断条件。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Author&gt; authors = getAuthors();</span><br><span class=\"line\">authors.stream()</span><br><span class=\"line\">        .filter(new Predicate&lt;Author&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public boolean test(Author author) &#123;</span><br><span class=\"line\">                return author.getAge() &gt; 16;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;.or(new Predicate&lt;Author&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public boolean test(Author author) &#123;</span><br><span class=\"line\">                return author.getAge() &lt; 56;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)).forEach(author -&gt; System.out.println(author.getAge() + &quot;::::&quot; + author.getBooks()));</span><br></pre></td></tr></table></figure>\n<ul>\n<li>negate      Predicate接口中的方法。negate方法相当于是在判断添加前面加了个<code>!</code> 表示取反</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Author&gt; authors = getAuthors();</span><br><span class=\"line\">authors.stream()</span><br><span class=\"line\">        .filter(<span class=\"keyword\">new</span> <span class=\"title class_\">Predicate</span>&lt;Author&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">test</span><span class=\"params\">(Author author)</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> author.getAge() &gt; <span class=\"number\">16</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;.negate()).forEach(author -&gt; System.out.println(author.getAge() + <span class=\"string\">&quot;::::&quot;</span> + author.getBooks()));</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法引用\">方法引用</h2>\n<p>​\t我们在使用lambda时，如果<code>方法体中只有一个方法的调用</code>的话（包括<code>构造方法</code>）,我们可以用<code>方法引用</code>进一步简化代码。</p>\n<h3 id=\"基本格式\">基本格式</h3>\n<p>​\t<code>类名或者对象名::方法名</code></p>\n<h3 id=\"语法详解-了解\">语法详解(了解)</h3>\n<h4 id=\"引用类的静态方法\">引用类的静态方法</h4>\n<ul>\n<li>\n<p>格式         <code>类名::方法名</code></p>\n</li>\n<li>\n<p>前提</p>\n<ul>\n<li>如果我们在重写方法的时候，方法体中<strong>只有一行代码</strong>，</li>\n<li>并且这行代码是<strong>调用了某个<code>类的静态方法</code></strong>，</li>\n<li>并且我们把要重写的<strong>抽象方法中所有的参数都按照顺序传入了这个静态方法中</strong>，这个时候我们就可以引用类的静态方法。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Author&gt; authors = getAuthors();</span><br><span class=\"line\">Stream&lt;Author&gt; authorStream = authors.stream();</span><br><span class=\"line\">authorStream.map(author -&gt; author.getAge())</span><br><span class=\"line\">            .map(age-&gt;String.valueOf(age));</span><br><span class=\"line\">&lt;=&gt;</span><br><span class=\"line\">authorStream.map(author -&gt; author.getAge())</span><br><span class=\"line\">            .map(String::valueOf);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"引用对象的实例方法\">引用对象的实例方法</h4>\n<ul>\n<li>格式        <code> 对象名::方法名</code></li>\n<li>使用前提\n<ul>\n<li>如果我们在重写方法的时候，方法体中<strong>只有一行代码</strong>，</li>\n<li>并且这行代码是<strong>调用了某个<code>对象的成员方法</code></strong>，</li>\n<li>并且我们把要重写的<strong>抽象方法中所有的参数都按照顺序传入了这个成员方法中</strong>，这个时候我们就可以引用对象的实例方法</li>\n</ul>\n</li>\n</ul>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    List&lt;Author&gt; authors = getAuthors();</span><br><span class=\"line\"></span><br><span class=\"line\">    Stream&lt;Author&gt; authorStream = authors.stream();</span><br><span class=\"line\">    <span class=\"type\">StringBuilder</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>();</span><br><span class=\"line\">    authorStream.map(author -&gt; author.getName())</span><br><span class=\"line\">            .forEach(name-&gt;sb.append(name));</span><br><span class=\"line\"></span><br><span class=\"line\">authorStream.map(author -&gt; author.getName())</span><br><span class=\"line\">            .forEach(sb::append);</span><br></pre></td></tr></table></figure>\n<h4 id=\"引用类的实例方法\">引用类的实例方法</h4>\n<ul>\n<li>\n<p>格式             <code>类名::方法名</code></p>\n</li>\n<li>\n<p>使用前提</p>\n<ul>\n<li>如果我们在重写方法的时候，方法体中<strong>只有一行代码</strong>，</li>\n<li>并且这行代码是**<code>调用了第一个参数的成员方法</code>**，</li>\n<li>并且我们把要<strong>重写的抽象方法中<code>剩余的所有的参数都按照顺序传入了这个成员方法中</code></strong>，这个时候我们就可以引用类的实例方法。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Function_</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">interface</span> <span class=\"title class_\">UseString</span>&#123;</span><br><span class=\"line\">        String <span class=\"title function_\">use</span><span class=\"params\">(String str,<span class=\"type\">int</span> start,<span class=\"type\">int</span> length)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">subAuthorName</span><span class=\"params\">(String str, UseString useString)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> useString.use(str,start,length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> subAuthorName(<span class=\"string\">&quot;ry123&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">UseString</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> String <span class=\"title function_\">use</span><span class=\"params\">(String str, <span class=\"type\">int</span> start, <span class=\"type\">int</span> length)</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> str.substring(start, length);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        System.out.println(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  &lt;=&gt;</span><br><span class=\"line\">\t\t <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> subAuthorName(<span class=\"string\">&quot;ry123&quot;</span>, String::substring);</span><br><span class=\"line\">        System.out.println(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"构造器引用\">构造器引用</h4>\n<blockquote>\n<p>如果<code>方法体中的一行代码是构造器的话</code>就可以使用构造器引用。</p>\n</blockquote>\n<ul>\n<li>\n<p>格式                   <code>类名::new</code></p>\n</li>\n<li>\n<p>使用前提</p>\n<ul>\n<li>如果我们在重写方法的时候，方法体中<strong>只有一行代码</strong>，</li>\n<li>并且这行代码是**<code>调用了某个类的构造方法</code>**，</li>\n<li>并且我们把**<code>要重写的抽象方法中的所有的参数都按照顺序传入了这个构造方法中</code>**，这个时候我们就可以引用构造器。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    getAuthors().stream()</span><br><span class=\"line\">                .map(author2 -&gt; author.getName())</span><br><span class=\"line\">                .map(<span class=\"keyword\">new</span> <span class=\"title class_\">Function</span>&lt;String, StringBuilder&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"keyword\">public</span> StringBuilder <span class=\"title function_\">apply</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>(name);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                .map(stringBuilder -&gt; stringBuilder.append(<span class=\"string\">&quot;ry123&quot;</span>).toString())</span><br><span class=\"line\">                .forEach(str -&gt; System.out.println(str));</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;=&gt;</span><br><span class=\"line\">    getAuthors().stream()</span><br><span class=\"line\">                .map(Author::getName)</span><br><span class=\"line\">                .map(StringBuilder::<span class=\"keyword\">new</span>)</span><br><span class=\"line\">                .map(stringBuilder -&gt; stringBuilder.append(<span class=\"string\">&quot;ry123&quot;</span>).toString())</span><br><span class=\"line\">                .forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"高级用法\">高级用法</h2>\n<h3 id=\"基本数据类型优化\">基本数据类型优化</h3>\n<ul>\n<li>\n<p>我们之前用到的很多Stream的方法由于都使用了泛型。所以涉及到的参数和返回值都是引用数据类型。</p>\n</li>\n<li>\n<p>即使我们操作的是整数小数，但是实际用的都是他们的包装类。</p>\n</li>\n<li>\n<p>JDK5中引入的自动装箱和自动拆箱让我们在使用对应的包装类时就好像使用基本数据类型一样方便。</p>\n</li>\n<li>\n<p>但是你一定要知道装箱和拆箱肯定是要消耗时间的。虽然这个时间消耗很下。但是在大量的数据不断的重复装箱拆箱的时候，你就不能无视这个时间损耗了。</p>\n</li>\n<li>\n<p>所以为了让我们能够对这部分的时间消耗进行优化。Stream还提供了很多专门针对基本数据类型的方法。</p>\n</li>\n</ul>\n<p>例如：<code>mapToInt</code>,<code>mapToLong</code>,<code>mapToDouble</code>,<code>flatMapToInt</code>,<code>flatMapToDouble</code>等。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  List&lt;Author&gt; authors = getAuthors();</span><br><span class=\"line\">        authors.stream()</span><br><span class=\"line\">                .map(Author::getAge)</span><br><span class=\"line\">                .map(age-&gt;age+ <span class=\"number\">10</span>)</span><br><span class=\"line\">                .map(age-&gt;age+ <span class=\"number\">20</span>)</span><br><span class=\"line\">                .forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 上述过程有很多 隐式的拆箱装箱的操作</span></span><br><span class=\"line\">&lt;=&gt; <span class=\"comment\">// 改进如下</span></span><br><span class=\"line\">   List&lt;Author&gt; authors = getAuthors();</span><br><span class=\"line\">        authors.stream()</span><br><span class=\"line\">                .mapToInt(Author::getAge)<span class=\"comment\">// 改进</span></span><br><span class=\"line\">                .map(age-&gt;age+ <span class=\"number\">10</span>)</span><br><span class=\"line\">                .map(age-&gt;age+ <span class=\"number\">20</span>)</span><br><span class=\"line\">                .forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n<h3 id=\"并行流\">并行流</h3>\n<ul>\n<li>\n<p>当流中有大量元素时，我们可以使用并行流去提高操作的效率。</p>\n</li>\n<li>\n<p>并行流就是<code>把任务分配给多个线程去完全执行</code>。如果我们自己去用代码实现的话其实会非常的复杂，并且要求你对并发编程有足够的理解和认识。而如果我们使用Stream的话，我们只需要修改一个方法的调用就可以使用并行流来帮我们实现，从而提高效率。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Function_Reference();</span></span><br><span class=\"line\">    List&lt;Author&gt; authors = getAuthors();</span><br><span class=\"line\">    <span class=\"comment\">//basicDataTypeUpdate(authors);</span></span><br><span class=\"line\">    Stream&lt;Integer&gt; stream = Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> stream</span><br><span class=\"line\">            .peek(num -&gt; System.out.println(num + Thread.currentThread().getName()))</span><br><span class=\"line\">            .filter(num -&gt; num &gt; <span class=\"number\">5</span>)</span><br><span class=\"line\">            .reduce((res, ele) -&gt; res + ele)</span><br><span class=\"line\">            .get();</span><br><span class=\"line\">    System.out.println(result);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1main</span><br><span class=\"line\">2main</span><br><span class=\"line\">3main</span><br><span class=\"line\">4main</span><br><span class=\"line\">5main</span><br><span class=\"line\">6main</span><br><span class=\"line\">7main</span><br><span class=\"line\">8main</span><br><span class=\"line\">9main</span><br><span class=\"line\">10main</span><br><span class=\"line\">40</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>parallel</code>方法可以把串行流转换成并行流。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Function_Reference();</span></span><br><span class=\"line\"> List&lt;Author&gt; authors = getAuthors();</span><br><span class=\"line\"> <span class=\"comment\">//basicDataTypeUpdate(authors);</span></span><br><span class=\"line\"> Stream&lt;Integer&gt; stream = Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\"> <span class=\"type\">Integer</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> stream.parallel()</span><br><span class=\"line\">         .peek(num -&gt; System.out.println(num + Thread.currentThread().getName()))</span><br><span class=\"line\">         .filter(num -&gt; num &gt; <span class=\"number\">5</span>)</span><br><span class=\"line\">         .reduce((res, ele) -&gt; res + ele)</span><br><span class=\"line\">         .get();</span><br><span class=\"line\"> System.out.println(result);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7main</span><br><span class=\"line\">4ForkJoinPool.commonPool-worker-1</span><br><span class=\"line\">5ForkJoinPool.commonPool-worker-8</span><br><span class=\"line\">2ForkJoinPool.commonPool-worker-11</span><br><span class=\"line\">6ForkJoinPool.commonPool-worker-6</span><br><span class=\"line\">9ForkJoinPool.commonPool-worker-2</span><br><span class=\"line\">10ForkJoinPool.commonPool-worker-15</span><br><span class=\"line\">3ForkJoinPool.commonPool-worker-9</span><br><span class=\"line\">8ForkJoinPool.commonPool-worker-13</span><br><span class=\"line\">1ForkJoinPool.commonPool-worker-4</span><br><span class=\"line\">40\t</span><br></pre></td></tr></table></figure>\n<ul>\n<li>也可以通过<code>parallelStream</code>直接获取并行流对象。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Author&gt; authors = getAuthors();</span><br><span class=\"line\">authors.parallelStream()</span><br><span class=\"line\">      .map(author -&gt; author.getAge())</span><br><span class=\"line\">      .map(age-&gt;age + <span class=\"number\">2</span>)</span><br><span class=\"line\">      .filter(age-&gt; age &gt; <span class=\"number\">12</span>)</span><br><span class=\"line\">      .map(age -&gt; age + <span class=\"number\">14</span>)</span><br><span class=\"line\">      .peek(num -&gt; System.out.println(num + Thread.currentThread().getName()))</span><br><span class=\"line\">      .forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">30main</span><br><span class=\"line\">31ForkJoinPool.commonPool-worker-9</span><br><span class=\"line\">31</span><br><span class=\"line\">49ForkJoinPool.commonPool-worker-11</span><br><span class=\"line\">49</span><br><span class=\"line\">30ForkJoinPool.commonPool-worker-4</span><br><span class=\"line\">30</span><br><span class=\"line\">30</span><br><span class=\"line\">30ForkJoinPool.commonPool-worker-2</span><br><span class=\"line\">30</span><br></pre></td></tr></table></figure>\n","_path":"post/a1b38e2c.html","_link":"http://rycan.top/post/a1b38e2c.html","_id":"cloioo9e7004mni0pc6jgghuv"}}