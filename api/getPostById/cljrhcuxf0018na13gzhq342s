{"type":"getPostById","data":{"title":"Netty 学习(未学的源码)","date":"2023-07-03T12:29:14.000Z","description":"Netty部分源码","categories":[{"name":"框架","_id":"cljrhcux9000cna1366flh9tf"}],"tags":[{"name":"Netty","_id":"cljrhcuxl0033na139qhp6arv"}],"content":"<meta name=\"referrer\" content=\"no-referrer\">\n<h1>韩顺平Netty源码分析</h1>\n<h2 id=\"Netty-核心源码剖析\">Netty 核心源码剖析</h2>\n<h3 id=\"基本说明\">基本说明</h3>\n<ol>\n<li>只有看过 <code>Netty</code> 源码，才能说是真的掌握了 <code>Netty</code> 框架。</li>\n<li>在 <code>io.netty.example</code> 包下，有很多 <code>Netty</code> 源码案例，可以用来分析。</li>\n<li>源码分析章节是针对有 <code>Java</code> 项目经验，并且玩过框架源码的人员讲的，否则你听起来会有相当的难度。</li>\n</ol>\n<h3 id=\"Netty-启动过程源码剖析\">Netty 启动过程源码剖析</h3>\n<h4 id=\"源码剖析目的\">源码剖析目的</h4>\n<p>用源码分析的方式走一下 <code>Netty</code>（服务器）的启动过程，更好的理解 <code>Netty</code> 的整体设计和运行机制。</p>\n<h4 id=\"源码剖析\">源码剖析</h4>\n<p>说明：</p>\n<ol>\n<li>源码需要剖析到 <code>Netty</code> 调用 <code>doBind</code> 方法，追踪到 <code>NioServerSocketChannel</code> 的 <code>doBind</code>。</li>\n<li>并且要 <code>Debug</code> 程序到 <code>NioEventLoop</code> 类的 <code>run</code> 代码，无限循环，在服务器端运行。</li>\n</ol>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306132233235.png\" alt></p>\n<h4 id=\"源码剖析过程\">源码剖析过程</h4>\n<p><strong>1. <code>demo</code> 源码的基本理解</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 服务器启动类源码</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Copyright 2012 The Netty Project</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * The Netty Project licenses this file to you under the Apache License,</span></span><br><span class=\"line\"><span class=\"comment\"> * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance</span></span><br><span class=\"line\"><span class=\"comment\"> * with the License. You may obtain a copy of the License at:</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *   http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class=\"line\"><span class=\"comment\"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span></span><br><span class=\"line\"><span class=\"comment\"> * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span></span><br><span class=\"line\"><span class=\"comment\"> * License for the specific language governing permissions and limitations</span></span><br><span class=\"line\"><span class=\"comment\"> * under the License.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> atguigu.netty.example.echo2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.ChannelFuture;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.ChannelInitializer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.ChannelOption;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.ChannelPipeline;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.EventLoopGroup;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.handler.logging.LogLevel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.handler.logging.LoggingHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.handler.ssl.SslContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.handler.ssl.SslContextBuilder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.handler.ssl.util.SelfSignedCertificate;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Echoes back any received data from a client.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EchoServer</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"variable\">SSL</span> <span class=\"operator\">=</span> System.getProperty(<span class=\"string\">&quot;ssl&quot;</span>) != <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">PORT</span> <span class=\"operator\">=</span> Integer.parseInt(System.getProperty(<span class=\"string\">&quot;port&quot;</span>, <span class=\"string\">&quot;8007&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Configure SSL.</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> SslContext sslCtx;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (SSL) &#123;</span><br><span class=\"line\">            <span class=\"type\">SelfSignedCertificate</span> <span class=\"variable\">ssc</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SelfSignedCertificate</span>();</span><br><span class=\"line\">            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            sslCtx = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Configure the server.</span></span><br><span class=\"line\">        <span class=\"type\">EventLoopGroup</span> <span class=\"variable\">bossGroup</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"type\">EventLoopGroup</span> <span class=\"variable\">workerGroup</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">ServerBootstrap</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrap</span>();</span><br><span class=\"line\">            b.group(bossGroup, workerGroup)</span><br><span class=\"line\">                    .channel(NioServerSocketChannel.class)</span><br><span class=\"line\">                    .option(ChannelOption.SO_BACKLOG, <span class=\"number\">100</span>)</span><br><span class=\"line\">                    .handler(<span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.INFO))</span><br><span class=\"line\">                    .childHandler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                            <span class=\"type\">ChannelPipeline</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> ch.pipeline();</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (sslCtx != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                                p.addLast(sslCtx.newHandler(ch.alloc()));</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            <span class=\"comment\">//p.addLast(new LoggingHandler(LogLevel.INFO));</span></span><br><span class=\"line\">                            p.addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">EchoServerHandler</span>());</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Start the server.</span></span><br><span class=\"line\">            <span class=\"type\">ChannelFuture</span> <span class=\"variable\">f</span> <span class=\"operator\">=</span> b.bind(PORT).sync();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Wait until the server socket is closed.</span></span><br><span class=\"line\">            f.channel().closeFuture().sync();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Shut down all event loops to terminate all threads.</span></span><br><span class=\"line\">            bossGroup.shutdownGracefully();</span><br><span class=\"line\">            workerGroup.shutdownGracefully();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>说明：</p>\n<ol>\n<li>先看启动类：<code>main</code> 方法中，首先创建了关于 SSL 的配置类。</li>\n<li>重点分析下创建了两个 <code>EventLoopGroup</code> 对象：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">EventLoopGroup</span> <span class=\"variable\">bossGroup</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"type\">EventLoopGroup</span> <span class=\"variable\">workerGroup</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>(1) 这两个对象是整个 <code>Netty</code> 的核心对象，可以说，整个 <code>Netty</code> 的运作都依赖于他们。<code>bossGroup</code> 用于接受 <code>TCP</code> 请求，他会将请求交给 <code>workerGroup</code>，<code>workerGroup</code> 会获取到真正的连接，然后和连接进行通信，比如读写解码编码等操作。</p>\n<p>(2) <code>EventLoopGroup</code> 是事件循环组（线程组）含有多个 <code>EventLoop</code>，可以注册 <code>channel</code>，用于在事件循环中去进行选择（和选择器相关）。【debug看】</p>\n<p>(3) <code>new NioEventLoopGroup(1);</code> 这个 <code>1</code> 表示 <code>bossGroup</code> 事件组有 <code>1</code> 个线程你可以指定，如果 <code>new NioEventLoopGroup()</code> 会含有默认个线程 <code>cpu核数 * 2</code>，即可以充分的利用多核的优势，【可以dubug一把】</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class=\"number\">1</span>, SystemPropertyUtil.getInt(<span class=\"string\">&quot;io.netty.eventLoopThreads&quot;</span>, NettyRuntime.availableProcessors() * <span class=\"number\">2</span>));Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>会创建 <code>EventExecutor</code> 数组 <code>children = new EventExecutor[nThreads];</code> // <code>debug</code> 一下每个元素的类型就是 <code>NIOEventLoop</code>，<code>NIOEventLoop</code> 实现了 <code>EventLoop</code> 接口和 <code>Executor</code> 接口 <code>try</code> 块中创建了一个 <code>ServerBootstrap</code> 对象，他是一个引导类，用于启动服务器和引导整个程序的初始化（看下源码 <code>allowseasybootstrapof&#123;@linkServerChannel&#125;</code>）。它和 <code>ServerChannel</code> 关联，而 <code>ServerChannel</code> 继承了 <code>Channel</code>，有一些方法 <code>remoteAddress</code> 等[可以Debug下]随后，变量 <code>b</code> 调用了 <code>group</code> 方法将两个 <code>group</code> 放入了自己的字段中，用于后期引导使用【<code>debug</code> 下 <code>group</code> 方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *Set the &#123;<span class=\"doctag\">@link</span> EventLoopGroup&#125; for the parent (acceptor) and the child (client) . These</span></span><br><span class=\"line\"><span class=\"comment\"> *&#123;<span class=\"doctag\">@link</span> EventLoopGroup&#125;&#x27;s are used to handle all the events and IO for &#123;<span class=\"doctag\">@link</span> ServerChannel&#125; and </span></span><br><span class=\"line\"><span class=\"comment\"> *&#123;<span class=\"doctag\">@link</span> Channel&#125;&#x27;s.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span>Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>】。</p>\n<p>(4) 然后添加了一个 <code>channel</code>，其中参数一个 <code>Class</code> 对象，引导类将通过这个 <code>Class</code> 对象反射创建 <code>ChannelFactory</code>。然后添加了一些 <code>TCP</code> 的参数。【说明：<code>Channel</code> 的创建在 <code>bind</code> 方法，可以 <code>Debug</code> 下 <code>bind</code>，会找到 <code>channel = channelFactory.newChannel();</code> 】</p>\n<p>(5) 再添加了一个服务器专属的日志处理器 <code>handler</code> 。</p>\n<p>(6) 再添加一个 <code>SocketChannel</code>（不是 <code>ServerSocketChannel</code>）的 <code>handler</code>。</p>\n<p>(7) 然后绑定端口并阻塞至连接成功。</p>\n<p>(8) 最后 <code>main</code> 线程阻塞等待关闭。</p>\n<p>(9) <code>finally</code> 块中的代码将在服务器关闭时优雅关闭所有资源。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Copyright 2012 The Netty Project</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * The Netty Project licenses this file to you under the Apache License,</span></span><br><span class=\"line\"><span class=\"comment\"> * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance</span></span><br><span class=\"line\"><span class=\"comment\"> * with the License. You may obtain a copy of the License at:</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *   http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class=\"line\"><span class=\"comment\"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span></span><br><span class=\"line\"><span class=\"comment\"> * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span></span><br><span class=\"line\"><span class=\"comment\"> * License for the specific language governing permissions and limitations</span></span><br><span class=\"line\"><span class=\"comment\"> * under the License.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> atguigu.netty.example.echo2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.ChannelHandler.Sharable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Handler implementation for the echo server.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Sharable</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EchoServerHandler</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class=\"line\">        ctx.write(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelReadComplete</span><span class=\"params\">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class=\"line\">        ctx.flush();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">exceptionCaught</span><span class=\"params\">(ChannelHandlerContext ctx, Throwable cause)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Close the connection when an exception is raised.</span></span><br><span class=\"line\">        cause.printStackTrace();</span><br><span class=\"line\">        ctx.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>说明:</p>\n<ol>\n<li>这是一个普通的处理器类，用于处理客户端发送来的消息，在我们这里，我们简单的解析出客户端传过来的内容，然后打印，最后发送字符串给客户端。</li>\n<li>大致讲解了我们的 <code>demo</code> 源码的作用。后面的 <code>debug</code> 的时候会详细。</li>\n</ol>\n<p><strong>2. 分析 EventLoopGroup 的过程</strong></p>\n<p>2.1 构造器方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">NioEventLoopGroup</span> <span class=\"params\">(<span class=\"type\">int</span> nThreads)</span> &#123; </span><br><span class=\"line\">    <span class=\"built_in\">this</span>(nThreads, (Executor) <span class=\"literal\">null</span>);</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>2.2 上面的 <code>this(nThreads, (Executor) null);</code> 调用构造器（通过 <code>alt + d</code> 看即可）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">NioEventLoopGroup</span> <span class=\"params\">(<span class=\"type\">int</span> nThreads, Executor executor)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>(nThreads, executor, SelectorProvider.provider());</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>2.3 上面的 <code>this(nThreads, executor, SelectorProvider.provider());</code> 调用下面构造器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">NioEventLoopGroup</span> <span class=\"params\">(<span class=\"type\">int</span> nThreads, Executor executor, <span class=\"keyword\">final</span> SelectorProvider selectorProvider)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>(nThreads, executor, selectorProvider,DefaultSelectStrategyFactory.INSTANCE);</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>2.4 上面的 <code>this()...</code> 调用构造器（<code>alt + d</code>）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">NioEventLoopGroup</span> <span class=\"params\">(<span class=\"type\">int</span> nThreads, Executor executor, <span class=\"keyword\">final</span> SelectorProvider selectorProvider,<span class=\"keyword\">final</span> SelectStrategyFactory selectStrategyFactory)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(nThreads, executor, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>2.5 上面的 <code>super()..</code> 的方法是父类：<code>MultithreadEventLoopGroup</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"title function_\">MultithreadEventLoopGroup</span> <span class=\"params\">(<span class=\"type\">int</span> nThreads, Executor executor, Object...args)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(nThreads == <span class=\"number\">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>2.6 追踪到源码抽象类 <code>MultithreadEventExecutorGroup</code> 的构造器方法 <code>MultithreadEventExecutorGroup</code> 才是 <code>NioEventLoopGroup</code> 真正的构造方法，这里可以看成是一个模板方法，使用了设计模式的模板模式（可看我录制视频），所以，我们就需要好好分析 <code>MultithreadEventExecutorGroup</code> 方法了</p>\n<p>2.7 分析 <code>MultithreadEventExecutorGroup</code></p>\n<p>参数说明：</p>\n<ul>\n<li><code>@param nThreads</code> 使用的线程数，默认为 <code>core * 2</code>【可以追踪源码】</li>\n<li><code>@param executor</code> 执行器:如果传入 <code>null</code>, 则采用 <code>Netty</code> 默认的线程工厂和默认的执行器 <code>ThreadPerTaskExecutor</code></li>\n<li><code>@param chooserFactory</code> 单例 <code>new DefaultEventExecutorChooserFactory()</code></li>\n<li><code>@param args args</code> 在创建执行器的时候传入固定参数</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"title function_\">MultithreadEventExecutorGroup</span><span class=\"params\">(<span class=\"type\">int</span> nThreads, Executor executor,</span></span><br><span class=\"line\"><span class=\"params\">                                        EventExecutorChooserFactory chooserFactory, Object... args)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nThreads &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(String.format(<span class=\"string\">&quot;nThreads: %d (expected: &gt; 0)&quot;</span>, nThreads));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (executor == <span class=\"literal\">null</span>) &#123; <span class=\"comment\">// 如果传入的执行器是空的则采用默认的线程工厂和默认的执行器</span></span><br><span class=\"line\">        executor = <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPerTaskExecutor</span>(newDefaultThreadFactory());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建指定线程数的执行器数组</span></span><br><span class=\"line\">    children = <span class=\"keyword\">new</span> <span class=\"title class_\">EventExecutor</span>[nThreads];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化线程数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nThreads; i ++) &#123;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">success</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 创建 new NioEventLoop</span></span><br><span class=\"line\">            children[i] = newChild(executor, args);</span><br><span class=\"line\">            success = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Think about if this is a good exception type</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;failed to create a child event loop&quot;</span>, e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果创建失败，优雅关闭</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!success) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; i; j ++) &#123;</span><br><span class=\"line\">                    children[j].shutdownGracefully();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; i; j ++) &#123;</span><br><span class=\"line\">                    <span class=\"type\">EventExecutor</span> <span class=\"variable\">e</span> <span class=\"operator\">=</span> children[j];</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">while</span> (!e.isTerminated()) &#123;</span><br><span class=\"line\">                            e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (InterruptedException interrupted) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// Let the caller handle the interruption.</span></span><br><span class=\"line\">                        Thread.currentThread().interrupt();</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    chooser = chooserFactory.newChooser(children);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> FutureListener&lt;Object&gt; terminationListener = <span class=\"keyword\">new</span> <span class=\"title class_\">FutureListener</span>&lt;Object&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">operationComplete</span><span class=\"params\">(Future&lt;Object&gt; future)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (terminatedChildren.incrementAndGet() == children.length) &#123;</span><br><span class=\"line\">                terminationFuture.setSuccess(<span class=\"literal\">null</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 为每一个单例线程池添加一个关闭监听器</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (EventExecutor e: children) &#123;</span><br><span class=\"line\">        e.terminationFuture().addListener(terminationListener);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Set&lt;EventExecutor&gt; childrenSet = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedHashSet</span>&lt;EventExecutor&gt;(children.length);</span><br><span class=\"line\">    <span class=\"comment\">//将所有的单例线程池添加到一个 HashSet 中。</span></span><br><span class=\"line\">    Collections.addAll(childrenSet, children);</span><br><span class=\"line\">    readonlyChildren = Collections.unmodifiableSet(childrenSet);</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>说明：</p>\n<ol>\n<li>如果 <code>executor</code> 是 <code>null</code>，创建一个默认的 <code>ThreadPerTaskExecutor</code>，使用 <code>Netty</code> 默认的线程工厂。</li>\n<li>根据传入的线程数（<code>CPU * 2</code>）创建一个线程池（单例线程池）数组。</li>\n<li>循环填充数组中的元素。如果异常，则关闭所有的单例线程池。</li>\n<li>根据线程选择工厂创建一个线程选择器。</li>\n<li>为每一个单例线程池添加一个关闭监听器。</li>\n<li>将所有的单例线程池添加到一个 <code>HashSet</code> 中。</li>\n</ol>\n<p><strong>3. ServerBootstrap 创建和构造过程</strong></p>\n<p>3.1 <code>ServerBootstrap</code> 是个空构造，但是有默认的成员变量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; childOptions = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedHashMap</span>&lt;ChannelOption&lt;?&gt;, Object&gt;();</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; childAttrs = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;AttributeKey&lt;?&gt;, Object&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// config 对象，会在后面起很大作用</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">ServerBootstrapConfig</span> <span class=\"variable\">config</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrapConfig</span>(<span class=\"built_in\">this</span>);</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> EventLoopGroup childGroup;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> ChannelHandler childHandler;</span><br><span class=\"line\">Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>3.2 分析一下 <code>ServerBootstrap</code> 基本使用情况</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ServerBootstrap</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrap</span>();</span><br><span class=\"line\">b.group(bossGroup, workerGroup)</span><br><span class=\"line\">        .channel(NioServerSocketChannel.class)</span><br><span class=\"line\">        .option(ChannelOption.SO_BACKLOG, <span class=\"number\">100</span>)</span><br><span class=\"line\">        .handler(<span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.INFO))</span><br><span class=\"line\">        .childHandler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                <span class=\"type\">ChannelPipeline</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> ch.pipeline();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (sslCtx != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    p.addLast(sslCtx.newHandler(ch.alloc()));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//p.addLast(new LoggingHandler(LogLevel.INFO));</span></span><br><span class=\"line\">                p.addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">EchoServerHandler</span>());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>说明:</p>\n<ol>\n<li>链式调用：<code>group</code> 方法，将 <code>boss</code> 和 <code>worker</code> 传入，<code>boss</code> 赋值给 <code>parentGroup</code> 属性, <code>worker</code> 赋值给 <code>childGroup</code> 属性。</li>\n<li><code>channel</code> 方法传入 <code>NioServerSocketChannelclass</code> 对象。会根据这个 <code>class</code> 创建 <code>channel</code> 对象。</li>\n<li><code>option</code> 方法传入 <code>TCP</code> 参数，放在一个 <code>LinkedHashMap</code> 中。</li>\n<li><code>handler</code> 方法传入一个 <code>handler</code> 中，这个 <code>hanlder</code> 只专属于 <code>ServerSocketChannel</code> 而不是 <code>SocketChannel</code>。</li>\n<li><code>childHandler</code> 传入一个 <code>hanlder</code>，这个 <code>handler</code> 将会在每个客户端连接的时候调用。供 <code>SocketChannel</code> 使用。</li>\n</ol>\n<p><strong>4. 绑定端口的分析</strong></p>\n<p>4.1 服务器就是在这个 <code>bind</code> 方法里启动完成的 4.2 <code>bind</code> 方法代码,追踪到创建了一个端口对象，并做了一些空判断，核心代码 <code>doBind</code>，我们看看</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> ChannelFuture <span class=\"title function_\">bind</span><span class=\"params\">(SocketAddress localAddress)</span> &#123;</span><br><span class=\"line\">    validate();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (localAddress == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NullPointerException</span>(<span class=\"string\">&quot;localAddress&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> doBind(localAddress);</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>4.3 <code>doBind</code> 源码剖析，核心是两个方法 <code>initAndRegister</code> 和 <code>doBind0</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> ChannelFuture <span class=\"title function_\">doBind</span><span class=\"params\">(<span class=\"keyword\">final</span> SocketAddress localAddress)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">ChannelFuture</span> <span class=\"variable\">regFuture</span> <span class=\"operator\">=</span> initAndRegister();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> regFuture.channel();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (regFuture.cause() != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> regFuture;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (regFuture.isDone()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// At this point we know that the registration was complete and successful.</span></span><br><span class=\"line\">        <span class=\"type\">ChannelPromise</span> <span class=\"variable\">promise</span> <span class=\"operator\">=</span> channel.newPromise();</span><br><span class=\"line\">        <span class=\"comment\">//============================================</span></span><br><span class=\"line\">        <span class=\"comment\">//说明:执行doBind0方法，完成对端口的绑定</span></span><br><span class=\"line\">        <span class=\"comment\">//============================================</span></span><br><span class=\"line\">        doBind0(regFuture, channel, localAddress, promise);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> promise;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Registration future is almost always fulfilled already, but just in case it&#x27;s not.</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">PendingRegistrationPromise</span> <span class=\"variable\">promise</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PendingRegistrationPromise</span>(channel);</span><br><span class=\"line\">        regFuture.addListener(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelFutureListener</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">operationComplete</span><span class=\"params\">(ChannelFuture future)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                <span class=\"type\">Throwable</span> <span class=\"variable\">cause</span> <span class=\"operator\">=</span> future.cause();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cause != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span></span><br><span class=\"line\">                    <span class=\"comment\">// IllegalStateException once we try to access the EventLoop of the Channel.</span></span><br><span class=\"line\">                    promise.setFailure(cause);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Registration was successful, so set the correct executor to use.</span></span><br><span class=\"line\">                    <span class=\"comment\">// See https://github.com/netty/netty/issues/2586</span></span><br><span class=\"line\">                    promise.registered();</span><br><span class=\"line\"></span><br><span class=\"line\">                    doBind0(regFuture, channel, localAddress, promise);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> promise;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>4.4 分析说明 <code>initAndRegister</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> ChannelFuture <span class=\"title function_\">initAndRegister</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        channel = channelFactory.newChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 说明：channelFactory.newChannel() 方法的作用通过 ServerBootstrap 的通道工厂反射创建一个 NioServerSocketChannel,具体追踪源码可以得到下面结论</span></span><br><span class=\"line\"><span class=\"comment\">         * (1)通过 NIO 的 SelectorProvider 的 openServerSocketChannel 方法得到 JDK 的 channel。目的是让 Netty 包装 JDK 的 channel。</span></span><br><span class=\"line\"><span class=\"comment\">         * (2)创建了一个唯一的 ChannelId，创建了一个 NioMessageUnsafe，用于操作消息，创建了一个 DefaultChannelPipeline 管道，是个双向链表结构，用于过滤所有的进出的消息。</span></span><br><span class=\"line\"><span class=\"comment\">         * (3)创建了一个 NioServerSocketChannelConfig 对象，用于对外展示一些配置。 </span></span><br><span class=\"line\"><span class=\"comment\">         </span></span><br><span class=\"line\"><span class=\"comment\">         * channel = channelFactory.newChannel();//NioServerSocketChannel</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">         * 说明：init 初始化这个 NioServerSocketChannel，具体追踪源码可以得到如下结论</span></span><br><span class=\"line\"><span class=\"comment\">         * (1) init 方法，这是个抽象方法 (AbstractBootstrap类的），由ServerBootstrap实现（可以追一下源码//setChannelOptions(channel,options,logger);）。</span></span><br><span class=\"line\"><span class=\"comment\">         * (2)设置 NioServerSocketChannel 的 TCP 属性。</span></span><br><span class=\"line\"><span class=\"comment\">         * (3)由于 LinkedHashMap 是非线程安全的，使用同步进行处理。</span></span><br><span class=\"line\"><span class=\"comment\">         * (4)对 NioServerSocketChannel 的 ChannelPipeline 添加 ChannelInitializer 处理器。</span></span><br><span class=\"line\"><span class=\"comment\">         * (5)可以看出，init 的方法的核心作用在和 ChannelPipeline 相关。</span></span><br><span class=\"line\"><span class=\"comment\">         * (6)从 NioServerSocketChannel 的初始化过程中，我们知道，pipeline 是一个双向链表，并且，他本身就初始化了 head 和 tail，这里调用了他的 addLast 方法，也就是将整个 handler 插入到 tail 的前面，因为 tail 永远会在后面，需要做一些系统的固定工作。</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        init(channel);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (channel != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            channel.unsafe().closeForcibly();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultChannelPromise</span>(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultChannelPromise</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">FailedChannel</span>(), GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">ChannelFuture</span> <span class=\"variable\">regFuture</span> <span class=\"operator\">=</span> config().group().register(channel);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (regFuture.cause() != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (channel.isRegistered()) &#123;</span><br><span class=\"line\">            channel.close();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            channel.unsafe().closeForcibly();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> regFuture;</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>说明：</p>\n<ol>\n<li>基本说明：<code>initAndRegister()</code> 初始化 <code>NioServerSocketChannel</code> 通道并注册各个 <code>handler</code>，返回一个 <code>future</code>。</li>\n<li>通过 <code>ServerBootstrap</code> 的通道工厂反射创建一个 <code>NioServerSocketChannel</code>。</li>\n<li><code>init</code> 初始化这个 <code>NioServerSocketChannel</code>。</li>\n<li><code>config().group().register(channel)</code> 通过 <code>ServerBootstrap</code> 的 <code>bossGroup</code> 注册 <code>NioServerSocketChannel</code>。</li>\n<li>最后，返回这个异步执行的占位符即 <code>regFuture</code>。</li>\n</ol>\n<p>4.5 <code>init</code> 方法会调用 <code>addLast</code>，现在进入到 <code>addLast</code> 方法内查看</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ChannelPipeline <span class=\"title function_\">addLast</span><span class=\"params\">(EventExecutorGroup group, String name, ChannelHandler handler)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"built_in\">this</span>) &#123;</span><br><span class=\"line\">        checkMultiplicity(handler);</span><br><span class=\"line\">        newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class=\"line\">        addLast0(newCtx);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!registered) &#123;</span><br><span class=\"line\">            newCtx.setAddPending();</span><br><span class=\"line\">            callHandlerCallbackLater(newCtx, <span class=\"literal\">true</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">EventExecutor</span> <span class=\"variable\">executor</span> <span class=\"operator\">=</span> newCtx.executor();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!executor.inEventLoop()) &#123;</span><br><span class=\"line\">            callHandlerAddedInEventLoop(newCtx, executor);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    callHandlerAdded0(newCtx);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>说明：</p>\n<ol>\n<li><code>addLast</code> 方法，在 <code>DefaultChannelPipeline</code> 类中</li>\n<li><code>addLast</code> 方法这就是 <code>pipeline</code> 方法的核心</li>\n<li>检查该 <code>handler</code> 是否符合标准。</li>\n<li>创建一个 <code>AbstractChannelHandlerContext</code> 对象，这里说一下，<code>ChannelHandlerContext</code> 对象是 <code>ChannelHandler</code> 和 <code>ChannelPipeline</code> 之间的关联，每当有 <code>ChannelHandler</code> 添加到 <code>Pipeline</code> 中时，都会创建 <code>Context</code>。<code>Context</code> 的主要功能是管理他所关联的 <code>Handler</code> 和同一个 <code>Pipeline</code> 中的其他 <code>Handler</code> 之间的交互。</li>\n<li>将 <code>Context</code> 添加到链表中。也就是追加到 <code>tail</code> 节点的前面。</li>\n<li>最后，同步或者异步或者晚点异步的调用 <code>callHandlerAdded0</code> 方法</li>\n</ol>\n<p>4.6 前面说了 <code>dobind</code> 方法有 <code>2</code> 个重要的步骤，<code>initAndRegister</code> 说完，接下来看 <code>doBind0</code> 方法，代码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doBind0</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"keyword\">final</span> ChannelFuture regFuture, <span class=\"keyword\">final</span> Channel channel,</span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"keyword\">final</span> SocketAddress localAddress, <span class=\"keyword\">final</span> ChannelPromise promise)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// This method is invoked before channelRegistered() is triggered.  Give user handlers a chance to set up</span></span><br><span class=\"line\">    <span class=\"comment\">// the pipeline in its channelRegistered() implementation.</span></span><br><span class=\"line\">    channel.eventLoop().execute(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (regFuture.isSuccess()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//bind方法这里下断点，这里下断点，来玩!!</span></span><br><span class=\"line\">                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                promise.setFailure(regFuture.cause());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>说明：</p>\n<ol>\n<li>该方法的参数为 <code>initAndRegister</code> 的 <code>future</code>，<code>NioServerSocketChannel</code>，端口地址，<code>NioServerSocketChannel</code> 的 <code>promise</code></li>\n<li>这里就可以根据前面下的断点，一直 <code>debug</code>：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将调用 LoggingHandler 的 invokeBind 方法,最后会追到</span></span><br><span class=\"line\"><span class=\"comment\">// DefaultChannelPipeline 类的 bind</span></span><br><span class=\"line\"><span class=\"comment\">// 然后进入到 unsafe.bind 方法 debug，注意要追踪到</span></span><br><span class=\"line\"><span class=\"comment\">// unsafe.bind，要 debug 第二圈的时候，才能看到。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">bind</span> <span class=\"params\">(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    unsafe.bind(localAddress,promise);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 继续追踪 AbstractChannel 的 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">bind</span> <span class=\"params\">(<span class=\"keyword\">final</span> SocketAddress localAddress, <span class=\"keyword\">final</span> ChannelPromise promise)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//....</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//!!!! 小红旗可以看到，这里最终的方法就是 doBind 方法，执行成功后，执行通道的 fireChannelActive 方法，告诉所有的 handler，已经成功绑定。</span></span><br><span class=\"line\">        doBind(localAddress);<span class=\"comment\">//</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        safeSetFailure(promise, t);</span><br><span class=\"line\">        closeIfClosed();</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<ol>\n<li>最终 <code>doBind</code> 就会追踪到 <code>NioServerSocketChannel</code> 的 <code>doBind</code>，说明 <code>Netty</code> 底层使用的是 <code>NIO</code></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doBind</span> <span class=\"params\">(SocketAddress localAddress)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (PlatformDependent.javaVersion() &gt;= <span class=\"number\">7</span>) &#123;</span><br><span class=\"line\">        javaChannel().bind(localAddress, config.getBacklog());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        javaChannel().socket().bind(localAddress, config.getBacklog());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<ol>\n<li>回到 <code>bind</code> 方法（<code>alt + v</code>），最后一步：<code>safeSetSuccess(promise)</code>，告诉 <code>promise</code> 任务成功了。其可以执行监听器的方法了。到此整个启动过程已经结束了，ok 了</li>\n<li>继续 <code>atl + v</code> 服务器就回进入到（<code>NioEventLoop</code> 类）一个循环代码，进行监听</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<h4 id=\"Netty-启动过程梳理\">Netty 启动过程梳理</h4>\n<ol>\n<li>创建 <code>2</code> 个 <code>EventLoopGroup</code> 线程池数组。数组默认大小 <code>CPU * 2</code>，方便 <code>chooser</code> 选择线程池时提高性能</li>\n<li><code>BootStrap</code> 将 <code>boss</code> 设置为 <code>group</code> 属性，将 <code>worker</code> 设置为 <code>childer</code> 属性</li>\n<li>通过 <code>bind</code> 方法启动，内部重要方法为 <code>initAndRegister</code> 和 <code>dobind</code> 方法</li>\n<li><code>initAndRegister</code> 方法会反射创建 <code>NioServerSocketChannel</code> 及其相关的 <code>NIO</code> 的对象，<code>pipeline</code>，<code>unsafe</code>，同时也为 <code>pipeline</code> 初始了 <code>head</code> 节点和 <code>tail</code> 节点。</li>\n<li>在 <code>register0</code> 方法成功以后调用在 <code>dobind</code> 方法中调用 <code>doBind0</code> 方法，该方法会调用 <code>NioServerSocketChannel</code> 的 <code>doBind</code> 方法对 <code>JDK</code> 的 <code>channel</code> 和端口进行绑定，完成 <code>Netty</code> 服务器的所有启动，并开始监听连接事件。</li>\n</ol>\n<h3 id=\"Netty-接受请求过程源码剖析\">Netty 接受请求过程源码剖析</h3>\n<h4 id=\"源码剖析目的-2\">源码剖析目的</h4>\n<ol>\n<li>服务器启动后肯定是要接受客户端请求并返回客户端想要的信息的，下面源码分析 <code>Netty</code> 在启动之后是如何接受客户端请求的</li>\n<li>在 <code>io.netty.example</code> 包下</li>\n</ol>\n<h4 id=\"源码剖析-2\">源码剖析</h4>\n<p>说明：</p>\n<ol>\n<li>从之前服务器启动的源码中，我们得知，服务器最终注册了一个 <code>Accept</code> 事件等待客户端的连接。我们也知道，<code>NioServerSocketChannel</code> 将自己注册到了 <code>boss</code> 单例线程池（<code>reactor</code> 线程）上，也就是 <code>EventLoop</code>。</li>\n<li>先简单说下 <code>EventLoop</code> 的逻辑(后面我们详细讲解 <code>EventLoop</code>)</li>\n</ol>\n<p><code>EventLoop</code> 的作用是一个死循环，而这个循环中做 3 件事情：</p>\n<ol>\n<li>\n<p>有条件的等待 <code>NIO</code> 事件。</p>\n</li>\n<li>\n<p>处理 <code>NIO</code> 事件。</p>\n</li>\n<li>\n<p>处理消息队列中的任务。</p>\n</li>\n<li>\n<p>仍用前面的项目来分析：进入到 <code>NioEventLoop</code> 源码中后，在 <code>private void processSelectedKey(SelectionKey k, AbstractNioChannel ch)</code> 方法开始调试最终我们要分析到 <code>AbstractNioChannel</code> 的 <code>doBeginRead</code> 方法，当到这个方法时，针对于这个客户端的连接就完成了，接下来就可以监听读事件了</p>\n<p>源码分析过程</p>\n</li>\n<li>\n<p>断点位置 <code>NioEventLoop</code> 的如下方法 <code>processSelectedKey</code></p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class=\"number\">0</span> || readyOps == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    unsafe.read();<span class=\"comment\">//断点位置</span></span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<ol>\n<li>执行浏览器 <code>http://localhost:8007/</code> ，客户端发出请求</li>\n<li>从的断点我们可以看到，<code>readyOps</code> 是 <code>16</code>，也就是 <code>Accept</code> 事件。说明浏览器的请求已经进来了。</li>\n<li>这个 <code>unsafe</code> 是 <code>boss</code> 线程中 <code>NioServerSocketChannel</code> 的 <code>AbstractNioMessageChannel$NioMessageUnsafe</code> 对象。我们进入到 <code>AbstractNioMessageChannel$NioMessageUnsafe</code> 的 <code>read</code> 方法中</li>\n<li><code>read</code> 方法代码并分析:</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">read</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    asserteventLoop().inEventLoop();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">ChannelConfig</span> <span class=\"variable\">config</span> <span class=\"operator\">=</span> config();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">ChannelPipeline</span> <span class=\"variable\">pipeline</span> <span class=\"operator\">=</span> pipeline();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> RecvByteBufAllocator.<span class=\"type\">Handle</span> <span class=\"variable\">allocHandle</span> <span class=\"operator\">=</span> unsafe().recvBufAllocHandle();</span><br><span class=\"line\">    allocHandle.reset(config);</span><br><span class=\"line\">    booleanclosed = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"type\">Throwable</span> <span class=\"variable\">exception</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">localRead</span> <span class=\"operator\">=</span> doReadMessages(readBuf);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (localRead == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (localRead &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    closed = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">                allocHandle.incMessagesRead(localRead);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> (allocHandle.continueReading());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">            exception = t;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> readBuf.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">            readPending = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            pipeline.fireChannelRead(readBuf.get(i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        readBuf.clear();</span><br><span class=\"line\">        allocHandle.readComplete();</span><br><span class=\"line\">        pipeline.fireChannelReadComplete();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (exception != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            closed = closeOnReadError(exception);</span><br><span class=\"line\"></span><br><span class=\"line\">            pipeline.fireExceptionCaught(exception);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (closed) &#123;</span><br><span class=\"line\">            inputShutdown = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(isOpen()) &#123;</span><br><span class=\"line\">                close(voidPromise());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//Check if there is a readPending which was not processed yet.</span></span><br><span class=\"line\">        <span class=\"comment\">//This could be for two reasons:</span></span><br><span class=\"line\">        <span class=\"comment\">//* The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method</span></span><br><span class=\"line\">        <span class=\"comment\">//* The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method</span></span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        <span class=\"comment\">// See https://github.com/netty/netty/issues/2254</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class=\"line\">            removeReadOp();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>说明： 1)检查该 <code>eventloop</code> 线程是否是当前线程。<code>asserteventLoop().inEventLoop()</code></p>\n<p>2)执行 <code>doReadMessages</code> 方法，并传入一个 <code>readBuf</code> 变量，这个变量是一个 <code>List</code>，也就是容器。</p>\n<p>3)循环容器，执行 <code>pipeline.fireChannelRead(readBuf.get(i));</code></p>\n<p>4)<code>doReadMessages</code> 是读取 <code>boss</code> 线程中的 <code>NioServerSocketChannel</code> 接受到的请求。并把这些请求放进容器，一会我们 <code>debug</code> 下 <code>doReadMessages</code> 方法。</p>\n<p>5)循环遍历容器中的所有请求，调用 <code>pipeline</code> 的 <code>fireChannelRead</code> 方法，用于处理这些接受的请求或者其他事件，在 <code>read</code> 方法中，循环调用 <code>ServerSocket</code> 的 <code>pipeline</code> 的 <code>fireChannelRead</code> 方法,开始执行管道中的 <code>handler</code> 的 <code>ChannelRead</code> 方法（<code>debug</code> 进入）</p>\n<ol>\n<li>追踪一下 <code>doReadMessages</code> 方法，就可以看得更清晰</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"type\">int</span> <span class=\"title function_\">doReadMessages</span> <span class=\"params\">(List&lt;Object&gt; buf)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"type\">SocketChannel</span> <span class=\"variable\">ch</span> <span class=\"operator\">=</span> SocketUtils.accept(javaChannel());</span><br><span class=\"line\">    buf.add(newNioSocketChannel(<span class=\"built_in\">this</span>, ch));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>说明： 1)通过工具类，调用 <code>NioServerSocketChannel</code> 内部封装的 <code>serverSocketChannel</code> 的 <code>accept</code> 方法，这是 <code>NIO</code> 做法。</p>\n<p>2)获取到一个 <code>JDK</code> 的 <code>SocketChannel</code>，然后，使用 <code>NioSocketChannel</code> 进行封装。最后添加到容器中</p>\n<p>3)这样容器 <code>buf</code> 中就有了 <code>NioSocketChannel</code> 【如果有兴趣可以追一下 <code>NioSocketChannel</code> 是如何创建的，我就不追了】</p>\n<ol>\n<li>回到 <code>read</code> 方法，继续分析循环执行 <code>pipeline.fireChannelRead</code> 方法</li>\n</ol>\n<p>1)前面分析 <code>doReadMessages</code> 方法的作用是通过 <code>ServerSocket</code> 的 <code>accept</code> 方法获取到 <code>TCP</code> 连接，然后封装成 <code>Netty</code> 的 <code>NioSocketChannel</code> 对象。最后添加到容器中</p>\n<p>2)在 <code>read</code> 方法中，循环调用 <code>ServerSocket</code> 的 <code>pipeline</code> 的 <code>fireChannelRead</code> 方法,开始执行管道中的 <code>handler</code> 的 <code>ChannelRead</code> 方法（<code>debug</code> 进入）</p>\n<p>3)经过 <code>dubug</code>（多次），可以看到会反复执行多个 <code>handler</code> 的 <code>ChannelRead</code>，我们知道，<code>pipeline</code> 里面又 <code>4</code> 个 <code>handler</code>，分别是 <code>Head</code>，<code>LoggingHandler</code>，<code>ServerBootstrapAcceptor</code>，<code>Tail</code>。</p>\n<p>4)我们重点看看 <code>ServerBootstrapAcceptor</code>。<code>debug</code> 之后，断点会进入到 <code>ServerBootstrapAcceptor</code> 中来。我们来看看 <code>ServerBootstrapAcceptor</code> 的 <code>channelRead</code> 方法（要多次 <code>debug</code> 才可以）</p>\n<p>5)<code>channelRead</code> 方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead</span> <span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">final</span> <span class=\"variable\">Channelchild</span> <span class=\"operator\">=</span> (Channel)msg;</span><br><span class=\"line\">    child.pipeline().addLast(childHandler);</span><br><span class=\"line\">    setChannelOptions(child, childOptions, logger);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e : childAttrs) &#123;</span><br><span class=\"line\">        child.attr((AttributeKey&lt;Object&gt;)e.getKey()).set(e.getValue());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;<span class=\"comment\">//将客户端连接注册到 worker 线程池</span></span><br><span class=\"line\">        childGroup.register(child).addListener(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelFutureListener</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">operationComplete</span><span class=\"params\">(ChannelFuturefuture)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!future.isSuccess()) &#123;</span><br><span class=\"line\">                    forceClose(child, future.cause());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        forceClose(child, t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>说明： 1)<code>msg</code> 强转成 <code>Channel</code>，实际上就是 <code>NioSocketChannel</code>。</p>\n<p>2)添加 <code>NioSocketChannel</code> 的 <code>pipeline</code> 的 <code>handler</code>，就是我们 <code>main</code> 方法里面设置的 <code>childHandler</code> 方法里的。</p>\n<p>3)设置 <code>NioSocketChannel</code> 的各种属性。</p>\n<p>4)将该 <code>NioSocketChannel</code> 注册到 <code>childGroup</code> 中的一个 <code>EventLoop</code> 上，并添加一个监听器。</p>\n<p>5)这个 <code>childGroup</code> 就是我们 <code>main</code> 方法创建的数组 <code>workerGroup</code>。</p>\n<ol>\n<li>进入 <code>register</code> 方法查看(步步追踪会到)</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">register</span> <span class=\"params\">(EventLoop eventLoop, <span class=\"keyword\">final</span> ChannelPromise promise)</span> &#123;</span><br><span class=\"line\">    AbstractChannel.<span class=\"built_in\">this</span>.eventLoop = eventLoop;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class=\"line\">        register0(promise);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        eventLoop.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>()&#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                register0(promise);<span class=\"comment\">//进入到这里</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 继续进入到下面方法，执行管道中可能存在的任务,这里我们就不追了Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>最终会调用 <code>doBeginRead</code> 方法，也就是 <code>AbstractNioChannel</code> 类的方法</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doBeginRead</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"comment\">//Channel.read() or ChannelHandlerContext.read() was called</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">SelectionKey</span> <span class=\"variable\">selectionKey</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.selectionKey;<span class=\"comment\">//断点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!selectionKey.isValid()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    readPending = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">interestOps</span> <span class=\"operator\">=</span> selectionKey.interestOps();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((interestOps&amp;readInterestOp) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<ol>\n<li>这个地方调试时，请把前面的断点都去掉，然后启动服务器就会停止在 <code>doBeginRead</code>（需要先放过该断点，然后浏览器请求，才能看到效果）</li>\n<li>执行到这里时，针对于这个客户端的连接就完成了，接下来就可以监听读事件了</li>\n</ol>\n<h4 id=\"Netty-接受请求过程梳理\">Netty 接受请求过程梳理</h4>\n<p>总体流程：接受连接 --&gt; 创建一个新的 <code>NioSocketChannel</code> --&gt; 注册到一个 <code>workerEventLoop</code> 上 --&gt; 注册 <code>selecotRead</code> 事件。</p>\n<ol>\n<li>服务器轮询 <code>Accept</code> 事件，获取事件后调用 <code>unsafe</code> 的 <code>read</code> 方法，这个 <code>unsafe</code> 是 <code>ServerSocket</code> 的内部类，该方法内部由 <code>2</code> 部分组成</li>\n<li><code>doReadMessages</code> 用于创建 <code>NioSocketChannel</code> 对象，该对象包装 <code>JDK</code> 的 <code>NioChannel</code> 客户端。该方法会像创建 <code>ServerSocketChanel</code> 类似创建相关的 <code>pipeline</code>，<code>unsafe</code>，<code>config</code></li>\n<li>随后执行执行 <code>pipeline.fireChannelRead</code> 方法，并将自己绑定到一个 <code>chooser</code> 选择器选择的 <code>workerGroup</code> 中的一个 <code>EventLoop</code>。并且注册一个 <code>0</code>，表示注册成功，但并没有注册读（1）事件</li>\n</ol>\n<h3 id=\"Pipeline-Handler-HandlerContext-创建源码剖析\">Pipeline Handler HandlerContext 创建源码剖析</h3>\n<h4 id=\"源码剖析目的-3\">源码剖析目的</h4>\n<p><code>Netty</code> 中的 <code>ChannelPipeline</code>、<code>ChannelHandler</code> 和 <code>ChannelHandlerContext</code> 是非常核心的组件，我们从源码来分析 <code>Netty</code> 是如何设计这三个核心组件的，并分析是如何创建和协调工作的.</p>\n<h4 id=\"源码剖析说明\">源码剖析说明)</h4>\n<p>说明 分析过程中，有很多的图形，所以我们准备了一个文档，在文档的基础上来做源码剖析</p>\n<h4 id=\"源码剖析-3\">源码剖析</h4>\n<ol>\n<li>ChannelPipeline | ChannelHandler | ChannelHandlerContext介绍</li>\n<li>1 三者关系</li>\n</ol>\n<p>1)每当 <code>ServerSocket</code> 创建一个新的连接，就会创建一个 <code>Socket</code>，对应的就是目标客户端。</p>\n<p>2)每一个新创建的 <code>Socket</code> 都将会分配一个全新的 <code>ChannelPipeline</code>（以下简称 <code>pipeline</code>）</p>\n<p>3)每一个 <code>ChannelPipeline</code> 内部都含有多个 <code>ChannelHandlerContext</code>（以下简称 <code>Context</code>）</p>\n<p>4)他们一起组成了双向链表，这些 <code>Context</code> 用于包装我们调用 <code>addLast</code> 方法时添加的 <code>ChannelHandler</code>（以下简称 <code>handler</code>）</p>\n<p><img src=\"https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_02.png\" alt></p>\n<p>1)上图中：<code>ChannelSocket</code> 和 <code>ChannelPipeline</code> 是一对一的关联关系，而 <code>pipeline</code> 内部的多个 <code>Context</code> 形成了链表，<code>Context</code> 只是对 <code>Handler</code> 的封装。 2)当一个请求进来的时候，会进入 <code>Socket</code> 对应的 <code>pipeline</code>，并经过 <code>pipeline</code> 所有的 <code>handler</code>，对，就是设计模式中的过滤器模式。</p>\n<p>1.2 ChannelPipeline 作用及设计</p>\n<p>1)<code>pipeline</code> 的接口设计</p>\n<p><img src=\"https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_03.png\" alt></p>\n<p>部分源码</p>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306132233060.png\" alt></p>\n<p>可以看到该接口继承了 <code>inBound</code>，<code>outBound</code>，<code>Iterable</code> 接口，表示他可以调用数据出站的方法和入站的方法，同时也能遍历内部的链表，看看他的几个代表性的方法，基本上都是针对 <code>handler</code> 链表的插入，追加，删除，替换操作，类似是一个 <code>LinkedList</code>。同时，也能返回 <code>channel</code>（也就是 <code>socket</code>）</p>\n<p>1)在 <code>pipeline</code> 的接口文档上，提供了一幅图</p>\n<p><img src=\"https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_05.png\" alt></p>\n<p>对上图的解释说明： *这是一个 <code>handler</code> 的 <code>list</code>，<code>handler</code> 用于处理或拦截入站事件和出站事件，<code>pipeline</code> 实现了过滤器的高级形式，以便用户控制事件如何处理以及 <code>handler</code> 在 <code>pipeline</code> 中如何交互。</p>\n<p>*上图描述了一个典型的 <code>handler</code> 在 <code>pipeline</code> 中处理 <code>I/O</code> 事件的方式，<code>IO</code> 事件由 <code>inboundHandler</code> 或者 <code>outBoundHandler</code> 处理，并通过调用 <code>ChannelHandlerContext.fireChannelRead</code> 方法转发给其最近的处理程序。</p>\n<p>*入站事件由入站处理程序以自下而上的方向处理，如图所示。入站处理程序通常处理由图底部的 <code>I/O</code> 线程生成入站数据。入站数据通常从如 <code>SocketChannel.read(ByteBuffer)</code> 获取。</p>\n<p>*通常一个 <code>pipeline</code> 有多个 <code>handler</code>，例如，一个典型的服务器在每个通道的管道中都会有以下处理程序协议解码器-将二进制数据转换为 <code>Java</code> 对象。协议编码器-将 <code>Java</code> 对象转换为二进制数据。业务逻辑处理程序-执行实际业务逻辑（例如数据库访问）</p>\n<p>*你的业务程序不能将线程阻塞，会影响 <code>IO</code> 的速度，进而影响整个 <code>Netty</code> 程序的性能。如果你的业务程序很快，就可以放在 <code>IO</code> 线程中，反之，你需要异步执行。或者在添加 <code>handler</code> 的时候添加一个线程池，例如：</p>\n<p>// 下面这个任务执行的时候，将不会阻塞 <code>IO</code> 线程，执行的线程来自 <code>group</code> 线程池</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pipeline.addLast(group, &quot;handler&quot;, new MyBusinessLogicHandler());</span><br></pre></td></tr></table></figure>\n<p>1.3 <code>ChannelHandler</code> 作用及设计</p>\n<p>1)源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ChannelHandler</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//当把 ChannelHandler 添加到 pipeline 时被调用</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">handlerAdded</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception;</span><br><span class=\"line\">    <span class=\"comment\">//当从 pipeline 中移除时调用</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">handlerRemoved</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception;</span><br><span class=\"line\">    <span class=\"comment\">//当处理过程中在 pipeline 发生异常时调用</span></span><br><span class=\"line\">    <span class=\"meta\">@Deprecated</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">exceptionCaught</span><span class=\"params\">(ChannelHandlerContext ctx, Throwable cause)</span> <span class=\"keyword\">throws</span> Exception;</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>2)<code>ChannelHandler</code> 的作用就是处理 <code>IO</code> 事件或拦截 <code>IO</code> 事件，并将其转发给下一个处理程序 <code>ChannelHandler</code>。<code>Handler</code> 处理事件时分入站和出站的，两个方向的操作都是不同的，因此，<code>Netty</code> 定义了两个子接口继承 <code>ChannelHandler</code></p>\n<p>2)<code>ChannelInboundHandler</code> 入站事件接口</p>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306132233156.png\" alt></p>\n<p>*<code>channelActive</code> 用于当 <code>Channel</code> 处于活动状态时被调用；</p>\n<p>*<code>channelRead</code> 当从 <code>Channel</code> 读取数据时被调用等等方法。</p>\n<p>*程序员需要重写一些方法，当发生关注的事件，需要在方法中实现我们的业务逻辑，因为当事件发生时，<code>Netty</code> 会回调对应的方法。</p>\n<p>3)`ChannelOutboundHandler 出站事件接口</p>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306132233621.png\" alt></p>\n<p>*<code>bind</code> 方法，当请求将 <code>Channel</code> 绑定到本地地址时调用</p>\n<p>*<code>close</code> 方法，当请求关闭 <code>Channel</code> 时调用等等</p>\n<p>*出站操作都是一些连接和写出数据类似的方法。</p>\n<p>4)<code>ChannelDuplexHandler</code> 处理出站和入站事件</p>\n<p><img src=\"https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_08.png\" alt></p>\n<p>*<code>ChannelDuplexHandler</code> 间接实现了入站接口并直接实现了出站接口。</p>\n<p>*是一个通用的能够同时处理入站事件和出站事件的类。</p>\n<p>1.4 <code>ChannelHandlerContext</code> 作用及设计</p>\n<p>1)<code>ChannelHandlerContext</code> <code>UML</code> 图</p>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306132233721.png\" alt></p>\n<p><code>ChannelHandlerContext</code> 继承了出站方法调用接口和入站方法调用接口</p>\n<p>1)<code>ChannelOutboundInvoker</code> 和 <code>ChannelInboundInvoker</code> 部分源码</p>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306132233114.png\" alt></p>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306132234644.png\" alt></p>\n<p>*这两个 <code>invoker</code> 就是针对入站或出站方法来的，就是在入站或出站 <code>handler</code> 的外层再包装一层，达到在方法前后拦截并做一些特定操作的目的</p>\n<p>2)<code>ChannelHandlerContext</code> 部分源码</p>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306132234217.png\" alt></p>\n<p>*<code>ChannelHandlerContext</code> 不仅仅时继承了他们两个的方法，同时也定义了一些自己的方法</p>\n<p>*这些方法能够获取 <code>Context</code> 上下文环境中对应的比如 <code>channel</code>，<code>executor</code>，<code>handler</code>，<code>pipeline</code>，内存分配器，关联的 <code>handler</code> 是否被删除。</p>\n<p>*<code>Context</code> 就是包装了 <code>handler</code> 相关的一切，以方便 <code>Context</code> 可以在 <code>pipeline</code> 方便的操作 <code>handler</code></p>\n<p>2.ChannelPipeline | ChannelHandler | ChannelHandlerContext</p>\n<p>创建过程分为 <code>3</code> 个步骤来看创建的过程：</p>\n<p>*任何一个 <code>ChannelSocket</code> 创建的同时都会创建一个 <code>pipeline</code>。</p>\n<p>*当用户或系统内部调用 <code>pipeline</code> 的 <code>add</code></p>\n<p>*** 方法添加 <code>handler</code> 时，都会创建一个包装这 <code>handler</code> 的 <code>Context</code>。</p>\n<p>*这些 <code>Context</code> 在 <code>pipeline</code> 中组成了双向链表。</p>\n<p>2.1 <code>Socket</code> 创建的时候创建 <code>pipeline</code> 在 <code>SocketChannel</code> 的抽象父类 <code>AbstractChannel</code> 的构造方法中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"title function_\">AbstractChannel</span><span class=\"params\">(Channel parent)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.parent=parent;<span class=\"comment\">//断点测试</span></span><br><span class=\"line\">    id = newId();</span><br><span class=\"line\">    unsafe = <span class=\"keyword\">new</span> <span class=\"title class_\">Unsafe</span>();</span><br><span class=\"line\">    pipeline = <span class=\"keyword\">new</span> <span class=\"title class_\">ChannelPipeline</span>();</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p><code>Debug</code> 一下，可以看到代码会执行到这里，然后继续追踪到</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"title function_\">DefaultChannelPipeline</span><span class=\"params\">(Channel channel)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class=\"string\">&quot;channel&quot;</span>);</span><br><span class=\"line\">    succeededFuture = <span class=\"keyword\">new</span> <span class=\"title class_\">SucceededChannelFuture</span>(channel, <span class=\"literal\">null</span>);</span><br><span class=\"line\">    voidPromise = <span class=\"keyword\">new</span> <span class=\"title class_\">VoidChannelPromise</span>(channel, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    tail = <span class=\"keyword\">new</span> <span class=\"title class_\">TailContext</span>(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    head = <span class=\"keyword\">new</span> <span class=\"title class_\">HeadContext</span>(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    head.next = tail;</span><br><span class=\"line\">    tail.prev = head;</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>说明：</p>\n<p>1）将 <code>channel</code> 赋值给 <code>channel</code> 字段，用于 <code>pipeline</code> 操作 <code>channel</code>。</p>\n<p>2）创建一个 <code>future</code> 和 <code>promise</code>，用于异步回调使用。</p>\n<p>3）创建一个 <code>inbound</code> 的 <code>tailContext</code>，创建一个既是 <code>inbound</code> 类型又是 <code>outbound</code> 类型的 <code>headContext</code>。</p>\n<p>4）最后，将两个 <code>Context</code> 互相连接，形成双向链表。</p>\n<p>5）<code>tailContext</code> 和 <code>HeadContext</code> 非常的重要，所有 <code>pipeline</code> 中的事件都会流经他们，</p>\n<p>2.2 在 add<strong>添加处理器的时候创建Context</strong>看下 <code>DefaultChannelPipeline</code> 的 <code>addLast</code> 方法如何创建的 <code>Context</code>，代码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ChannelPipeline <span class=\"title function_\">addLast</span><span class=\"params\">(EventExecutorGroup executor, ChannelHandler... handlers)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (handlers == <span class=\"literal\">null</span>) &#123;<span class=\"comment\">//断点</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NullPointerException</span>(<span class=\"string\">&quot;handlers&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ChannelHandler h : handlers) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        addLast(executor, <span class=\"literal\">null</span>, h);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>继续 Debug</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ChannelPipeline <span class=\"title function_\">addLast</span><span class=\"params\">(EventExecutorGroup group, String name, ChannelHandler handler)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(<span class=\"built_in\">this</span>) &#123;</span><br><span class=\"line\">        checkMultiplicity(handler);</span><br><span class=\"line\"></span><br><span class=\"line\">        newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class=\"line\">        addLast0(newCtx);</span><br><span class=\"line\">        <span class=\"comment\">//If the registered is false it means that the channel was not registered on an eventloop yet.</span></span><br><span class=\"line\">        <span class=\"comment\">//In this case we add the context to the pipeline and add a task that will call</span></span><br><span class=\"line\">        <span class=\"comment\">//ChannelHandler.handlerAdded(...) once the channel is registered.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!registered) &#123;</span><br><span class=\"line\">            newCtx.setAddPending();</span><br><span class=\"line\">            callHandlerCallbackLater(newCtx, <span class=\"literal\">true</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">EventExecutor</span> <span class=\"variable\">executor</span> <span class=\"operator\">=</span> newCtx.executor();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!executor.inEventLoop()) &#123;</span><br><span class=\"line\">            newCtx.setAddPending();</span><br><span class=\"line\">            executor.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span> <span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                    callHandlerAdded0(newCtx);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    callHandlerAdded0(newCtx);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>说明 1)<code>pipeline</code> 添加 <code>handler</code>，参数是线程池，<code>name</code> 是 <code>null</code>，<code>handler</code> 是我们或者系统传入的 <code>handler</code>。<code>Netty</code> 为了防止多个线程导致安全问题，同步了这段代码，步骤如下：</p>\n<p>2)检查这个 <code>handler</code> 实例是否是共享的，如果不是，并且已经被别的 <code>pipeline</code> 使用了，则抛出异常。</p>\n<p>3)调用 <code>new Context(group, filterName(name, handler), handler)</code> 方法，创建一个 <code>Context</code>。从这里可以看出来了，每次添加一个 <code>handler</code> 都会创建一个关联 <code>Context</code>。</p>\n<p>4)调用 <code>addLast</code> 方法，将 <code>Context</code> 追加到链表中。</p>\n<p>5)如果这个通道还没有注册到 <code>selecor</code> 上，就将这个 <code>Context</code> 添加到这个 <code>pipeline</code> 的待办任务中。当注册好了以后，就会调用 <code>callHandlerAdded0</code> 方法（默认是什么都不做，用户可以实现这个方法）。</p>\n<p>6)到这里，针对三对象创建过程，了解的差不多了，和最初说的一样，每当创建 <code>ChannelSocket</code> 的时候都会创建一个绑定的 <code>pipeline</code>，一对一的关系，创建 <code>pipeline</code> 的时候也会创建 <code>tail</code> 节点和 <code>head</code> 节点，形成最初的链表。<code>tail</code> 是入站 <code>inbound</code> 类型的 <code>handler</code>，<code>head</code> 既是 <code>inbound</code> 也是 <code>outbound</code> 类型的 <code>handler</code>。在调用 <code>pipeline</code> 的 <code>addLast</code> 方法的时候，会根据给定的 <code>handler</code> 创建一个 <code>Context</code>，然后，将这个 <code>Context</code> 插入到链表的尾端（<code>tail</code> 前面）。到此就 <code>OK</code> 了。</p>\n<h4 id=\"创建过程梳理\">创建过程梳理</h4>\n<ol>\n<li>每当创建 <code>ChannelSocket</code> 的时候都会创建一个绑定的 <code>pipeline</code>，一对一的关系，创建 <code>pipeline</code> 的时候也会创建 <code>tail</code> 节点和 <code>head</code> 节点，形成最初的链表。</li>\n<li>在调用 <code>pipeline</code> 的 <code>addLast</code> 方法的时候，会根据给定的 <code>handler</code> 创建一个 <code>Context</code>，然后，将这个 <code>Context</code> 插入到链表的尾端（<code>tail</code> 前面）。</li>\n<li><code>Context</code> 包装 <code>handler</code>，多个 <code>Context</code> 在 <code>pipeline</code> 中形成了双向链表</li>\n<li>入站方向叫 <code>inbound</code>，由 <code>head</code> 节点开始，出站方法叫 <code>outbound</code>，由 <code>tail</code> 节点开始</li>\n</ol>\n<h3 id=\"ChannelPipeline-调度-handler-的源码剖析\">ChannelPipeline 调度 handler 的源码剖析</h3>\n<h4 id=\"源码剖析目的-4\">源码剖析目的</h4>\n<ol>\n<li>\n<p>当一个请求进来的时候，<code>ChannelPipeline</code> 是如何调用内部的这些 <code>handler</code> 的呢？我们一起来分析下。</p>\n</li>\n<li>\n<p>首先，当一个请求进来的时候，会第一个调用 <code>pipeline</code> 的相关方法，如果是入站事件，这些方法由 <code>fire</code> 开头，表示开始管道的流动。让后面的 <code>handler</code> 继续处理</p>\n</li>\n</ol>\n<h4 id=\"源码剖析-4\">源码剖析</h4>\n<p>说明</p>\n<p>当浏览器输入 <code>http://localhost:8007</code> 。可以看到会执行 <code>handler</code> 在 <code>Debug</code> 时，可以将断点下在 <code>DefaultChannelPipeline</code> 类的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ChannelPipeline <span class=\"title function_\">fireChannelActive</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    AbstractChannelHandlerContext.invokeChannelActive(head);<span class=\"comment\">//断点</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>源码分析</p>\n<ol>\n<li><code>DefaultChannelPipeline</code> 是如何实现这些 <code>fire</code> 方法的 3.1 <code>DefaultChannelPipeline</code> 源码</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DefaultChannelPipeline</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ChannelPipeline</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ChannelPipeline <span class=\"title function_\">fireChannelActive</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        AbstractChannelHandlerContext.invokeChannelActive(head);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"title function_\">ChannelPipelinefireChannelInactive</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        AbstractChannelHandlerContext.invokeChannelInactive(head);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ChannelPipeline <span class=\"title function_\">fireExceptionCaught</span><span class=\"params\">(Throwable cause)</span> &#123;</span><br><span class=\"line\">        AbstractChannelHandlerContext.invokeExceptionCaught(head, cause);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ChannelPipeline <span class=\"title function_\">fireUserEventTriggered</span><span class=\"params\">(Object event)</span> &#123;</span><br><span class=\"line\">        AbstractChannelHandlerContext.invokeUserEventTriggered(head, event);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ChannelPipeline <span class=\"title function_\">fireChannelRead</span><span class=\"params\">(Objectmsg)</span> &#123;</span><br><span class=\"line\">        AbstractChannelHandlerContext.invokeChannelRead(head, msg);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ChannelPipeline <span class=\"title function_\">fireChannelReadComplete</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        AbstractChannelHandlerContext.invokeChannelReadComplete(head);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ChannelPipeline <span class=\"title function_\">fireChannelWritabilityChanged</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        AbstractChannelHandlerContext.invokeChannelWritabilityChanged(head);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>说明： 可以看出来，这些方法都是 <code>inbound</code> 的方法，也就是入站事件，调用静态方法传入的也是 <code>inbound</code> 的类型 <code>head</code> <code>handler</code>。这些静态方法则会调用 <code>head</code> 的 <code>ChannelInboundInvoker</code> 接口的方法，再然后调用 <code>handler</code> 的真正方法</p>\n<p>3.2再看下 <code>piepline</code> 的 <code>outbound</code> 的 <code>fire</code> 方法实现源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DefaultChannelPipeline</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ChannelPipeline</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ChannelFuture <span class=\"title function_\">bind</span><span class=\"params\">(SocketAddress localAddress)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tail.bind(localAddress);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ChannelFuture <span class=\"title function_\">connect</span><span class=\"params\">(SocketAddress remoteAddress)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tail.connect(remoteAddress);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ChannelFuture <span class=\"title function_\">connect</span><span class=\"params\">(SocketAddress remoteAddress, SocketAddress localAddress)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tail.connect(remoteAddress, localAddress);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ChannelFuture <span class=\"title function_\">disconnect</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tail.disconnect();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ChannelFuture <span class=\"title function_\">close</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tail.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ChannelFuture <span class=\"title function_\">deregister</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tail.deregister();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ChannelPipeline <span class=\"title function_\">flush</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        tail.flush();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ChannelFuture <span class=\"title function_\">bind</span><span class=\"params\">(SocketAddress localAddress, ChannelPromise promise)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tail.bind(localAddress, promise);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ChannelFuture <span class=\"title function_\">connect</span><span class=\"params\">(SocketAddress remoteAddress, ChannelPromise promise)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tail.connect(remoteAddress, promise);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ChannelFuture <span class=\"title function_\">connect</span><span class=\"params\">(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tail.connect(remoteAddress, localAddress, promise);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ChannelFuture <span class=\"title function_\">disconnect</span><span class=\"params\">(ChannelPromise promise)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tail.disconnect(promise);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>说明：</p>\n<p>1)这些都是出站的实现，但是调用的是 <code>outbound</code> 类型的 <code>tailhandler</code> 来进行处理，因为这些都是 <code>outbound</code> 事件。</p>\n<p>2)出站是 <code>tail</code> 开始，入站从 <code>head</code> 开始。因为出站是从内部向外面写，从 <code>tail</code> 开始，能够让前面的 <code>handler</code> 进行处理，防止 <code>handler</code> 被遗漏，比如编码。反之，入站当然是从 <code>head</code> 往内部输入，让后面的 <code>handler</code> 能够处理这些输入的数据。比如解码。因此虽然 <code>head</code> 也实现了 <code>outbound</code> 接口，但不是从 head 开始执行出站任务</p>\n<p>4.关于如何调度，用一张图来表示:</p>\n<p><img src=\"https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_13.png\" alt></p>\n<p>说明： 1)<code>pipeline</code> 首先会调用 <code>Context</code> 的静态方法 <code>fireXXX</code>，并传入 <code>Context</code></p>\n<p>2)然后，静态方法调用 <code>Context</code> 的 <code>invoker</code> 方法，而 <code>invoker</code> 方法内部会调用该 <code>Context</code> 所包含的 <code>Handler</code> 的真正的 <code>XXX</code> 方法，调用结束后，如果还需要继续向后传递，就调用 <code>Context</code> 的 <code>fireXXX2</code> 方法，循环往复。</p>\n<h4 id=\"ChannelPipeline-调度-handler-梳理\">ChannelPipeline 调度 handler 梳理</h4>\n<ol>\n<li><code>Context</code> 包装 <code>handler</code>，多个 <code>Context</code> 在 <code>pipeline</code> 中形成了双向链表，入站方向叫 <code>inbound</code>，由 <code>head</code> 节点开始，出站方法叫 <code>outbound</code>，由 <code>tail</code> 节点开始。</li>\n<li>而节点中间的传递通过 <code>Abstract ChannelHandlerContext</code> 类内部的 <code>fire</code> 系列方法，找到当前节点的下一个节点不断的循环传播。是一个过滤器形式完成对 <code>handler</code> 的调度</li>\n</ol>\n<h3 id=\"Netty-心跳-heartbeat-服务源码剖析\">Netty 心跳(heartbeat)服务源码剖析</h3>\n<h4 id=\"源码剖析目的-5\">源码剖析目的</h4>\n<p><code>Netty</code> 作为一个网络框架，提供了诸多功能，比如编码解码等，<code>Netty</code> 还提供了非常重要的一个服务 – 心跳机制 <code>heartbeat</code>。通过心跳检查对方是否有效，这是 <code>RPC</code> 框架中是必不可少的功能。下面我们分析一下 <code>Netty</code> 内部心跳服务源码实现。</p>\n<h4 id=\"源码剖析-5\">源码剖析</h4>\n<p>说明</p>\n<p><code>Netty</code> 提供了 <code>IdleStateHandler</code>，<code>ReadTimeoutHandler</code>，<code>WriteTimeoutHandler</code> 三个 <code>Handler</code> 检测连接的有效性，重点分析 <code>IdleStateHandler</code>。</p>\n<p>如图</p>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306132234179.png\" alt></p>\n<p>源码剖析：</p>\n<p>5.<code>Netty</code> 提供的心跳介绍</p>\n<p>1)<code>Netty</code> 提供了 <code>IdleStateHandler</code>，<code>ReadTimeoutHandler</code>，<code>WriteTimeoutHandler</code> 三个 <code>Handler</code> 检测连接的有效性。</p>\n<p>2)如图</p>\n<p><img src=\"https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_15.png\" alt></p>\n<p>3)<code>ReadTimeout</code> 事件和 <code>WriteTimeout</code> 事件都会自动关闭连接，而且，属于异常处理，所以，这里只是介绍以下，我们重点看 <code>IdleStateHandler</code>。</p>\n<p>6.<code>IdleStateHandler</code> 分析</p>\n<p>6.1 <code>4</code> 个属性</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> observeOutput; <span class=\"comment\">//是否考虑出站时较慢的情况。默认值是 false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> readerIdleTimeNanos; <span class=\"comment\">//读事件空闲时间，0 则禁用事件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> writerIdleTimeNanos;<span class=\"comment\">//写事件空闲时间，0 则禁用事件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> allIdleTimeNanos;<span class=\"comment\">//读或写空闲时间，0 则禁用事件Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure>\n<p>6.2<code>handlerAdded</code> 方法</p>\n<p>当该 <code>handler</code> 被添加到 <code>pipeline</code> 中时，则调用 <code>initialize</code> 方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initialize</span><span class=\"params\">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//Avoid the case where destroy() is called before scheduling timeouts.</span></span><br><span class=\"line\">    <span class=\"comment\">//See:https://github.com/netty/netty/issues/143</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(state) &#123;</span><br><span class=\"line\">        case1:</span><br><span class=\"line\">        case2:</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    state=<span class=\"number\">1</span>;</span><br><span class=\"line\">    initOutputChanged(ctx);</span><br><span class=\"line\">    </span><br><span class=\"line\">    lastReadTime = lastWriteTime = ticksInNanos();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(readerIdleTimeNanos &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//这里的 schedule 方法会调用 eventLoop 的 schedule 方法，将定时任务添加进队列中</span></span><br><span class=\"line\">        readerIdleTimeout = schedule(ctx, <span class=\"keyword\">new</span> <span class=\"title class_\">ReaderIdleTimeoutTask</span>(ctx), readerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(writerIdleTimeNanos &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        writerIdleTimeout = schedule(ctx, <span class=\"keyword\">new</span> <span class=\"title class_\">WriterIdleTimeoutTask</span>(ctx), writerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(allIdleTimeNanos &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        allIdleTimeout = schedule(ctx, <span class=\"keyword\">new</span> <span class=\"title class_\">AllIdleTimeoutTask</span>(ctx), allIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>只要给定的参数大于 <code>0</code>，就创建一个定时任务，每个事件都创建。同时，将 <code>state</code> 状态设置为 <code>1</code>，防止重复初始化。调用 <code>initOutputChanged</code> 方法，初始化“监控出站数据属性”。</p>\n<p>6.3该类内部的 <code>3</code> 个定时任务类</p>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306132234863.png\" alt></p>\n<p>1)这 <code>3</code> 个定时任务分别对应读，写，读或者写事件。共有一个父类（<code>AbstractIdleTask</code>）。这个父类提供了一个模板方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AbstractIdleTask</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ChannelHandlerContext ctx;</span><br><span class=\"line\">    </span><br><span class=\"line\">    AbstractIdleTask(ChannelHandlerContext ctx) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.ctx = ctx;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!ctx.channel().isOpen()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        run(ctx);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">(ChannelHandlerContext ctx)</span>;</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>说明：当通道关闭了，就不执行任务了。反之，执行子类的 <code>run</code> 方法</p>\n<p>7.读事件的 <code>run</code> 方法（即 <code>ReaderIdleTimeoutTask</code> 的 <code>run</code> 方法）分析</p>\n<p>1)代码及其说明</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">nextDelay</span> <span class=\"operator\">=</span> readerIdleTimeNanos;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!reading) &#123;</span><br><span class=\"line\">        nextDelay -= ticksInNanos() - lastReadTime;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nextDelay &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//Reader is idle-set a new timeout and notify the callback.</span></span><br><span class=\"line\">        <span class=\"comment\">//用于取消任务 promise</span></span><br><span class=\"line\">        readerIdleTimeout = schedule(ctx, <span class=\"built_in\">this</span>, readerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">first</span> <span class=\"operator\">=</span> firstReaderIdleEvent;</span><br><span class=\"line\">        firstReaderIdleEvent = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//再次提交任务</span></span><br><span class=\"line\">            <span class=\"type\">IdleStateEvent</span> <span class=\"variable\">event</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IdleStateEvent</span>(IdleState.READER_IDLE, first);</span><br><span class=\"line\">            <span class=\"comment\">//触发用户 handler use</span></span><br><span class=\"line\">            channelIdle(ctx, event);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">            ctx.fireExceptionCaught(t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//Read occurred before the timeout - set a new timeout with shorter delay.</span></span><br><span class=\"line\">        readerIdleTimeout = schedule(ctx, <span class=\"built_in\">this</span>, nextDelay, TimeUnit.NANOSECONDS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>说明：</p>\n<p>1)得到用户设置的超时时间。</p>\n<p>2)如果读取操作结束了（执行了 <code>channelReadComplete</code> 方法设置），就用当前时间减去给定时间和最后一次读（执操作的时间行了 <code>channelReadComplete</code> 方法设置），如果小于 <code>0</code>，就触发事件。反之，继续放入队列。间隔时间是新的计算时间。</p>\n<p>3)触发的逻辑是：首先将任务再次放到队列，时间是刚开始设置的时间，返回一个 <code>promise</code> 对象，用于做取消操作。然后，设置 <code>first</code> 属性为<code>false</code>，表示，下一次读取不再是第一次了，这个属性在 <code>channelRead</code> 方法会被改成 <code>true</code>。</p>\n<p>4)创建一个 <code>IdleStateEvent</code> 类型的写事件对象，将此对象传递给用户的 <code>UserEventTriggered</code> 方法。完成触发事件的操作。</p>\n<p>5)总的来说，每次读取操作都会记录一个时间，定时任务时间到了，会计算当前时间和最后一次读的时间的间隔，如果间隔超过了设置的时间，就触发 <code>UserEventTriggered</code> 方法。//前面介绍 <code>IdleStateHandler</code> 说过,可以看一下</p>\n<p>8.写事件的 <code>run</code> 方法（即 <code>WriterIdleTimeoutTask</code> 的 <code>run</code> 方法）分析</p>\n<p>1)<code>run</code> 代码和分析</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">lastWriteTime</span> <span class=\"operator\">=</span> IdleStateHandler.<span class=\"built_in\">this</span>.lastWriteTime;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">nextDelay</span> <span class=\"operator\">=</span> writerIdleTimeNanos - (ticksInNanos()-lastWriteTime);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextDelay &lt;=<span class=\"number\">0</span> ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//Writer is idle - set a new timeout and notify the callback.</span></span><br><span class=\"line\">        writerIdleTimeout = schedule(ctx, <span class=\"built_in\">this</span>, writerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">first</span> <span class=\"operator\">=</span> firstWriterIdleEvent;</span><br><span class=\"line\">        firstWriterIdleEvent = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(hasOutputChanged(ctx, first)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"type\">IdleStateEvent</span> <span class=\"variable\">event</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IdleStateEvent</span>(IdleState.WRITER_IDLE, first);</span><br><span class=\"line\">            channelIdle(ctx, event);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">            ctx.fireExceptionCaught(t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//Write occurred before the timeout - set a new timeout with shorter delay.</span></span><br><span class=\"line\">        writerIdleTimeout = schedule(ctx, <span class=\"built_in\">this</span>, nextDelay, TimeUnit.NANOSECONDS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>说明：写任务的 <code>run</code> 代码逻辑基本和读任务的逻辑一样，唯一不同的就是有一个针对出站较慢数据的判断 <code>hasOutputChanged</code></p>\n<p>9.所有事件的 <code>run</code> 方法（即 <code>AllIdleTimeoutTask</code> 的 <code>run</code> 方法）分析</p>\n<p>代码分析</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">nextDelay</span> <span class=\"operator\">=</span> allIdleTimeNanos;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!reading) &#123;</span><br><span class=\"line\">        nextDelay -= ticksInNanos() - Math.max(lastReadTime, lastWriteTime);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nextDelay &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//Both reader and writer are idle - set a new timeout and</span></span><br><span class=\"line\">        <span class=\"comment\">//notify the callback.</span></span><br><span class=\"line\">        allIdleTimeout = schedule(ctx, <span class=\"built_in\">this</span>, allIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">first</span> <span class=\"operator\">=</span> firstAllIdleEvent;</span><br><span class=\"line\">        firstAllIdleEvent = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(hasOutputChanged(ctx, first)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"type\">IdleStateEvent</span> <span class=\"variable\">event</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IdleStateEvent</span>(IdleState.ALL_IDLE, first);</span><br><span class=\"line\">            channelIdle(ctx, event);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span>(Throwable t) &#123;</span><br><span class=\"line\">            ctx.fireExceptionCaught(t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//Either read or write occurred before the timeout - set a new</span></span><br><span class=\"line\">        <span class=\"comment\">//timeout with shorter delay.</span></span><br><span class=\"line\">        allIdleTimeout = schedule(ctx, <span class=\"built_in\">this</span>, nextDelay, TimeUnit.NANOSECONDS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>说明：</p>\n<p>1)表示这个监控着所有的事件。当读写事件发生时，都会记录。代码逻辑和写事件的的基本一致：</p>\n<p>2)需要大家注意的地方是</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">nextDelay</span> <span class=\"operator\">=</span> allIdleTimeNanos;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(!reading) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//当前时间减去最后一次写或读的时间，若大于 0，说明超时了</span></span><br><span class=\"line\">    nextDelay -= ticksInNanos() - Math.max(lastReadTime, lastWriteTime);</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>3)这里的时间计算是取读写事件中的最大值来的。然后像写事件一样，判断是否发生了写的慢的情况。</p>\n<p>10.小结 <code>Netty</code> 的心跳机制</p>\n<p>1)<code>IdleStateHandler</code> 可以实现心跳功能，当服务器和客户端没有任何读写交互时，并超过了给定的时间，则会触发用户 <code>handler</code> 的 <code>userEventTriggered</code> 方法。用户可以在这个方法中尝试向对方发送信息，如果发送失败，则关闭连接。</p>\n<p>2)<code>IdleStateHandler</code> 的实现基于 <code>EventLoop</code> 的定时任务，每次读写都会记录一个值，在定时任务运行的时候，通过计算当前时间和设置时间和上次事件发生时间的结果，来判断是否空闲。</p>\n<p>3)内部有 <code>3</code> 个定时任务，分别对应读事件，写事件，读写事件。通常用户监听读写事件就足够了。</p>\n<p>4)同时，<code>IdleStateHandler</code> 内部也考虑了一些极端情况：客户端接收缓慢，一次接收数据的速度超过了设置的空闲时间。<code>Netty</code> 通过构造方法中的 <code>observeOutput</code> 属性来决定是否对出站缓冲区的情况进行判断。</p>\n<p>5)如果出站缓慢，<code>Netty</code> 不认为这是空闲，也就不触发空闲事件。但第一次无论如何也是要触发的。因为第一次无法判断是出站缓慢还是空闲。当然，出站缓慢的话，可能造成 <code>OOM</code>，<code>OOM</code> 比空闲的问题更大。</p>\n<p>6)所以，当你的应用出现了内存溢出，<code>OOM</code> 之类，并且写空闲极少发生（使用了 <code>observeOutput</code> 为 <code>true</code>），那么就需要注意是不是数据出站速度过慢。</p>\n<p>7)还有一个注意的地方：就是 <code>ReadTimeoutHandler</code>，它继承自 <code>IdleStateHandler</code>，当触发读空闲事件的时候，就触发 <code>ctx</code>. <code>fireExceptionCaught</code> 方法，并传入一个 <code>ReadTimeoutException</code>，然后关闭 <code>Socket</code>。</p>\n<p>8)而 <code>WriteTimeoutHandler</code> 的实现不是基于 <code>IdleStateHandler</code> 的，他的原理是，当调用 <code>write</code> 方法的时候，会创建一个定时任务，任务内容是根据传入的 <code>promise</code> 的完成情况来判断是否超出了写的时间。当定时任务根据指定时间开始运行，发现 <code>promise</code> 的 <code>isDone</code> 方法返回 <code>false</code>，表明还没有写完，说明超时了，则抛出异常。当 <code>write</code> 方法完成后，会打断定时任务。</p>\n<h3 id=\"Netty-核心组件-EventLoop-源码剖析\">Netty 核心组件 EventLoop 源码剖析</h3>\n<h4 id=\"源码剖析目的-6\">源码剖析目的</h4>\n<p><code>Echo</code> 第一行代码就是：<code>EventLoopGroup bossGroup = new NioEventLoopGroup(1)</code>; 下面分析其最核心的组件 <code>EventLoop</code>。</p>\n<h4 id=\"源码剖析-6\">源码剖析</h4>\n<p>源码剖析</p>\n<p>1.<code>EventLoop</code>介绍 1.1首先看看 <code>NioEventLoop</code> 的继承图</p>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306132234266.png\" alt></p>\n<p>说明重点： 1)<code>ScheduledExecutorService</code> 接口表示是一个定时任务接口，<code>EventLoop</code> 可以接受定时任务。</p>\n<p>2)<code>EventLoop</code> 接口：<code>Netty</code> 接口文档说明该接口作用：一旦 <code>Channel</code> 注册了，就处理该 <code>Channel</code> 对应的所有 <code>I/O</code> 操作。</p>\n<p>3)<code>SingleThreadEventExecutor</code> 表示这是一个单个线程的线程池</p>\n<p>4)<code>EventLoop</code> 是一个单例的线程池，里面含有一个死循环的线程不断的做着 <code>3</code> 件事情：监听端口，处理端口事件，处理队列事件。每个 <code>EventLoop</code> 都可以绑定多个 <code>Channel</code>，而每个 <code>Channel</code> 始终只能由一个 <code>EventLoop</code> 来处理</p>\n<ol>\n<li><code>NioEventLoop</code> 的使用 - <code>execute</code> 方法</li>\n</ol>\n<p>2.1 <code>execute</code> 源码剖析</p>\n<p><img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202306132234725.png\" alt></p>\n<p>在 <code>EventLoop</code> 的使用，一般就是 <code>eventloop.execute(task);</code> 看下 <code>execute</code> 方法的实现(在 <code>SingleThreadEventExecutor</code> 类中)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">execute</span><span class=\"params\">(Runnable task)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(task == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NullPointerException</span>(<span class=\"string\">&quot;task&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">inEventLoop</span> <span class=\"operator\">=</span> inEventLoop();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(inEventLoop) &#123;</span><br><span class=\"line\">        addTask(task);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        startThread();</span><br><span class=\"line\">        addTask(task);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(isShutdown() &amp;&amp; removeTask(task)) &#123;</span><br><span class=\"line\">            reject();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!addTaskWakesUp&amp;&amp;wakesUpForTask(task)) &#123;</span><br><span class=\"line\">        wakeup(inEventLoop);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>说明: 1)首先判断该 <code>EventLoop</code> 的线程是否是当前线程，如果是，直接添加到任务队列中去，如果不是，则尝试启动线程（但由于线程是单个的，因此只能启动一次），随后再将任务添加到队列中去。</p>\n<p>2)如果线程已经停止，并且删除任务失败，则执行拒绝策略，默认是抛出异常。</p>\n<p>3)如果 <code>addTaskWakesUp</code> 是 <code>false</code>，并且任务不是 <code>NonWakeupRunnable</code> 类型的，就尝试唤醒 <code>selector</code>。这个时候，阻塞在 <code>selecor</code>的线程就会立即返回</p>\n<p>4)可以下断点来追踪</p>\n<p>2.2我们 <code>debugaddTask</code> 和 <code>offerTask</code> 方法源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addTask</span><span class=\"params\">(Runnable task)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(task == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NullPointerException</span>(<span class=\"string\">&quot;task&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!offerTask(task)) &#123;</span><br><span class=\"line\">        reject(task);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">offerTask</span><span class=\"params\">(Runnable task)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(isShutdown()) &#123;</span><br><span class=\"line\">        reject();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> taskQueue.offer(task);</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>3.<code>NioEventLoop</code> 的父类 <code>SingleThreadEventExecutor</code> 的 <code>startThread</code> 方法 3.1当执行 <code>execute</code> 方法的时候，如果当前线程不是 <code>EventLoop</code> 所属线程，则尝试启动线程，也就是 <code>startThread</code> 方法，dubug 代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">startThread</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(state == ST_NOT_STARTED) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(STATE_UPDATER.compareAndSet(<span class=\"built_in\">this</span>, ST_NOT_STARTED, ST_STARTED)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                doStartThread();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span>(Throwable cause) &#123;</span><br><span class=\"line\">                STATE_UPDATER.set(<span class=\"built_in\">this</span>, ST_NOT_STARTED);</span><br><span class=\"line\">                PlatformDependent.throwException(cause);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>说明:该方法首先判断是否启动过了，保证 <code>EventLoop</code> 只有一个线程，如果没有启动过，则尝试使用 <code>Cas</code> 将 <code>state</code> 状态改为 <code>ST_STARTED</code>，也就是已启动。然后调用 <code>doStartThread</code> 方法。如果失败，则进行回滚</p>\n<p>看下 <code>doStartThread</code> 方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doStartThread</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    executor.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">success</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            updateLastExecutionTime();</span><br><span class=\"line\">            <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                SingleThreadEventExecutor.<span class=\"built_in\">this</span>.run();</span><br><span class=\"line\">                success=<span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>( ; ; ) &#123;</span><br><span class=\"line\">                    intoldState = state;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(oldState &gt;= ST_SHUTTING_DOWN || STATE_UPDATER.compareAndSet(SingleThreadEventExecutor.<span class=\"built_in\">this</span>, oldState, ST_SHUTTING_DOWN)) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>( ; ; ) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(confirmShutdown()) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        cleanup();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                        STATE_UPDATER.set(SingleThreadEventExecutor.<span class=\"built_in\">this</span>,ST_TERMINATED);</span><br><span class=\"line\">                        threadLock.release();</span><br><span class=\"line\">                        terminationFuture.setSuccess(<span class=\"literal\">null</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>说明： 1)首先调用 <code>executor</code> 的 <code>execute</code> 方法，这个 <code>executor</code> 就是在创建 <code>EventLoopGroup</code> 的时候创建的 <code>ThreadPerTaskExecutor</code> 类。该 <code>execute</code> 方法会将 <code>Runnable</code> 包装成 <code>Netty</code> 的 <code>FastThreadLocalThread</code>。</p>\n<p>2)任务中，首先判断线程中断状态，然后设置最后一次的执行时间。</p>\n<p>3)执行当前 <code>NioEventLoop</code> 的 <code>run</code> 方法，注意：这个方法是个死循环，是整个 <code>EventLoop</code> 的核心</p>\n<p>4)在 <code>finally</code> 块中，使用 <code>CAS</code> 不断修改 <code>state</code> 状态，改成 <code>ST_SHUTTING_DOWN</code>。也就是当线程 <code>Loop</code> 结束的时候。关闭线程。最后还要死循环确认是否关闭，否则不会 <code>break</code>。然后，执行 <code>cleanup</code> 操作，更新状态为</p>\n<p>5)<code>ST_TERMINATED</code>，并释放当前线程锁。如果任务队列不是空，则打印队列中还有多少个未完成的任务。并回调 <code>terminationFuture</code> 方法。</p>\n<p>6)其实最核心的就是 <code>EventLoop</code> 自身的 <code>run</code> 方法。再继续深入 <code>run</code> 方法</p>\n<p>4.<code>EventLoop</code> 中的 <code>Loop</code> 是靠 <code>run</code> 实现的，我们分析下 <code>run</code> 方法(该方法在 <code>NioEventLoop</code>)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>( ; ; ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span>(selectStrategy.calculateStrategy(selectNowSupplier,hasTasks())) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> SelectStrategy.CONTINUE:</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> SelectStrategy.SELECT:</span><br><span class=\"line\">                    select(wakenUp.getAndSet(<span class=\"literal\">false</span>));</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(wakenUp.get()) &#123;</span><br><span class=\"line\">                        selector.wakeup();</span><br><span class=\"line\">                    &#125;    </span><br><span class=\"line\">                <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            cancelledKeys = <span class=\"number\">0</span>;</span><br><span class=\"line\">            needsToSelectAgain = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">ioRatio</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.ioRatio;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ioRatio == <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    processSelectedKeys();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//Ensure we always run tasks.</span></span><br><span class=\"line\">                    runAllTasks();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">ioStartTime</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    processSelectedKeys();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//Ensure we always runtasks.</span></span><br><span class=\"line\">                    <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">ioTime</span> <span class=\"operator\">=</span> System.nanoTime() - ioStartTime;</span><br><span class=\"line\">                    runAllTasks(ioTime * (<span class=\"number\">100</span> - ioRatio) / ioRatio);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span>(Throwable t) &#123;</span><br><span class=\"line\">            handleLoopException(t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//Always handle shutdown even if the loop processing threw an exception.</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(isShuttingDown()) &#123;</span><br><span class=\"line\">                closeAll();</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(confirmShutdown()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">            handleLoopException(t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>说明: 1)从上面的步骤可以看出，整个 <code>run</code> 方法做了 <code>3</code> 件事情： <code>select</code> 获取感兴趣的事件。 <code>processSelectedKeys</code> 处理事件。 <code>runAllTasks</code> 执行队列中的任务。</p>\n<p>2)上面的三个方法，我们就追一下 <code>select</code> 方法(体现非阻塞)核心 <code>select</code> 方法解析</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">select</span><span class=\"params\">(<span class=\"type\">boolean</span> oldWakenUp)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    <span class=\"type\">Selector</span> <span class=\"variable\">selector</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.selector;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">selectCnt</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">currentTimeNanos</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">selectDeadLineNanos</span> <span class=\"operator\">=</span> currentTimeNanos + delayNanos(currentTimeNanos);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>( ; ; ) &#123;</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">timeoutMillis</span> <span class=\"operator\">=</span> (selectDeadLineNanos - currentTimeNanos + <span class=\"number\">500000L</span>)/<span class=\"number\">1000000L</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(timeoutMillis &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(selectCnt == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    selector.selectNow();</span><br><span class=\"line\">                    selectCnt=<span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//If a task was submitted when wakenUp value was true, the task didn&#x27;t get a chance to call</span></span><br><span class=\"line\">            <span class=\"comment\">//Selector#wakeup. So we need to check task queue again before executing select operation.</span></span><br><span class=\"line\">            <span class=\"comment\">//If wedon&#x27;t, the task might be pended until select operation was timedout.</span></span><br><span class=\"line\">            <span class=\"comment\">//It might be pended until idle timeout if IdleStateHandler existed inpipeline.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(hasTasks() &amp;&amp; wakenUp.compareAndSet(<span class=\"literal\">false</span>, <span class=\"literal\">true</span>)) &#123;</span><br><span class=\"line\">                selector.selectNow();</span><br><span class=\"line\">                selectCnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">selectedKeys</span> <span class=\"operator\">=</span> selector.select(timeoutMillis);<span class=\"comment\">//否则阻塞给定时间，默认一秒</span></span><br><span class=\"line\">            selectCnt++;</span><br><span class=\"line\">            <span class=\"comment\">//如果 1 秒后返回，有返回值||select被用户唤醒||任务队列有任务||有定时任务即将被执行；则跳出循环</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(selectedKeys != <span class=\"number\">0</span> || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//-Selected something,</span></span><br><span class=\"line\">                <span class=\"comment\">//-waken up by user,or</span></span><br><span class=\"line\">                <span class=\"comment\">//-the task queue has apending task.</span></span><br><span class=\"line\">                <span class=\"comment\">//-a scheduled task is ready for processing</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(Thread.interrupted()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//Thread was interrupted so reset selected keys and break so we not run into a busy loop.</span></span><br><span class=\"line\">                <span class=\"comment\">//As this is most likely a bug in the handler of the user or it&#x27;s client library we will</span></span><br><span class=\"line\">                <span class=\"comment\">//also log it.</span></span><br><span class=\"line\">                <span class=\"comment\">//</span></span><br><span class=\"line\">                <span class=\"comment\">//See https://github.com/netty/netty/issues/2426</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">                    logger.debug(<span class=\"string\">&quot;Selector.select() returned prematurely because &quot;</span> + <span class=\"string\">&quot; Thread.currentThread().interrupt() was called. Use &quot;</span> + <span class=\"string\">&quot; NioEventLoop.shutdownGracefully() to shutdowntheNioEventLoop.&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                selectCnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">time</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//timeoutMillis elapsed without any thing selected.</span></span><br><span class=\"line\">                selectCnt =<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class=\"number\">0</span> &amp;&amp; selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//The selector returned prematurely many times in a row.</span></span><br><span class=\"line\">                <span class=\"comment\">//Rebuild the selector to work around the problem.</span></span><br><span class=\"line\">                logger.warn(<span class=\"string\">&quot;Selector.select() returned prematurely &#123;&#125; times in a row; rebuilding Selector &#123;&#125;.&quot;</span>, selectCnt, selector);</span><br><span class=\"line\">                rebuildSelector();</span><br><span class=\"line\">                selector = <span class=\"built_in\">this</span>.selector;</span><br><span class=\"line\">                <span class=\"comment\">//Select again to populate selectedKeys.</span></span><br><span class=\"line\">                selector.selectNow();</span><br><span class=\"line\">                selectCnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            currentTimeNanos = time;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">                logger.debug(<span class=\"string\">&quot;Selector.select()returned prematurely &#123;&#125; times in a row for Selector&#123;&#125;.&quot;</span>, selectCnt - <span class=\"number\">1</span>, selector);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (CancelledKeyException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">            logger.debug(CancelledKeyException.class.getSimpleName() + <span class=\"string\">&quot;raisedbyaSelector &#123;&#125; - JDKbug?&quot;</span>, selector, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//Harmless exception - log anyway</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>说明：调用 <code>selector</code> 的 <code>select</code> 方法，默认阻塞一秒钟，如果有定时任务，则在定时任务剩余时间的基础上在加上 <code>0.5</code> 秒进行阻塞。当执行 <code>execute</code> 方法的时候，也就是添加任务的时候，唤醒 <code>selector</code>，防止 <code>selector</code> 阻塞时间过长</p>\n<p>5.<code>EventLoop</code> 作为 <code>Netty</code> 的核心的运行机制小结</p>\n<p>1)每次执行 <code>execute</code> 方法都是向队列中添加任务。当第一次添加时就启动线程，执行 <code>run</code> 方法，而 <code>run</code> 方法是整个 <code>EventLoop</code> 的核心，就像 <code>EventLoop</code> 的名字一样，<code>LoopLoop</code>，不停的 <code>Loop</code>，<code>Loop</code> 做什么呢？做 <code>3</code> 件事情。</p>\n<p>调用 <code>selector</code> 的 <code>select</code> 方法，默认阻塞一秒钟，如果有定时任务，则在定时任务剩余时间的基础上在加上 <code>0.5</code> 秒进行阻塞。当执行 <code>execute</code> 方法的时候，也就是添加任务的时候，唤醒 <code>selecor</code>，防止 <code>selector</code> 阻塞时间过长。</p>\n<p>当 <code>selector</code> 返回的时候，回调用 <code>processSelectedKeys</code> 方法对 <code>selectKey</code> 进行处理。</p>\n<p>当 <code>processSelectedKeys</code> 方法执行结束后，则按照 <code>ioRatio</code> 的比例执行 <code>runAllTasks</code> 方法，默认是 <code>IO</code> 任务时间和非 <code>IO</code> 任务时间是相同的，你也可以根据你的应用特点进行调优。比如非 <code>IO</code> 任务比较多，那么你就将</p>\n<p><code>ioRatio</code> 调小一点，这样非 <code>IO</code> 任务就能执行的长一点。防止队列积攒过多的任务。</p>\n<h3 id=\"handler-中加入线程池和-Context-中添加线程池的源码剖析\">handler 中加入线程池和 Context 中添加线程池的源码剖析</h3>\n<h4 id=\"源码剖析目的-7\">源码剖析目的</h4>\n<ol>\n<li>在 <code>Netty</code> 中做耗时的，不可预料的操作，比如数据库，网络请求，会严重影响 <code>Netty</code> 对 <code>Socket</code> 的处理速度。</li>\n<li>而解决方法就是将耗时任务添加到异步线程池中。但就添加线程池这步操作来讲，可以有 <code>2</code> 种方式，而且这 <code>2</code> 种方式实现的区别也蛮大的。</li>\n<li>处理耗时业务的第一种方式 – <code>handler</code> 中加入线程池</li>\n<li>处理耗时业务的第二种方式 – <code>Context</code> 中添加线程池</li>\n<li>我们就来分析下两种方式</li>\n</ol>\n<h4 id=\"源码剖析-7\">源码剖析</h4>\n<p>说明 演示两种方式的实现，以及从源码来追踪两种方式执行流程</p>\n<ol>\n<li>处理耗时业务的第一种方式 – handler种加入线程池</li>\n<li>1对前面的 <code>Netty</code> <code>demo</code>源码进行修改，在 <code>EchoServerHandler</code> 的 <code>channelRead</code> 方法进行异步</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Sharable</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EchoServerHandler</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">EventExecutorGroup</span> <span class=\"variable\">group</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultEventExecutorGroup</span>(<span class=\"number\">16</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> <span class=\"keyword\">throws</span> UnsupportedEncodingException, InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">msgCop</span> <span class=\"operator\">=</span> msg;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">ChannelHandlerContext</span> <span class=\"variable\">cxtCop</span> <span class=\"operator\">=</span> ctx;</span><br><span class=\"line\">        group.submit(<span class=\"keyword\">new</span> <span class=\"title class_\">Callable</span>&lt;Object&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> Object <span class=\"title function_\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                <span class=\"type\">ByteBuf</span> <span class=\"variable\">buf</span> <span class=\"operator\">=</span> (ByteBuf)msgCop;</span><br><span class=\"line\">                <span class=\"type\">byte</span>[] req = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[buf.readableBytes()];</span><br><span class=\"line\">                buf.readBytes(req);</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">body</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(req, <span class=\"string\">&quot;UTF-8&quot;</span>);</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">10</span> * <span class=\"number\">1000</span>);</span><br><span class=\"line\">                System.err.println(body + <span class=\"string\">&quot; &quot;</span> + Thread.currentThread().getName());</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">reqString</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Helloiamserver~~~&quot;</span>;</span><br><span class=\"line\">                <span class=\"type\">ByteBuf</span> <span class=\"variable\">resp</span> <span class=\"operator\">=</span> Unpooled.copiedBuffer(reqString.getBytes());</span><br><span class=\"line\">                cxtCop.writeAndFlush(resp);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;goon..&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelReadComplete</span><span class=\"params\">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class=\"line\">        ctx.flush();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">exceptionCaught</span><span class=\"params\">(ChannelHandlerContext ctx, Throwable cause)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Close the connection when an exception is raised.</span></span><br><span class=\"line\">        cause.printStackTrace();</span><br><span class=\"line\">        ctx.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>说明： 1)在 <code>channelRead</code> 方法，模拟了一个耗时 <code>10</code> 秒的操作，这里，我们将这个任务提交到了一个自定义的业务线程池中，这样，就不会阻塞 <code>Netty</code> 的 <code>IO</code> 线程。</p>\n<p>11.2这样处理之后，整个程序的逻辑如图</p>\n<p><img src=\"https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_19.png\" alt></p>\n<p>说明：</p>\n<p>1)解释一下上图，当 <code>IO</code> 线程轮询到一个 <code>socket</code> 事件，然后，<code>IO</code> 线程开始处理，当走到耗时 <code>handler</code> 的时候，将耗时任务交给业务线程池。</p>\n<p>2)当耗时任务执行完毕再执行 <code>pipeline write</code> 方法的时候，(代码中使用的是 <code>context</code> 的 <code>write</code> 方法，上图画的是执行 <code>pipeline</code> 方法，是一个意思)会将任务这个任务交给 <code>IO</code> 线程</p>\n<p>11.3 <code>write</code> 方法的源码(在 <code>AbstractChannelHandlerContext</code> 类)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">write</span><span class=\"params\">(Object msg, <span class=\"type\">boolean</span> flush, ChannelPromise promise)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">AbstractChannelHandlerContext</span> <span class=\"variable\">next</span> <span class=\"operator\">=</span> findContextOutbound();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> pipeline.touch(msg, next);</span><br><span class=\"line\">    <span class=\"type\">EventExecutor</span> <span class=\"variable\">executor</span> <span class=\"operator\">=</span> next.executor();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(executor.inEventLoop()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flush) &#123;</span><br><span class=\"line\">            next.invokeWriteAndFlush(m, promise);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            next.invokeWrite(m, promise);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        AbstractWriteTask task;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flush) &#123;</span><br><span class=\"line\">            task = WriteAndFlushTask.newInstance(next, m, promise);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            task = WriteTask.newInstance(next, m, promise);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        safeExecute(executor, task, promise, m);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>说明:</p>\n<p>1)当判定下个 <code>outbound</code> 的 <code>executor</code> 线程不是当前线程的时候，会将当前的工作封装成 <code>task</code>，然后放入 <code>mpsc</code> 队列中，等待 <code>IO</code> 任务执行完毕后执行队列中的任务。</p>\n<p>2)这里可以 Debug 来验证(提醒：Debug 时，服务器端 Debug, 客户端 <code>Run</code> 的方式)，当我们使用了 <code>group.submit(new Callable&lt;Object&gt; ()&#123;&#125;</code> 在 <code>handler</code> 中加入线程池，就会进入到 <code>safeExecute(executor, task, promise, m);</code> 如果去掉这段代码，而使用普通方式来执行耗时的业务，那么就不会进入到 <code>safeExecute(executor, task, promise, m);</code>（说明：普通方式执行耗时代码，看我准备好的案例即可）</p>\n<p>12.处理耗时业务的第二种方式 -<code>Context</code> 中添加线程池 1.1在添加 <code>pipeline</code> 中的 <code>handler</code> 时候，添加一个线程池</p>\n<p>//属性</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">EventExecutorGroup</span> <span class=\"variable\">group</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultEventExecutorGroup</span>(<span class=\"number\">16</span>);</span><br><span class=\"line\"><span class=\"type\">ServerBootstrap</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrap</span>();</span><br><span class=\"line\">                b.group(bossGroup, workerGroup)</span><br><span class=\"line\">                 .channel(NioServerSocketChannel.class)</span><br><span class=\"line\">                 .option(ChannelOption.SO_BACKLOG, <span class=\"number\">100</span>)</span><br><span class=\"line\">                 .handler(newLoggingHandler(LogLevel.INFO))</span><br><span class=\"line\">                 .childHandler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">                     <span class=\"meta\">@Override</span></span><br><span class=\"line\">                     <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                         <span class=\"type\">ChannelPipeline</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> ch.pipeline();</span><br><span class=\"line\">                         <span class=\"keyword\">if</span>(sslCtx != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                             p.addLast(sslCtx.newHandler(ch.alloc()));</span><br><span class=\"line\">                         &#125;</span><br><span class=\"line\">                         <span class=\"comment\">//p.addLast(new LoggingHandler(LogLevel.INFO));</span></span><br><span class=\"line\">                         <span class=\"comment\">//p.addLast(new EchoServerHandler());</span></span><br><span class=\"line\">                         p.addLast(group, <span class=\"keyword\">new</span> <span class=\"title class_\">EchoServerHandler</span>());</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>说明：</p>\n<p>1)<code>handler</code> 中的代码就使用普通的方式来处理耗时业务。</p>\n<p>2)当我们在调用 <code>addLast</code> 方法添加线程池后，<code>handler</code> 将优先使用这个线程池，如果不添加，将使用 <code>IO</code> 线程</p>\n<p>3)当走到 <code>AbstractChannelHandlerContext</code> 的 <code>invokeChannelRead</code> 方法的时候，<code>executor.inEventLoop()</code> 是不会通过的，因为当前线程是 <code>IO</code> 线程 <code>Context</code>（也就是 <code>Handler</code>）的 <code>executor</code> 是业务线程，所以会异步执行，debug 下源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">invokeChannelRead</span><span class=\"params\">(<span class=\"keyword\">final</span> AbstractChannelHandlerContext next, Object msg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class=\"string\">&quot;msg&quot;</span>), next);</span><br><span class=\"line\">    <span class=\"type\">EventExecutor</span> <span class=\"variable\">executor</span> <span class=\"operator\">=</span> next.executor();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(executor.inEventLoop()) &#123;</span><br><span class=\"line\">        next.invokeChannelRead(m);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        executor.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;<span class=\"comment\">//执行run</span></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                next.invokeChannelRead(m);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>\n<p>4)验证时，我们如果去掉 <code>p.addLast(group,newEchoServerHandler());</code> 改成 <code>p.addLastnewEchoServerHandler());</code> 你会发现代码不会进行异步执行。</p>\n<p>5)后面的整个流程就变成和第一个方式一样了</p>\n<p>13.两种方式的比较</p>\n<p>1)第一种方式在 <code>handler</code> 中添加异步，可能更加的自由，比如如果需要访问数据库，那我就异步，如果不需要，就不异步，异步会拖长接口响应时间。因为需要将任务放进 <code>mpscTask</code> 中。如果 <code>IO</code> 时间很短，<code>task</code> 很多，可能一个循环下来，都没时间执行整个 <code>task</code>，导致响应时间达不到指标。</p>\n<p>2)第二种方式是 <code>Netty</code> 标准方式(即加入到队列)，但是，这么做会将整个 <code>handler</code> 都交给业务线程池。不论耗时不耗时，都加入到队列里，不够灵活。</p>\n<p>3)各有优劣，从灵活性考虑，第一种较好。</p>\n<h1>满一航Netty源码分析</h1>\n<h2 id=\"2-源码分析\">2. 源码分析</h2>\n<h3 id=\"2-1-启动剖析\">2.1 启动剖析</h3>\n<p>我们就来看看 netty 中对下面的代码是怎样进行处理的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1 netty 中使用 NioEventLoopGroup （简称 nio boss 线程）来封装线程和 selector</span></span><br><span class=\"line\"><span class=\"type\">Selector</span> <span class=\"variable\">selector</span> <span class=\"operator\">=</span> Selector.open(); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2 创建 NioServerSocketChannel，同时会初始化它关联的 handler，以及为原生 ssc 存储 config</span></span><br><span class=\"line\"><span class=\"type\">NioServerSocketChannel</span> <span class=\"variable\">attachment</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioServerSocketChannel</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//3 创建 NioServerSocketChannel 时，创建了 java 原生的 ServerSocketChannel</span></span><br><span class=\"line\"><span class=\"type\">ServerSocketChannel</span> <span class=\"variable\">serverSocketChannel</span> <span class=\"operator\">=</span> ServerSocketChannel.open(); </span><br><span class=\"line\">serverSocketChannel.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//4 启动 nio boss 线程执行接下来的操作</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//5 注册（仅关联 selector 和 NioServerSocketChannel），未关注事件</span></span><br><span class=\"line\"><span class=\"type\">SelectionKey</span> <span class=\"variable\">selectionKey</span> <span class=\"operator\">=</span> serverSocketChannel.register(selector, <span class=\"number\">0</span>, attachment);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//6 head -&gt; 初始化器 -&gt; ServerBootstrapAcceptor -&gt; tail，初始化器是一次性的，只为添加 acceptor</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//7 绑定端口</span></span><br><span class=\"line\">serverSocketChannel.bind(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"number\">8080</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//8 触发 channel active 事件，在 head 中关注 op_accept 事件</span></span><br><span class=\"line\">selectionKey.interestOps(SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>\n<p>入口 <code>io.netty.bootstrap.ServerBootstrap#bind</code></p>\n<p>关键代码 <code>io.netty.bootstrap.AbstractBootstrap#doBind</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> ChannelFuture <span class=\"title function_\">doBind</span><span class=\"params\">(<span class=\"keyword\">final</span> SocketAddress localAddress)</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 1. 执行初始化和注册 regFuture 会由 initAndRegister 设置其是否完成，从而回调 3.2 处代码</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">ChannelFuture</span> <span class=\"variable\">regFuture</span> <span class=\"operator\">=</span> initAndRegister();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> regFuture.channel();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (regFuture.cause() != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> regFuture;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2. 因为是 initAndRegister 异步执行，需要分两种情况来看，调试时也需要通过 suspend 断点类型加以区分</span></span><br><span class=\"line\">    <span class=\"comment\">// 2.1 如果已经完成</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (regFuture.isDone()) &#123;</span><br><span class=\"line\">        <span class=\"type\">ChannelPromise</span> <span class=\"variable\">promise</span> <span class=\"operator\">=</span> channel.newPromise();</span><br><span class=\"line\">        <span class=\"comment\">// 3.1 立刻调用 doBind0</span></span><br><span class=\"line\">        doBind0(regFuture, channel, localAddress, promise);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> promise;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"comment\">// 2.2 还没有完成</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">PendingRegistrationPromise</span> <span class=\"variable\">promise</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PendingRegistrationPromise</span>(channel);</span><br><span class=\"line\">        <span class=\"comment\">// 3.2 回调 doBind0</span></span><br><span class=\"line\">        regFuture.addListener(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelFutureListener</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">operationComplete</span><span class=\"params\">(ChannelFuture future)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                <span class=\"type\">Throwable</span> <span class=\"variable\">cause</span> <span class=\"operator\">=</span> future.cause();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cause != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 处理异常...</span></span><br><span class=\"line\">                    promise.setFailure(cause);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    promise.registered();</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 3. 由注册线程去执行 doBind0</span></span><br><span class=\"line\">                    doBind0(regFuture, channel, localAddress, promise);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> promise;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关键代码 <code>io.netty.bootstrap.AbstractBootstrap#initAndRegister</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> ChannelFuture <span class=\"title function_\">initAndRegister</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        channel = channelFactory.newChannel();</span><br><span class=\"line\">        <span class=\"comment\">// 1.1 初始化 - 做的事就是添加一个初始化器 ChannelInitializer</span></span><br><span class=\"line\">        init(channel);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理异常...</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultChannelPromise</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">FailedChannel</span>(), GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 1.2 注册 - 做的事就是将原生 channel 注册到 selector 上</span></span><br><span class=\"line\">    <span class=\"type\">ChannelFuture</span> <span class=\"variable\">regFuture</span> <span class=\"operator\">=</span> config().group().register(channel);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (regFuture.cause() != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理异常...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> regFuture;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关键代码 <code>io.netty.bootstrap.ServerBootstrap#init</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里 channel 实际上是 NioServerSocketChannel</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">(Channel channel)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (options) &#123;</span><br><span class=\"line\">        setChannelOptions(channel, options, logger);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (attrs) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">            AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey();</span><br><span class=\"line\">            channel.attr(key).set(e.getValue());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">ChannelPipeline</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> channel.pipeline();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">EventLoopGroup</span> <span class=\"variable\">currentChildGroup</span> <span class=\"operator\">=</span> childGroup;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">ChannelHandler</span> <span class=\"variable\">currentChildHandler</span> <span class=\"operator\">=</span> childHandler;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (childOptions) &#123;</span><br><span class=\"line\">        currentChildOptions = childOptions.entrySet().toArray(newOptionArray(<span class=\"number\">0</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (childAttrs) &#123;</span><br><span class=\"line\">        currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(<span class=\"number\">0</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">// 为 NioServerSocketChannel 添加初始化器</span></span><br><span class=\"line\">    p.addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(<span class=\"keyword\">final</span> Channel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">ChannelPipeline</span> <span class=\"variable\">pipeline</span> <span class=\"operator\">=</span> ch.pipeline();</span><br><span class=\"line\">            <span class=\"type\">ChannelHandler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> config.handler();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (handler != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                pipeline.addLast(handler);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 初始化器的职责是将 ServerBootstrapAcceptor 加入至 NioServerSocketChannel</span></span><br><span class=\"line\">            ch.eventLoop().execute(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                    pipeline.addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrapAcceptor</span>(</span><br><span class=\"line\">                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关键代码 <code>io.netty.channel.AbstractChannel.AbstractUnsafe#register</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">register</span><span class=\"params\">(EventLoop eventLoop, <span class=\"keyword\">final</span> ChannelPromise promise)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 一些检查，略...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    AbstractChannel.<span class=\"built_in\">this</span>.eventLoop = eventLoop;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class=\"line\">        register0(promise);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 首次执行 execute 方法时，会启动 nio 线程，之后注册等操作在 nio 线程上执行</span></span><br><span class=\"line\">            <span class=\"comment\">// 因为只有一个 NioServerSocketChannel 因此，也只会有一个 boss nio 线程</span></span><br><span class=\"line\">            <span class=\"comment\">// 这行代码完成的事实是 main -&gt; nio boss 线程的切换</span></span><br><span class=\"line\">            eventLoop.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                    register0(promise);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 日志记录...</span></span><br><span class=\"line\">            closeForcibly();</span><br><span class=\"line\">            closeFuture.setClosed();</span><br><span class=\"line\">            safeSetFailure(promise, t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>io.netty.channel.AbstractChannel.AbstractUnsafe#register0</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">register0</span><span class=\"params\">(ChannelPromise promise)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">firstRegistration</span> <span class=\"operator\">=</span> neverRegistered;</span><br><span class=\"line\">        <span class=\"comment\">// 1.2.1 原生的 nio channel 绑定到 selector 上，注意此时没有注册 selector 关注事件，附件为 NioServerSocketChannel</span></span><br><span class=\"line\">        doRegister();</span><br><span class=\"line\">        neverRegistered = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        registered = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 1.2.2 执行 NioServerSocketChannel 初始化器的 initChannel</span></span><br><span class=\"line\">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 回调 3.2 io.netty.bootstrap.AbstractBootstrap#doBind0</span></span><br><span class=\"line\">        safeSetSuccess(promise);</span><br><span class=\"line\">        pipeline.fireChannelRegistered();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 对应 server socket channel 还未绑定，isActive 为 false</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isActive()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (firstRegistration) &#123;</span><br><span class=\"line\">                pipeline.fireChannelActive();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (config().isAutoRead()) &#123;</span><br><span class=\"line\">                beginRead();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Close the channel directly to avoid FD leak.</span></span><br><span class=\"line\">        closeForcibly();</span><br><span class=\"line\">        closeFuture.setClosed();</span><br><span class=\"line\">        safeSetFailure(promise, t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关键代码 <code>io.netty.channel.ChannelInitializer#initChannel</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initMap.add(ctx)) &#123; <span class=\"comment\">// Guard against re-entrance.</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 1.2.2.1 执行初始化</span></span><br><span class=\"line\">            initChannel((C) ctx.channel());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable cause) &#123;</span><br><span class=\"line\">            exceptionCaught(ctx, cause);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 1.2.2.2 移除初始化器</span></span><br><span class=\"line\">            <span class=\"type\">ChannelPipeline</span> <span class=\"variable\">pipeline</span> <span class=\"operator\">=</span> ctx.pipeline();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pipeline.context(<span class=\"built_in\">this</span>) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                pipeline.remove(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关键代码 <code>io.netty.bootstrap.AbstractBootstrap#doBind0</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 3.1 或 3.2 执行 doBind0</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doBind0</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"keyword\">final</span> ChannelFuture regFuture, <span class=\"keyword\">final</span> Channel channel,</span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"keyword\">final</span> SocketAddress localAddress, <span class=\"keyword\">final</span> ChannelPromise promise)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    channel.eventLoop().execute(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (regFuture.isSuccess()) &#123;</span><br><span class=\"line\">                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                promise.setFailure(regFuture.cause());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关键代码 <code>io.netty.channel.AbstractChannel.AbstractUnsafe#bind</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">bind</span><span class=\"params\">(<span class=\"keyword\">final</span> SocketAddress localAddress, <span class=\"keyword\">final</span> ChannelPromise promise)</span> &#123;</span><br><span class=\"line\">    assertEventLoop();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Boolean.TRUE.equals(config().getOption(ChannelOption.SO_BROADCAST)) &amp;&amp;</span><br><span class=\"line\">        localAddress <span class=\"keyword\">instanceof</span> InetSocketAddress &amp;&amp;</span><br><span class=\"line\">        !((InetSocketAddress) localAddress).getAddress().isAnyLocalAddress() &amp;&amp;</span><br><span class=\"line\">        !PlatformDependent.isWindows() &amp;&amp; !PlatformDependent.maybeSuperUser()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 记录日志...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">wasActive</span> <span class=\"operator\">=</span> isActive();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 3.3 执行端口绑定</span></span><br><span class=\"line\">        doBind(localAddress);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        safeSetFailure(promise, t);</span><br><span class=\"line\">        closeIfClosed();</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!wasActive &amp;&amp; isActive()) &#123;</span><br><span class=\"line\">        invokeLater(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 3.4 触发 active 事件</span></span><br><span class=\"line\">                pipeline.fireChannelActive();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    safeSetSuccess(promise);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3.3 关键代码 <code>io.netty.channel.socket.nio.NioServerSocketChannel#doBind</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doBind</span><span class=\"params\">(SocketAddress localAddress)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (PlatformDependent.javaVersion() &gt;= <span class=\"number\">7</span>) &#123;</span><br><span class=\"line\">        javaChannel().bind(localAddress, config.getBacklog());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        javaChannel().socket().bind(localAddress, config.getBacklog());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3.4 关键代码 <code>io.netty.channel.DefaultChannelPipeline.HeadContext#channelActive</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class=\"line\">    ctx.fireChannelActive();</span><br><span class=\"line\">\t<span class=\"comment\">// 触发 read (NioServerSocketChannel 上的 read 不是读取数据，只是为了触发 channel 的事件注册)</span></span><br><span class=\"line\">    readIfIsAutoRead();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关键代码 <code>io.netty.channel.nio.AbstractNioChannel#doBeginRead</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doBeginRead</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Channel.read() or ChannelHandlerContext.read() was called</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">SelectionKey</span> <span class=\"variable\">selectionKey</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.selectionKey;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!selectionKey.isValid()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    readPending = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">interestOps</span> <span class=\"operator\">=</span> selectionKey.interestOps();</span><br><span class=\"line\">    <span class=\"comment\">// readInterestOp 取值是 16，在 NioServerSocketChannel 创建时初始化好，代表关注 accept 事件</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((interestOps &amp; readInterestOp) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-2-NioEventLoop-剖析\">2.2 NioEventLoop 剖析</h3>\n<p>NioEventLoop 线程不仅要处理 IO 事件，还要处理 Task（包括普通任务和定时任务），</p>\n<p>提交任务代码 <code>io.netty.util.concurrent.SingleThreadEventExecutor#execute</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">execute</span><span class=\"params\">(Runnable task)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (task == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NullPointerException</span>(<span class=\"string\">&quot;task&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">inEventLoop</span> <span class=\"operator\">=</span> inEventLoop();</span><br><span class=\"line\">    <span class=\"comment\">// 添加任务，其中队列使用了 jctools 提供的 mpsc 无锁队列</span></span><br><span class=\"line\">    addTask(task);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!inEventLoop) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// inEventLoop 如果为 false 表示由其它线程来调用 execute，即首次调用，这时需要向 eventLoop 提交首个任务，启动死循环，会执行到下面的 doStartThread</span></span><br><span class=\"line\">        startThread();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isShutdown()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果已经 shutdown，做拒绝逻辑，代码略...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果线程由于 IO select 阻塞了，添加的任务的线程需要负责唤醒 NioEventLoop 线程</span></span><br><span class=\"line\">        wakeup(inEventLoop);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>唤醒 select 阻塞线程<code>io.netty.channel.nio.NioEventLoop#wakeup</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">wakeup</span><span class=\"params\">(<span class=\"type\">boolean</span> inEventLoop)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!inEventLoop &amp;&amp; wakenUp.compareAndSet(<span class=\"literal\">false</span>, <span class=\"literal\">true</span>)) &#123;</span><br><span class=\"line\">        selector.wakeup();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>启动 EventLoop 主循环 <code>io.netty.util.concurrent.SingleThreadEventExecutor#doStartThread</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doStartThread</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> thread == <span class=\"literal\">null</span>;</span><br><span class=\"line\">    executor.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 将线程池的当前线程保存在成员变量中，以便后续使用</span></span><br><span class=\"line\">            thread = Thread.currentThread();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (interrupted) &#123;</span><br><span class=\"line\">                thread.interrupt();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">success</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            updateLastExecutionTime();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 调用外部类 SingleThreadEventExecutor 的 run 方法，进入死循环，run 方法见下</span></span><br><span class=\"line\">                SingleThreadEventExecutor.<span class=\"built_in\">this</span>.run();</span><br><span class=\"line\">                success = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                logger.warn(<span class=\"string\">&quot;Unexpected exception from an event executor: &quot;</span>, t);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 清理工作，代码略...</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>io.netty.channel.nio.NioEventLoop#run</code> 主要任务是执行死循环，不断看有没有新任务，有没有 IO 事件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// calculateStrategy 的逻辑如下：</span></span><br><span class=\"line\">                <span class=\"comment\">// 有任务，会执行一次 selectNow，清除上一次的 wakeup 结果，无论有没有 IO 事件，都会跳过 switch</span></span><br><span class=\"line\">                <span class=\"comment\">// 没有任务，会匹配 SelectStrategy.SELECT，看是否应当阻塞</span></span><br><span class=\"line\">                <span class=\"keyword\">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> SelectStrategy.CONTINUE:</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">case</span> SelectStrategy.BUSY_WAIT:</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">case</span> SelectStrategy.SELECT:</span><br><span class=\"line\">                        <span class=\"comment\">// 因为 IO 线程和提交任务线程都有可能执行 wakeup，而 wakeup 属于比较昂贵的操作，因此使用了一个原子布尔对象 wakenUp，它取值为 true 时，表示该由当前线程唤醒</span></span><br><span class=\"line\">                        <span class=\"comment\">// 进行 select 阻塞，并设置唤醒状态为 false</span></span><br><span class=\"line\">                        <span class=\"type\">boolean</span> <span class=\"variable\">oldWakenUp</span> <span class=\"operator\">=</span> wakenUp.getAndSet(<span class=\"literal\">false</span>);</span><br><span class=\"line\">                        </span><br><span class=\"line\">                        <span class=\"comment\">// 如果在这个位置，非 EventLoop 线程抢先将 wakenUp 置为 true，并 wakeup</span></span><br><span class=\"line\">                        <span class=\"comment\">// 下面的 select 方法不会阻塞</span></span><br><span class=\"line\">                        <span class=\"comment\">// 等 runAllTasks 处理完成后，到再循环进来这个阶段新增的任务会不会及时执行呢?</span></span><br><span class=\"line\">                        <span class=\"comment\">// 因为 oldWakenUp 为 true，因此下面的 select 方法就会阻塞，直到超时</span></span><br><span class=\"line\">                        <span class=\"comment\">// 才能执行，让 select 方法无谓阻塞</span></span><br><span class=\"line\">                        select(oldWakenUp);</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (wakenUp.get()) &#123;</span><br><span class=\"line\">                            selector.wakeup();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                rebuildSelector0();</span><br><span class=\"line\">                handleLoopException(e);</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            cancelledKeys = <span class=\"number\">0</span>;</span><br><span class=\"line\">            needsToSelectAgain = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">// ioRatio 默认是 50</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">ioRatio</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.ioRatio;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ioRatio == <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    processSelectedKeys();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// ioRatio 为 100 时，总是运行完所有非 IO 任务</span></span><br><span class=\"line\">                    runAllTasks();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;                </span><br><span class=\"line\">                <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">ioStartTime</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    processSelectedKeys();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 记录 io 事件处理耗时</span></span><br><span class=\"line\">                    <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">ioTime</span> <span class=\"operator\">=</span> System.nanoTime() - ioStartTime;</span><br><span class=\"line\">                    <span class=\"comment\">// 运行非 IO 任务，一旦超时会退出 runAllTasks</span></span><br><span class=\"line\">                    runAllTasks(ioTime * (<span class=\"number\">100</span> - ioRatio) / ioRatio);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">            handleLoopException(t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isShuttingDown()) &#123;</span><br><span class=\"line\">                closeAll();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (confirmShutdown()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">            handleLoopException(t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"⚠️-注意\">⚠️ 注意</h4>\n<blockquote>\n<p>这里有个费解的地方就是 wakeup，它既可以由提交任务的线程来调用（比较好理解），也可以由 EventLoop 线程来调用（比较费解），这里要知道 wakeup 方法的效果：</p>\n<ul>\n<li>由非 EventLoop 线程调用，会唤醒当前在执行 select 阻塞的 EventLoop 线程</li>\n<li>由 EventLoop 自己调用，会本次的 wakeup 会取消下一次的 select 操作</li>\n</ul>\n</blockquote>\n<p>参考下图</p>\n<img src=\"/post/../Desktop/%25E5%2590%2588%25E9%259B%2586/technical-notes-master/study-notes/%25E7%25BD%2591%25E7%25BB%259C%25E7%25BC%2596%25E7%25A8%258B/img/0032.png\">\n<p><code>io.netty.channel.nio.NioEventLoop#select</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">select</span><span class=\"params\">(<span class=\"type\">boolean</span> oldWakenUp)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    <span class=\"type\">Selector</span> <span class=\"variable\">selector</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.selector;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">selectCnt</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">currentTimeNanos</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">        <span class=\"comment\">// 计算等待时间</span></span><br><span class=\"line\">        <span class=\"comment\">// * 没有 scheduledTask，超时时间为 1s</span></span><br><span class=\"line\">        <span class=\"comment\">// * 有 scheduledTask，超时时间为 `下一个定时任务执行时间 - 当前时间`</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">selectDeadLineNanos</span> <span class=\"operator\">=</span> currentTimeNanos + delayNanos(currentTimeNanos);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">timeoutMillis</span> <span class=\"operator\">=</span> (selectDeadLineNanos - currentTimeNanos + <span class=\"number\">500000L</span>) / <span class=\"number\">1000000L</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 如果超时，退出循环</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (timeoutMillis &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (selectCnt == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    selector.selectNow();</span><br><span class=\"line\">                    selectCnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 如果期间又有 task 退出循环，如果没这个判断，那么任务就会等到下次 select 超时时才能被执行</span></span><br><span class=\"line\">            <span class=\"comment\">// wakenUp.compareAndSet(false, true) 是让非 NioEventLoop 不必再执行 wakeup</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (hasTasks() &amp;&amp; wakenUp.compareAndSet(<span class=\"literal\">false</span>, <span class=\"literal\">true</span>)) &#123;</span><br><span class=\"line\">                selector.selectNow();</span><br><span class=\"line\">                selectCnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// select 有限时阻塞</span></span><br><span class=\"line\">            <span class=\"comment\">// 注意 nio 有 bug，当 bug 出现时，select 方法即使没有时间发生，也不会阻塞住，导致不断空轮询，cpu 占用 100%</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">selectedKeys</span> <span class=\"operator\">=</span> selector.select(timeoutMillis);</span><br><span class=\"line\">            <span class=\"comment\">// 计数加 1</span></span><br><span class=\"line\">            selectCnt ++;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 醒来后，如果有 IO 事件、或是由非 EventLoop 线程唤醒，或者有任务，退出循环</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (selectedKeys != <span class=\"number\">0</span> || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Thread.interrupted()) &#123;</span><br><span class=\"line\">               \t<span class=\"comment\">// 线程被打断，退出循环</span></span><br><span class=\"line\">                <span class=\"comment\">// 记录日志</span></span><br><span class=\"line\">                selectCnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">time</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果超时，计数重置为 1，下次循环就会 break</span></span><br><span class=\"line\">                selectCnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">            <span class=\"comment\">// 计数超过阈值，由 io.netty.selectorAutoRebuildThreshold 指定，默认 512</span></span><br><span class=\"line\">            <span class=\"comment\">// 这是为了解决 nio 空轮询 bug</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">                    selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 重建 selector</span></span><br><span class=\"line\">                selector = selectRebuildSelector(selectCnt);</span><br><span class=\"line\">                selectCnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            currentTimeNanos = time;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 记录日志</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (CancelledKeyException e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 记录日志</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>处理 keys <code>io.netty.channel.nio.NioEventLoop#processSelectedKeys</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">processSelectedKeys</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (selectedKeys != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 通过反射将 Selector 实现类中的就绪事件集合替换为 SelectedSelectionKeySet </span></span><br><span class=\"line\">        <span class=\"comment\">// SelectedSelectionKeySet 底层为数组实现，可以提高遍历性能（原本为 HashSet）</span></span><br><span class=\"line\">        processSelectedKeysOptimized();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        processSelectedKeysPlain(selector.selectedKeys());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>io.netty.channel.nio.NioEventLoop#processSelectedKey</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">processSelectedKey</span><span class=\"params\">(SelectionKey k, AbstractNioChannel ch)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> AbstractNioChannel.<span class=\"type\">NioUnsafe</span> <span class=\"variable\">unsafe</span> <span class=\"operator\">=</span> ch.unsafe();</span><br><span class=\"line\">    <span class=\"comment\">// 当 key 取消或关闭时会导致这个 key 无效</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!k.isValid()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 无效时处理...</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">readyOps</span> <span class=\"operator\">=</span> k.readyOps();</span><br><span class=\"line\">        <span class=\"comment\">// 连接事件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">ops</span> <span class=\"operator\">=</span> k.interestOps();</span><br><span class=\"line\">            ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class=\"line\">            k.interestOps(ops);</span><br><span class=\"line\"></span><br><span class=\"line\">            unsafe.finishConnect();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 可写事件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            ch.unsafe().forceFlush();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 可读或可接入事件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class=\"number\">0</span> || readyOps == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果是可接入 io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果是可读 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read</span></span><br><span class=\"line\">            unsafe.read();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (CancelledKeyException ignored) &#123;</span><br><span class=\"line\">        unsafe.close(unsafe.voidPromise());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-3-accept-剖析\">2.3 accept 剖析</h3>\n<p>nio 中如下代码，在 netty 中的流程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1 阻塞直到事件发生</span></span><br><span class=\"line\">selector.select();</span><br><span class=\"line\"></span><br><span class=\"line\">Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iter.hasNext()) &#123;    </span><br><span class=\"line\">    <span class=\"comment\">//2 拿到一个事件</span></span><br><span class=\"line\">    <span class=\"type\">SelectionKey</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> iter.next();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//3 如果是 accept 事件</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key.isAcceptable()) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//4 执行 accept</span></span><br><span class=\"line\">        <span class=\"type\">SocketChannel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> serverSocketChannel.accept();</span><br><span class=\"line\">        channel.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//5 关注 read 事件</span></span><br><span class=\"line\">        channel.register(selector, SelectionKey.OP_READ);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>先来看可接入事件处理（accept）</p>\n<p><code>io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">read</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> <span class=\"title function_\">eventLoop</span><span class=\"params\">()</span>.inEventLoop();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">ChannelConfig</span> <span class=\"variable\">config</span> <span class=\"operator\">=</span> config();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">ChannelPipeline</span> <span class=\"variable\">pipeline</span> <span class=\"operator\">=</span> pipeline();    </span><br><span class=\"line\">    <span class=\"keyword\">final</span> RecvByteBufAllocator.<span class=\"type\">Handle</span> <span class=\"variable\">allocHandle</span> <span class=\"operator\">=</span> unsafe().recvBufAllocHandle();</span><br><span class=\"line\">    allocHandle.reset(config);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">closed</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"type\">Throwable</span> <span class=\"variable\">exception</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// doReadMessages 中执行了 accept 并创建 NioSocketChannel 作为消息放入 readBuf</span></span><br><span class=\"line\">                <span class=\"comment\">// readBuf 是一个 ArrayList 用来缓存消息</span></span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">localRead</span> <span class=\"operator\">=</span> doReadMessages(readBuf);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (localRead == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (localRead &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    closed = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// localRead 为 1，就一条消息，即接收一个客户端连接</span></span><br><span class=\"line\">                allocHandle.incMessagesRead(localRead);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> (allocHandle.continueReading());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">            exception = t;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> readBuf.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; size; i ++) &#123;</span><br><span class=\"line\">            readPending = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 触发 read 事件，让 pipeline 上的 handler 处理，这时是处理</span></span><br><span class=\"line\">            <span class=\"comment\">// io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#channelRead</span></span><br><span class=\"line\">            pipeline.fireChannelRead(readBuf.get(i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        readBuf.clear();</span><br><span class=\"line\">        allocHandle.readComplete();</span><br><span class=\"line\">        pipeline.fireChannelReadComplete();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (exception != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            closed = closeOnReadError(exception);</span><br><span class=\"line\"></span><br><span class=\"line\">            pipeline.fireExceptionCaught(exception);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (closed) &#123;</span><br><span class=\"line\">            inputShutdown = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isOpen()) &#123;</span><br><span class=\"line\">                close(voidPromise());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class=\"line\">            removeReadOp();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关键代码 <code>io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#channelRead</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这时的 msg 是 NioSocketChannel</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Channel</span> <span class=\"variable\">child</span> <span class=\"operator\">=</span> (Channel) msg;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// NioSocketChannel 添加  childHandler 即初始化器</span></span><br><span class=\"line\">    child.pipeline().addLast(childHandler);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置选项</span></span><br><span class=\"line\">    setChannelOptions(child, childOptions, logger);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;</span><br><span class=\"line\">        child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 注册 NioSocketChannel 到 nio worker 线程，接下来的处理也移交至 nio worker 线程</span></span><br><span class=\"line\">        childGroup.register(child).addListener(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelFutureListener</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">operationComplete</span><span class=\"params\">(ChannelFuture future)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!future.isSuccess()) &#123;</span><br><span class=\"line\">                    forceClose(child, future.cause());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        forceClose(child, t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>又回到了熟悉的 <code>io.netty.channel.AbstractChannel.AbstractUnsafe#register</code>  方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">register</span><span class=\"params\">(EventLoop eventLoop, <span class=\"keyword\">final</span> ChannelPromise promise)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 一些检查，略...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    AbstractChannel.<span class=\"built_in\">this</span>.eventLoop = eventLoop;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class=\"line\">        register0(promise);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这行代码完成的事实是 nio boss -&gt; nio worker 线程的切换</span></span><br><span class=\"line\">            eventLoop.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                    register0(promise);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 日志记录...</span></span><br><span class=\"line\">            closeForcibly();</span><br><span class=\"line\">            closeFuture.setClosed();</span><br><span class=\"line\">            safeSetFailure(promise, t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>io.netty.channel.AbstractChannel.AbstractUnsafe#register0</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">register0</span><span class=\"params\">(ChannelPromise promise)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">firstRegistration</span> <span class=\"operator\">=</span> neverRegistered;</span><br><span class=\"line\">        doRegister();</span><br><span class=\"line\">        neverRegistered = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        registered = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        <span class=\"comment\">// 执行初始化器，执行前 pipeline 中只有 head -&gt; 初始化器 -&gt; tail</span></span><br><span class=\"line\">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class=\"line\">        <span class=\"comment\">// 执行后就是 head -&gt; logging handler -&gt; my handler -&gt; tail</span></span><br><span class=\"line\"></span><br><span class=\"line\">        safeSetSuccess(promise);</span><br><span class=\"line\">        pipeline.fireChannelRegistered();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isActive()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (firstRegistration) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 触发 pipeline 上 active 事件</span></span><br><span class=\"line\">                pipeline.fireChannelActive();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (config().isAutoRead()) &#123;</span><br><span class=\"line\">                beginRead();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        closeForcibly();</span><br><span class=\"line\">        closeFuture.setClosed();</span><br><span class=\"line\">        safeSetFailure(promise, t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>回到了熟悉的代码 <code>io.netty.channel.DefaultChannelPipeline.HeadContext#channelActive</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class=\"line\">    ctx.fireChannelActive();</span><br><span class=\"line\">\t<span class=\"comment\">// 触发 read (NioSocketChannel 这里 read，只是为了触发 channel 的事件注册，还未涉及数据读取)</span></span><br><span class=\"line\">    readIfIsAutoRead();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>io.netty.channel.nio.AbstractNioChannel#doBeginRead</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doBeginRead</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Channel.read() or ChannelHandlerContext.read() was called</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">SelectionKey</span> <span class=\"variable\">selectionKey</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.selectionKey;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!selectionKey.isValid()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    readPending = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 这时候 interestOps 是 0</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">interestOps</span> <span class=\"operator\">=</span> selectionKey.interestOps();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((interestOps &amp; readInterestOp) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 关注 read 事件</span></span><br><span class=\"line\">        selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-4-read-剖析\">2.4 read 剖析</h3>\n<p>再来看可读事件 <code>io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read</code>，注意发送的数据未必能够一次读完，因此会触发多次 nio read 事件，一次事件内会触发多次 pipeline read，一次事件会触发一次 pipeline read complete</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">read</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">ChannelConfig</span> <span class=\"variable\">config</span> <span class=\"operator\">=</span> config();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (shouldBreakReadReady(config)) &#123;</span><br><span class=\"line\">        clearReadPending();</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">ChannelPipeline</span> <span class=\"variable\">pipeline</span> <span class=\"operator\">=</span> pipeline();</span><br><span class=\"line\">    <span class=\"comment\">// io.netty.allocator.type 决定 allocator 的实现</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">ByteBufAllocator</span> <span class=\"variable\">allocator</span> <span class=\"operator\">=</span> config.getAllocator();</span><br><span class=\"line\">    <span class=\"comment\">// 用来分配 byteBuf，确定单次读取大小</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> RecvByteBufAllocator.<span class=\"type\">Handle</span> <span class=\"variable\">allocHandle</span> <span class=\"operator\">=</span> recvBufAllocHandle();</span><br><span class=\"line\">    allocHandle.reset(config);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">ByteBuf</span> <span class=\"variable\">byteBuf</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">close</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            byteBuf = allocHandle.allocate(allocator);</span><br><span class=\"line\">            <span class=\"comment\">// 读取</span></span><br><span class=\"line\">            allocHandle.lastBytesRead(doReadBytes(byteBuf));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (allocHandle.lastBytesRead() &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                byteBuf.release();</span><br><span class=\"line\">                byteBuf = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                close = allocHandle.lastBytesRead() &lt; <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (close) &#123;</span><br><span class=\"line\">                    readPending = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            allocHandle.incMessagesRead(<span class=\"number\">1</span>);</span><br><span class=\"line\">            readPending = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 触发 read 事件，让 pipeline 上的 handler 处理，这时是处理 NioSocketChannel 上的 handler</span></span><br><span class=\"line\">            pipeline.fireChannelRead(byteBuf);</span><br><span class=\"line\">            byteBuf = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        <span class=\"comment\">// 是否要继续循环</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (allocHandle.continueReading());</span><br><span class=\"line\"></span><br><span class=\"line\">        allocHandle.readComplete();</span><br><span class=\"line\">        <span class=\"comment\">// 触发 read complete 事件</span></span><br><span class=\"line\">        pipeline.fireChannelReadComplete();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (close) &#123;</span><br><span class=\"line\">            closeOnRead(pipeline);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        handleReadException(pipeline, byteBuf, t, close, allocHandle);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class=\"line\">            removeReadOp();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>io.netty.channel.DefaultMaxMessagesRecvByteBufAllocator.MaxMessageHandle#continueReading(io.netty.util.UncheckedBooleanSupplier)</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">continueReading</span><span class=\"params\">(UncheckedBooleanSupplier maybeMoreDataSupplier)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> </span><br><span class=\"line\">           <span class=\"comment\">// 一般为 true</span></span><br><span class=\"line\">           config.isAutoRead() &amp;&amp;</span><br><span class=\"line\">           <span class=\"comment\">// respectMaybeMoreData 默认为 true</span></span><br><span class=\"line\">           <span class=\"comment\">// maybeMoreDataSupplier 的逻辑是如果预期读取字节与实际读取字节相等，返回 true</span></span><br><span class=\"line\">           (!respectMaybeMoreData || maybeMoreDataSupplier.get()) &amp;&amp;</span><br><span class=\"line\">           <span class=\"comment\">// 小于最大次数，maxMessagePerRead 默认 16</span></span><br><span class=\"line\">           totalMessages &lt; maxMessagePerRead &amp;&amp;</span><br><span class=\"line\">           <span class=\"comment\">// 实际读到了数据</span></span><br><span class=\"line\">           totalBytesRead &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","_path":"post/6d654720.html","_link":"http://rycan.top/post/6d654720.html","_id":"cljrhcuxf0018na13gzhq342s"}}