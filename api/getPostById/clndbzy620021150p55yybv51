{"type":"getPostById","data":{"title":"Redis的最佳实践","date":"2023-07-06T18:03:15.000Z","description":"单机模式下的redis基本介绍","categories":[{"name":"redis","_id":"clndbzy65002l150pfhmegzit"}],"tags":[{"name":"redis","_id":"clndbzy6b0046150pd9z39ioz"}],"content":"<meta name=\"referrer\" content=\"no-referrer\">\n<h2 id=\"Redis的最佳实践\">Redis的最佳实践</h2>\n<h3 id=\"键值设计\">键值设计</h3>\n<ul>\n<li>\n<p>优雅的key结构</p>\n<ul>\n<li>\n<p>Redis的Key虽然可以自定义，但最好遵循下面的几个最佳实践约定：</p>\n<ul>\n<li>遵循基本格式：[业务名称]:[数据名]:[id]</li>\n<li>长度不超过44字节</li>\n<li>不包含特殊字符</li>\n</ul>\n</li>\n<li>\n<p>这样设计的好处：</p>\n<ul>\n<li>可读性强</li>\n<li>避免key冲突</li>\n<li>方便管理</li>\n<li>更节省内存： key是string类型，底层编码包含int、embstr和raw三种。\n<ul>\n<li>embstr在小于44字节使用，采用连续内存空间，内存占用更小。</li>\n<li>当字节数大于44字节时，会转为raw模式存储，在raw模式下，内存空间不是连续的，而是采用一个指针指向了另外一段内存空间，在这段空间里存储SDS内容，这样空间不连续，访问的时候性能也就会收到影响，还有可能产生内存碎片</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"拒绝BigKey\">拒绝BigKey</h3>\n<ul>\n<li>BigKey通常以Key的大小和Key中成员的数量来综合判定</li>\n</ul>\n<h3 id=\"恰当的数据结构例题\">恰当的数据结构例题</h3>\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202307061655001.png\" alt=\"image-20230527201830448\" style=\"zoom:33%;\">\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202307061655739.png\" alt=\"image-20230527201908854\" style=\"zoom:33%;\">\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202305272020140.png\" alt=\"image-20230527202048068\" style=\"zoom:33%;\">\n<img src=\"https://gitee.com/Ryang1118/typora/raw/master/images/202307061654710.png\" alt=\"image-20230527202148144\" style=\"zoom:33%;\">\n<ul>\n<li>Key的最佳实践\n<ul>\n<li>固定格式：[业务名]:[数据名]:[id]</li>\n<li>足够简短：不超过44字节</li>\n<li>不包含特殊字符</li>\n</ul>\n</li>\n<li>Value的最佳实践：\n<ul>\n<li>合理的拆分数据，拒绝BigKey</li>\n<li>选择合适数据结构</li>\n<li>Hash结构的entry数量不要超过1000</li>\n<li>设置合理的超时时间</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"相关建议\">相关建议</h3>\n<h4 id=\"持久化配置相关建议\">持久化配置相关建议</h4>\n<ul>\n<li>用来做缓存的Redis实例尽量不要开启持久化功能</li>\n<li>建议关闭RDB持久化功能，使用AOF持久化</li>\n<li>利用脚本定期在slave节点做RDB，实现数据备份</li>\n<li>设置合理的rewrite阈值，避免频繁的bgrewrite</li>\n<li>配置no-appendfsync-on-rewrite = yes，禁止在rewrite期间做aof，避免因AOF引起的阻塞</li>\n<li>部署有关建议：\n<ul>\n<li>Redis实例的物理机要预留足够内存，应对fork和rewrite</li>\n<li>单个Redis实例内存上限不要太大，例如4G或8G。可以加快fork的速度、减少主从同步、数据迁移压力</li>\n<li>不要与CPU密集型应用部署在一起</li>\n<li>不要与高硬盘负载应用一起部署。例如：数据库、消息队列</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"慢查询优化-建议\">慢查询优化 建议</h4>\n<p>注意此处的慢查询指的是：  <font color=\"red\">在Redis执行时耗时超过某个阈值的命令，称为慢查询</font></p>\n<p>危害</p>\n<ul>\n<li>会导致大量请求阻塞，从而引起报错</li>\n</ul>\n<p>配置</p>\n<ul>\n<li><code>slowlog-log-slower-than：慢查询阈值，单位是微秒。默认是10000，建议1000</code></li>\n<li><code>slowlog-max-len：慢查询日志（本质是一个队列）的长度。默认是128，建议1000</code></li>\n</ul>\n<p>查看慢查询</p>\n<ul>\n<li>slowlog len：查询慢查询日志长度</li>\n<li>slowlog get [n]：读取n条慢查询日志</li>\n<li>slowlog reset：清空慢查询列表</li>\n</ul>\n<h3 id=\"命令及安全配置\">命令及安全配置</h3>\n<p>漏洞出现的核心的原因有以下几点：</p>\n<ul>\n<li>Redis未设置密码</li>\n<li>利用了Redis的config set命令动态修改Redis配置</li>\n<li>使用了Root账号权限启动Redis</li>\n</ul>\n<p>解决：</p>\n<ul>\n<li>Redis一定要设置密码</li>\n<li>禁止线上使用下面命令：keys、flushall、flushdb、config set等命令。可以利用rename-command禁用。</li>\n<li>bind：限制网卡，禁止外网网卡访问</li>\n<li>开启防火墙</li>\n<li>不要使用Root账户启动Redis</li>\n<li>尽量不使用默认的端口</li>\n</ul>\n<h3 id=\"Redis内存划分和内存配置\">Redis内存划分和内存配置</h3>\n<p>危害</p>\n<ul>\n<li>当Redis内存不足时，可能导致Key频繁被删除、响应时间变长、QPS不稳定等问题。当内存使用率达到90%以上时就需要我们警惕，并快速定位到内存占用的原因。</li>\n</ul>\n<p>碎片问题的产生：</p>\n<ul>\n<li>Redis底层分配并不是这个key有多大，他就会分配多大，而是有他自己的分配策略，比如8,16,20等等，假定当前key只需要10个字节，此时分配8肯定不够，那么他就会分配16个字节，多出来的6个字节就不能被使用，这就是我们常说的 碎片问题</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>内存占用</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数据内存</td>\n<td>是Redis最主要的部分，存储Redis的键值信息。主要问题是BigKey问题、内存碎片问题</td>\n</tr>\n<tr>\n<td>进程内存</td>\n<td>Redis主进程本身运⾏肯定需要占⽤内存，如代码、常量池等等；这部分内存⼤约⼏兆，在⼤多数⽣产环境中与Redis数据占⽤的内存相⽐可以忽略。</td>\n</tr>\n<tr>\n<td>缓冲区内存</td>\n<td>一般包括客户端缓冲区、AOF缓冲区、复制缓冲区等。客户端缓冲区又包括输入缓冲区和输出缓冲区两种。这部分内存占用波动较大，不当使用BigKey，可能导致内存溢出。</td>\n</tr>\n</tbody>\n</table>\n<p>查看到Redis目前的内存分配状态</p>\n<ul>\n<li>info memory：查看内存分配的情况</li>\n<li>memory xxx：查看key的主要占用情况</li>\n</ul>\n<p>缓冲区内存常见的有三种：</p>\n<ul>\n<li>复制缓冲区：主从复制的repl_backlog_buf，如果太小可能导致频繁的全量复制，影响性能。通过replbacklog-size来设置，默认1mb</li>\n<li>AOF缓冲区：AOF刷盘之前的缓存区域，AOF执行rewrite的缓冲区。无法设置容量上限</li>\n<li><code>客户端缓冲区</code>：分为输入缓冲区和输出缓冲区，输入缓冲区最大1G且不能设置。输出缓冲区可以设置</li>\n</ul>\n<p>以上复制缓冲区和AOF缓冲区 不会有问题，最关键就是<code>客户端缓冲区</code>的问题</p>\n<p>客户端缓冲区：指的就是我们发送命令时，客户端用来缓存命令的一个缓冲区，也就是我们向redis输入数据的输入端缓冲区和redis向客户端返回数据的响应缓存区，输入缓冲区最大1G且不能设置，所以这一块我们根本不用担心，如果超过了这个空间，redis会直接断开，因为本来此时此刻就代表着redis处理不过来了，我们需要担心的就是输出端缓冲区</p>\n<p>在处理大量的big value，解决方案有两个</p>\n<p>1、设置一个大小</p>\n<p>2、增加我们带宽的大小，避免我们出现大量数据从而直接超过了redis的承受能力</p>\n<h3 id=\"集群的一系列问题\">集群的一系列问题</h3>\n<p>集群虽然具备高可用特性，能实现自动故障恢复，但是如果使用不当，也会存在一些问题：</p>\n<ul>\n<li>集群完整性问题</li>\n<li>集群带宽问题</li>\n<li>数据倾斜问题</li>\n<li>客户端性能问题</li>\n<li>命令的集群兼容性问题</li>\n<li>lua和事务问题[<code>如果key不在一个节点，那么是无法保证lua的执行和事务的特性的，所以在集群模式是没有办法执行lua和事务的</code>]</li>\n</ul>\n<blockquote>\n<p>单体Redis（主从Redis）已经能达到万级别的QPS，并且也具备很强的高可用特性。如果主从能满足业务需求的情况下，所以如果不是在万不得已的情况下，尽量不搭建Redis集群</p>\n</blockquote>\n<h3 id=\"redis的实战举例\">redis的实战举例</h3>\n<ul>\n<li>\n<p>数据共享，分布式Session</p>\n</li>\n<li>\n<p>分布式锁</p>\n</li>\n<li>\n<p>全局ID</p>\n</li>\n<li>\n<p>计算器、点赞</p>\n</li>\n<li>\n<p>位统计</p>\n</li>\n<li>\n<p>购物车</p>\n</li>\n<li>\n<p>轻量级消息队列     list  &amp;   stream</p>\n</li>\n<li>\n<p>抽奖</p>\n</li>\n<li>\n<p>点赞、签到、打卡</p>\n</li>\n<li>\n<p>交集差集并集，用户关注，可能认识的人</p>\n</li>\n<li>\n<p>热点新闻、热搜排行</p>\n</li>\n</ul>\n<h3 id=\"CAP\">CAP</h3>\n<p>redis <code>集群</code>是<code>AP</code>  redis <code>单机</code> 是 <code>C</code></p>\n","_path":"post/474b8f0f.html","_link":"http://rycan.top/post/474b8f0f.html","_id":"clndbzy620021150p55yybv51"}}