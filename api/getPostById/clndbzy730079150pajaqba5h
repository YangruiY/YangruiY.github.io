{"type":"getPostById","data":{"title":"简单的笔记","date":"2023-10-05T15:20:16.000Z","description":"杂记","categories":[{"name":"杂记","_id":"clndbzy75007n150p8dm0gqpq"}],"tags":[{"name":"杂记","_id":"clndbzy77007z150p7n6t2kwi"}],"content":"<meta name=\"referrer\" content=\"no-referrer\">\n<h2 id=\"类初始化的时机\">类初始化的时机</h2>\n<ol>\n<li>创建类的实例</li>\n<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>\n<li>调用类的静态方法</li>\n<li>反射（比如：Class.forName(“com.atguigu.Test”)）</li>\n<li>初始化一个类的子类</li>\n<li>Java虚拟机启动时被标明为启动类的类</li>\n<li>JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</li>\n</ol>\n<h2 id=\"sql中where和having的区别\">sql中where和having的区别</h2>\n<h3 id=\"差异场景\">差异场景</h3>\n<p>1.一般情况下，WHERE 用于过滤数据行，而 HAVING 用于过滤分组。 2.WHERE 查询条件中不可以使用聚合函数，而 HAVING 查询条件中可以使用聚合函数。使用HAVING对聚合函数过滤，在查询字段中要有该聚合函数，WHERE后面不能跟聚合函数，对聚合函数的过滤用HAVING。</p>\n<p>聚合函数就是例如SUM,COUNT,MAX,AVG等对一组(多条)数据操作的函数，需要配合group by 来使</p>\n<p>用。如：</p>\n<p><code>SELECT SUM(population),region FROM To1_Beijing GROUP BY region; </code> 3.WHERE 在数据分组前进行过滤，而 HAVING 在数据分组后进行过滤 。 4.WHERE 针对数据库文件进行过滤，而 HAVING 针对查询结果进行过滤。也就是说，WHERE 根据数据表中的字段直接进行过滤，而 HAVING 是根据前面已经查询出的字段进行过滤。虽然HAVING可以对查询出的一般字段（即不是聚合函数）进行过滤。但建议用WHERE。因为HAVING是对分组过滤，WHERE是对数据行过滤，两者的逻辑不一样。在分组前就能过滤，为什么不在分组前过过滤，这样执行sql效率会高些。 5.WHERE 查询条件中不可以使用字段别名，而 HAVING 查询条件中可以使用字段别名。</p>\n<p>6.where和having的执行顺序不同，where 早于 group by 早于 having where子句在聚合前先筛选记录，也就是说作用在group by 子句和having子句前，而 having子句在聚合后对组记录进行筛选</p>\n<h3 id=\"场景举例\">场景举例</h3>\n<p>\\1. where和having都可以使用的场景</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select goods_price,goods_name from sw_goods where goods_price &gt; 100</span><br><span class=\"line\">select goods_price,goods_name from sw_goods having goods_price &gt; 100</span><br></pre></td></tr></table></figure>\n<p>解释：上面的having可以用的前提是我已经筛选出了goods_price字段，在这种情况下和where的效果是等效的，但是如果我没有select goods_price 就会报错！！因为having是从前筛选的字段再筛选，而where是从数据表中的字段直接进行的筛选的。</p>\n<p>\\2. 只可以用where，不可以用having的情况</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select goods_name,goods_number from sw_goods where goods_price &gt; 100</span><br><span class=\"line\">select goods_name,goods_number from sw_goods having goods_price &gt; 100 //报错！！！因为前面并没有筛选出goods_price 字段</span><br></pre></td></tr></table></figure>\n<p>\\3. 只可以用having，不可以用where情况</p>\n<p>查询每种goods_category_id商品的价格平均值，获取平均价格大于1000元的商品信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select goods_category_id , avg(goods_price) as ag from sw_goods group by goods_category having ag &gt; 1000</span><br><span class=\"line\">select goods_category_id , avg(goods_price) as ag from sw_goods where ag&gt;1000 group by goods_category //报错！！因为from sw_goods 这张数据表里面没有ag这个字段</span><br></pre></td></tr></table></figure>\n<p>注意:where 后面要跟的是数据表里的字段，如果我把ag换成avg(goods_price)也是错误的！因为表里没有该字段。而having只是根据前面查询出来的是什么就可以后面接什么。</p>\n<h2 id=\"dev分支获取最新更改\">dev分支获取最新更改</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout feature_branch_1 </span><br><span class=\"line\">git pull origin develop --rebase  //快速变基更细，将当前分支对应的远程分支更新到本地</span><br></pre></td></tr></table></figure>\n<h2 id=\"Spring中InitializingBean接口使用理解\">Spring中InitializingBean接口使用理解</h2>\n<p>InitializingBean接口为bean提供了初始化方法的方式，它只包括afterPropertiesSet方法，凡是继承该接口的类，在初始化bean的时候会执行该方法。</p>\n<p><strong>测试程序如下：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import org.springframework.beans.factory.InitializingBean;</span><br><span class=\"line\">import org.springframework.stereotype.Service;</span><br><span class=\"line\"> </span><br><span class=\"line\">public class InitBean implements InitializingBean&#123;</span><br><span class=\"line\">    @override</span><br><span class=\"line\">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class=\"line\">       System.out.println(&quot;启动时自动执行 afterPropertiesSet...&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    public void init()&#123;</span><br><span class=\"line\">        System.out.println(&quot;init method...&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;　</span><br></pre></td></tr></table></figure>\n<p><strong>配置文件如下：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class=\"line\">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class=\"line\">    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class=\"line\">    xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;</span><br><span class=\"line\">    xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;</span><br><span class=\"line\">    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class=\"line\">    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class=\"line\">    xsi:schemaLocation=</span><br><span class=\"line\">    &quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</span><br><span class=\"line\">     http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd</span><br><span class=\"line\">     http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd</span><br><span class=\"line\">     http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd</span><br><span class=\"line\">     http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd</span><br><span class=\"line\">     http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span><br><span class=\"line\">     default-lazy-init=&quot;true&quot;&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &lt;bean id=&quot;initBean&quot;  class=&quot;com.netease.nsip.spring.InitBean&quot; init-method=&quot;init&quot;&gt; &lt;/bean&gt;</span><br><span class=\"line\">&lt;/beans&gt;　　</span><br></pre></td></tr></table></figure>\n<p><strong>主程序如下：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import org.springframework.context.ApplicationContext;</span><br><span class=\"line\">import org.springframework.context.support.FileSystemXmlApplicationContext;</span><br><span class=\"line\"> </span><br><span class=\"line\">public class Main &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        ApplicationContext context = new</span><br><span class=\"line\">                FileSystemXmlApplicationContext(&quot;classpath:/applicationContext-core.xml&quot;);</span><br><span class=\"line\">        context.getBean(&quot;initBean&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;　　</span><br></pre></td></tr></table></figure>\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">启动时自动执行 afterPropertiesSet...</span><br><span class=\"line\">init method...　　</span><br></pre></td></tr></table></figure>\n<p>这说明在spring初始化bean的时候，如果bean实现了InitializingBean接口，会自动调用afterPropertiesSet方法。</p>\n<p>问题：实现<code>InitializingBean</code>接口与在配置文件中指定init-method有什么不同？</p>\n<p>由结果可看出，在spring初始化bean的时候，如果该bean是实现了InitializingBean接口，并且同时在配置文件中指定了init-method，系统则是先调用afterPropertiesSet方法，然后在调用init-method中指定的方法。这方式在spring中是怎么实现的？通过查看spring的加载bean的源码类(<code>AbstractAutowireCapableBeanFactory</code>)可看出其中奥妙<code>AbstractAutowireCapableBeanFactory</code>类中的<code>invokeInitMethods</code>讲解的非常清楚，源码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected void invokeInitMethods(String beanName, final Object bean, RootBeanDefinition mbd)</span><br><span class=\"line\">            throws Throwable &#123;</span><br><span class=\"line\">//判断该bean是否实现了实现了InitializingBean接口，如果实现了InitializingBean接口，则只掉调用bean的afterPropertiesSet方法</span><br><span class=\"line\">        boolean isInitializingBean = (bean instanceof InitializingBean);</span><br><span class=\"line\">        if (isInitializingBean &amp;&amp; (mbd == null || !mbd.isExternallyManagedInitMethod(&quot;afterPropertiesSet&quot;))) &#123;</span><br><span class=\"line\">            if (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">                logger.debug(&quot;Invoking afterPropertiesSet() on bean with name &#x27;&quot; + beanName + &quot;&#x27;&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">             </span><br><span class=\"line\">            if (System.getSecurityManager() != null) &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() &#123;</span><br><span class=\"line\">                        public Object run() throws Exception &#123;</span><br><span class=\"line\">                            //直接调用afterPropertiesSet</span><br><span class=\"line\">                            ((InitializingBean) bean).afterPropertiesSet();</span><br><span class=\"line\">                            return null;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;,getAccessControlContext());</span><br><span class=\"line\">                &#125; catch (PrivilegedActionException pae) &#123;</span><br><span class=\"line\">                    throw pae.getException();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;               </span><br><span class=\"line\">            else &#123;</span><br><span class=\"line\">                //直接调用afterPropertiesSet</span><br><span class=\"line\">                ((InitializingBean) bean).afterPropertiesSet();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (mbd != null) &#123;</span><br><span class=\"line\">            String initMethodName = mbd.getInitMethodName();</span><br><span class=\"line\">            //判断是否指定了init-method方法，如果指定了init-method方法，则再调用制定的init-method</span><br><span class=\"line\">            if (initMethodName != null &amp;&amp; !(isInitializingBean &amp;&amp; &quot;afterPropertiesSet&quot;.equals(initMethodName)) &amp;&amp;</span><br><span class=\"line\">                    !mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class=\"line\">                    //进一步查看该方法的源码，可以发现init-method方法中指定的方法是通过反射实现</span><br><span class=\"line\">                invokeCustomInitMethod(beanName, bean, mbd);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>总结：</strong></p>\n<ol>\n<li>spring为bean提供了两种初始化bean的方式，实现InitializingBean接口，实现afterPropertiesSet方法，或者在配置文件中同过init-method指定，两种方式可以同时使用。</li>\n<li>实现InitializingBean接口是直接调用afterPropertiesSet方法，比通过反射调用init-method指定的方法效率相对来说要高点。但是init-method方式消除了对spring的依赖。</li>\n<li>如果调用afterPropertiesSet方法时出错，则不调用init-method指定的方法。</li>\n</ol>\n<p>参考：</p>\n<p><a href=\"https://blog.csdn.net/mamamalululu00000000/article/details/107813432\">https://blog.csdn.net/mamamalululu00000000/article/details/107813432</a></p>\n<h2 id=\"ApplicationContextAware接口\">ApplicationContextAware接口</h2>\n<p>Sping 框架提供的用于获取应用环境启动后获取（ApplicationContext）环境上下文 和容器中的bean <strong>ApplicationContextAware</strong>直译过来即**“应用程序上下文感知”**</p>\n<h3 id=\"常见用法即工具类\">常见用法即工具类</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import org.springframework.beans.BeansException;</span><br><span class=\"line\">import org.springframework.context.ApplicationContext;</span><br><span class=\"line\">import org.springframework.context.ApplicationContextAware;</span><br><span class=\"line\">import org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\">@Component</span><br><span class=\"line\">public final class SpringContextAwareTool implements ApplicationContextAware &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static ApplicationContext applicationContext;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 获取</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static ApplicationContext getApplicationContext()&#123;</span><br><span class=\"line\">        return applicationContext;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 通过bean 名获取</span><br><span class=\"line\">     * @param beanName</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static Object getBean(String beanName)&#123;</span><br><span class=\"line\">        return getApplicationContext().getBean(beanName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 通过 类的 .class 获取</span><br><span class=\"line\">     * @param clazz</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz)&#123;</span><br><span class=\"line\">        return getApplicationContext().getBean(clazz);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 该方法在容器初始化入口处时被执行</span><br><span class=\"line\">     * @param applicationContext</span><br><span class=\"line\">     * @throws BeansException</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class=\"line\">        if (SpringContextAwareTool.applicationContext == null)&#123;</span><br><span class=\"line\">            SpringContextAwareTool.applicationContext = applicationContext;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简单来说当容器初始化的时候 实现了 <code>ApplicationContextAware</code> 的类的 <code>setApplicationContext</code> 方法会被调用执行 <code>applicatonContext</code> 对象会被框架给与，此时上方的方法中 静态属性 <code>applicationContext</code> 也就被赋值了，之后就可以使用静态的<code>applicatonContext</code> 的 getBean时就顺利成章可以使用了，从而获取到 容器中<code>bean</code>。</p>\n<p>注意：如果不将实现了<code>ApplicationContextAware</code>接口的类标记为<code>@Component</code>或其他相关注解，Spring容器将无法自动检测并注入该类。这是因为Spring需要通过注解扫描或配置文件来识别和创建bean。如果没有适当的注解，Spring无法知道应该将其作为bean进行管理。因此，为了使<code>ApplicationContextAware</code>接口能够生效，需要将实现类标记为Spring管理的组件，通常使用<code>@Component</code>注解。</p>\n<p>总结：</p>\n<p>所有实例化的类 都会进入到 <code>ApplicationContextAwareProcessor</code> 的 <code>postProcessBeforeInitialization</code> 方法中，此时当该实例化类为 <code>Aware</code>类型且是<code>ApplicationContextAware</code> 类型时会调用<code>setApplicationContext(this.applicationContext)</code>，也就完成了把Spring上下文（ApplicationContext）的赋值过程上方的实例中 重写的set方法也就被执行 ，也就是说实现了 <code>ApplicationContextAware</code> 的类且有注解<code>@Component</code>就会被在容器初始化时调。</p>\n<h3 id=\"同时实现InitializingBean\">同时实现<code>InitializingBean</code></h3>\n<p>实现<strong>InitializingBean</strong>后 若重写 afterPropertiesSet，则会在 初始化完成，即容器中的Bean 完成填装后,继续执行<strong>afterPropertiesSet</strong>中的方法，类似如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import com.dtdream.dthink.dtalent.dmall.exception.DXPException;</span><br><span class=\"line\">import com.dtdream.dthink.dtalent.dmall.exception.ExceptionType;</span><br><span class=\"line\">import org.springframework.beans.BeansException;</span><br><span class=\"line\">import org.springframework.beans.factory.InitializingBean;</span><br><span class=\"line\">import org.springframework.context.ApplicationContext;</span><br><span class=\"line\">import org.springframework.context.ApplicationContextAware;</span><br><span class=\"line\">import org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.HashMap;</span><br><span class=\"line\">import java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\">@Component</span><br><span class=\"line\">public class Xxxxxxxxxxxxxx implements ApplicationContextAware, InitializingBean &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static final Map&lt;String, XXXXXX&gt; MY_MAP = new HashMap&lt;&gt;();</span><br><span class=\"line\">    </span><br><span class=\"line\">    private ApplicationContext applicationContext;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// 将容器中部分已经注入的Bean 放到某一个Map 中</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class=\"line\">        applicationContext.getBeansOfType(XXXXXX.class).values()</span><br><span class=\"line\">                .forEach(processor -&gt; MY_MAP.put(Xxxxxxxx, processor));</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//  初始化环境上下文  已获取容器中已注册的Bean</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class=\"line\">        this.applicationContext = applicationContext;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t// 提供外部调用 可以从当前方法获得放到Map 中的Bean</span><br><span class=\"line\">    public Xxxxxxxxx getExchangeProcessor(String type) throws MyException&#123;</span><br><span class=\"line\">        XXXXXXXXXX processor = MY_MAP.get(type);</span><br><span class=\"line\">        if (processor == null) &#123;</span><br><span class=\"line\">            throw new MyException(.............);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return processor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用Maven下载源代码以及java-doc\">使用Maven下载源代码以及java doc</h2>\n<p>命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn dependency:resolve -Dclassifier=javadoc   </span><br></pre></td></tr></table></figure>\n<h2 id=\"InitBinder注解\">InitBinder注解</h2>\n<p><code>@InitBinder</code>是一个Spring MVC注解，用于在控制器中对请求参数进行预处理和数据绑定操作。</p>\n<p>具体来说，<code>@InitBinder</code>注解的作用如下：</p>\n<ol>\n<li>数据绑定：<code>@InitBinder</code>注解可以用于指定一个方法，用于处理请求参数的数据绑定。在这个方法中，你可以通过注册自定义的属性编辑器（<code>PropertyEditor</code>）或者通过其他方式对请求参数进行转换、格式化和验证等操作。</li>\n<li>请求参数预处理：<code>@InitBinder</code>注解还可以用于预处理请求参数，例如对某些参数进行默认值设置、去除空格、过滤敏感信息等操作。</li>\n</ol>\n<p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import org.springframework.web.bind.WebDataBinder;</span><br><span class=\"line\">import org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class=\"line\">import org.springframework.web.bind.annotation.InitBinder;</span><br><span class=\"line\"></span><br><span class=\"line\">@ControllerAdvice</span><br><span class=\"line\">public class MyControllerAdvice &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @InitBinder</span><br><span class=\"line\">    public void initBinder(WebDataBinder binder) &#123;</span><br><span class=\"line\">        // 注册自定义属性编辑器</span><br><span class=\"line\">        binder.registerCustomEditor(Date.class, new CustomDateEditor(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;), true));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个示例中，<code>initBinder()</code>方法被标记为<code>@InitBinder</code>，它会在控制器处理请求之前被调用。在该方法中，我们通过<code>WebDataBinder</code>对象注册了一个自定义的属性编辑器，用于将请求参数中的日期字符串转换为<code>Date</code>对象。</p>\n<p>通过使用<code>@InitBinder</code>注解，你可以对控制器中的请求参数进行灵活的预处理和数据绑定操作，以满足特定的业务需求。</p>\n<h2 id=\"什么是内存RSS\">什么是内存RSS</h2>\n<h3 id=\"解释\">解释</h3>\n<ol>\n<li>VSS - Virtual Set Size 虚拟耗用内存（包含共享库占用的内存）</li>\n<li>RSS - Resident Set Size 实际使用物理内存（包含共享库占用的内存）</li>\n<li>PSS - Proportional Set Size 实际使用的物理内存（比例分配共享库占用的内存）</li>\n<li>USS - Unique Set Size 进程独自占用的物理内存（不包含共享库占用的内存）</li>\n</ol>\n<h3 id=\"参考\">参考</h3>\n<p><a href=\"https://www.jianshu.com/p/8a0a039397a8\">https://www.jianshu.com/p/8a0a039397a8</a></p>\n<h2 id=\"http协议解决粘包拆包半包的编码解码过程、以及Netty使用http协议的原理\">http协议解决粘包拆包半包的编码解码过程、以及Netty使用http协议的原理</h2>\n<p><a href=\"https://blog.csdn.net/u013378306/article/details/107742524?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-7-107742524-null-null.pc_agg_new_rank&amp;utm_term=http%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84&amp;spm=1000.2123.3001.4430\">http粘包和半包问题</a></p>\n<h2 id=\"git-tips\">git tips</h2>\n<h3 id=\"如何切换到某个分支的历史commit上？\">如何切换到某个分支的历史commit上？</h3>\n<p>命令：git checkout <commit id></commit></p>\n<h3 id=\"已经在一个分支的某个历史commit上之后如何切换到最新的commit上？\">已经在一个分支的某个历史commit上之后如何切换到最新的commit上？</h3>\n<p>git checkout <branch name></branch></p>\n<h3 id=\"查看git引用执行操作\">查看git引用执行操作</h3>\n<p>git reflog</p>\n<h3 id=\"本地分支同步远程分支最新修改指令推荐\">本地分支同步远程分支最新修改指令推荐</h3>\n<p>git pull origin <remote branch name> --rebase</remote></p>\n<h3 id=\"关联远程分支\">关联远程分支</h3>\n<p>git branch --set-upstream-to=<remote branch name> 设置当前分支关联的远程分支为远程分支</remote></p>\n<p>例如 git branch --set-upstream-to=origin/V6.6.0-master</p>\n<h3 id=\"回滚操作\">回滚操作</h3>\n<p>git reset --hard <commit id> 回退到某个提交节点(注意，此处如果本地有修改会被清除)</commit></p>\n<p>git reset --soft <commit id>  回退到某个提交节点(不会清除修改)</commit></p>\n<h3 id=\"如何撤销Git操作\">如何撤销Git操作</h3>\n<p><a href=\"https://www.ruanyifeng.com/blog/2019/12/git-undo.html\">https://www.ruanyifeng.com/blog/2019/12/git-undo.html</a></p>\n<h2 id=\"参考-2\">参考</h2>\n<p><a href=\"https://backlog.com/git-tutorial/cn/\">猴子都能懂的GIT</a></p>\n<p><a href=\"https://learngitbranching.js.org/\">https://learngitbranching.js.org/</a></p>\n<p><a href=\"http://rogerdudler.github.io/git-guide/index.zh.html\">git - 简明指南</a></p>\n<p><a href=\"http://marklodato.github.io/visual-git-guide/index-zh-cn.html\">图解Git</a></p>\n<h1>Spring</h1>\n<h2 id=\"Bean主要的执行顺序\">Bean主要的执行顺序</h2>\n<p>IOC容器启动之后，业务bean的创建+初始化过程中构造方法、@Autowired、BeanPostProcessor、InitializingBean等的执行顺序为：</p>\n<ol>\n<li>最先执行构造方法 ， 对应于对象的创建，此时也可能会向bean里设置(设置并非注入)一些属性</li>\n<li>接着会将所有标有@Autowired的属性全部注入到当前bean</li>\n<li>遍历所有的BeanPostProcessor，并调用每一个processor的<code>postProcessBeforeInitialization</code>方法</li>\n<li>initialize bean，执行InitializingBean接口对应的afterPropertiesSet方法,或者是@Bean注解中initMethod字段指定的方法或是注解@PostConstruct对应的方法</li>\n<li>遍历所有的BeanPostProcessor，并调用每一个processor的<code>postProcesstAfterInitialization</code>方法</li>\n<li>使用bean</li>\n<li>销毁bean，执行DisposableBean接口对应的destroy方法,或者是@Bean注解中destroy字段指定的方法或是注解@PreDestroy对应的方法</li>\n</ol>\n<p>ps:步骤4和步骤7中方法还可以用xml方式进行配置。</p>\n<h2 id=\"事件驱动\">事件驱动</h2>\n<p>todo</p>\n<h2 id=\"常用注解\">常用注解</h2>\n<h3 id=\"ConditionalOnProperty\">ConditionalOnProperty</h3>\n<p>ConditionalOnProperty只有在 application.properties 或 application.yml 文件中 module.enabled 属性的值为 true 时才会生效。 @ConditionalOnProperty 注解有以下主要属性： - name：属性的名称，可以是一个数组，所有属性都必须匹配才能使配置生效。 - havingValue：期待的属性值。只有属性的值等于 havingValue，配置才会生效。 - matchIfMissing：如果属性不存在，是否应使配置生效。默认值为 false，即如果属性不存在，配置不会生效。 - prefix：用于构造属性名称的前缀。</p>\n<h3 id=\"InitBinder\">InitBinder</h3>\n<p>在 Spring Boot 中，@InitBinder 是一个注解，它用于自定义数据绑定的规则。@InitBinder 可以用在控制器类中的方法上，用于指定一些数据绑定的操作。</p>\n<p>在 Spring MVC 中，当接收到 HTTP 请求时，Spring 会将请求参数自动绑定到对应的 Java 对象中。而有时候，我们需要对这些参数进行进一步的处理，例如转换数据类型或者对数据进行验证等操作。这时，我们可以使用 @InitBinder 注解来自定义数据绑定的规则。</p>\n<p>使用 @InitBinder 注解时，需要在控制器类中定义一个带有 WebDataBinder 参数的方法，并在该方法上添加 @InitBinder 注解。WebDataBinder 是 Spring MVC 中的一个工具类，它可以用于数据绑定、类型转换和验证等操作。在该方法中，可以通过 WebDataBinder 对象来添加一些自定义的属性编辑器、格式化器或者验证器，从而实现对数据绑定过程的自定义控制。</p>\n<p>例如，假设我们有一个 Student 类，其中包含一个 birthDate 属性，它的类型为 Date。而在 HTTP 请求中，该属性的值是一个字符串，我们需要将其转换为 Date 类型的对象。这时，我们可以在控制器类中定义一个带有 @InitBinder 注解的方法，如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Controller</span><br><span class=\"line\">public class StudentController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @InitBinder</span><br><span class=\"line\">    public void initBinder(WebDataBinder binder) &#123;</span><br><span class=\"line\">        DateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class=\"line\">        dateFormat.setLenient(false);</span><br><span class=\"line\">        binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @RequestMapping(&quot;/addStudent&quot;)</span><br><span class=\"line\">    public String addStudent(@ModelAttribute(&quot;student&quot;) Student student, ModelMap modelMap) &#123;</span><br><span class=\"line\">        // 处理添加学生的业务逻辑</span><br><span class=\"line\">        return &quot;success&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，在数据绑定时，当 Spring MVC 遇到类型为 Date 的属性时，就会自动调用 CustomDateEditor 类的 setAsText() 方法，将字符串类型的值转换为 Date 类型的值。</p>\n<p>需要注意的是，在实际开发中，如果我们使用了全局配置，即通过配置文件或者注解来定义了全局的属性编辑器、格式化器或者验证器，那么在 @InitBinder 注解中添加的属性编辑器、格式化器或者验证器可能会被全局配置所覆盖，因此需要注意避免冲突。</p>\n<h3 id></h3>\n<h2 id=\"Spring中的设计模式\">Spring中的设计模式</h2>\n<p><strong>单例模式</strong></p>\n<p>spring中默认bean的作用域就是单例模式，减少对象的创建。通过ConcurrentHashMap实现的多级缓存实现单例。</p>\n<p><strong>工厂设计模式</strong></p>\n<p>spring中通过beanFactory或 ApplicationContext 创建 bean 对象</p>\n<p><strong>代理设计模式</strong></p>\n<p>Spring AOP 功能的实现。</p>\n<p><strong>模板模式</strong></p>\n<p>Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式</p>\n<p><strong>观察者模式</strong></p>\n<p>ApplicationEvent 事件 ApplicationListener 事件监听者  ApplicationEventPublisher 事件发布者</p>\n<p><strong>适配器模式</strong></p>\n<p>Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller</p>\n<p><strong>装饰者模式</strong></p>\n<p>装饰者模式可以动态地给对象添加一些额外的属性或行为。相比于使用继承，装饰者模式更加灵活</p>\n<h2 id=\"常用接口\">常用接口</h2>\n<h3 id=\"DisposableBean\">DisposableBean</h3>\n<p><code>DisposableBean</code>是 Spring 框架中的一个接口，用于在 Spring 容器销毁（关闭）时执行一些清理操作。</p>\n<p><code>DisposableBean</code>接口定义了一个方法<code>destroy()</code>，在 Spring 容器关闭时会调用该方法。开发人员可以在<code>destroy()</code>方法中实现一些资源释放、清理或销毁操作，例如关闭数据库连接、释放文件资源等。</p>\n<p>使用<code>DisposableBean</code>接口的主要优点是它可以与 Spring 容器无缝集成，确保在容器关闭时执行清理操作，避免资源泄漏或不正确的状态。</p>\n<p>以下是一个简单的示例，演示了如何在实现<code>DisposableBean</code>接口的类中定义清理操作：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import org.springframework.beans.factory.DisposableBean;</span><br><span class=\"line\"></span><br><span class=\"line\">public class MyBean implements DisposableBean &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void destroy() throws Exception &#123;</span><br><span class=\"line\">        // 执行清理操作，释放资源等</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当 Spring 容器关闭时，会自动调用<code>MyBean</code>类的<code>destroy()</code>方法，以便执行清理操作。</p>\n<h3 id=\"BeanFactoryAware\">BeanFactoryAware</h3>\n<p><code>BeanFactoryAware</code>是 Spring 框架中的一个接口，用于让实现该接口的 Bean 对象获取对 Spring 容器的引用。</p>\n<p>当一个 Bean 实现了<code>BeanFactoryAware</code>接口后，Spring 容器在将该 Bean 实例化并注入依赖后，会调用<code>setBeanFactory(BeanFactory beanFactory)</code>方法，将容器的 BeanFactory 实例作为参数传递给该方法。</p>\n<p>使用<code>BeanFactoryAware</code>接口可以让 Bean 对象在被容器初始化时获取对容器的引用，从而可以在需要时访问容器的功能，例如获取其他 Bean 实例、获取属性配置等。</p>\n<h3 id=\"BeanNameAware\">BeanNameAware</h3>\n<p>#setBeanName设置bean名字</p>\n<h3 id=\"BeanPostProcessor\">BeanPostProcessor</h3>\n<p>主要是下面的两个方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">postProcessBeforeInitialization</span><br><span class=\"line\">postProcesstAfterInitialization</span><br></pre></td></tr></table></figure>\n<h3 id=\"ApplicationContext\">ApplicationContext</h3>\n<h3 id=\"ApplicationListener\">ApplicationListener</h3>\n<h1>SpringBoot</h1>\n<h2 id=\"SpringBoot自动装配原理以及手写starter\">SpringBoot自动装配原理以及手写starter</h2>\n<p>在以前单独使用SpringMVC Web编程框架时，我们需要单独配置<em><strong>DispatcherServlet</strong></em>和<em><strong>Tomcat</strong></em>，使用SpringBoot之后，我们只需要引入<em><strong>SpringBoot-Starter-Web</strong></em>就能直接开始编写Controller等Web相关的代码，这就是SpringBoot为们提供的<em><strong>开箱即用</strong></em>的便捷能力，下面就以<em><strong>SpringBoot-Starter-Web</strong></em>来说明SpringBoot自动配置的关键原理</p>\n<h3 id=\"SpringBoot自动装配案例\">SpringBoot自动装配案例</h3>\n<h4 id=\"DispatcherServlet的自动装配\">DispatcherServlet的自动装配</h4>\n<p>首先我们定位到SpringBoot自动配置的Maven依赖</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">   &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;</span><br><span class=\"line\">   &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt;</span><br><span class=\"line\"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<p>在依赖的Jar包中我们可以在<em><strong>META-INF/spring.factories</strong></em>中找到自动配置类：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration</span><br></pre></td></tr></table></figure>\n<p>在这个类中存在有一个静态内部类：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration.DispatcherServletConfiguration</span><br></pre></td></tr></table></figure>\n<p>下图是这个配置类的主要源码和解析：</p>\n<p><img src=\"https://apijoyspace.jd.com/v1/files/laQFW0mgeIDWR0UgkO2V/link\" alt></p>\n<p>下面将上图中关键的注解功能，分别进行功能说明</p>\n<p>//todo</p>\n<h1>Redis</h1>\n<h2 id=\"EVALSHA命令\">EVALSHA命令</h2>\n<p>Redis的<code>EVALSHA</code>命令用于执行预先存储在Redis服务器中的Lua脚本。它接受一个SHA1哈希值作为参数，该哈希值对应于在服务器上使用<code>SCRIPT LOAD</code>命令加载的Lua脚本。</p>\n<p>以下是<code>EVALSHA</code>命令的用法示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EVALSHA &lt;sha1&gt; &lt;numkeys&gt; &lt;key&gt; [&lt;key&gt; ...] &lt;arg&gt; [&lt;arg&gt; ...]</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>&lt;sha1&gt;</code>：预先加载的Lua脚本的SHA1哈希值。</li>\n<li><code>&lt;numkeys&gt;</code>：指定在执行脚本时作为参数传递给脚本的键数量。</li>\n<li><code>&lt;key&gt;</code>：要传递给脚本的键名。</li>\n<li><code>&lt;arg&gt;</code>：要传递给脚本的参数。</li>\n</ul>\n<p>例如，假设你已经在Redis服务器上加载了以下Lua脚本，并获取到其SHA1哈希值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">local value = redis.call(&#x27;GET&#x27;, KEYS[1])</span><br><span class=\"line\">return value</span><br></pre></td></tr></table></figure>\n<p>然后，你可以使用<code>EVALSHA</code>命令执行该脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EVALSHA &quot;b67c5c7f3d7e8e7e9c3a3f8a6f2f1c5b8e9d4f8&quot; 1 mykey</span><br></pre></td></tr></table></figure>\n<p>在上述示例中，<code>&quot;b67c5c7f3d7e8e7e9c3a3f8a6f2f1c5b8e9d4f8&quot;</code>是Lua脚本的SHA1哈希值，<code>1</code>表示只有一个键名（<code>mykey</code>）传递给脚本。</p>\n<p>需要注意的是，如果使用<code>EVALSHA</code>命令执行的脚本在服务器上不存在，或者SHA1哈希值与预先加载的脚本不匹配，将会返回一个错误。在这种情况下，可以使用<code>EVAL</code>命令来执行脚本，而不是使用SHA1哈希值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EVAL &quot;local value = redis.call(&#x27;GET&#x27;, KEYS[1]) return value&quot; 1 mykey</span><br></pre></td></tr></table></figure>\n<p>这样可以确保即使没有预先加载脚本，也能够执行Lua脚本。</p>\n<h2 id=\"Script\">Script</h2>\n<h3 id=\"限流脚本\">限流脚本</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">local key = KEYS[1];</span><br><span class=\"line\">local slidingWindow = ARGV[1];</span><br><span class=\"line\">local nowTime = tonumber(ARGV[2]);</span><br><span class=\"line\">local nowTimeRandom = ARGV[3];</span><br><span class=\"line\">local maxLimit = tonumber(ARGV[4]);</span><br><span class=\"line\"></span><br><span class=\"line\">redis.call(&#x27;zremrangebyscore&#x27;, key, 0, nowTime - slidingWindow);</span><br><span class=\"line\"></span><br><span class=\"line\">local num = redis.call(&#x27;zcard&#x27;, key);</span><br><span class=\"line\"></span><br><span class=\"line\">if (num &lt; maxLimit) then</span><br><span class=\"line\">    redis.call(&#x27;zadd&#x27;, key, nowTime, nowTimeRandom);</span><br><span class=\"line\">    redis.call(&#x27;expire&#x27;, key, slidingWindow);</span><br><span class=\"line\">end</span><br><span class=\"line\">return num + 1</span><br></pre></td></tr></table></figure>\n<h1>并发</h1>\n<h2 id=\"定时任务线程池\">定时任务线程池</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Executors.newSingleThreadScheduledExecutor#scheduleAtFixedRate</span><br></pre></td></tr></table></figure>\n<p>定时执行任务，入参initialDelay第一次调用<code>scheduleAtFixedRate</code>方法到执行提交的任务的时间间隔</p>\n<h1>极客时间</h1>\n<p><a href=\"https://learn.lianglianglee.com/\">https://learn.lianglianglee.com/</a></p>\n<h1>小问题</h1>\n<h2 id=\"Resource注解能获取到bean而applicationContext-getBean获取不到的情况\">@Resource注解能获取到bean而applicationContext.getBean获取不到的情况</h2>\n<ol>\n<li><strong>Bean的生命周期</strong>：在Spring Bean的生命周期中，<code>@Resource</code>注解的注入是在<code>postProcessBeforeInitialization</code>阶段进行的，而<code>applicationContext.getBean()</code>通常在<code>postProcessAfterInitialization</code>阶段进行。如果你尝试在<code>postProcessAfterInitialization</code>阶段之前（比如<code>postProcessBeforeInitialization</code>阶段）通过<code>applicationContext.getBean()</code>获取Bean，可能会失败，因为那时Bean可能还没有完全初始化。</li>\n<li><strong>Bean的作用域</strong>：如果你的Bean定义为请求作用域或会话作用域，那么在非Web环境下（例如，在普通的Java方法中）通过<code>applicationContext.getBean()</code>获取Bean可能会失败。这是因为在非Web环境下，Spring无法获取到当前的请求或会话。而<code>@Resource</code>注解可以处理这种情况，因为它直接使用CGLIB创建一个代理，这个代理会在每次请求时从正确的作用域中获取Bean。</li>\n</ol>\n","_path":"post/62a21792.html","_link":"http://rycan.top/post/62a21792.html","_id":"clndbzy730079150pajaqba5h"}}